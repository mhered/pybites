{
    "user": {
        "github_username": "mhered8b899449424048c5",
        "github_first_name": "Manuel",
        "github_last_name": "Heredia",
        "date_joined_platform": "2022-09-09 12:13:02.052789+00:00",
        "user_active": true,
        "bio": null,
        "client_browser": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_6_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.6.1 Mobile/15E148 Safari/604.1",
        "email": "spam.mhered@gmail.com",
        "verified_email": true,
        "enable_notifications": true,
        "has_pybites_fork": true,
        "is_premium": true,
        "is_tester": false,
        "show_profile": true,
        "show_score": true
    },
    "gumroad": {
        "license": "4E5830ED-6B4D440D-BE443DCB-9F29CDA8",
        "purchase": "_TnUldPCEnW7zswrsIemVg==",
        "quantity": 1
    },
    "messages": [
        {
            "subject": "Bite 266. Composition, Inheritance, Abstract Base Class, what?",
            "body": "Hard but satisfying. I had to do a bit of manual tayloring of the printout.\r\n\r\n```from abc import ABC, abstractmethod\r\nfrom collections import namedtuple\r\nfrom dataclasses import dataclass\r\nfrom datetime import date\r\nfrom os import getenv, path\r\nfrom pathlib import Path\r\nfrom typing import Any, List, Optional, NamedTuple\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup as Soup  # type: ignore\r\n\r\nTMP = getenv(\"TMP\", \"/tmp\")\r\nTODAY = date.today()\r\n\r\nCandidate = NamedTuple(\"Candidate\", [\r\n        ('name', str), \r\n        ('votes', int),\r\n    ]\r\n)\r\nLeaderBoard = NamedTuple(\r\n    \"LeaderBoard\", [\r\n        ('Candidate', str), \r\n        ('Average', str), \r\n        ('Delegates', str), \r\n        ('Contributions', str), \r\n        ('Coverage', str),\r\n    ]\r\n)\r\nPoll = NamedTuple(\r\n    \"Poll\",[\r\n        ('Poll', str),\r\n        ('Date', str),\r\n        ('Sample', int),\r\n        ('Sanders', float),\r\n        ('Biden', float),\r\n        ('Gabbard', float),\r\n        ('Spread', float),\r\n    ]\r\n)\r\n\r\n\r\ndef as_float(string):\r\n    try:\r\n        return float(string)\r\n    except ValueError:\r\n        return 0        \r\n\r\n@dataclass\r\nclass File:\r\n    \"\"\"File represents a filesystem path.\r\n\r\n    Variables:\r\n        name: str -- The filename that will be created on the filesystem.\r\n        path: Path -- Path object created from the name passed in.\r\n\r\n    Methods:\r\n        [property]\r\n        data: -> Optional[str] -- If the file exists, it returns its contents.\r\n            If it does not exist, it returns None.\r\n    \"\"\"\r\n    name: str\r\n    path: Path = ''\r\n    \r\n    def __post_init__(self):\r\n        if self.path:\r\n            self.path = Path(self_path , self.name)\r\n        else:\r\n            self.path = Path(TMP,f'{TODAY}_{self.name}')\r\n        \r\n    @property\r\n    def data(self) -> Optional[str]:\r\n        if path.isfile(self.path):\r\n            with open(self.path) as f:\r\n                return f.read()\r\n        else:\r\n            return None\r\n\r\n@dataclass\r\nclass Web:\r\n    \"\"\"Web object.\r\n\r\n    Web is an object that downloads the page from the url that is passed\r\n    to it and stores it in the File instance that is passed to it. If the\r\n    File already exists, it just reads the file, otherwise it downloads it\r\n    and stores it in File.\r\n\r\n    Variables:\r\n        url: str -- The url of the web page.\r\n        file: File -- The File object to store the page data into.\r\n\r\n    Methods:\r\n        [property]\r\n        data: -> Optional[str] -- Reads the text from File or retrieves it from the\r\n            web if it does not exists.\r\n\r\n        [property]\r\n        soup: -> Soup -- Parses the data from File and turns it into a BeautifulSoup\r\n            object.\r\n    \"\"\"\r\n    url: str\r\n    file: File\r\n\r\n    @property\r\n    def data(self) -> Optional[str]:\r\n        \"\"\"Reads the data from the File object.\r\n\r\n        First it checks if the File object has any data. If it doesn't, it retrieves\r\n        it and saves it to the File. It then reads it from the File and returns it.\r\n\r\n        Returns:\r\n            Optional[str] -- The string data from the File object.\r\n        \"\"\"\r\n        if not self.file.data:\r\n            urlretrieve(self.url, self.file.path)\r\n        return self.file.data\r\n\r\n    @property\r\n    def soup(self) -> Soup:\r\n        \"\"\"Converts string data from File into a BeautifulSoup object.\r\n\r\n        Returns:\r\n            Soup -- BeautifulSoup object created from the File.\r\n        \"\"\"\r\n        soup = Soup(self.data, 'html.parser')\r\n        return soup\r\n\r\n\r\nclass Site(ABC):\r\n    \"\"\"Site Abstract Base Class.\r\n\r\n    Defines the structure for the objects based on this class and defines the interfaces\r\n    that should be implemented in order to work properly.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        [abstractmethod]\r\n        parse_rows: -> Union[List[LeaderBoard], List[Poll]] -- Parses a BeautifulSoup\r\n            table element and returns the text found in the td elements as\r\n            namedtuples.\r\n\r\n        [abstractmethod]\r\n        polls: -> Union[List[LeaderBoard], List[Poll]] -- Does the parsing of the table\r\n            and rows for you. It takes the table index number if given, otherwise\r\n            parses table 0.\r\n\r\n        [abstractmethod]\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation.\r\n    \"\"\"\r\n    web: Web\r\n\r\n    def find_table(self, loc: int = 0) -> str:\r\n        \"\"\"Finds the table elements from the Soup object\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Parses the Web object for table elements and\r\n                returns the first one that it finds unless an integer representing\r\n                the required table is passed. (default: {0})\r\n\r\n        Returns:\r\n            str -- The html table\r\n        \"\"\"\r\n            \r\n        return self.web.soup.find_all('table')[loc or 0]\r\n\r\n    @abstractmethod\r\n    def parse_rows(self, table: Soup) -> List[Any]:\r\n        \"\"\"Abstract Method\r\n        \r\n        Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as NamedTuple.\r\n\r\n        Returns:\r\n            List[NamedTuple] -- List of NamedTuple that were created from the\r\n                table data.\r\n        \"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def polls(self, table: int = 0) -> List[Any]:\r\n        \"\"\"Abstract Method\r\n\r\n        Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[NamedTuple] -- List of NamedTuple that were created from the\r\n                table data.\r\n        \"\"\"\r\n        pass\r\n    \r\n    @abstractmethod\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Abstract Method\r\n        \r\n        Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n        \"\"\"\r\n        pass\r\n\r\n\r\n@dataclass\r\nclass RealClearPolitics(Site):\r\n    \"\"\"RealClearPolitics object.\r\n\r\n    RealClearPolitics is a custom class to parse a Web instance from the\r\n    realclearpolitics website.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        parse_rows: -> List[Poll] -- Parses a BeautifulSoup table element and\r\n            returns the text found in the td elements as Poll namedtuples.\r\n\r\n        polls: -> List[Poll] -- Does the parsing of the table and rows for you.\r\n            It takes the table index number if given, otherwise parses table 0.\r\n\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation:\r\n\r\n            Example:\r\n\r\n            RealClearPolitics\r\n            =================\r\n                Biden: 214.0\r\n              Sanders: 142.0\r\n              Gabbard: 6.0\r\n\r\n    \"\"\"\r\n\r\n    web:Web\r\n\r\n    def parse_rows(self, table: Soup) -> List[Poll]:\r\n        \"\"\"Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as Poll namedtuples.\r\n\r\n        Returns:\r\n            List[Poll] -- List of Poll namedtuples that were created from the\r\n                table data.\r\n        \"\"\"\r\n        lst=[]\r\n        for row in table.find_all('tr')[2:]:\r\n            tds=row.find_all('td')\r\n            poll=tds[0].text\r\n            date=tds[1].text\r\n            sample=as_float(tds[2].text)\r\n            biden=as_float(tds[3].text)\r\n            sanders=as_float(tds[4].text)\r\n            gabbard=as_float(tds[5].text)\r\n            spread=as_float(tds[5].text)\r\n            lst.append(Poll(poll, date, sample, sanders, biden, gabbard, spread))\r\n        # print(lst)\r\n        return lst\r\n\r\n    def polls(self, table: int = 0) -> List[Poll]:\r\n        \"\"\"Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[Poll] -- List of Poll namedtuples that were created from the\r\n                table data.\r\n        \"\"\"\r\n        return self.parse_rows(self.find_table(table))\r\n\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n\r\n        \"\"\"\r\n        output=\"\"\"\\nRealClearPolitics\\n=================\\n\"\"\"\r\n        for candidate in 'Biden', 'Sanders', 'Gabbard':\r\n            output+=f'{candidate:>9}: {sum(getattr(poll, candidate) for poll in self.polls(loc))}\\n'\r\n        print(output)\r\n\r\n\r\n@dataclass\r\nclass NYTimes(Site):\r\n    \"\"\"NYTimes object.\r\n\r\n    NYTimes is a custom class to parse a Web instance from the nytimes website.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        parse_rows: -> List[LeaderBoard] -- Parses a BeautifulSoup table element and\r\n            returns the text found in the td elements as LeaderBoard namedtuples.\r\n\r\n        polls: -> List[LeaderBoard] -- Does the parsing of the table and rows for you.\r\n            It takes the table index number if given, otherwise parses table 0.\r\n\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation:\r\n\r\n            Example:\r\n\r\n            NYTimes\r\n            =================================\r\n\r\n                               Pete Buttigieg\r\n            ---------------------------------\r\n            National Polling Average: 10%\r\n                   Pledged Delegates: 25\r\n            Individual Contributions: $76.2m\r\n                Weekly News Coverage: 3\r\n\r\n    \"\"\"\r\n\r\n    web: Web\r\n\r\n    def parse_rows(self, table: Soup) -> List[LeaderBoard]:\r\n        \"\"\"Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as LeaderBoard namedtuples.\r\n\r\n        Returns:\r\n            List[LeaderBoard] -- List of LeaderBoard namedtuples that were created from\r\n            the table data.\r\n        \"\"\"\r\n        lst=[]\r\n        for row in table.find_all('tr')[1:4]:\r\n            tds=row.find_all('td')\r\n            candidate=tds[0].text.strip()\r\n            average=tds[1].text.strip()\r\n            delegates=int(tds[2].text.strip())\r\n            contributions=tds[3].text.strip()\r\n            coverage=int(tds[4].text.strip('# '))\r\n            # print(\" # \".join([candidate, average, delegates, contributions, coverage]))\r\n            lst.append(LeaderBoard(candidate, average, delegates, contributions, coverage))\r\n        return lst\r\n        \r\n\r\n    def polls(self, table: int = 0) -> List[LeaderBoard]:\r\n        \"\"\"Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[LeaderBoard] -- List of LeaderBoard namedtuples that were created from\r\n                the table data.\r\n        \"\"\"\r\n        return self.parse_rows(self.find_table(table))\r\n\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n        \"\"\"\r\n        output=f\"\\nNYTimes\\n{'='*33}\\n\\n\"\r\n        for item in self.polls(loc):\r\n            output+=f\"{item.Candidate:>33}\\n{'-'*33}\\n\"\r\n            output+=f'{\"National Polling Average\":>24}: {item.Average}\\n'\r\n            output+=f'{\"Pledged Delegates\":>24}: {item.Delegates}\\n'\r\n            output+=f'{\"Individual Contributions\":>24}: {item.Contributions}\\n'\r\n            output+=f'{\"Weekly News Coverage\":>24}: {item.Coverage}\\n\\n'            \r\n        print(output)\r\n\r\n\r\ndef gather_data():\r\n    rcp_file = File(\"realclearpolitics.html\")\r\n    rcp_url = (\r\n        \"https://bites-data.s3.us-east-2.amazonaws.com/2020-03-10_realclearpolitics.html\"\r\n    )\r\n    rcp_web = Web(rcp_url, rcp_file)\r\n    rcp = RealClearPolitics(rcp_web)\r\n    rcp.stats(3)\r\n\r\n    nyt_file = File(\"nytimes.html\")\r\n    nyt_url = (\r\n        \"https://bites-data.s3.us-east-2.amazonaws.com/2020-03-10_nytimes.html\"\r\n    )\r\n    nyt_web = Web(nyt_url, nyt_file)\r\n    nyt = NYTimes(nyt_web)\r\n    nyt.stats()\r\n\r\n```",
            "from_user": "mhered8b899449424048c5",
            "to_user": "clamytoe",
            "sent_date": "2022-12-16 21:12:21.718816+00:00"
        },
        {
            "subject": "Bite 206. Calculate and evenly split the bill",
            "body": "Really suffered with this one...\r\n\r\n\r\n```import decimal\r\n\r\ndef check_split(item_total, tax_rate, tip, people):\r\n    \"\"\"Calculate check value and evenly split.\r\n\r\n       :param item_total: str (e.g. '$8.68')\r\n       :param tax_rate: str (e.g. '4.75%)\r\n       :param tip: str (e.g. '10%')\r\n       :param people: int (e.g. 3)\r\n\r\n       :return: tuple of (grand_total: str, splits: list)\r\n                e.g. ('$10.00', [3.34, 3.33, 3.33])\r\n    \"\"\"\r\n    \r\n    \r\n    \"\"\"ctx = decimal.getcontext()\r\n    ctx.rounding = decimal.ROUND_HALF_EVEN\r\n    \"\"\"\r\n    \r\n    item_total = decimal.Decimal(item_total.lstrip('$'))\r\n    tax = item_total * decimal.Decimal(tax_rate.rstrip('%'))/decimal.Decimal('100')\r\n    tax = tax.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_HALF_EVEN)\r\n\r\n    after_tax= item_total + tax\r\n    \r\n    tip = after_tax * decimal.Decimal(tip.rstrip('%'))/decimal.Decimal('100')\r\n    tip = tip.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_HALF_EVEN)\r\n\r\n    grand_total= after_tax + tip\r\n    grand_total = grand_total.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_HALF_EVEN)\r\n    \r\n    per_person= grand_total / people\r\n    per_person = per_person.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_HALF_EVEN)\r\n    \r\n    split=[per_person for _ in range(people)]\r\n    split[0]+=grand_total-sum(split)\r\n    \r\n    grand_total=f'${grand_total}'\r\n    \r\n    return (grand_total, split)\r\n    \r\n    \r\nprint(check_split('$9.99', '3.25%', '10%', 2))  # ('$9.99', '3.25%', '10%', 2), expected = '$11.34' vs '$11.35'\r\nprint(check_split('$186.70', '6.75%', '18%', 6))  # ('$186.70', '6.75%', '18%', 6), expected = '$235.17' vs '$235.18'\r\nprint(check_split('$141.86', '2%', '18%', 9))  # ('$141.86', '2%', '18%', 9), expected = '$170.75' vs '$170.74'\r\n\r\n\r\n``` `pytest` run speed: `0.05` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "taspotts",
            "sent_date": "2022-12-16 19:25:04.997393+00:00"
        },
        {
            "subject": "Day 100! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 100: #Python #milestone: I coded for 100 days straight @PyBites - join me @ CodeChalleng.es!\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-12-16 10:01:42.122455+00:00"
        },
        {
            "subject": "Bite 296. Jagged list",
            "body": "Got this one!\r\n\r\n```from typing import List\r\nfrom itertools import zip_longest\r\n\r\ndef jagged_list(lst_of_lst: List[List[int]], fillvalue: int = 0) -> List[List[int]]:\r\n    zipped = zip_longest(*lst_of_lst, fillvalue = fillvalue)\r\n    return [list(item) for item in zip(*zipped)]\r\n\r\nprint(jagged_list([[1, 1, 1, 1], [0, 0, 0, 0], [1]], fillvalue=1))``` `pytest` run speed: `0.04` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "taspotts",
            "sent_date": "2022-12-15 23:09:36.273740+00:00"
        },
        {
            "subject": "Day 099! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 99: #100DaysOfCode progress: today I worked on Bite 28. Converting date strings to datetimes: https://codechalleng.es/bites/28 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-12-15 10:01:32.982246+00:00"
        },
        {
            "subject": "Day 098! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 98: #100DaysOfCode progress: today I worked on Bite 27. Parse omdb movie json data: https://codechalleng.es/bites/27 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-12-14 10:01:24.370011+00:00"
        },
        {
            "subject": "Congratulations on hitting the Black Ninja Belt",
            "body": "Hey Manuel,\n\nCongratulations on yet another milestone: you just earned your Black Ninja Belt!\n\nWe generated <a href=\"https://codechalleng.es/settings/#certificates\">your Ninja Certificate</a>.\n(If you need to update your first / last name, don't worry, you can generate it again.)\n\nKeep up the momentum and code more Python. Great job!\n\n- Bob & Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-12-13 21:04:48.123208+00:00"
        },
        {
            "subject": "Day 097! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 97: #100DaysOfCode progress: today I worked on Bite 25. No promo twice, keep state in a class: https://codechalleng.es/bites/25 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-12-13 10:01:48.047672+00:00"
        },
        {
            "subject": "Bite 94. Parse PyCon talk data from YouTube",
            "body": "Proud of this\r\n\r\n```from collections import namedtuple\r\nimport os\r\nimport pickle\r\nimport urllib.request\r\nimport re\r\nfrom datetime import timedelta\r\n\r\n\r\n# prework\r\n# download pickle file and store it in a tmp file\r\npkl_file = 'pycon_videos.pkl'\r\ndata = f'https://bites-data.s3.us-east-2.amazonaws.com/{pkl_file}'\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\npycon_videos = os.path.join(tmp, pkl_file)\r\nurllib.request.urlretrieve(data, pycon_videos)\r\n\r\nfrom pprint import pprint\r\n\r\n# the pkl contains a list of Video namedtuples\r\nVideo = namedtuple('Video', 'id title duration metrics')\r\n\r\n\r\ndef load_pycon_data(pycon_videos=pycon_videos):\r\n    \"\"\"Load the pickle file (pycon_videos) and return the data structure\r\n       it holds\"\"\"\r\n    with open(pycon_videos, 'rb') as f:\r\n        return pickle.load(f)\r\n\r\n\r\ndef get_most_popular_talks_by_views(videos):\r\n    \"\"\"Return the pycon video list sorted by viewCount\"\"\"\r\n    return sorted(videos, key=lambda x:int(x.metrics['viewCount']),reverse=True)    \r\n\r\n\r\ndef get_most_popular_talks_by_like_ratio(videos):\r\n    \"\"\"Return the pycon video list sorted by most likes relative to\r\n       number of views, so 10 likes on 175 views ranks higher than\r\n       12 likes on 300 views. Discount the dislikeCount from the likeCount.\r\n       Return the filtered list\"\"\"\r\n       \r\n    fun = lambda x: (int(x.metrics['likeCount']) - int(x.metrics['dislikeCount']))/ int(x.metrics['viewCount'])\r\n    return sorted(videos, key=fun,reverse=True)    \r\n\r\n\r\ndef _video_duration(duration_str):\r\n    \r\n    hours=int(re.search('[0-9]+(?=H)', duration_str).group(0)) if 'H' in duration_str else 0\r\n    minutes=int(re.search('[0-9]+(?=M)', duration_str).group(0)) if 'M' in duration_str else 0\r\n    seconds=int(re.search('[0-9]+(?=S)', duration_str).group(0)) if 'S' in duration_str else 0\r\n    return timedelta(hours=hours, minutes=minutes, seconds=seconds)\r\n\r\ndef get_talks_gt_one_hour(videos):\r\n    \"\"\"Filter the videos list down to videos of > 1 hour\"\"\"\r\n    return [video for video in videos if _video_duration(video.duration) > timedelta(hours=1)] \r\n\r\n\r\ndef get_talks_lt_twentyfour_min(videos):\r\n    \"\"\"Filter videos list down to videos that have a duration of less than\r\n       24 minutes\"\"\"\r\n    return [video for video in videos if _video_duration(video.duration) < timedelta(minutes=24)] \r\n```",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-12-12 18:28:37.474612+00:00"
        },
        {
            "subject": "Day 096! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 96: #100DaysOfCode progress: today I worked on Bite 22. Write a decorator with argument: https://codechalleng.es/bites/22 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-12-12 10:01:42.824720+00:00"
        },
        {
            "subject": "Bite 200. \ud83e\udd73 Minecraft Enchantable Items",
            "body": "Wow this was a nice one. Not too difficult but long and left me a feeling of achievement at the end.\r\n \r\n```import os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup as Soup\r\nimport re\r\nfrom pprint import pprint\r\n\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nHTML_FILE = TMP / \"enchantment_list_pc.html\"\r\n\r\n# source:\r\n# https://www.digminecraft.com/lists/enchantment_list_pc.php\r\nURL = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n       \"minecraft-enchantment.html\")\r\n\r\n\r\nclass Enchantment:\r\n    \"\"\"Minecraft enchantment class\r\n    \r\n    Implements the following: \r\n        id_name, name, max_level, description, items\r\n    \"\"\"\r\n    \r\n    LEVEL={'I':1, 'II':2, 'III':3, 'IV':4 , 'V':5}\r\n    \r\n    def __init__(self, id_name, name, max_level, description, items = None):\r\n        \r\n        self.id_name = id_name  # Internal name of the enchantment\r\n        self.name = name  # User friendly name of the enchantment\r\n        self.max_level = max_level  # Enchantment level. Original is in Roman numerals; they need to be converted to integers\r\n        self.description = description  # Summary of what the enchantment does\r\n        self.items = items or [] # List of item names that are typically enchanted with this enchantment.\r\n\r\n    def __repr__(self):\r\n        return f'{self.name.title()} ({self.max_level}): {self.description}'\r\n\r\nclass Item:\r\n    \"\"\"Minecraft enchantable item class\r\n    \r\n    Implements the following: \r\n        name, enchantments\r\n    \"\"\"\r\n\r\n    def __init__(self, name, enchantments = None):\r\n        \r\n        self.name = name\r\n        self.enchantments = enchantments or []\r\n        \r\n    def __repr__(self):\r\n        result= f'{self.name.title()}: \\n'\r\n        for enchantment in sorted(self.enchantments,key=lambda x:x.id_name):\r\n            result+=f'  [{enchantment.max_level}] {enchantment.id_name}\\n'\r\n        return result\r\n\r\n\r\ndef _get_items(string):\r\n    \r\n    filename=string.split('/')[-1].split('.')[0]\r\n    # replace fishing_rod fishing-rod\r\n    filename=filename.replace('fishing_rod', 'fishing-rod')\r\n    items_raw=filename.split('_')\r\n    items = [item for item in items_raw if item.lower() not in ['enchanted','iron', 'sm']]\r\n    return list(map(lambda x: x.replace('fishing-rod','fishing_rod'),items))\r\n\r\ndef generate_enchantments(soup):\r\n    \"\"\"Generates a dictionary of Enchantment objects\r\n    \r\n    With the key being the id_name of the enchantment.\r\n    \"\"\"\r\n    table = soup.find('table',{'id':'minecraft_items'})\r\n    rows = table.find_all('tr')\r\n    enchantments={}\r\n    for row in rows[1:]:\r\n        # print(row)\r\n        cols = row.find_all('td')\r\n        id_name = cols[0].em.text\r\n        # id_name = re.search('(?<=/enchantments/)[A-Za-z_]+(?=\\.php)',id_name_raw).group(0)\r\n        # print(id_name_raw, id_name)\r\n        name = cols[0].a.text\r\n        max_level = Enchantment.LEVEL[cols[1].text.upper()] \r\n        description = cols[2].text\r\n        items = _get_items(cols[4].find('img',{'class':'img-rounded'})['data-src'])\r\n        enchantments[id_name]=Enchantment(id_name, name, max_level, description,items)\r\n    return enchantments\r\n\r\n\r\ndef _get_item_name(item_id):\r\n    return \" \".join(item_id.split('_')).title()\r\n\r\n\r\ndef generate_items(data):\r\n    \"\"\"Generates a dictionary of Item objects\r\n    \r\n    With the key being the item name.\r\n    \"\"\"\r\n    items_dict= {}\r\n    \r\n    for enchantment in data.values():\r\n        for item_id in enchantment.items:\r\n            #create Item object with this enchantment or append enchantment if Item exists\r\n            if item_id in items_dict:\r\n                items_dict[item_id].enchantments.append(enchantment)\r\n            else:\r\n                items_dict[item_id] = Item(_get_item_name(item_id),[enchantment])\r\n    return items_dict\r\n    \r\n\r\n\r\ndef get_soup(file=HTML_FILE):\r\n    \"\"\"Retrieves/takes source HTML and returns a BeautifulSoup object\"\"\"\r\n    if isinstance(file, Path):\r\n        if not file.is_file():\r\n            urlretrieve(URL, file)\r\n\r\n        with file.open() as html_source:\r\n            soup = Soup(html_source, \"html.parser\")\r\n    else:\r\n        soup = Soup(file, \"html.parser\")\r\n\r\n    return soup\r\n\r\n\r\ndef main():\r\n    \"\"\"This function is here to help you test your final code.\r\n    \r\n    Once complete, the print out should match what's at the bottom of this file\"\"\"\r\n    soup = get_soup()\r\n    enchantment_data = generate_enchantments(soup)\r\n    print(enchantment_data)\r\n    minecraft_items = generate_items(enchantment_data)\r\n    for item in minecraft_items:\r\n        print(minecraft_items[item], \"\\n\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n    \r\n\r\n``` `pytest` run speed: `0.46` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-12-11 22:57:06.122142+00:00"
        },
        {
            "subject": "Day 095! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 95: #100DaysOfCode progress: today I worked on Bite 18. Find the most common word: https://codechalleng.es/bites/18 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-12-11 10:01:53.388781+00:00"
        },
        {
            "subject": "Bite 291. Find the fastest speech",
            "body": "I was not happy about my solution, found it a bit clumsy and sensitive to input error, but inspecting the proposed solution it is not much worse.\r\nI guess I am becoming more demanding.\r\n\r\n```from datetime import timedelta, datetime\r\nfrom typing import List\r\n\r\n\r\ndef get_srt_section_ids(text: str) -> List[int]:\r\n    \"\"\"Parse a caption (srt) text passed in and return a\r\n       list of section numbers ordered descending by\r\n       highest speech speed\r\n       (= ratio of \"time past:characters spoken\")\r\n\r\n       e.g. this section:\r\n\r\n       1\r\n       00:00:00,000 --> 00:00:01,000\r\n       let's code\r\n\r\n       (10 chars in 1 second)\r\n\r\n       has a higher ratio then:\r\n\r\n       2\r\n       00:00:00,000 --> 00:00:03,000\r\n       code\r\n\r\n       (4 chars in 3 seconds)\r\n\r\n       You can ignore milliseconds for this exercise.\r\n    \"\"\"\r\n    lines=iter(text.lstrip().splitlines())\r\n    sections_speed=[]\r\n    for line in lines:\r\n        section=int(line)\r\n        timing=next(lines)\r\n        start,stop=timing.split(' --> ')\r\n        start=datetime.strptime(start.split(',')[0], '%H:%M:%S')\r\n        stop=datetime.strptime(stop.split(',')[0], '%H:%M:%S')\r\n        duration=stop-start\r\n        speech_lines=[]\r\n        speech_line=next(lines)\r\n        while speech_line:\r\n            speech_lines.append(speech_line)\r\n            try:\r\n                speech_line=next(lines)\r\n            except StopIteration:\r\n                speech_line =''\r\n        \r\n        speech='\\n'.join(speech_lines)\r\n        chars_per_second = len(speech)/duration.total_seconds()\r\n        sections_speed.append((section,chars_per_second))\r\n        # print('##'.join([str(section),str(duration),speech,str(chars_per_second)]))\r\n    # print(sections_speed)\r\n    return [item[0] for item in sorted(sections_speed, key=lambda x:x[1], reverse=True)]\r\n    \r\n    \r\n    \r\n    \r\ntext = \"\"\"\r\n1\r\n00:00:00,498 --> 00:00:02,827\r\nBeautiful is better than ugly.\r\n\r\n2\r\n00:00:02,827 --> 00:00:06,383\r\nExplicit is better than implicit.\r\n\r\n3\r\n00:00:06,383 --> 00:00:09,427\r\nSimple is better than complex.\r\n\"\"\"\r\n\r\nprint(get_srt_section_ids(text))``` `pytest` run speed: `0.04` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-12-10 23:45:29.974062+00:00"
        },
        {
            "subject": "Day 094! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 94: #100DaysOfCode progress: today I worked on Bite 17. Form teams from a group of friends: https://codechalleng.es/bites/17 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-12-10 10:01:22.595782+00:00"
        },
        {
            "subject": "Day 093! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 93: #100DaysOfCode progress: today I worked on Bite 14. Generate a table of n sequences: https://codechalleng.es/bites/14 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-12-09 10:01:24.907590+00:00"
        },
        {
            "subject": "Day 092! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 92: #100DaysOfCode progress: today I worked on Bite 13. Convert dict to namedtuple/json: https://codechalleng.es/bites/13 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-12-08 10:01:30.537076+00:00"
        },
        {
            "subject": "Bite 275. Get the most common email domains",
            "body": "Forgot to make it case insensitive...\r\n\r\n```from collections import Counter\r\n\r\nimport bs4\r\nimport requests\r\n\r\n\r\nCOMMON_DOMAINS = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n                  \"common-domains.html\")\r\nTARGET_DIV = {\"class\": \"middle_info_noborder\"}\r\n\r\ndef get_common_domains(url=COMMON_DOMAINS):\r\n    \"\"\"Scrape the url return the 100 most common domain names\"\"\"\r\n\r\n    content = requests.get(url).text\r\n\r\n    soup = bs4.BeautifulSoup(content, \"html.parser\")\r\n    target_div=soup.find('div', TARGET_DIV)\r\n    row_domains=target_div.find_all('tr')\r\n    return [row.td.next_sibling.next_sibling.get_text() for row in row_domains ]\r\n\r\ndef get_most_common_domains(emails, common_domains=None):\r\n    \"\"\"Given a list of emails return the most common domain names,\r\n       ignoring the list (or set) of common_domains\"\"\"\r\n    if common_domains is None:\r\n        common_domains = get_common_domains()\r\n\r\n    # your code\r\n    domains = [email.split('@')[1] for email in emails]\r\n    domains_filtered= [domain for domain in domains if domain not in common_domains]\r\n\r\n    return Counter(domains_filtered).most_common()\r\n\r\n\r\nlst= get_common_domains()\r\nprint(len(lst))\r\nprint(lst)\r\n\r\n# sample email list from mockaroo, edited manually\r\ntest_emails='''\r\nsally.sainsberry@bbb.org\r\ndcrauford1@gmail.com\r\nnmaccawley2@zdnet.com\r\ngsteinor3@vkontakte.ru\r\nn.mayer4@zdnet.com\r\nlaurent.lohrensen5@bbb.org\r\ntrich6@jigsy.com\r\nmbiggs7@linkedin.com\r\nraymond.jaquest@gmail.com\r\nedimitresco9@zdnet.com\r\nrvaraha@yahoo.com\r\n'''.strip().split()\r\nprint(get_most_common_domains(test_emails))\r\n``` `pytest` run speed: `0.52` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-12-08 07:56:28.026609+00:00"
        },
        {
            "subject": "Day 091! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 91: #100DaysOfCode progress: today I worked on Bite 12. Write a user validation function: https://codechalleng.es/bites/12 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-12-07 10:01:34.620890+00:00"
        },
        {
            "subject": "Day 090! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 90: #100DaysOfCode progress: today I worked on Bite 10. Practice exceptions: https://codechalleng.es/bites/10 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-12-06 10:01:24.921056+00:00"
        },
        {
            "subject": "Day 089! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 89: #100DaysOfCode progress: today I worked on Bite 9. Palindromes: https://codechalleng.es/bites/9 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-12-05 10:01:31.042397+00:00"
        },
        {
            "subject": "Bite 195. Analyze NBA Data with sqlite3",
            "body": "Proud of this my first incursion in SQL...\r\n\r\n```from collections import namedtuple\r\nimport csv\r\nimport os\r\nfrom pathlib import Path\r\nimport sqlite3\r\nimport random\r\nimport string\r\n\r\nimport requests\r\n\r\nDATA_URL = 'https://query.data.world/s/ezwk64ej624qyverrw6x7od7co7ftm'\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\n\r\nsalt = ''.join(\r\n    random.choice(string.ascii_lowercase) for i in range(20)\r\n)\r\nDB = TMP / f'nba_{salt}.db'\r\n\r\nPlayer = namedtuple('Player', ('name year first_year team college active '\r\n                               'games avg_min avg_points'))\r\n\r\nconn = sqlite3.connect(DB)\r\ncur = conn.cursor()\r\n\r\n\r\ndef import_data():\r\n    with requests.Session() as session:\r\n        content = session.get(DATA_URL).content.decode('utf-8')\r\n\r\n    reader = csv.DictReader(content.splitlines(), delimiter=',')\r\n\r\n    players = []\r\n    for row in reader:\r\n        players.append(Player(name=row['Player'],\r\n                              year=row['Draft_Yr'],\r\n                              first_year=row['first_year'],\r\n                              team=row['Team'],\r\n                              college=row['College'],\r\n                              active=row['Yrs'],\r\n                              games=row['Games'],\r\n                              avg_min=row['Minutes.per.Game'],\r\n                              avg_points=row['Points.per.Game']))\r\n\r\n    cur.execute('''CREATE TABLE IF NOT EXISTS players\r\n                  (name, year, first_year, team, college, active,\r\n                  games, avg_min, avg_points)''')\r\n    cur.executemany('INSERT INTO players VALUES (?,?,?,?,?,?,?,?,?)', players)\r\n    conn.commit()\r\n\r\n\r\nimport_data()\r\n\r\n\r\n# you code:\r\n\r\ndef player_with_max_points_per_game():\r\n    \"\"\"The player with highest average points per game (don't forget to CAST to\r\n       numeric in your SQL query)\"\"\"\r\n       \r\n    rows = cur.execute(\"SELECT name FROM players ORDER BY CAST(avg_points AS FLOAT) DESC\").fetchone()\r\n    return rows[0]\r\n\r\n\r\n\r\ndef number_of_players_from_duke():\r\n    \"\"\"Return the number of players with college == Duke University\"\"\"\r\n    target_college = \"Duke University\"\r\n    count = cur.execute(\"SELECT COUNT(name) FROM players WHERE college = ? \",(target_college,)).fetchone()\r\n    return count[0]\r\n\r\n\r\ndef avg_years_active_players_stanford():\r\n    \"\"\"Return the average years that players from \"Stanford University\r\n       are active (\"active\" column)\"\"\"\r\n    target_college = \"Stanford University\"\r\n    rows = cur.execute(\"SELECT CAST(active AS FLOAT) FROM players WHERE college = ? \",(target_college,)).fetchall()\r\n    return round(sum(row[0] for row in rows)/len(rows),2)\r\n\r\n\r\ndef year_with_most_new_players():\r\n    \"\"\"Return the year with the most new players.\r\n       Hint: you can use GROUP BY on the year column.\r\n    \"\"\"\r\n    \r\n    \"\"\"this works\r\n    rows = cur.execute(\"SELECT year, COUNT(name) FROM players GROUP BY CAST(year AS INT)\").fetchall()\r\n    return max(rows, key=lambda x: x[1])[0]\r\n    \"\"\"\r\n    \r\n    rows = cur.execute(\"SELECT CAST(year AS INT) FROM players GROUP BY CAST(year AS INT) ORDER BY COUNT(name) DESC\").fetchone()\r\n    return rows[0]\r\n    \r\n\r\nprint(player_with_max_points_per_game())\r\nprint(number_of_players_from_duke())\r\nprint(avg_years_active_players_stanford())\r\nprint(year_with_most_new_players())``` `pytest` run speed: `0.46` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-12-04 10:19:22.821925+00:00"
        },
        {
            "subject": "Day 088! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 88: #100DaysOfCode progress: today I worked on Bite 7. Parsing dates from logs: https://codechalleng.es/bites/7 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-12-04 10:01:17.830240+00:00"
        },
        {
            "subject": "Bite 124. Marvel data analysis",
            "body": "Looks like I misunderstood the instructions for the most popular and female percentage functions, and reading below I wasn't the only one.\r\nI still think the version I implemented for most popular kind of makes more sense...\r\n\r\n```from collections import Counter, namedtuple, defaultdict\r\nimport csv\r\nimport re\r\n\r\nimport requests\r\n\r\nfrom pprint import pprint\r\n\r\nMARVEL_CSV = 'https://raw.githubusercontent.com/pybites/marvel_challenge/master/marvel-wikia-data.csv'  # noqa E501\r\n\r\nCharacter = namedtuple('Character', 'pid name sid align sex appearances year')\r\n\r\nMALE, FEMALE, AGENDER, GENDERFLUID = 'male characters', 'female characters', 'agender characters', 'genderfluid characters'\r\nVALID_GENDERS = [MALE, FEMALE, AGENDER, GENDERFLUID ]\r\n\r\n# csv parsing code provided so this Bite can focus on the parsing\r\n\r\ndef _get_csv_data():\r\n    \"\"\"Download the marvel csv data and return its decoded content\"\"\"\r\n    with requests.Session() as session:\r\n        return session.get(MARVEL_CSV).content.decode('utf-8')\r\n\r\n\r\ndef load_data():\r\n    \"\"\"Converts marvel.csv into a sequence of Character namedtuples\r\n       as defined above\"\"\"\r\n    content = _get_csv_data()\r\n    reader = csv.DictReader(content.splitlines(), delimiter=',')\r\n    for row in reader:\r\n        name = re.sub(r'(.*?)\\(.*', r'\\1', row['name']).strip()\r\n        yield Character(pid=row['page_id'],\r\n                        name=name,\r\n                        sid=row['ID'],\r\n                        align=row['ALIGN'],\r\n                        sex=row['SEX'],\r\n                        appearances=row['APPEARANCES'],\r\n                        year=row['Year'])\r\n\r\n\r\ncharacters = list(load_data())\r\n\r\n\r\n# start coding\r\n\r\ndef most_popular_characters(characters=characters, top=5):\r\n    \"\"\"Get the most popular character by number of appearances,\r\n       return top n characters (default 5)\r\n    \"\"\"\r\n    \r\n    \"\"\"\r\n    # this works but results differ. Note e.g. Benjamin Grimm appears \r\n    # several times with the same name, this code adds them all together\r\n    \r\n    char_appears = defaultdict(int)\r\n    for character in characters:\r\n         if character.appearances:\r\n            char_appears[character.name]+= int(character.appearances)\r\n\r\n    count = Counter(char_appears).most_common(top)\r\n    return [name for name, appears in count]\r\n    \"\"\"\r\n    \r\n    # wrote this to mimic results in the tests. Now every line of 'Benjamin Grimm'\r\n    # is considered separately\r\n    \r\n    char_appears= {c.pid: int(c.appearances) for c in characters if c.appearances}\r\n    top_chars_by_pid = Counter(char_appears).most_common(top)\r\n    return [c.name for pid,appears in top_chars_by_pid for c in characters if c.pid ==pid]\r\n        \r\n\r\n\r\n\r\ndef max_and_min_years_new_characters(characters=characters):\r\n    \"\"\"Get the year with most and least new characters introduced respectively,\r\n       use either the 'FIRST APPEARANCE' or 'Year' column in the csv\r\n       characters, or the 'year' attribute of the namedtuple, return a tuple\r\n       of (max_year, min_year)\r\n    \"\"\"\r\n    new_chars_per_year = defaultdict(int)\r\n    for character in characters:\r\n        if character.year:\r\n            new_chars_per_year[character.year]+=1\r\n    count = Counter(new_chars_per_year).most_common()\r\n    return count[0][0],count[-1][0]\r\n\r\n\r\n\r\ndef get_percentage_female_characters(characters=characters):\r\n    \"\"\"Get the percentage of female characters as percentage of all genders\r\n       over all appearances.\r\n       Ignore characters that don't have gender ('sex' attribue) set\r\n       (in your characters data set you should only have Male, Female,\r\n       Agender and Genderfluid Characters.\r\n       Return the result rounded to 2 digits\r\n    \"\"\"\r\n\r\n    \"\"\"\r\n    appearances_by_gender = defaultdict(int)\r\n    for character in characters:\r\n        if character.sex.lower() in VALID_GENDERS:\r\n            appearances_by_gender[character.sex.lower()]+=int(character.appearances or 0)\r\n        \r\n        else:\r\n            print(character.sex +\" : \"+ character.appearances)\r\n        \r\n    total = sum(value for value in appearances_by_gender.values())\r\n    return round(100*appearances_by_gender[FEMALE]/total,2)\r\n    \"\"\"\r\n    \r\n    chars_by_gender = defaultdict(int)\r\n    for character in characters:\r\n        if character.sex.lower():\r\n            chars_by_gender[character.sex.lower()]+=1\r\n\r\n    total = sum(value for key, value in chars_by_gender.items() if key.lower() in VALID_GENDERS)\r\n    return round(100*chars_by_gender[FEMALE]/total,2)\r\n    \r\n\r\n\r\nprint(most_popular_characters(top=10))\r\nprint(max_and_min_years_new_characters())\r\nprint(get_percentage_female_characters())\r\n``` `pytest` run speed: `0.74` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-12-03 16:40:10.755278+00:00"
        },
        {
            "subject": "Day 087! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 87: #100DaysOfCode progress: today I worked on Bite 6. PyBites Die Hard: https://codechalleng.es/bites/6 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-12-03 10:01:34.893137+00:00"
        },
        {
            "subject": "Bite 23. Find words that are > 95% similar",
            "body": "Using `itertools.combinations()`...\r\n\r\n```import os\r\nimport re\r\nfrom difflib import SequenceMatcher\r\nimport itertools\r\nfrom urllib.request import urlretrieve\r\nimport string\r\n\r\n# prep\r\nTAG_HTML = re.compile(r'<category>([^<]+)</category>')\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nTEMPFILE = os.path.join(TMP, 'feed')\r\nMIN_TAG_LEN = 10\r\nIDENTICAL = 1.0\r\nSIMILAR = 0.95\r\n\r\nurlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/tags.xml',\r\n    TEMPFILE\r\n)\r\n\r\n\r\ndef _get_tags(tempfile=TEMPFILE):\r\n    \"\"\"Helper to parse all tags from a static copy of PyBites' feed,\r\n       providing this here so you can focus on difflib\"\"\"\r\n    with open(tempfile) as f:\r\n        content = f.read().lower()\r\n    # take a small subset to keep it performant\r\n    tags = TAG_HTML.findall(content)\r\n    tags = [tag for tag in tags if len(tag) > MIN_TAG_LEN]\r\n    return set(tags)\r\n\r\n\r\ndef get_similarities(tags=None):\r\n    \"\"\"Should return a list of similar tag pairs (tuples)\"\"\"\r\n    tags = tags or _get_tags()\r\n    # do your thing ...\r\n    JUNK = string.punctuation + string.whitespace\r\n    pairs = [\r\n        pair for pair in itertools.combinations(tags, 2) \r\n        if SequenceMatcher(\r\n            lambda x: x in JUNK, pair[0], pair[1]\r\n            ).ratio() >= SIMILAR\r\n        ]\r\n    return pairs\r\n    \r\n\r\n# get_similarities()\r\n\r\n``` `pytest` run speed: `0.82` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-12-02 11:56:26.517935+00:00"
        },
        {
            "subject": "Day 086! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 86: #100DaysOfCode progress: today I worked on Bite 4. Top 10 PyBites tags: https://codechalleng.es/bites/4 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-12-02 10:01:31.554464+00:00"
        },
        {
            "subject": "Day 085! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 85: #100DaysOfCode progress: today I worked on Bite 3. Word Values: https://codechalleng.es/bites/3 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-12-01 10:01:28.085241+00:00"
        },
        {
            "subject": "Bite 113. Filter words with non-ascii characters",
            "body": "Duh! It was soo simple...\r\n\r\n```import string\r\nimport unicodedata\r\n\r\ndef _non_ascii_char(c):\r\n    # non-ascii number: it is a number but not an ascii number \r\n    if unicodedata.category(c) in ['Nd'] and c not in string.digits:\r\n            return True\r\n    # non-ascii letter: it is not punctuation or number (i.e. it is a letter) but not an ascii letter\r\n    if unicodedata.category(c) not in ['Po', 'Pd', 'Nd'] and c.lower() not in string.ascii_lowercase:\r\n            return True\r\n    return False\r\n    \r\ndef extract_non_ascii_words(text):\r\n    \"\"\"Filter a text returning a list of non-ascii words\"\"\"\r\n    return [word for word in text.split() if any(_non_ascii_char(c) for c in word.strip())]\r\n\r\n``` `pytest` run speed: `0.05` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-30 23:48:44.231138+00:00"
        },
        {
            "subject": "Day 084! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 84: #100DaysOfCode progress: today I worked on Bite 347. Which words can you type with one hand?: https://codechalleng.es/bites/347 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-30 10:01:21.903922+00:00"
        },
        {
            "subject": "Day 083! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 83: #100DaysOfCode progress: today I worked on Bite 337. A little detour: Pydantic: https://codechalleng.es/bites/337 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-29 10:01:39.606769+00:00"
        },
        {
            "subject": "Feedback for Bite 20. Write a context manager",
            "body": "Hey Manuel,\r\n\r\nGood idea, did you have some specific code already?\r\n\r\nThanks\r\nBob\r\n\r\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-29 08:38:05.811318+00:00"
        },
        {
            "subject": "Feedback for Bite 20. Write a context manager",
            "body": "Rated level: 5\n\nComments: My code assumed only one transaction is performed inside the context manager and passed the tests, but looking at the proposed solution I realize mine is incomplete. Maybe we should add a test case where more than one transaction? ",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-28 19:06:50.689798+00:00"
        },
        {
            "subject": "Bite 20. Write a context manager",
            "body": "My code passed the tests, but looking at the proposed solution I realize mine is incomplete: it should not assume that only one transaction is performed inside the context manager...\r\n\r\n```class Account:\r\n\r\n    def __init__(self):\r\n        self._transactions = []\r\n\r\n    @property\r\n    def balance(self):\r\n        return sum(self._transactions)\r\n\r\n    def __add__(self, amount):\r\n        self._transactions.append(amount)\r\n\r\n    def __sub__(self, amount):\r\n        self._transactions.append(-amount)\r\n\r\n    # add 2 dunder methods here to turn this class \r\n    # into a 'rollback' context manager\r\n        \r\n    def __enter__(self):\r\n        return self\r\n        \r\n    def __exit__(self, exc_type, exc_value, exc_traceback):\r\n        if self.balance<0:\r\n            self._transactions.pop(-1)\r\n            \r\n        \r\n\r\n``` `pytest` run speed: `0.05` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-28 19:04:13.835960+00:00"
        },
        {
            "subject": "Day 082! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 82: #100DaysOfCode progress: today I worked on Bite 336. FastAPI Hello World: https://codechalleng.es/bites/336 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-28 10:01:23.333057+00:00"
        },
        {
            "subject": "Day 081! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 81: #100DaysOfCode progress: today I worked on Bite 324. Pretty string: https://codechalleng.es/bites/324 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-27 10:01:32.374688+00:00"
        },
        {
            "subject": "Day 080! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 80: #100DaysOfCode progress: today I worked on Bite 323. Iterables intersection: https://codechalleng.es/bites/323 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-26 10:01:45.900786+00:00"
        },
        {
            "subject": "Bite 362. Add a Password Prompt to Your Command Line Interface (CLI)",
            "body": "I didn't manage to pass the tests until I added ` = typer.Argument('Robin', help=\"Name\")` to the `name` parameter.\r\nAny ideas what am I doing wrong?\r\n\r\n\r\n```import typer\r\n\r\napp = typer.Typer()\r\n\r\n\r\n@app.command()\r\ndef main(\r\n    name: str = typer.Argument('Robin', help=\"Name\"),\r\n    password: str = typer.Option(\r\n        ..., prompt=True, confirmation_prompt=True, hide_input=True\r\n    ),\r\n):\r\n    print(f\"Hello {name}. Doing something very secure with password.\")\r\n    print(f\"...just kidding, here it is, very insecure: {password}\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app()\r\n    \r\n``` `pytest` run speed: `0.20` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "r33b",
            "sent_date": "2022-11-25 21:49:39.797178+00:00"
        },
        {
            "subject": "Day 079! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 79: #100DaysOfCode progress: today I worked on Bite 322. Reading progress: https://codechalleng.es/bites/322 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-25 10:01:39.513677+00:00"
        },
        {
            "subject": "Bite 144. Calculate the Number of Months Passed",
            "body": "A magic number escaped me...\r\n ```from datetime import date\r\n\r\nfrom dateutil.relativedelta import relativedelta\r\n\r\nSTART_DATE = date(2018, 11, 1)\r\nMIN_DAYS_TO_COUNT_AS_MONTH = 10\r\nMONTHS_PER_YEAR = 12\r\n\r\n\r\ndef calc_months_passed(year, month, day):\r\n    \"\"\"Construct a date object from the passed in arguments.\r\n       If this fails due to bad inputs reraise the exception.\r\n       Also if the new date is < START_DATE raise a ValueError.\r\n\r\n       Then calculate how many months have passed since the\r\n       START_DATE constant. We suggest using dateutil.relativedelta!\r\n\r\n       One rule: if a new month is >= 10 (MIN_DAYS_TO_COUNT_AS_MONTH)\r\n       days in, it counts as an extra  month.\r\n\r\n       For example:\r\n       date(2018, 11, 10) = 9 days in => 0 months\r\n       date(2018, 11, 11) = 10 days in => 1 month\r\n       date(2018, 12, 11) = 1 month + 10 days in => 2 months\r\n       date(2019, 12, 11) = 1 year + 1 month + 10 days in => 14 months\r\n       etc.\r\n\r\n       See the tests for more examples.\r\n\r\n       Return the number of months passed int.\r\n    \"\"\"\r\n    try:\r\n        my_date=date(year,month,day)\r\n    except (TypeError, ValueError) as error:\r\n        raise error\r\n    \r\n    if my_date <START_DATE:\r\n        raise ValueError\r\n        \r\n    time_passed=relativedelta(my_date,START_DATE)\r\n    print(time_passed)\r\n    return time_passed.years*12 + time_passed.months + (1 if time_passed.days >= 10 else 0)\r\n    ```",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-25 00:06:08.114162+00:00"
        },
        {
            "subject": "Bite 330. Simple Math Equation Solver",
            "body": "Quite proud of this. I used `pop()`, deep copies and `permutations`\r\n\r\n```from itertools import permutations\r\nfrom operator import add, sub, mul\r\nfrom typing import List, Union, Iterable\r\n\r\nALLOWED_OPERATORS = \"+-*\"\r\nALLOWED_NUMBERS = [1,2,3,4,5,6,7,8,9]\r\n\r\ndef _eval(operator_path, numbers):\r\n    _operator_path = operator_path[:]\r\n    _numbers = numbers[:]\r\n\r\n    while '*' in _operator_path:\r\n        i = _operator_path.index('*')\r\n        op = _operator_path.pop(i)\r\n        _numbers[i]*=_numbers.pop(i+1)\r\n\r\n    while len(_operator_path)>0:\r\n        op = _operator_path.pop(0)\r\n        if op=='+':\r\n            _numbers[0]+=_numbers.pop(1)\r\n        if op=='-':\r\n            _numbers[0]-=_numbers.pop(1)\r\n    return _numbers[0]\r\n\r\n\r\ndef find_all_solutions(\r\n    operator_path: List[str], expected_result: int\r\n) -> Union[List[List[int]], Iterable[List[int]]]:\r\n    # TODO: blank canvas to fill\r\n    \r\n    if not isinstance(expected_result, int):\r\n        raise ValueError(\"Result must be of type int\")\r\n        \r\n    if not all(op in ALLOWED_OPERATORS for op in operator_path):\r\n        raise ValueError(\"Result must be of type int\")\r\n        \r\n    num_ops=len(operator_path) + 1\r\n    all_permutations = permutations(ALLOWED_NUMBERS, num_ops)\r\n    \r\n    return [list(perm) for perm in all_permutations if _eval(operator_path, list(perm)) == expected_result]\r\n``` `pytest` run speed: `1.22` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "schustercf",
            "sent_date": "2022-11-24 23:38:03.653850+00:00"
        },
        {
            "subject": "Day 078! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 78: #100DaysOfCode progress: today I worked on Bite 319. Identity and equality: https://codechalleng.es/bites/319 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-24 10:01:35.076954+00:00"
        },
        {
            "subject": "Bite 329. Convert dict keys to snake case",
            "body": "Not pretty but it works\r\n\r\n\r\n```from pprint import pprint\r\nimport string\r\nimport re\r\n    \r\ndef _make_snake(word):\r\n    # replace - with _\r\n    # make [0] lower\r\n    # replace upper with _lower\r\n    if len(word)<2:\r\n        return word.lower()\r\n    result = [word[0].lower()]\r\n    for letter in word[1:]:\r\n        if  letter =='-':\r\n            result.append('_')\r\n        elif letter in string.ascii_uppercase:\r\n            result.append('_'+letter.lower())\r\n        else:\r\n            result.append(letter)\r\n    word=\"\".join(result)\r\n    word=re.sub('(?<=[a-z])(?=[0-9])|(?<=[0-9])(?=[a-z])', '_', word)\r\n    return word\r\n\r\ndef snake_case_keys(data):\r\n    print(data)\r\n    if isinstance(data,str):\r\n        return data\r\n    if isinstance(data,list):\r\n        data_list = data\r\n    if isinstance(data, dict):\r\n        data_list = [data]\r\n\r\n    for i,data in enumerate(data_list):\r\n        if isinstance(data,str):\r\n            continue\r\n        if isinstance(data,list):\r\n            for j,item in enumerate(data):\r\n                data[j]=snake_case_keys(item)\r\n            \r\n        if isinstance(data,dict):    \r\n            data = {_make_snake(key): value for key,value in data.items()}\r\n            for key, value in data.items():\r\n                if isinstance(value, dict) or isinstance(value, list):\r\n                    data[key]= snake_case_keys(value)\r\n    \r\n            data_list[i] = data\r\n        \r\n    return data_list if len(data_list)>1 else data_list[0]\r\n        \r\n\r\ndata={\r\n    \"camelCase\": \"Value1\",\r\n    \"camelcase\": \"Value1\",\r\n    \"PascalCase\": \"Value2\",\r\n    \"kebab-case\": \"Value3\",\r\n    \"ACRONYM\": \"Value4\",\r\n    \"number22\": {\r\n                \"helmetColor\": \"black\",\r\n                \"armorColor\": \"black\",\r\n                \"capeColor\": \"black\",\r\n            },\r\n    \"nested_list\": [{\"firstName\": \"Luke\"},\r\n                     {\"firstName\": \"Leia\"}],\r\n    \"random\": [\r\n                \"Luke\",\r\n                [\r\n                    \"blowing up the death star\",\r\n                    {\"skillName\": \"bulls-eye womprats\",\r\n                     \"skillParameters\": \"with my T47\"},\r\n                ],\r\n            ]\r\n}\r\n\r\npprint(snake_case_keys(data))``` `pytest` run speed: `0.07` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-23 18:24:27.151531+00:00"
        },
        {
            "subject": "Day 077! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 77: #100DaysOfCode progress: today I worked on Bite 318. Decode base64 encoded data: https://codechalleng.es/bites/318 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-23 10:01:47.953444+00:00"
        },
        {
            "subject": "Bite 347. Which words can you type with one hand?",
            "body": "Hello `issubset()`!\r\n\r\n```from enum import Enum\r\n\r\n\r\nclass Hand(str, Enum):\r\n    RIGHT = \"right\"\r\n    LEFT = \"left\"\r\n    BOTH = \"both\"\r\n\r\n\r\nLEFT_HAND_CHARS = set(\"QWERTASDFGZXCVB\")\r\nRIGHT_HAND_CHARS = set(\"YUIOPHJKLNM\")\r\n\r\n\r\ndef get_hand_for_word(word: str) -> Hand:\r\n    \"\"\"\r\n    Use the LEFT_HAND_CHARS and RIGHT_HAND_CHARS sets to determine\r\n    if the passed in word can be written with only the left or right\r\n    hand, or if both hands are needed.\r\n    \"\"\"\r\n    \r\n    if all(letter.upper() in LEFT_HAND_CHARS for letter in word):\r\n        return Hand.LEFT\r\n    elif all(letter.upper() in RIGHT_HAND_CHARS for letter in word):\r\n        return Hand.RIGHT\r\n    else:\r\n        return Hand.BOTH\r\n```",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-22 18:51:17.988358+00:00"
        },
        {
            "subject": "Day 076! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 76: #100DaysOfCode progress: today I worked on Bite 317. Pickling objects: https://codechalleng.es/bites/317 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-22 10:01:29.736884+00:00"
        },
        {
            "subject": "Day 075! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 75: #100DaysOfCode progress: today I worked on Bite 314. Print names to columns: https://codechalleng.es/bites/314 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-21 10:01:22.184861+00:00"
        },
        {
            "subject": "Day 074! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 74: #100DaysOfCode progress: today I worked on Bite 295. Join lists: https://codechalleng.es/bites/295 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-20 10:01:42.567241+00:00"
        },
        {
            "subject": "Bite 293. N digit numbers",
            "body": "A different take: I processed the strings instead of the ints.\r\n\r\n```from typing import List, TypeVar\r\nT = TypeVar('T', int, float)\r\nimport re\r\n\r\ndef n_digit_numbers(numbers: List[T], n: int) -> List[int]:\r\n    result=[]\r\n    for num in numbers:\r\n        num_n_digit=int(re.sub('\\.|-','',str(num)).ljust(n,'0')[:n])\r\n        if num<0:\r\n            num_n_digit*=-1\r\n        result.append(num_n_digit)\r\n    return result\r\n    \r\n``` `pytest` run speed: `0.06` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "taspotts",
            "sent_date": "2022-11-19 23:26:12.935270+00:00"
        },
        {
            "subject": "Feedback for Bite 174. String manipulation and metrics",
            "body": "Rated level: 10\n\nComments: Nice bite but would greatly benefit from 1) clarifying the instructions that describe what is expected from cleaning and 2) redesigning the tests to facilitate manual troubleshooting against the expected implementation - the long sample texts and checking only against the length of the expected result are not of much help.\r\nAlso I believe there is a mistake in the expected value of one of the tests: `test_word_metrics_with_word_removed`, on line 104, the count for `saving` should be 7.\r\n\r\nI like the problem, I arrived to a working solution but I just was not unable to pass the tests. I eventually gave up - something I hate to do. A bit frustrating. ",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-19 23:05:40.353211+00:00"
        },
        {
            "subject": "Bite 174. String manipulation and metrics",
            "body": "Quite frustrated with this bite, and reading the discussion I see I am not the only one.\r\nI got my code working fine but the test would still not pass. I ended up giving up and checking the solution, which I hate.\r\nI actually think there is a mistake in the tests: I manually confirmed that the word 'saving' appears 7 times in the `TAX_SYSTEM_IN_US` text.\r\nWhile this is consistent with the expected value in `test_graph_beer_tax` (line 130), in `test_word_metrics_with_word_removed` (line 114) the expected value is 6, which I believe is incorrect, because the removed word in this case should not affect the count of this word.\r\n\r\n@Martin If I may suggest, it would have helped if the tests included something more than the length of the resulting `cleaned` string, e.g. providing the cleaned string for simpler examples that can be troubleshooted manually.",
            "from_user": "mhered8b899449424048c5",
            "to_user": "clamytoe",
            "sent_date": "2022-11-19 22:49:53.653121+00:00"
        },
        {
            "subject": "Day 073! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 73: #100DaysOfCode progress: today I worked on Bite 293. N digit numbers: https://codechalleng.es/bites/293 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-19 10:01:22.265622+00:00"
        },
        {
            "subject": "Bite 99. Write an infinite sequence generator",
            "body": "I really struggled with this one because I was calling the generator incorrectly \r\nAlso, not proud of how I built the list with numbers and letters interwoven. @Sierra I need to look into `itertools.chain.from_iterable` instead...\r\nLooking at the proposed solution made me understand it was unnecessary, as you can have a sequence of `yield` statements inside the loop.\r\n\r\n\r\n```import string\r\nfrom itertools import cycle\r\n\r\ndef sequence_generator():\r\n    lst=zip(enumerate(string.ascii_uppercase,1))\r\n    lst=list(sum(lst,())) # flatten tuples\r\n    lst=list(sum(lst,())) # flatten tuples again\r\n    \r\n    for item in cycle(lst):\r\n        yield item\r\n\r\na=sequence_generator()\r\n\r\nfor _ in range(60):\r\n    print(next(a))\r\n``` `pytest` run speed: `0.04` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-18 19:19:07.108284+00:00"
        },
        {
            "subject": "Day 072! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 72: #100DaysOfCode progress: today I worked on Bite 289. Round to next number: https://codechalleng.es/bites/289 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-18 10:01:24.293959+00:00"
        },
        {
            "subject": "Bite 40. Write a binary search algorithm",
            "body": "Rather proud of this one...\r\n\r\n```import string \r\n\r\ndef binary_search(sequence, target):\r\n    start = 0\r\n    end = len(sequence)\r\n\r\n    while start<=end:\r\n        midp=(end+start)//2\r\n\r\n        if sequence[midp]==target: \r\n            return midp\r\n\r\n        if sequence[midp]<target: \r\n            start = midp+1\r\n            continue\r\n\r\n        if sequence[midp]>target: \r\n            end = midp-1\r\n            continue\r\n        \r\n    return None\r\n``` `pytest` run speed: `0.04` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-17 13:01:57.704491+00:00"
        },
        {
            "subject": "Day 071! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 71: #100DaysOfCode progress: today I worked on Bite 288. Smallest number: https://codechalleng.es/bites/288 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-17 10:01:45.858324+00:00"
        },
        {
            "subject": "Congratulations on hitting the Brown Ninja Belt",
            "body": "Hey Manuel,\n\nCongratulations on yet another milestone: you just earned your Brown Ninja Belt!\n\nWe generated <a href=\"https://codechalleng.es/settings/#certificates\">your Ninja Certificate</a>.\n(If you need to update your first / last name, don't worry, you can generate it again.)\n\nKeep up the momentum and code more Python. Great job!\n\n- Bob & Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-16 23:01:29.806508+00:00"
        },
        {
            "subject": "Bite 179. Strip comments from Python code",
            "body": "I obviously didn't learn my regex...\r\n\r\n\r\n```SINGLE_LINE = '#'\r\nINLINE = '  # '\r\nMULTI_LINE = '\"\"\"'\r\n\r\ndef strip_comments(code):\r\n    # see Bite description\r\n    result=[]\r\n    inside_multiline=False\r\n    for line in code.splitlines():\r\n        if inside_multiline:\r\n            if MULTI_LINE in line:\r\n                inside_multiline= False\r\n            continue\r\n        if line.lstrip().startswith(SINGLE_LINE):\r\n            continue\r\n        if INLINE in line:\r\n            result.append(line[:line.find(INLINE)])\r\n            continue\r\n        if line.lstrip().startswith(MULTI_LINE):\r\n            if MULTI_LINE in line.lstrip()[3:]:\r\n                continue\r\n            inside_multiline=True\r\n            continue\r\n       \r\n        result.append(line)\r\n    return \"\\n\".join(result)\r\n\r\n\r\ncode = '''\"\"\"this is\r\nmy awesome script\r\n\"\"\"\r\n# importing modules\r\nimport re\r\n\r\ndef hello(name):\r\n    \"\"\"my function docstring\"\"\"\r\n    return f'hello {name}'  # my inline comment\r\n'''   \r\n    \r\n    \r\nprint(strip_comments(code))``` `pytest` run speed: `0.04` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-16 22:06:19.632218+00:00"
        },
        {
            "subject": "Day 070! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 70: #100DaysOfCode progress: today I worked on Bite 283. Like there's no tomorrow?: https://codechalleng.es/bites/283 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-16 10:01:35.753379+00:00"
        },
        {
            "subject": "Bite 349. Writing better Spanish",
            "body": "Oh `unicodedata.decomposition()`!\r\n\r\n```import os\r\nfrom pathlib import Path\r\nfrom typing import List\r\nimport unicodedata\r\nfrom urllib.request import urlretrieve\r\nimport re\r\n\r\ndef _get_spanish_dictionary_words() -> List[str]:\r\n    filename = \"spanish.txt\"\r\n    # source of file\r\n    # https://raw.githubusercontent.com/bitcoin/bips\r\n    # /master/bip-0039/spanish.txt\r\n    url = f\"https://bites-data.s3.us-east-2.amazonaws.com/{filename}\"\r\n    tmp_folder = os.getenv(\"TMP\", \"/tmp\")\r\n    local_filepath = Path(tmp_folder) / filename\r\n    if not Path(local_filepath).exists():\r\n        urlretrieve(url, local_filepath)\r\n    return local_filepath.read_text().splitlines()\r\n\r\n\r\nSPANISH_WORDS = _get_spanish_dictionary_words()\r\n_accentuate = {unicodedata.normalize('NFKD', word).encode('ascii', 'ignore').decode('utf8'): word for word in SPANISH_WORDS}\r\n\r\ndef get_accentuated_sentence(\r\n    text: str, words: List[str] = SPANISH_WORDS\r\n) -> str:\r\n    replaced = []\r\n    for word_w_signs in text.split():\r\n        word = re.sub(r'[^a-zA-Z0-9]', '', word_w_signs)\r\n        replaced.append(word_w_signs.replace(word, _accentuate.get(word, word)))\r\n    return \" \".join(replaced)\r\n\r\nprint(get_accentuated_sentence(\"sesion de escribir, primera pagina de mi poesia hecha\"))``` `pytest` run speed: `0.07` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-15 18:17:27.444516+00:00"
        },
        {
            "subject": "Day 069! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 69: #100DaysOfCode progress: today I worked on Bite 279. Armstrong numbers: https://codechalleng.es/bites/279 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-15 10:01:14.205991+00:00"
        },
        {
            "subject": "Day 068! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 68: #100DaysOfCode progress: today I worked on Bite 278. Major and minor numbers: https://codechalleng.es/bites/278 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-14 10:01:21.440149+00:00"
        },
        {
            "subject": "Bite 131. Screen scraper",
            "body": "Hello @Chris I also got the deprecation warnings and I am not using `regex`.\r\nI think they are related to the definition of the screenfetch strings `debian` line 5 of the test file and `output` on line 1 of the code file.:\r\n```\r\n=============================== warnings summary ===============================\r\n/tmp/test_screenfetch.py:5\r\n  /tmp/test_screenfetch.py:5: DeprecationWarning: invalid escape sequence \\;\r\n    debian = \"\"\"\r\n\r\n/tmp/screenfetch.py:1\r\n  /tmp/screenfetch.py:1: DeprecationWarning: invalid escape sequence \\.\r\n    output = \"\"\"\r\n\r\n-- Docs: https://docs.pytest.org/en/latest/warnings.html\r\n======================== 7 passed, 2 warnings in 0.05s =========================\r\n``` ",
            "from_user": "mhered8b899449424048c5",
            "to_user": "clamytoe",
            "sent_date": "2022-11-13 19:25:52.782113+00:00"
        },
        {
            "subject": "Bite 131. Screen scraper",
            "body": "Had to try a few strategies before I found a way through\r\n \r\n```\r\ndef sysinfo_scrape(output):\r\n    \"\"\"Scrapes the output from screenfetch and returns a dictionary\"\"\"\r\n    lines=output.splitlines()\r\n    graph, name_raw = lines[1].rsplit(' ',1)\r\n    graph_width=len(graph)\r\n\r\n    result= {}\r\n    result['Name']=name_raw.strip()\r\n\r\n    for line in lines[2:]:\r\n        if line[graph_width:].strip():\r\n            key_raw, value_raw = line[graph_width:].split(':',1)\r\n            result[key_raw.strip()] = value_raw.strip()\r\n    return result\r\n\r\n# print(sysinfo_scrape(output))``` `pytest` run speed: `0.05` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "clamytoe",
            "sent_date": "2022-11-13 19:20:07.337379+00:00"
        },
        {
            "subject": "Bite 155. Split a string by spaces or quoted text",
            "body": "Nice meeting you `shlex`\r\n\r\n```import re\r\ndef split_words_and_quoted_text(text):\r\n    \"\"\"Split string text by space unless it is\r\n       wrapped inside double quotes, returning a list\r\n       of the elements.\r\n\r\n       For example\r\n       if text =\r\n       'Should give \"3 elements only\"'\r\n\r\n       the resulting list would be:\r\n       ['Should', 'give', '3 elements only']\r\n    \"\"\"\r\n    matches = re.findall('\"(.+?)\"|([\\w-]+)', text)\r\n    return [\"\".join(item) for item in matches]\r\n\r\n\r\ntext = 'Should give \"3 elements only\"'\r\n       \r\nprint(split_words_and_quoted_text(text))``` `pytest` run speed: `0.04` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-13 17:56:41.175333+00:00"
        },
        {
            "subject": "Day 067! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 67: #100DaysOfCode progress: today I worked on Bite 270. Most frequent digit in number: https://codechalleng.es/bites/270 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-13 10:01:23.469207+00:00"
        },
        {
            "subject": "Bite 53. Convert text into multiple columns",
            "body": "Really proud of how I solved this one...\r\n\r\n```import textwrap\r\nimport itertools \r\nfrom pprint import pprint \r\n\r\nCOL_WIDTH = 20\r\nCOL_MARGIN = 4\r\n\r\n\r\ndef text_to_columns(text):\r\n    \"\"\"Split text (input arg) to columns, the amount of double\r\n       newlines (\\n\\n) in text determines the amount of columns.\r\n       Return a string with the column output like:\r\n       line1\\nline2\\nline3\\n ... etc ...\r\n       See also the tests for more info.\"\"\"\r\n\r\n    paragraphs = text.split('\\n\\n')\r\n    \r\n    paragraphs_wrapped = [textwrap.wrap(par.strip(), width=COL_WIDTH) for par in paragraphs]\r\n\r\n    lines_zipped_by_column= list(itertools.zip_longest(*paragraphs_wrapped, fillvalue=\"\"))\r\n\r\n    result = []\r\n    for line in lines_zipped_by_column:\r\n        result.append(\"\".join(col.ljust(COL_WIDTH+COL_MARGIN) for col in line))\r\n    return \"\\n\".join(result)\r\n    \r\n    \r\ntext = \"\"\"My house is small but cosy.\r\n\r\n    It has a white kitchen and an empty fridge.\"\"\"\r\n    \r\npprint(text_to_columns(text))``` `pytest` run speed: `0.04` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-12 19:39:10.136455+00:00"
        },
        {
            "subject": "Day 066! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 66: #100DaysOfCode progress: today I worked on Bite 262. GC content: https://codechalleng.es/bites/262 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-12 10:01:27.556049+00:00"
        },
        {
            "subject": "Bite 257. Extract users dict from a multiline string",
            "body": "Loved so much this line `name = re.sub(',+', ' ', name.rstrip(',')) or 'unknown'` in the proposed solution that I took the bite again to modify my code... \r\nOriginally I was using:\r\n```if name:\r\n    name = re.sub(',+', ' ', name.rstrip(','))\r\nelse:\r\n    name='unknown'\r\n```\r\n\r\n```import re        \r\n\r\ndef get_users(passwd: str) -> dict:\r\n    \"\"\"Split password output by newline,\r\n      extract user and name (1st and 5th columns),\r\n      strip trailing commas from name,\r\n      replace multiple commas in name with a single space\r\n      return dict of keys = user, values = name.\r\n    \"\"\"\r\n    result_dict={}\r\n    for line in passwd.strip().splitlines():\r\n        user, _, _, _, name, *_ =line.split(':')\r\n        name = re.sub(',+', ' ', name.rstrip(',')) or 'unknown'\r\n        result_dict[user]=name\r\n\r\n    return result_dict\r\n\r\n\r\ntest= \"\"\"\r\npostfix:x:108:112::/var/spool/postfix:/bin/false\r\nssh-rsa:x:1004:1004::/home/ssh-rsa:/bin/bash\r\nartagnon:x:1005:1005:Ramkumar R,,,,Git GSOC:/home/artagnon:/bin/bash\r\n\"\"\"\r\n\r\nprint(get_users(test))``` `pytest` run speed: `0.04` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-12 09:32:32.252993+00:00"
        },
        {
            "subject": "Day 065! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 65: #100DaysOfCode progress: today I worked on Bite 257. Extract users dict from a multiline string: https://codechalleng.es/bites/257 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-11 10:01:23.398828+00:00"
        },
        {
            "subject": "Bite 252. Let's play with Pandas Series",
            "body": "I loved the elegant trick to return even/odd indexes in the proposed solution:\r\n```\r\nfirst_idx = 0 if even_index else 1\r\nreturn ser.iloc[first_idx::2]\r\n```\r\n\r\n```import numpy as np\r\nimport pandas as pd\r\n\r\n\r\ndef return_at_index(ser: pd.Series, idx: int) -> object:\r\n    \"\"\"Return the Object at the given index of the Series\r\n    If you want to be extra careful catch and raise an error if\r\n       the index does not exist.\r\n    \"\"\"\r\n    \r\n    try:\r\n        return ser.iloc[idx]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef get_slice(ser: pd.Series, start: int, end: int) -> pd.core.series.Series:\r\n    \"\"\"Return the slice of the given Series in the range between\r\n    start and end.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[start:end]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef get_slice_inclusive(ser: pd.Series,\r\n                        start: int, end: int) -> pd.core.series.Series:\r\n    \"\"\"Return the slice of the given Series in the range between\r\n    start and end inclusive.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[start:end+1]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef return_head(ser: pd.Series, num: int) -> pd.core.series.Series:\r\n    \"\"\"Return the first num elements of the given Series.\r\n    \"\"\"\r\n    return ser.head(num)\r\n\r\n\r\ndef return_tail(ser: pd.Series, num: int) -> pd.core.series.Series:\r\n    \"\"\"Return the last num elements of the given Series.\r\n    \"\"\"\r\n    return ser.tail(num)\r\n\r\n\r\ndef get_index(ser: pd.Series) -> pd.core.indexes.base.Index:\r\n    \"\"\"Return all indexes of the given Series.\r\n    \"\"\"\r\n    return ser.index\r\n\r\n\r\n\r\ndef get_values(ser: pd.Series) -> np.ndarray:\r\n    \"\"\"Return all the values of the given Series.\r\n    \"\"\"\r\n    return ser.values\r\n\r\n\r\ndef get_every_second_indexes(ser: pd.Series,\r\n                             even_index=True) -> pd.core.series.Series:\r\n    \"\"\"Return all rows where the index is either even or odd.\r\n    If even_index is True return every index where idx % 2 == 0\r\n    If even_index is False return every index where idx % 2 != 0\r\n    Assume default indexing i.e. 0 -> n\r\n    \"\"\"\r\n    if even_index:\r\n        rows = [idx%2==0 for idx in ser.index]\r\n    else:\r\n        rows = [idx%2!=0 for idx in ser.index]\r\n    return ser.iloc[rows]\r\n``` `pytest` run speed: `1.02` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "davidcolton",
            "sent_date": "2022-11-10 18:55:49.705846+00:00"
        },
        {
            "subject": "Day 064! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 64: #100DaysOfCode progress: today I worked on Bite 254. Global vs local variables: https://codechalleng.es/bites/254 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-10 10:01:16.867980+00:00"
        },
        {
            "subject": "Bite 251. Introducing Pandas Series",
            "body": "```import string\r\n\r\nimport pandas as pd\r\n\r\n\r\ndef basic_series() -> pd.Series:\r\n    \"\"\"Create a pandas Series containing the values 1, 2, 3, 4, 5\r\n    Don't worry about the indexes for now.\r\n    The name of the series should be 'Fred'\r\n    \"\"\"\r\n    return pd.Series([1, 2, 3, 4, 5], name=\"Fred\", dtype='int64')\r\n\r\n\r\ndef float_series() -> pd.Series:\r\n    \"\"\"Create a pandas Series containing the all the values\r\n    from 0.000 -> 1.000 e.g. 0.000, 0.001, 0.002... 0.999, 1.000\r\n    Don't worry about the indexes or the series name.\r\n    \"\"\"\r\n    PRECISION = 1000\r\n    lst=[i/PRECISION for i in range(PRECISION+1)]\r\n    return pd.Series(lst, dtype='float64')\r\n\r\n\r\ndef alpha_index_series() -> pd.Series:\r\n    \"\"\"Create a Series with values 1, 2, ... 25, 26 of type int64\r\n    and add an index with values a, b, ... y, z\r\n    so index 'a'=1, 'b'=2 ... 'y'=25, 'z'=26\r\n    Don't worry about the series name.\r\n    \"\"\"\r\n    gen=((label,value) for value, label in enumerate(string.ascii_lowercase, start=1))\r\n    return pd.Series(dict(gen), dtype='int64')\r\n\r\ndef object_values_series() -> pd.Series:\r\n    \"\"\"Create a Series with values A, B, ... Y, Z of type object\r\n    and add an index with values 101, 102, ... 125, 126\r\n    so index 101='A', 102='B' ... 125='Y', 126='Z'\r\n    Don't worry about the series name.\r\n    \"\"\"\r\n    gen=((label,value) for label,value in enumerate(string.ascii_uppercase, start=101))\r\n    return pd.Series(dict(gen), dtype='object')\r\n\r\n\r\nprint(float_series())\r\nprint(alpha_index_series())\r\nprint(object_values_series())```",
            "from_user": "mhered8b899449424048c5",
            "to_user": "davidcolton",
            "sent_date": "2022-11-09 20:15:43.701037+00:00"
        },
        {
            "subject": "Day 063! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 63: #100DaysOfCode progress: today I worked on Bite 252. Let's play with Pandas Series: https://codechalleng.es/bites/252 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-09 10:01:16.350953+00:00"
        },
        {
            "subject": "Bite 358. Implementation of a Simple Typer Test",
            "body": "Must get used to `@pytest.mark.parametrize()`!\r\n\r\n```import pytest\r\nfrom typer.testing import CliRunner\r\n\r\nfrom script import app\r\n\r\n\r\n@pytest.fixture()\r\ndef runner() -> CliRunner:\r\n    return CliRunner()\r\n\r\n    \r\ndef test_app(runner):\r\n    result = runner.invoke(app, [\"Manolo\"])\r\n    assert result.exit_code == 0\r\n    assert \"Hello Manolo!\" in result.stdout\r\n\r\n\r\ndef test_help_msg(runner):\r\n    result = runner.invoke(app, [\"--help\"])\r\n    assert result.exit_code == 0\r\n    assert \"CLI that allows you to greet a person.\" in result.stdout\r\n    assert \"The name of the person to greet.\" in result.stdout\r\n```",
            "from_user": "mhered8b899449424048c5",
            "to_user": "r33b",
            "sent_date": "2022-11-08 18:39:23.050927+00:00"
        },
        {
            "subject": "Bite 72. Retrieve the right Ninja Belt based on score",
            "body": "I am sure this is not the most pythonic way to go, but it works.\r\n\r\n```from bisect import bisect\r\n\r\nscores = [10, 50, 100, 175, 250, 400, 600, 800, 1000]\r\nbelts = 'white yellow orange green blue brown black paneled red'.split()\r\n\r\n\r\ndef get_belt(user_score, scores=scores, belts=belts):\r\n    # scores_belts= list(zip(scores,belts))\r\n    ind= bisect(scores, user_score)\r\n    if ind==0:\r\n        return None\r\n    elif ind>=len(belts):\r\n        return belts[-1]\r\n    else:\r\n        return belts[ind-1]\r\n\r\nfor score, expected in [(3,'None'),(10,'white'),(12,'white'),(900,'paneled'),(1000,'red'),(1001,'red')]:\r\n    print(f\"{score=} {expected=} result={get_belt(score)}\")``` `pytest` run speed: `0.06` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-08 12:22:34.811152+00:00"
        },
        {
            "subject": "Day 062! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 62: #100DaysOfCode progress: today I worked on Bite 251. Introducing Pandas Series: https://codechalleng.es/bites/251 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-08 10:01:10.018136+00:00"
        },
        {
            "subject": "Bite 154. Write your own Data Class",
            "body": "Neat!\r\n\r\n```from dataclasses import dataclass\r\n\r\n@dataclass(order=True)\r\nclass Bite:\r\n    \"\"\"Class for describing PyBites.\"\"\"\r\n    number: int\r\n    title: str\r\n    level: str = \"Beginner\"\r\n\r\n    def __post_init__(self):\r\n        self.title = self.title.capitalize()\r\n``` `pytest` run speed: `0.06` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-08 09:39:59.442204+00:00"
        },
        {
            "subject": "Day 061! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 61: #100DaysOfCode progress: today I worked on Bite 246. Test print / standard output: https://codechalleng.es/bites/246 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-07 10:01:37.438898+00:00"
        },
        {
            "subject": "Day 060! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 60: #100DaysOfCode progress: today I worked on Bite 241. Write tests for list_to_decimal: https://codechalleng.es/bites/241 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-06 10:01:01.605271+00:00"
        },
        {
            "subject": "Day 059! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 59: #100DaysOfCode progress: today I worked on Bite 238. Write tests for Fibonacci: https://codechalleng.es/bites/238 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-05 10:01:15.121170+00:00"
        },
        {
            "subject": "Day 058! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 58: #100DaysOfCode progress: today I worked on Bite 231. Where are the emojis?: https://codechalleng.es/bites/231 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-04 10:01:03.221433+00:00"
        },
        {
            "subject": "Bite 225. Swap case PyBites characters",
            "body": "Wow the proposed solution is so much more elegant! \r\nLoved the use of `if else` in the comprehension and was delighted to discover `swapcase()`\r\n \r\n```PYBITES = \"pybites\"\r\n\r\n\r\ndef convert_pybites_chars(text):\r\n    \"\"\"Swap case all characters in the word pybites for the given text.\r\n       Return the resulting string.\"\"\"\r\n    result=[]\r\n    for letter in text:\r\n        if letter in PYBITES:\r\n            letter = letter.upper()\r\n        elif letter in PYBITES.upper():\r\n            letter = letter.lower()\r\n        result.append(letter)\r\n    return \"\".join(result)\r\n    \r\ntext = \"Today we added TWO NEW Bites to our Platform, exciting!\"\r\nprint(convert_pybites_chars(text))``` `pytest` run speed: `0.08` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-04 07:40:36.163491+00:00"
        },
        {
            "subject": "Bite 272. Find common words",
            "body": "Loved the proposed solution using `set(map(str.lower,sentence))` to make it case insensitive and remove duplicates and `&` for the intersection\r\n\r\n\r\n```from collections import Counter\r\n\r\nfrom typing import List\r\n\r\n\r\ndef common_words(sentence1: List[str], sentence2: List[str]) -> List[str]:\r\n    \"\"\"\r\n    Input:  Two sentences - each is a  list of words in case insensitive ways.\r\n    Output: those common words appearing in both sentences. Capital and lowercase \r\n            words are treated as the same word. \r\n\r\n            If there are duplicate words in the results, just choose one word. \r\n            Returned words should be sorted by word's length.\r\n    \"\"\"\r\n    \r\n    # all lower() to make case insensitive\r\n    sentence2_lower = [word.lower() for word in sentence2]\r\n\r\n    # set() eliminates duplicates\r\n    result = set(word.lower() for word in sentence1 if word.lower() in sentence2_lower)\r\n    \r\n    return sorted(result,key=len)\r\n    \r\n\r\nS = ['You', 'can', 'do', 'anything', 'but', 'not', 'everything', 'do']\r\nT = ['We', 'are', 'what', 'we', 'repeatedly', 'do', 'is', 'not', 'an', 'act', 'do']\r\nprint(common_words(S,T))``` `pytest` run speed: `0.04` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "danielhao5",
            "sent_date": "2022-11-03 17:57:01.751689+00:00"
        },
        {
            "subject": "Day 057! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 57: #100DaysOfCode progress: today I worked on Bite 225. Swap case PyBites characters: https://codechalleng.es/bites/225 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-03 10:01:10.182611+00:00"
        },
        {
            "subject": "Bite 190. Parse income distribution from Latin America XML",
            "body": "I really struggled with this one because the labels didn't work as expected.\r\n\r\n`wb:name` and `wb:incomeLevel` were not found, instead I had to use `{http://www.worldbank.org}name` and `{http://www.worldbank.org}incomeLevel`. \r\n\r\n(I found out by listing elements with `root.iter()`)\r\n\r\nAm I the only one who experienced this issue?\r\n\r\n\r\n```import os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\n\r\nimport xml.etree.ElementTree as ET\r\nfrom collections import defaultdict\r\n\r\n# import the countries xml file\r\ntmp = Path(os.getenv(\"TMP\", \"/tmp\"))\r\ncountries = tmp / 'countries.xml'\r\n\r\nif not countries.exists():\r\n    urlretrieve(\r\n        'https://bites-data.s3.us-east-2.amazonaws.com/countries.xml',\r\n        countries\r\n    )\r\n\r\n\r\ndef get_income_distribution(xml=countries):\r\n    \"\"\"\r\n    - Read in the countries xml as stored in countries variable.\r\n    - Parse the XML\r\n    - Return a dict of:\r\n      - keys = incomes (wb:incomeLevel)\r\n      - values = list of country names (wb:name)\r\n    \"\"\"\r\n    result = defaultdict(list)\r\n\r\n    for country in ET.parse(xml).getroot():\r\n        name = country.find('{http://www.worldbank.org}name').text\r\n        income = country.find('{http://www.worldbank.org}incomeLevel').text\r\n        result[income].append(name) \r\n\r\n    return result\r\n    ``` `pytest` run speed: `0.06` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-02 19:24:39.531895+00:00"
        },
        {
            "subject": "Bite 122. Check if two words are anagrams",
            "body": "```from collections import Counter \r\n\r\ndef is_anagram(word1, word2):\r\n    \"\"\"Receives two words and returns True/False (boolean) if word2 is\r\n       an anagram of word1, ignore case and spacing.\r\n       About anagrams: https://en.wikipedia.org/wiki/Anagram\"\"\"\r\n    return _letters(word1) == _letters(word2) \r\n        \r\ndef _letters(word):\r\n    return Counter([letter.lower() for letter in word if letter.isalnum() ])\r\n\r\n\"\"\"\r\ntests=[\r\n    (\"rail safety\", \"fairy tales\"),\r\n    (\"roast beef\", \"eat for BSE\"),\r\n    (\"restful\", \"fluster\"),\r\n    (\"funeral\", \"real fun\"),\r\n    (\"adultery\", \"true lady\"),\r\n    (\"customers\", \"store scum\"),\r\n    (\"forty five\", \"over fifty\"),\r\n    (\"William Shakespeare\", \"I am a weakish speller\"),\r\n    (\"Madam Curie\", \"Radium came\"),\r\n    ]\r\n    \r\nfor word1, word2 in tests:\r\n    print(is_anagram(word1, word2))\r\n    \r\n\"\"\"``` `pytest` run speed: `0.08` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-02 18:17:50.969163+00:00"
        },
        {
            "subject": "Day 056! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 56: #100DaysOfCode progress: today I worked on Bite 218. Create a sandwich decorator: https://codechalleng.es/bites/218 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-02 10:01:24.226796+00:00"
        },
        {
            "subject": "Bite 138. OOP fun at the Zoo",
            "body": "Nice use of itertools.count() and next() for the counter, I'm jaleous!\r\n\r\n```from pprint import pprint\r\n\r\nclass Animal:\r\n    sequence=10000\r\n    animals = []\r\n    \r\n    def __init__(self, name):\r\n        self.__class__.sequence +=1\r\n        self.id = self.__class__.sequence\r\n        self.name  = name.title()\r\n        self.__class__.animals.append(self)\r\n\r\n    def __str__(self):\r\n        return f\"{self.id}. {self.name}\"\r\n        \r\n    @classmethod\r\n    def zoo(cls):\r\n        return \"\\n\".join([str(item) for item in cls.animals])\r\n            ```",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-01 21:41:37.251638+00:00"
        },
        {
            "subject": "Bite 212. Suppressing exceptions",
            "body": "Didn't realise you could list together in the same suppress() nested exceptions\r\n```from contextlib import suppress\r\n\r\n\r\ndef sum_numbers(numbers):\r\n    \"\"\"This generator divides each number by its consecutive number.\r\n       So if it gets passed in [4, 2, 1] it yields 4/2 and 2/1.\r\n       It ignores ZeroDivisionError and TypeError exceptions (latter happens\r\n       when a string or other non-numeric data type is in numbers)\r\n\r\n       Task: use contextlib's suppress twice to make the code below more concise.\r\n    \"\"\"\r\n    for i, j in zip(numbers, numbers[1:]):\r\n        # replace the block below\r\n        with suppress(TypeError):\r\n            with suppress(ZeroDivisionError):\r\n                yield i/j\r\n    ``` `pytest` run speed: `0.06` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-11-01 20:54:01.242141+00:00"
        },
        {
            "subject": "Day 055! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 55: #100DaysOfCode progress: today I worked on Bite 215. Validate a license key: https://codechalleng.es/bites/215 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-11-01 10:01:05.712303+00:00"
        },
        {
            "subject": "Day 054! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 54: #100DaysOfCode progress: today I worked on Bite 214. A countdown generator: https://codechalleng.es/bites/214 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-31 10:00:55.030837+00:00"
        },
        {
            "subject": "Day 053! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 53: #100DaysOfCode progress: today I worked on Bite 210. Add Type Annotations: https://codechalleng.es/bites/210 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-30 10:01:20.291259+00:00"
        },
        {
            "subject": "Day 052! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 52: #100DaysOfCode progress: today I worked on Bite 209. Write a Sphinx docstring: https://codechalleng.es/bites/209 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-29 10:01:21.287768+00:00"
        },
        {
            "subject": "Day 051! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 51: #100DaysOfCode progress: today I worked on Bite 208. Find the number pairs summing up N: https://codechalleng.es/bites/208 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-28 10:01:18.090050+00:00"
        },
        {
            "subject": "Bite 267. Measure the size of an island",
            "body": "Nice use of `enumerate` in the proposed solution to scan the array:\r\n```\r\nfor r, row in enumerate(map_):\r\n    for c, val in enumerate(row):\r\n        ...\r\n```\r\n\r\n\r\n```# Hint:\r\n# You can define a helper funtion: get_others(map, row, col) to assist you.\r\n# Then in the main island_size function just call it when traversing the map.\r\n\r\n\r\ndef get_shores(map_, r, c):\r\n    \"\"\"Go through the map and check the size of the island\r\n       (= summing up all the 1s that are part of the island)\r\n\r\n       Input - the map, row, column position\r\n       Output - return the total number)\r\n    \"\"\"\r\n    nums = 0\r\n    rows= len(map_)\r\n    cols= (len(map_[0]))\r\n    # your code here\r\n    # print(f\"{r=},{c=}\")\r\n    #check N\r\n    if r==0:\r\n        nums+=1\r\n    else:\r\n        nums+=map_[r-1][c]==0\r\n    \r\n    #check S\r\n    if r==rows-1:\r\n        nums+=1\r\n    else:\r\n        nums+=map_[r+1][c]==0\r\n\r\n    #check E\r\n    if c==0:\r\n        nums+=1\r\n    else:\r\n        nums+=map_[r][c-1]==0\r\n\r\n    #check W\r\n    if c==cols-1:\r\n        nums+=1\r\n    else:\r\n        nums+=map_[r][c+1]==0\r\n    \r\n    return nums\r\n\r\n\r\ndef island_size(map_):\r\n    \"\"\"Hint: use the get_others helper\r\n\r\n    Input: the map\r\n    Output: the perimeter of the island\r\n    \"\"\"\r\n    perimeter = 0\r\n    rows= len(map_)\r\n    cols= (len(map_[0]))\r\n    # your code here\r\n    for i in range(rows):\r\n        for j in range(cols):\r\n            if map_[i][j] == 1:\r\n                perimeter +=get_shores(map_, i, j) \r\n    return perimeter\r\n    \r\n    \r\n``` `pytest` run speed: `0.05` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "danielhao5",
            "sent_date": "2022-10-27 18:40:34.539187+00:00"
        },
        {
            "subject": "Bite 189. Filter a list of names",
            "body": "I like the original solution with a generator, this one with a list is ok too\r\n\r\n```import string\r\nIGNORE_CHAR = 'b'\r\nQUIT_CHAR = 'q'\r\nMAX_NAMES = 5\r\n\r\n\r\ndef filter_names(names):\r\n    lst=[] \r\n    for name in names:\r\n        if name.startswith(IGNORE_CHAR) or any(char.isdigit() for char in name):\r\n            continue\r\n        if name.startswith(QUIT_CHAR):\r\n            break\r\n        lst.append(name)\r\n        if len(lst) >= MAX_NAMES:\r\n            break\r\n    return lst\r\n\r\nlst=['pet1e', 'milly', 'quit', 'me', 'you' ]\r\nprint(filter_names(lst))``` `pytest` run speed: `0.06` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-27 18:01:54.759667+00:00"
        },
        {
            "subject": "Day 050! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 50: #100DaysOfCode progress: today I worked on Bite 192. Some logging practice: https://codechalleng.es/bites/192 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-27 10:00:54.136858+00:00"
        },
        {
            "subject": "Day 049! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 49: #100DaysOfCode progress: today I worked on Bite 189. Filter a list of names: https://codechalleng.es/bites/189 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-26 10:00:52.226431+00:00"
        },
        {
            "subject": "Bite 86. Create a RGB-to-Hex converter",
            "body": "```def rgb_to_hex(rgb):\r\n    \"\"\"Receives (r, g, b)  tuple, checks if each rgb int is within RGB\r\n       boundaries (0, 255) and returns its converted hex, for example:\r\n       Silver: input tuple = (192,192,192) -> output hex str = #C0C0C0\"\"\"\r\n    if all(0<=col<=255 for col in rgb):\r\n        return f\"#{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}\".upper()\r\n    raise ValueError\r\n\r\n# print(rgb_to_hex((128, 128, 0)))``` `pytest` run speed: `0.08` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-25 18:16:13.136648+00:00"
        },
        {
            "subject": "Bite 181. Keep a list sorted upon insert",
            "body": "Beautiful!\r\n\r\n```import bisect\r\n\r\n\r\nclass OrderedList:\r\n\r\n    def __init__(self):\r\n        self._numbers = []\r\n\r\n    def add(self, num):\r\n        bisect.insort(self._numbers, num) # you complete\r\n\r\n    def __str__(self):\r\n        return ', '.join(str(num) for num in self._numbers)\r\n\r\nif __name__ == \"__main__\":\r\n    order = OrderedList()\r\n    order.add(10)\r\n    print(order)  # __str__ already provided\r\n    order.add(1)\r\n    print(order)\r\n    order.add(16)\r\n    print(order)\r\n    order.add(5)\r\n    print(order)\r\n``` `pytest` run speed: `0.06` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-25 17:54:35.984021+00:00"
        },
        {
            "subject": "Day 048! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 48: #100DaysOfCode progress: today I worked on Bite 188. Get statistics from PyBites test code: https://codechalleng.es/bites/188 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-25 10:00:55.018041+00:00"
        },
        {
            "subject": "Bite 180. Group names by country",
            "body": "I was hesitating to add `[1:]` to `splitlines()`...\r\n\r\n ```from collections import defaultdict\r\nfrom pprint import pprint \r\n\r\n# fake data from https://www.mockaroo.com\r\ndata = \"\"\"last_name,first_name,country_code\r\nWatsham,Husain,ID\r\nHarrold,Alphonso,BR\r\nApdell,Margo,CN\r\nTomblings,Deerdre,RU\r\nWasielewski,Sula,ID\r\nJeffry,Rudolph,TD\r\nBrenston,Luke,SE\r\nParrett,Ines,CN\r\nBraunle,Kermit,PL\r\nHalbard,Davie,CN\"\"\"\r\n\r\n\r\ndef group_names_by_country(data: str = data) -> defaultdict:\r\n    countries = defaultdict(list)\r\n    # your code\r\n    for line in data.splitlines():\r\n        surname, name, country = tuple(line.split(\",\"))\r\n        if country != \"country_code\":\r\n            countries[country].append(\" \".join([name,surname]))\r\n    return countries\r\n    \r\npprint(group_names_by_country())``` `pytest` run speed: `0.08` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-24 21:47:21.771141+00:00"
        },
        {
            "subject": "Day 047! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 47: #100DaysOfCode progress: today I worked on Bite 181. Keep a list sorted upon insert: https://codechalleng.es/bites/181 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-24 10:01:19.909542+00:00"
        },
        {
            "subject": "Bite 176. Create a variable length chessboard",
            "body": "I like the proposed solution much more than mine...\r\n\r\n```WHITE, BLACK = ' ', '#'\r\n\r\n\r\ndef create_chessboard(size=8):\r\n    \"\"\"Create a chessboard with of the size passed in.\r\n       Don't return anything, print the output to stdout\"\"\"\r\n    odd_row = (WHITE + BLACK)*(size // 2)\r\n    even_row = (BLACK + WHITE)*(size // 2)\r\n    if size%2:\r\n        odd_row+=WHITE\r\n        even_row+=BLACK\r\n    odd_row+=\"\\n\"\r\n    even_row+=\"\\n\"\r\n    board =  (odd_row + even_row)*(size // 2)\r\n    if size%2:\r\n        board+=odd_row\r\n    print(board)\r\n\r\ncreate_chessboard(8)```",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-23 17:11:20.288166+00:00"
        },
        {
            "subject": "Bite 48. Make a bar chart of new Safari books",
            "body": "Looks like this time I went for a very different solution. \r\nQuite fond of it though, I find that using `next()` was rather elegant in this case.\r\n \r\n```import os\r\nimport urllib.request\r\nimport time\r\nimport sys\r\n\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nDATA = 'safari.logs'\r\nSAFARI_LOGS = os.path.join(TMP, DATA)\r\nPY_BOOK, OTHER_BOOK = '\ud83d\udc0d', '.'\r\nBOOK_SENT_TO_SLACK=\"sending to slack channel\"\r\nPYTHON = \"python\"\r\n\r\nurllib.request.urlretrieve(\r\n    f'https://bites-data.s3.us-east-2.amazonaws.com/{DATA}',\r\n    SAFARI_LOGS\r\n)\r\n\r\ndef create_chart():\r\n    last_date = \"00-00\"\r\n    with open(SAFARI_LOGS) as f:\r\n        for line in f:\r\n            date, rest = line.split(\" \", 1)\r\n            _, book_title = rest.split(\"-\", 1)\r\n\r\n            if BOOK_SENT_TO_SLACK in next(f):\r\n                if date != last_date:\r\n                    sys.stdout.write(\"\\n\"+date+\" \")\r\n                    last_date = date\r\n                sys.stdout.write(PY_BOOK if PYTHON in book_title.lower() else OTHER_BOOK)\r\n\r\n                    \r\ncreate_chart()``` `pytest` run speed: `0.10` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-23 16:50:56.160664+00:00"
        },
        {
            "subject": "Day 046! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 46: #100DaysOfCode progress: today I worked on Bite 180. Group names by country: https://codechalleng.es/bites/180 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-23 10:01:16.890798+00:00"
        },
        {
            "subject": "Congrats on your Blue Ninja belt! Do you want to build bigger apps?",
            "body": "Hey Manuel,\n\nHitting this achievement speaks volumes about your understanding of Python and your commitment to learning.\n\nIt also raises the question: What's next?\n\nWhat are you going to do with this extraordinary skill?\n\nAre you going to put these gains to good use at work and push for a promotion or a better role?\n\nOr are you going to break free of the chains and do it your way as a freelancer?\n\nHeck, you could even start your own business ...\n\nWhatever your goal, don't let this momentum go to waste.\n\nWe want to and, more importantly, CAN help you get there.\n\nInterested in taking your Python / developer skills to the next level? Check out our PyBites Developer Mindset (PDM) coaching program:\nhttps://pybit.es/catalogue/the-pdm-program/\n\n- Bob & Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-22 12:10:59.650953+00:00"
        },
        {
            "subject": "Bite 239. Test FizzBuzz",
            "body": "Need to get used to `@pytest.mark.parametrize()`... \r\n```from fizzbuzz import fizzbuzz\r\n\r\n# write one or more pytest functions below, they need to start with test_\r\ndef test_for_fizz():\r\n    for num in [3, 6, 9, 12]:\r\n        assert fizzbuzz(num) == \"Fizz\"\r\n\r\ndef test_for_buzz():\r\n    for num in [5, 10, 20, 25]:\r\n        assert fizzbuzz(num) == \"Buzz\"\r\n    \r\ndef test_for_fizzbuzz():\r\n    for num in [15, 45, 75, 225]:\r\n        assert fizzbuzz(num) == \"Fizz Buzz\"\r\n\r\ndef test_for_other():\r\n    for num in [1, 2, 4, 7, 8, 11, 13, 14, 16]:\r\n        assert fizzbuzz(num) == num```",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-22 11:01:19.355445+00:00"
        },
        {
            "subject": "Day 045! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 45: #100DaysOfCode progress: today I worked on Bite 176. Create a variable length chessboard: https://codechalleng.es/bites/176 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-22 10:01:01.773855+00:00"
        },
        {
            "subject": "Bite 169. Simple length converter",
            "body": "My proposal was not very pythonic... \r\nI liked about the official solution the use of a dict as switch/case structure and the try/except to catch the TypeError\r\n\r\n```CM_PER_INCH=2.54\r\ndef convert(value: float, fmt: str) -> float:\r\n    \"\"\"Converts the value to the designated format.\r\n\r\n    :param value: The value to be converted must be numeric or raise a TypeError\r\n    :param fmt: String indicating format to convert to\r\n    :return: Float rounded to 4 decimal places after conversion\r\n    \"\"\"\r\n    if type(value) not in [int, float]:\r\n        raise TypeError\r\n    if not isinstance(fmt,str):\r\n        raise ValueError\r\n    if fmt.lower() == \"cm\":\r\n        k = CM_PER_INCH\r\n    elif fmt.lower() == \"in\":\r\n        k = 1 / CM_PER_INCH\r\n    else: \r\n        raise ValueError\r\n    \r\n    return round(k*value,4)``` `pytest` run speed: `0.16` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "clamytoe",
            "sent_date": "2022-10-21 19:32:47.036967+00:00"
        },
        {
            "subject": "Day 044! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 44: #100DaysOfCode progress: today I worked on Bite 172. Having fun with Python Partials: https://codechalleng.es/bites/172 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-21 10:00:51.384992+00:00"
        },
        {
            "subject": "Day 043! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 43: #100DaysOfCode progress: today I worked on Bite 169. Simple length converter: https://codechalleng.es/bites/169 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-20 10:01:10.230868+00:00"
        },
        {
            "subject": "Day 042! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 42: #100DaysOfCode progress: today I worked on Bite 167. Complete a User class: properties and representation dunder methods: https://codechalleng.es/bites/167 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-19 10:01:14.445808+00:00"
        },
        {
            "subject": "Bite 208. Find the number pairs summing up N",
            "body": "I was so happy with my one liner... but then I completely missed using itertools!\r\n\r\n```def find_number_pairs(numbers, N=10):\r\n\r\n    return [(n1,n2) for i,n1 in enumerate(numbers) for n2 in numbers[i+1:] if n1+n2 == N]\r\n\r\n    \"\"\" this works \r\n    lst = []\r\n    for i,n1 in enumerate(numbers):\r\n        for n2 in numbers[i+1:]:\r\n            # print(f\"{n1},{n2}\")\r\n            if n1+n2 == N:\r\n                lst.append((n1,n2))\r\n                \r\n    return lst\r\n    \"\"\"\r\n    \r\ntest2 = [0.24, 0.36, 0.04, 0.06, 0.33, 0.08, 0.20, 0.27, 0.3, 0.31, 0.76, 0.05, 0.08, 0.08, 0.67, 0.09, 0.66, 0.79, 0.95]\r\nprint(find_number_pairs(test2, N=1))\r\n\r\n\r\n``` `pytest` run speed: `0.04` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-18 19:27:28.680656+00:00"
        },
        {
            "subject": "Day 041! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 41: #100DaysOfCode progress: today I worked on Bite 165. Parse an /etc/passwd file output: https://codechalleng.es/bites/165 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-18 10:01:18.253996+00:00"
        },
        {
            "subject": "Day 040! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 40: #100DaysOfCode progress: today I worked on Bite 161. Count the number of files and directories: https://codechalleng.es/bites/161 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-17 10:00:57.059488+00:00"
        },
        {
            "subject": "Day 039! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 39: #100DaysOfCode progress: today I worked on Bite 153. Round a sequence of numbers: https://codechalleng.es/bites/153 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-16 10:00:58.498777+00:00"
        },
        {
            "subject": "Bite 143. Look up a value in 3 dictionaries",
            "body": "Missed ChainMap()!! Used the old for loop instead, seems comparatively slow\r\n\r\n```NOT_FOUND = \"Not found\"\r\n\r\ngroup1 = {'tim': 30, 'bob': 17, 'ana': 24}\r\ngroup2 = {'ana': 26, 'thomas': 64, 'helen': 26}\r\ngroup3 = {'brenda': 17, 'otto': 44, 'thomas': 46}\r\n\r\n\r\ndef get_person_age(name):\r\n    \"\"\"Look up name (case insensitive search) and return age.\r\n       If name in > 1 dict, return the match of the group with\r\n       greatest N (so group3 > group2 > group1)\r\n    \"\"\"\r\n    if isinstance(name,str):\r\n        for group in [group3, group2, group1]:\r\n            if name.lower() in group:\r\n                return group[name.lower()]    \r\n    return NOT_FOUND\r\n\r\n``` `pytest` run speed: `0.06` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-15 20:07:13.829676+00:00"
        },
        {
            "subject": "Day 038! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 38: #100DaysOfCode progress: today I worked on Bite 149. Sorting words with constraint: https://codechalleng.es/bites/149 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-15 10:00:50.829846+00:00"
        },
        {
            "subject": "Day 037! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 37: #100DaysOfCode progress: today I worked on Bite 143. Look up a value in 3 dictionaries: https://codechalleng.es/bites/143 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-14 10:00:49.095304+00:00"
        },
        {
            "subject": "Bite 39. Calculate the total duration of a course",
            "body": "I like the details that show mastery of the language and make the original solution cleaner than mine:  split() returns two values, incrementing timedelta instead of appending then adding...\r\nI am jaleous.\r\n\r\n```from datetime import datetime, timedelta\r\nimport os\r\nimport re\r\nfrom typing import List\r\nimport urllib.request\r\n\r\n# getting the data\r\nCOURSE_TIMES = os.path.join(\r\n    os.getenv(\"TMP\", \"/tmp\"),\r\n    'course_timings'\r\n)\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/course_timings',\r\n    COURSE_TIMES\r\n)\r\n\r\n\r\ndef get_all_timestamps() -> List[str]:\r\n    \"\"\"Read in the COURSE_TIMES and extract all MM:SS timestamps.\r\n       Here is a snippet of the input file:\r\n\r\n       Start  What is Practical JavaScript? (3:47)\r\n       Start  The voice in your ear (4:41)\r\n       Start  Is this course right for you? (1:21)\r\n       ...\r\n\r\n        Return a list of MM:SS timestamps\r\n    \"\"\"\r\n    with open(COURSE_TIMES) as f:\r\n        raw_list = [re.findall(\"\\((.+)\\)$\", line.lstrip()) for line in f.readlines()]\r\n    return [timestamp[0] for timestamp in raw_list if timestamp]\r\n\r\n\r\ndef calc_total_course_duration(timestamps) -> str:\r\n    \"\"\"Takes timestamps list as returned by get_all_timestamps\r\n       and calculates the total duration as HH:MM:SS\"\"\"\r\n    lst = []\r\n    for item in timestamps:\r\n        mm_ss = item.split(\":\")\r\n        lst.append(timedelta(minutes=int(mm_ss[0]), seconds=int(mm_ss[1])))\r\n    return str(sum(lst, timedelta()))\r\n    \r\n\r\nprint(calc_total_course_duration(get_all_timestamps()))``` `pytest` run speed: `0.10` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-13 10:57:51.461610+00:00"
        },
        {
            "subject": "Day 036! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 36: #100DaysOfCode progress: today I worked on Bite 136. Bloodtypes: https://codechalleng.es/bites/136 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-13 10:00:48.097616+00:00"
        },
        {
            "subject": "Day 035! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 35: #100DaysOfCode progress: today I worked on Bite 133. Convert an Amazon URL into an affiliation link: https://codechalleng.es/bites/133 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-12 10:01:06.867989+00:00"
        },
        {
            "subject": "Bite 265. Optimal fund raising",
            "body": "I see lots of variations. This implementation is not the fastest or most pythonic, but is simple and quite readable \r\n\r\n```IMPOSSIBLE = 'Mission impossible. No one can contribute.'\r\n\r\n\r\ndef max_fund(village):\r\n    \"\"\"Find a contiguous subarray with the largest sum.\"\"\"\r\n    # Hint: while iterating, you could save the best_sum collected so far\r\n    # return total, starting, ending\r\n    start = 0\r\n    end = 0\r\n    best_sum = float('-inf')\r\n    for i in range(len(village)):\r\n        for j in range(i+1,len(village)+1):\r\n            donations = sum(village[i:j])\r\n            if donations >= best_sum:\r\n                best_sum = donations\r\n                start = i\r\n                end = j\r\n    if best_sum <= 0:\r\n        print(IMPOSSIBLE)\r\n        return (0,0,0)\r\n    return (best_sum, start+1, end)\r\n    \r\n``` `pytest` run speed: `0.07` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "danielhao5",
            "sent_date": "2022-10-11 18:13:55.787344+00:00"
        },
        {
            "subject": "Day 034! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 34: #100DaysOfCode progress: today I worked on Bite 130. Analyze some basic Car Data: https://codechalleng.es/bites/130 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-11 10:01:08.428632+00:00"
        },
        {
            "subject": "Bite 259. Reverse complement",
            "body": "```# See tests for a more comprehensive complementary table\r\nSIMPLE_COMPLEMENTS_STR = \"\"\"#Reduced table with bases A, G, C, T\r\n Base\tComplementary Base\r\n A\tT\r\n T\tA\r\n G\tC\r\n C\tG\r\n\"\"\"\r\n\r\n\r\ndef _read_str_table(str_table):\r\n    \"\"\"\r\n    Takes a string defining a table of valid and comlementary bases \r\n    and returns a dict of base:complement\r\n    \"\"\"\r\n    lst = [line.split() for line in str_table.splitlines()[2:]]\r\n    return  {item[0].upper().strip(): item[-1].upper().strip() for item in lst}\r\n\r\n# Recommended helper function\r\ndef _clean_sequence(sequence, str_table):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns all sequences converted to upper case and remove invalid\r\n    characters\r\n    t!t%ttttAACCG --> TTTTTTAACCG\r\n    \"\"\"\r\n    base_table = _read_str_table(str_table)\r\n    return \"\".join([base for base in sequence.upper() if base in base_table])\r\n\r\n\r\ndef reverse(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a reversed string of sequence while removing all characters\r\n    not found in str_table characters\r\n    e.g. t!t%ttttAACCG --> GCCAATTTTTT\r\n    \"\"\"\r\n    return _clean_sequence(sequence, str_table)[::-1]\r\n\r\n\r\ndef complement(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a string containing complementary bases as defined in\r\n    str_table while removing non input_sequence characters\r\n    e.g. t!t%ttttAACCG --> AAAAAATTGGC\r\n    \"\"\"\r\n    base_table = _read_str_table(str_table)\r\n    return \"\".join([base_table[base] for base in _clean_sequence(sequence, str_table) ])\r\n    \r\n\r\ndef reverse_complement(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a string containing complementary bases as defined in str_table\r\n    while removing non input_sequence characters\r\n    e.g. t!t%ttttAACCG --> CGGTTAAAAAA\r\n    \"\"\"\r\n    return reverse(complement(sequence,str_table),str_table)\r\n\r\n\r\ntest_str = \"\"\"# Full table with ambigous bases\r\n Base\tName\tBases Represented\tComplementary Base\r\n A\tAdenine\tA\tT\r\n T\tThymidine\tT \tA\r\n U\tUridine(RNA only)\tU\tA\r\n G\tGuanidine\tG\tC\r\n C\tCytidine\tC\tG\r\n Y\tpYrimidine\tC T\tR\r\n R\tpuRine\tA G\tY\r\n S\tStrong(3Hbonds)\tG C\tS\r\n W\tWeak(2Hbonds)\tA T\tW\r\n K\tKeto\tT/U G\tM\r\n M\taMino\tA C\tK\r\n B\tnot A\tC G T\tV\r\n D\tnot C\tA G T\tH\r\n H\tnot G\tA C T\tD\r\n V\tnot T/U\tA C G\tB\r\n N\tUnknown\tA C G T\tN\r\n\"\"\"\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    print(_read_str_table(str_table=test_str))\r\n    print(_clean_sequence('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))\r\n    print(reverse('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))\r\n    print(complement('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))\r\n    print(reverse_complement('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))``` `pytest` run speed: `0.14` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "schustercf",
            "sent_date": "2022-10-10 21:53:20.353843+00:00"
        },
        {
            "subject": "Bite 117. Round a number even (a.k.a. banker's rounding)",
            "body": "You got me there...\r\n\r\n```def round_even(number):\r\n    \"\"\"Takes a number and returns it rounded even\"\"\"\r\n    decimal_part = number % 1\r\n    int_part = number - decimal_part\r\n    if decimal_part < 0.5:\r\n        return int_part\r\n    if decimal_part > 0.5:\r\n        return int_part + 1\r\n    if decimal_part == 0.5:\r\n        if int_part%2 == 0:\r\n            return int_part\r\n        return int_part + 1\r\n\r\n    \r\n    \r\n``` `pytest` run speed: `0.04` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-10 20:42:43.745650+00:00"
        },
        {
            "subject": "Day 033! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 33: #100DaysOfCode progress: today I worked on Bite 128. Work with datetime's strptime and strftime: https://codechalleng.es/bites/128 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-10 10:01:00.990211+00:00"
        },
        {
            "subject": "Bite 95. Subclass the dict built-in",
            "body": "First time around I ended up creating a `self.dict` inside the class, I even had to implement `__init__` and `__getitem__` methods but eventually the tests passed... \r\nI am sure this was not the intent of the exercise, but I have seen in the Forum a few people who ended up doing something similar, maybe <a href=\"#pybites\">@pybites</a> it would be worth reinforcing the tests to catch this?\r\n\r\nThen I saw `super()` in the official solution and I went back and modified my code as shown below:\r\n   \r\n```from datetime import date\r\nMSG = 'Hey {}, there are more people with your birthday!'\r\n\r\n\r\nclass BirthdayDict(dict):\r\n    \"\"\"Override dict to print a message every time a new person is added that has\r\n       the same birthday (day+month) as somebody already in the dict\"\"\"\r\n\r\n\r\n    def __setitem__(self, name, birthday):\r\n        for bday in self.values():\r\n            if birthday.day == bday.day and birthday.month == bday.month:\r\n                # match\r\n                print(MSG.format(name))\r\n        super().__setitem__(name, birthday)\r\n\r\n\r\nbd = BirthdayDict()\r\nbd['bob'] = date(1987, 6, 15)\r\nbd['tim'] = date(1984, 7, 15)\r\nprint(bd)\r\nbd['mary'] = date(1987, 6, 15)  # whole date match\r\n# Hey mary, there are more people with your birthday!\r\nbd['sara'] = date(1987, 6, 14)\r\nbd['mike'] = date(1981, 7, 15)  # day + month match\r\n# Hey mike, there are more people with your birthday!\r\n``` `pytest` run speed: `0.04` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-09 10:53:02.113465+00:00"
        },
        {
            "subject": "Bite 115. Count leading spaces",
            "body": "```def count_indents(text: str) -> int:\r\n    \"\"\"\r\n    Count and return the number of leading white space characters (' ').\r\n    \"\"\"\r\n    for i,letter in enumerate(text):\r\n        if letter !=\" \":\r\n            return i\r\n    # only spaces found\r\n    return len(text)\r\n    \r\nprint(count_indents(\"   n\"))``` `pytest` run speed: `0.04` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-09 10:18:04.962743+00:00"
        },
        {
            "subject": "Day 032! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 32: #100DaysOfCode progress: today I worked on Bite 117. Round a number even (a.k.a. banker's rounding): https://codechalleng.es/bites/117 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-09 10:00:59.934153+00:00"
        },
        {
            "subject": "Bite 263. Count the number of islands in a grid",
            "body": "I always find recursion hard, but I am happy about the result this time. \r\nI added a little visualization to follow how the code is exploring, which can be toggled setting the global VERBOSE to True/False.\r\n\r\nLiked that the official solution better follows DRY, but I find it maybe a bit less readable...\r\n\r\n```\r\n\r\nVERBOSE = False\r\n\r\ndef count_islands(grid):\r\n    \"\"\"\r\n    Input: 2D matrix, each item is [x, y] -> row, col.\r\n    Output: number of islands, or 0 if found none.\r\n    Notes: island is denoted by 1, ocean by 0 islands is counted by continuously\r\n        connected vertically or horizontally  by '1's.\r\n    It's also preferred to check/mark the visited islands:\r\n    - eg. using the helper function - mark_islands().\r\n    \"\"\"\r\n    \r\n    islands = 0         # var. for the counts\r\n    nrows = len(grid)\r\n    ncols = len(grid[0])\r\n    for i in range(nrows):\r\n        for j in range(ncols):\r\n            if grid[i][j] == 1:\r\n                islands += 1\r\n                if VERBOSE:\r\n                    print(f\"Found island number {islands}\")\r\n                mark_islands(i, j, grid)\r\n    print (f\"{islands} islands\")\r\n    return islands\r\n\r\n\r\ndef _print_grid(grid):\r\n    nrows = len(grid)\r\n    print(\"Exploring island:\")\r\n    for i in range(nrows):\r\n        print(\" \".join([str(el) for el in grid[i]]))\r\n    print(\"\\n\")\r\n    \r\n    \r\ndef mark_islands(i, j, grid):\r\n    \"\"\"\r\n    Input: the row, column and grid\r\n    Output: None. Just mark the visited islands as in-place operation.\r\n    \"\"\"\r\n    nrows = len(grid)\r\n    ncols = len(grid[0])\r\n    grid[i][j] = '#'      # one way to mark visited ones - suggestion.\r\n    if VERBOSE:\r\n        _print_grid(grid)\r\n    if i>0: \r\n        if grid[i-1][j] == 1:\r\n            mark_islands(i-1, j, grid)\r\n    if i<nrows-1:\r\n        if grid[i+1][j] == 1:\r\n            mark_islands(i+1, j, grid)\r\n    if j>0:\r\n        if grid[i][j-1] == 1:\r\n            mark_islands(i, j-1, grid)\r\n    if j<ncols-1:\r\n        if grid[i][j+1] == 1:\r\n            mark_islands(i, j+1, grid)\r\n\r\nif __name__ == \"__main__\":\r\n    \r\n    test_grid = [[1, 0, 0, 1],\r\n             [0, 0, 0, 0],\r\n             [0, 0, 0, 0],\r\n             [1, 0, 0, 1]]\r\n    \r\n    count_islands(test_grid)\r\n        ```",
            "from_user": "mhered8b899449424048c5",
            "to_user": "danielhao5",
            "sent_date": "2022-10-08 21:59:48.100044+00:00"
        },
        {
            "subject": "Bite 338. Create food objects",
            "body": "I really have no idea what I am doing or how to test it....\r\n\r\n```from typing import Dict\r\n\r\nfrom fastapi import FastAPI, Response, status\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n# write the Create endpoint\r\n@app.post(\"/\", status_code=200)\r\nasync def create_food(food: Food, response: Response):\r\n    foods[food.id] = food\r\n    response.status_code = status.HTTP_201_CREATED\r\n    return food```",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-08 21:18:45.072910+00:00"
        },
        {
            "subject": "Day 031! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 31: #100DaysOfCode progress: today I worked on Bite 115. Count leading spaces: https://codechalleng.es/bites/115 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-08 10:00:45.111264+00:00"
        },
        {
            "subject": "Bite 246. Test print / standard output",
            "body": "Really minimal but achieved 100% coverage and 100% mutpy score\r\n Not convinced about the use of `capsys.readouterr()[0].strip()` in the official solution, could it mask unexpected outputs?\r\n\r\n```import pytest\r\n\r\nfrom workouts import print_workout_days\r\n\r\n@pytest.mark.parametrize(\"test_input, expected\", [\r\n        (\"#1\", 'Mon, Tue\\n'), \r\n        (\"body\", 'Mon, Tue, Thu, Fri\\n'), \r\n        (\"cardio\", 'Wed\\n'),\r\n        (\"other\", 'No matching workout\\n')\r\n    ])\r\ndef test_print_workout_days(test_input, expected, capsys):\r\n    print_workout_days(test_input)\r\n    captured = capsys.readouterr()\r\n    assert captured.out == expected\r\n```",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-07 17:14:35.168837+00:00"
        },
        {
            "subject": "Day 030! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 30: #100DaysOfCode progress: today I worked on Bite 100. Display the last part of a file (Unix tail): https://codechalleng.es/bites/100 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-07 10:01:01.206138+00:00"
        },
        {
            "subject": "Congratulations on hitting the Green Ninja Belt",
            "body": "Hey Manuel,\n\nCongratulations on yet another milestone: you just earned your Green Ninja Belt!\n\nWe generated <a href=\"https://codechalleng.es/settings/#certificates\">your Ninja Certificate</a>.\n(If you need to update your first / last name, don't worry, you can generate it again.)\n\nKeep up the momentum and code more Python. Great job!\n\n- Bob & Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-06 21:53:35.971683+00:00"
        },
        {
            "subject": "Day 029! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 29: #100DaysOfCode progress: today I worked on Bite 96. Build Unix' wc program in Python: https://codechalleng.es/bites/96 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-06 10:00:50.502385+00:00"
        },
        {
            "subject": "Bite 91. Matching multiple strings",
            "body": "Why not using any()?\r\n\r\n```import string\r\n\r\nVOWELS = 'aeiou'\r\nPYTHON = 'python'\r\n\r\ndef contains_only_vowels(input_str):\r\n    \"\"\"Receives input string and checks if all chars are\r\n       VOWELS. Match is case insensitive.\"\"\"\r\n    return all(letter.lower() in VOWELS for letter in input_str)\r\n\r\n\r\ndef contains_any_py_chars(input_str):\r\n    \"\"\"Receives input string and checks if any of the PYTHON\r\n       chars are in it. Match is case insensitive.\"\"\"\r\n    return any(letter.lower() in PYTHON for letter in input_str)\r\n\r\n\r\ndef contains_digits(input_str):\r\n    \"\"\"Receives input string and checks if it contains\r\n       one or more digits.\"\"\"\r\n    return any(letter in string.digits for letter in input_str)\r\n    \r\n```",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-05 21:52:03.383053+00:00"
        },
        {
            "subject": "Bite 83. At what time does PyBites live?",
            "body": "Learned about aware datetimes\r\n\r\n```#!/usr/bin/env python\r\n\r\nfrom datetime import datetime\r\nfrom pytz import timezone, utc\r\n\r\nAUSTRALIA = timezone('Australia/Sydney')\r\nSPAIN = timezone('Europe/Madrid')\r\n\r\n\r\ndef what_time_lives_pybites(naive_utc_dt):\r\n    \"\"\"Receives a naive UTC datetime object and returns a two element\r\n       tuple of Australian and Spanish (timezone aware) datetimes\"\"\"\r\n    utc_dt = utc.localize(naive_utc_dt)\r\n    return (utc_dt.astimezone(AUSTRALIA), utc_dt.astimezone(SPAIN))\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    print(what_time_lives_pybites(datetime(2018, 11, 1, 14, 10, 0)))\r\n```",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-05 13:14:20.716704+00:00"
        },
        {
            "subject": "Day 028! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 28: #100DaysOfCode progress: today I worked on Bite 91. Matching multiple strings: https://codechalleng.es/bites/91 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-05 10:00:51.796441+00:00"
        },
        {
            "subject": "Day 027! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 27: #100DaysOfCode progress: today I worked on Bite 83. At what time does PyBites live?: https://codechalleng.es/bites/83 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-04 10:00:39.693508+00:00"
        },
        {
            "subject": "Bite 77. New places to travel to",
            "body": "Nice and easy one!\r\n```def uncommon_cities(my_cities, other_cities):\r\n    \"\"\"Compare my_cities and other_cities and return the number of different\r\n       cities between the two\"\"\"\r\n    return len(set(my_cities) ^ set(other_cities))\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    a = ['1','2','3','4','5','6']\r\n    b= ['3','4','5','6','7','8']\r\n    \r\n    print(uncommon_cities(a,b))```",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-03 16:50:17.804369+00:00"
        },
        {
            "subject": "Day 026! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 26: #100DaysOfCode progress: today I worked on Bite 80. Check equality of two lists: https://codechalleng.es/bites/80 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-03 10:00:47.136686+00:00"
        },
        {
            "subject": "Bite 49. Scrape Packt's html with BeautifulSoup",
            "body": "My solution was not so robust. I need to dive deeper into things like `.get` and `.find_next_sibling`, possibly others...\r\n\r\n```from collections import namedtuple\r\n\r\nfrom bs4 import BeautifulSoup as Soup\r\nimport requests\r\n\r\nPACKT = 'https://bites-data.s3.us-east-2.amazonaws.com/packt.html'\r\nCONTENT = requests.get(PACKT).text\r\n\r\nBook = namedtuple('Book', 'title description image link')\r\n\r\n\r\ndef get_book():\r\n    \"\"\"make a Soup object, parse the relevant html sections, and return a Book namedtuple\"\"\"\r\n    soup = Soup(CONTENT, 'html.parser')\r\n    \r\n    dotd_title_div = soup.find_all('div', class_=\"dotd-title\")\r\n    title = [element.find(\"h2\").text.strip() for element in dotd_title_div][0]\r\n    \r\n    dotd_description_parent_div = soup.find('div', class_=\"dotd-main-book-summary\")\r\n    description = list(dotd_description_parent_div.children)[7]\r\n    description = description.text.strip()\r\n\r\n    dotd_link_div = soup.find_all('div', class_=\"dotd-main-book-image\")\r\n    for element in dotd_link_div:\r\n        link = element.find(\"a\")\r\n    link = link[\"href\"]\r\n\r\n    dotd_image_img = soup.find('img', class_=\"imagecache-dotd_main_image\")\r\n    image = dotd_image_img[\"src\"]\r\n    \r\n    book = Book(title, description, image, link)\r\n    return book\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    print(get_book())```",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-10-02 22:11:24.091594+00:00"
        },
        {
            "subject": "Day 025! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 25: #100DaysOfCode progress: today I worked on Bite 77. New places to travel to: https://codechalleng.es/bites/77 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-02 10:00:50.988262+00:00"
        },
        {
            "subject": "Day 024! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 24: #100DaysOfCode progress: today I worked on Bite 74. What day of the week were you born on?: https://codechalleng.es/bites/74 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-10-01 10:00:51.170887+00:00"
        },
        {
            "subject": "Day 023! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 23: #100DaysOfCode progress: today I worked on Bite 68. Remove punctuation characters from a string: https://codechalleng.es/bites/68 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-30 10:00:41.176467+00:00"
        },
        {
            "subject": "Day 022! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 22: #100DaysOfCode progress: today I worked on Bite 67. Working with datetimes: https://codechalleng.es/bites/67 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-29 10:00:51.874305+00:00"
        },
        {
            "subject": "Day 021! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 21: #100DaysOfCode progress: today I worked on Bite 66. Calculate the running average of a sequence: https://codechalleng.es/bites/66 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-28 10:00:55.069199+00:00"
        },
        {
            "subject": "Day 020! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 20: #100DaysOfCode progress: today I worked on Bite 64. Fix a truncating zip function: https://codechalleng.es/bites/64 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-27 10:00:34.230798+00:00"
        },
        {
            "subject": "Congrats on your Orange Ninja Belt! Time to grow into a Python Developer ...",
            "body": "Hey Manuel,\n\nThis is it, you have earned your Orange belt and should have a fair grasp of Python now.\n\nWith the skills you have learned the next step is to go beyond mere exercises and work on bigger projects.\n\nThis has been THE crucial factor in advancing our careers as software developers.\n\nInterested in taking your Python / developer skills to the next level? Check out our PyBites Developer Mindset (PDM) coaching program:\nhttps://pybit.es/catalogue/the-pdm-program/\n\n- Bob & Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-26 17:16:12.537668+00:00"
        },
        {
            "subject": "Day 019! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 19: #100DaysOfCode progress: today I worked on Bite 56. Add a command line interface to our BMI calculator: https://codechalleng.es/bites/56 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-26 10:00:53.609950+00:00"
        },
        {
            "subject": "Newbie Bite 4. Printing Objects",
            "body": "Hello Bob,\r\noops my bad, you are absolutely right, and scrolling down is definitely something even a newbie should be able to do :-) ! ",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-09-25 10:33:24.528446+00:00"
        },
        {
            "subject": "Day 018! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 18: #100DaysOfCode progress: today I worked on Bite 55. Get the latest game releases from Steam's RSS feed: https://codechalleng.es/bites/55 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-25 10:00:34.432660+00:00"
        },
        {
            "subject": "Day 017! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 17: #100DaysOfCode progress: today I worked on Bite 54. Nicer formatting of a poem or text: https://codechalleng.es/bites/54 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-24 10:00:55.156353+00:00"
        },
        {
            "subject": "Day 016! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 16: #100DaysOfCode progress: today I worked on Bite 46. You are a programmer! Code Fizz Buzz: https://codechalleng.es/bites/46 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-23 10:00:40.600799+00:00"
        },
        {
            "subject": "Day 015! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 15: #100DaysOfCode progress: today I worked on Bite 45. Keep a queue of last n items: https://codechalleng.es/bites/45 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-22 10:00:47.158660+00:00"
        },
        {
            "subject": "Day 014! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 14: #100DaysOfCode progress: today I worked on Bite 44. License key generator: https://codechalleng.es/bites/44 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-21 10:00:32.381490+00:00"
        },
        {
            "subject": "Day 013! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 13: #100DaysOfCode progress: today I worked on Bite 43. Force keyword arguments: https://codechalleng.es/bites/43 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-20 10:00:54.850418+00:00"
        },
        {
            "subject": "Bite 38. Using ElementTree to parse XML",
            "body": "Probably the first time I am actually happier with my solution than the one proposed! \r\n\r\n```import xml.etree.ElementTree as ET\r\nfrom pprint import pprint\r\nfrom operator import itemgetter\r\n\r\n# from OMDB\r\nxmlstring = '''<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<root response=\"True\">\r\n  <movie title=\"The Prestige\" year=\"2006\" rated=\"PG-13\" released=\"20 Oct 2006\" runtime=\"130 min\" genre=\"Drama, Mystery, Sci-Fi\" director=\"Christopher Nolan\" />\r\n  <movie title=\"The Dark Knight\" year=\"2008\" rated=\"PG-13\" released=\"18 Jul 2008\" runtime=\"152 min\" genre=\"Action, Crime, Drama\" director=\"Christopher Nolan\" />\r\n  <movie title=\"The Dark Knight Rises\" year=\"2012\" rated=\"PG-13\" released=\"20 Jul 2012\" runtime=\"164 min\" genre=\"Action, Thriller\" director=\"Christopher Nolan\" />\r\n  <movie title=\"Dunkirk\" year=\"2017\" rated=\"PG-13\" released=\"21 Jul 2017\" runtime=\"106 min\" genre=\"Action, Drama, History\" director=\"Christopher Nolan\" />\r\n  <movie title=\"Interstellar\" year=\"2014\" rated=\"PG-13\" released=\"07 Nov 2014\" runtime=\"169 min\" genre=\"Adventure, Drama, Sci-Fi\" director=\"Christopher Nolan\"/>\r\n</root>'''  # noqa E501\r\n\r\n\r\ndef get_tree():\r\n    \"\"\"You probably want to use ET.fromstring\"\"\"\r\n    return ET.fromstring(xmlstring)\r\n\r\n\r\ndef get_movies():\r\n    \"\"\"Call get_tree and retrieve all movie titles, return a list or generator\"\"\"\r\n    for child in get_tree():\r\n        yield child.attrib['title']\r\n\r\ndef get_movie_longest_runtime():\r\n    \"\"\"Call get_tree again and return the movie title for the movie with the longest\r\n       runtime in minutes, for latter consider adding a _get_runtime helper\"\"\"\r\n    \r\n    lst = [ (_get_runtime(child.attrib['runtime']), child.attrib['title']) for child in get_tree() ] \r\n    longest_title= max(lst, key=itemgetter(0))[1] \r\n    return longest_title\r\n\r\n    \"\"\" this also works\r\n    longest_title=''\r\n    longest_t=0\r\n    for child in get_tree():\r\n        t = _get_runtime(child.attrib['runtime'])\r\n        if t > longest_t:\r\n            longest_t =t\r\n            longest_title = child.attrib['title']\r\n    return longest_title\r\n    \"\"\"\r\n\r\ndef _get_runtime(runtime_label):\r\n    return int(runtime_label.split()[0])\r\n    \r\n    \r\nprint(get_movie_longest_runtime())\r\n``` `pytest` run speed: `0.04` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-09-20 08:19:23.179320+00:00"
        },
        {
            "subject": "Bite 188. Get statistics from PyBites test code",
            "body": "Below my proposal. There were two points that I found worth exploring further in the official solution: \r\n1) use of yield when reading the file to create a generator. Advantages? \r\n2) use of STATS_OUTPUT.format(**stats) to fill the variables in a formatted string with fields of a dict. How does it work?\r\n\r\n```import os\r\nimport statistics\r\nfrom urllib.request import urlretrieve\r\n\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nS3 = 'https://bites-data.s3.us-east-2.amazonaws.com/'\r\nDATA = 'testfiles_number_loc.txt'\r\nSTATS = os.path.join(TMP, DATA)\r\nif not os.path.isfile(STATS):\r\n    urlretrieve(os.path.join(S3, DATA), STATS)\r\n\r\nSTATS_OUTPUT = \"\"\"\r\nBasic statistics:\r\n- count     : {count:7d}\r\n- min       : {min_:7d}\r\n- max       : {max_:7d}\r\n- mean      : {mean:7.2f}\r\n\r\nPopulation variance:\r\n- pstdev    : {pstdev:7.2f}\r\n- pvariance : {pvariance:7.2f}\r\n\r\nEstimated variance for sample:\r\n- count     : {sample_count:7.2f}\r\n- stdev     : {sample_stdev:7.2f}\r\n- variance  : {sample_variance:7.2f}\r\n\"\"\"\r\n\r\n\r\ndef get_all_line_counts(data: str = STATS) -> list:\r\n    \"\"\"Get all 186 line counts from the STATS file,\r\n       returning a list of ints\"\"\"\r\n    # TODO 1: get the 186 ints from downloaded STATS file\r\n    with open(STATS) as file:\r\n        lines= file.readlines()\r\n    lst = []\r\n    for line in lines:\r\n        num = int(line.split()[0]) \r\n        lst.append(num)\r\n    return lst\r\n\r\n\r\n\r\ndef create_stats_report(data=None):\r\n    if data is None:\r\n        # converting to a list in case a generator was returned\r\n        data = list(get_all_line_counts())\r\n\r\n    # taking a sample for the last section\r\n    sample = list(data)[::2]\r\n\r\n    # TODO 2: complete this dict, use data list and\r\n    # for the last 3 sample_ variables, use sample list\r\n    stats = dict(count=len(data),\r\n                 min_=min(data),\r\n                 max_=max(data),\r\n                 mean=statistics.mean(data),\r\n                 pstdev=statistics.pstdev(data),\r\n                 pvariance=statistics.pvariance(data),\r\n                 sample_count=len(sample),\r\n                 sample_stdev=statistics.stdev(sample),\r\n                 sample_variance=statistics.variance(sample),\r\n                 )\r\n\r\n    return STATS_OUTPUT.format(**stats)\r\n    \r\n    \r\nprint(create_stats_report())\r\n\r\n``` `pytest` run speed: `0.16` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-09-19 16:43:19.392892+00:00"
        },
        {
            "subject": "Day 012! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 12: #100DaysOfCode progress: today I worked on Bite 38. Using ElementTree to parse XML: https://codechalleng.es/bites/38 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-19 10:00:37.619105+00:00"
        },
        {
            "subject": "Final Intro Bite / earn your certificate!",
            "body": "Hey Manuel,\n\nWelcome to the 10th and final Intro Bite \ud83d\udc4c\r\n\r\nToday you will practice a bit of type conversion and exception handling. \r\n\r\nComplete the divide_numbers function, gaining your 10th point which should unlock the White Ninja Belt (if you did not earn a Belt before) and more importantly will let you <a href=\"https://codechalleng.es/settings/#certificates\">generate your Beginner Certificate</a>. \r\n\r\nMake sure you share it on social media, telling your friends and co-workers. You should be proud finishing this track! \ud83d\ude00\r\n\r\nThe other good news is that you should be ready at this point to start tackling the Beginner Bites, so hope we will see you crush those in the coming weeks ... \r\n\r\nThanks for coding with PyBites! \ud83d\ude4f\u2764\ufe0f\r\n\r\n<a href=\"https://codechalleng.es/bites/110/\">Code the final Intro Bite</a>\n\n<a href=\"https://codechalleng.es/settings/\">Opt out of (or pause) this email sequence.</a>\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-19 07:03:57.374377+00:00"
        },
        {
            "subject": "Day 011! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 11: #100DaysOfCode progress: today I worked on Bite 37. Rewrite a for loop using recursion: https://codechalleng.es/bites/37 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-18 10:00:38.247726+00:00"
        },
        {
            "subject": "A bit of exception handling",
            "body": "Hey Manuel,\n\nWow Intro Bite number 9 already, doesn't time just flies when coding? \r\n\r\nWe hope you're learning a lot and some of the operations got committed to muscle memory. \r\n\r\nIn this Bite you will lookup values from the workout_schedule dict and raise an exception when a key is not found. \r\n\r\nYou will return a variable message based on the value retrieved from this dict. \r\n\r\nHang in there, tomorrow you'll have finished all   1\ufe0f\u20e3  0\ufe0f\u20e3  Intro Bites and having earned your Beginner certificate!\r\n\r\n<a href=\"https://codechalleng.es/bites/109/\">Code the 9th Intro Bite</a>\n\n<a href=\"https://codechalleng.es/settings/\">Opt out of (or pause) this email sequence.</a>\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-18 07:03:00.323655+00:00"
        },
        {
            "subject": "Day 010! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 10: #100DaysOfCode progress: today I worked on Bite 32. Don't let mutability fool you: https://codechalleng.es/bites/32 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-17 10:00:34.192017+00:00"
        },
        {
            "subject": "Loop over a dict of namedtuples",
            "body": "Hey Manuel,\n\nLet's take it a step further and do a bit of math and work with a new data structure from the collections module: namedtuple. \r\n\r\nIn this 8th Intro Bite you will loop through a dict of ninja belts using the BeltStats namedtuples to calculate the total amount of points rewarded. Keep improving your Python!\r\n\r\nCompleting this Bite you'll be  8\ufe0f\u20e3  0\ufe0f\u20e3 % done, only 2 Intro Bites left. Keep it up!\r\n\r\n<a href=\"https://codechalleng.es/bites/108/\">Code the 8th Intro Bite</a>\n\n<a href=\"https://codechalleng.es/settings/\">Opt out of (or pause) this email sequence.</a>\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-17 07:02:26.516980+00:00"
        },
        {
            "subject": "Congratulations on hitting the Yellow Ninja Belt",
            "body": "Hey Manuel,\n\n<img src=\"https://ccbadges.s3.us-east-2.amazonaws.com/gifs/mario.gif\">\n\nCongratulations on achieving your Yellow Ninja Belt!\n\nWe generated <a href=\"https://codechalleng.es/settings/#certificates\">your Ninja Certificate</a>.\n(If you need to update your first / last name, don't worry, you can generate it again.)\n\nThank you for your dedication and commitment to learning Python using our platform.\n\nIf you have any feedback on the experience so far, features you'd like to see or even aspects of Python you'd like covered please reply to this message and let us know.\n\nNext up is your Orange Ninja Belt so keep that motivation coming and good luck solving further Bites - we know you can do it!\n\nKeep Calm and Code in Python!\n\nCheers,\nThe PyBites Team\n\nP.S. Show off your new Ninja Belt <a href=\"https://pybit.es/product/pybites-yellow-ninja-belt-mug/\" target=\"_blank\">with our Yellow Ninja Belt Coffee Mug</a> ...\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-16 15:33:41.471935+00:00"
        },
        {
            "subject": "Day 009! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 9: #100DaysOfCode progress: today I worked on Bite 29. Martin's IQ test: https://codechalleng.es/bites/29 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-16 10:00:26.914872+00:00"
        },
        {
            "subject": "Write a list comprehension",
            "body": "Hey Manuel,\n\nList comprehensions are one of our favorite features of the Python languages, they are so elegant!\r\n\r\nIn this 7th Intro Bite we have you write one that filters out numbers that are both positive and even (divisible by 2 that is). \r\n\r\nSharpen the Pythonic saw using PyBites ... ah and don't forget to tell your friends and co-workers about your awesome accomplishments accomplishments o the platform. \r\n\r\nDid you create your PyBites Profile yet? If not, you can do so <a href=\"https://codechalleng.es/settings/#profilepage\">here</a>.\r\n\r\nAnd without further ado go ahead and <a href=\"https://codechalleng.es/bites/107/\">code the 7th Intro Bite</a>.\n\n<a href=\"https://codechalleng.es/settings/\">Opt out of (or pause) this email sequence.</a>\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-16 07:02:44.269182+00:00"
        },
        {
            "subject": "Day 008! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 8: #100DaysOfCode progress: today I worked on Bite 26. Dictionary comprehensions are awesome: https://codechalleng.es/bites/26 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-15 10:00:44.529959+00:00"
        },
        {
            "subject": "Parse the Zen of Python",
            "body": "Hey Manuel,\n\nWow your 6h Intro Bite, you're halfway through them already! \r\n\r\nIn today's Bite you are presented with the Zen of Python (read it carefully by the way, you will reference it often!). \r\n\r\nComplete the strip_vowels function replacing all vowels and count the number of vowels you replaced. \r\n\r\nGain more fluency in Python and remember to type this from time to time:\r\n>>> import this\r\n\r\n<a href=\"https://codechalleng.es/bites/106/\">Code the sixth Intro Bite</a>\n\n<a href=\"https://codechalleng.es/settings/\">Opt out of (or pause) this email sequence.</a>\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-15 07:02:50.856386+00:00"
        },
        {
            "subject": "Bite 130. Analyze some basic Car Data",
            "body": "Not so far from the official solution but I really should have used Counter!\r\n\r\n```from collections import Counter\r\nfrom operator import itemgetter\r\n\r\nimport requests\r\n\r\nCAR_DATA = 'https://bites-data.s3.us-east-2.amazonaws.com/cars.json'\r\n\r\n# pre-work: load JSON data into program\r\n\r\nwith requests.Session() as s:\r\n    data = s.get(CAR_DATA).json()\r\n\r\n\r\n# your turn:\r\ndef most_prolific_automaker(year):\r\n    \"\"\"Given year 'year' return the automaker that released\r\n       the highest number of new car models\"\"\"\r\n    automakers_in_year = set([item['automaker'] for item in data if item['year'] == year])\r\n    models_per_automaker = [(automaker, len(get_models(automaker, year))) for automaker in automakers_in_year]\r\n    return max(models_per_automaker, key=itemgetter(1))[0]\r\n\r\n\r\ndef get_models(automaker, year):\r\n    \"\"\"Filter cars 'data' by 'automaker' and 'year',\r\n       return a set of models (a 'set' to avoid duplicate models)\"\"\"\r\n    filtered_list = [item['model'] for item in data if item['automaker'].lower() == automaker.lower() and item['year'] == year]\r\n    return set(filtered_list)\r\n\r\n\r\nprint(most_prolific_automaker(2013))``` `pytest` run speed: `0.22` seconds",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-09-14 21:40:26.718911+00:00"
        },
        {
            "subject": "Day 007! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 7: #100DaysOfCode progress: today I worked on Bite 21. Query a nested data structure: https://codechalleng.es/bites/21 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-14 10:00:17.147417+00:00"
        },
        {
            "subject": "Slice and dice!",
            "body": "Hey Manuel,\n\nWelcome to Intro Bite number 5. Time to step up the level a bit \ud83d\udcaa\r\n\r\nToday you will learn about more text manipulation techniques. \r\n\r\nCode up the slice_and_dice function and you'll be well on your way to tackle real world problems in Python! \r\n\r\nRemember you will get a nice Beginner certificate when you complete all 10 Intro Bites so hang in there! :)\r\n\r\n<a href=\"https://codechalleng.es/bites/105/\">Code the 5th Intro Bite</a>\n\n<a href=\"https://codechalleng.es/settings/\">Opt out of (or pause) this email sequence.</a>\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-14 07:03:02.894962+00:00"
        },
        {
            "subject": "Day 006! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 6: #100DaysOfCode progress: today I worked on Bite 19. Write a property: https://codechalleng.es/bites/19 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-13 10:00:32.961920+00:00"
        },
        {
            "subject": "Learn about the split and join methods",
            "body": "Hey Manuel,\n\nGoing from string to list and vice versa is something you'll often use. \r\n\r\nIn today's Intro Bite, your fourth already, you will split a message by newline (\\n) and stitch it back together using pipe (|) \r\n\r\nKeep calm and code more Python \ud83d\udc0d\r\n\r\n<a href=\"https://codechalleng.es/bites/104/\">Code the 4th Intro Bite</a>\n\n<a href=\"https://codechalleng.es/settings/\">Opt out of (or pause) this email sequence.</a>\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-13 07:03:00.793074+00:00"
        },
        {
            "subject": "Day 005! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 5: #100DaysOfCode progress: today I worked on Bite 16. PyBites date generator: https://codechalleng.es/bites/16 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-12 10:00:19.570083+00:00"
        },
        {
            "subject": "Get data from a dict",
            "body": "Hey Manuel,\n\nIn this third Intro Bite you are presented with a dict. \r\n\r\nYou will need to loop through its items printing how many games each user has won, properly pluralising the word \"games\". \r\n\r\nHave fun and learn more Python \ud83d\udcaa\r\n\r\n<a href=\"https://codechalleng.es/bites/103/\">Code the third Intro Bite</a>\n\n<a href=\"https://codechalleng.es/settings/\">Opt out of (or pause) this email sequence.</a>\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-12 07:04:24.027245+00:00"
        },
        {
            "subject": "Bite 336. FastAPI Hello World",
            "body": "Hello is there a way to see the result (i.e. the server running) inside the pybites platform? \r\nI can see it if I am at my computer and run it locally, but not in the platform ",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-09-11 22:44:10.952785+00:00"
        },
        {
            "subject": "Day 004! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 4: #100DaysOfCode progress: today I worked on Bite 15. Enumerate 2 sequences: https://codechalleng.es/bites/15 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-11 10:00:24.321215+00:00"
        },
        {
            "subject": "Code your second Intro Bite",
            "body": "Hey Manuel,\n\nWelcome back. Today we will make a little interactive program where we ask the user to enter a color and print it out or a message when it's not in the VALID_COLORS constant.  \r\n\r\nYou will learn about the while loop and the useful break and continue statements. \r\n\r\nSounds fun? Get coding \ud83d\udcbb\r\n\r\n<a href=\"https://codechalleng.es/bites/102/\">Code the second Intro Bite</a>\n\n<a href=\"https://codechalleng.es/settings/\">Opt out of (or pause) this email sequence.</a>\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-11 07:02:44.338797+00:00"
        },
        {
            "subject": "Newbie Bite 4. Printing Objects",
            "body": "Hi, is it me or the exercise description does not actually mention anywhere that you need to write the sentence \"Pybites was founded in December 2016.\" using the three pieces of data?\r\nI eventually found what to do inspecting the test output, but I am not sure this is too much to expect from a newbie.",
            "from_user": "mhered8b899449424048c5",
            "to_user": "pybites",
            "sent_date": "2022-09-11 01:27:07.238711+00:00"
        },
        {
            "subject": "Thanks for subscribing to our Premium tier",
            "body": "Hey Manuel,\n\nYou'll be amazed how much you'll improve your Python skills if you consistently code here!\n\nWe're always open for suggestions/ improvements to better serve your needs.\n\nLastly don't forget to join our Premium Slack Channel:\nhttps://codechalleng.es/settings/#slack\n\nAnd now go solve some more Bites, have fun and keep calm and code in Python :)\n\nThe PyBites Team\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-10 23:17:29.724279+00:00"
        },
        {
            "subject": "Congratulations on hitting the White Ninja Belt",
            "body": "Hey Manuel,\n\n<img src=\"https://ccbadges.s3.us-east-2.amazonaws.com/gifs/glee.gif\">\n\nCongratulations on achieving your very first Ninja Belt on the CodeChallenges platform.\n\nWe generated <a href=\"https://codechalleng.es/settings/#certificates\">your Ninja Certificate</a>.\n(If you need to update your first / last name, don't worry, you can generate it again.)\n\nThis white belt indicates you've earned 10 points. Keep it up!\n\nThere are many more Bites to go, a lot of Python to learn and a whole bunch of fun to be had!\n\nStay motivated and remember to Keep Calm and Code in Python.\n\nCheers,\nThe PyBites Team\n\nP.S. Now that you are a PyBites Ninja, why not showing the world <a href=\"https://pybit.es/product/pybites-white-ninja-belt-mug/\" target=\"_blank\">getting our White Ninja Belt Coffee Mug</a>?\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-10 13:17:10.476948+00:00"
        },
        {
            "subject": "Day 002! #100DaysOfCode",
            "body": "Hey Manuel,\n\nCheck out today's activity:\nDay 2: #100DaysOfCode progress: today I worked on Bite 5. Parse a list of names: https://codechalleng.es/bites/5 - code more #Python @PyBites CodeChalleng.es\n\nUpdate your progress here:\nhttps://codechalleng.es/100days/8180\n\nYou can opt out of this email notification and/or pause your 100 Days project here:\nhttps://codechalleng.es/100days/\n\nDon't forget to share you progress on Twitter / social media.\nWe'd love to see what you're building.\n\nHappy Coding!\nBob and Julian\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-10 10:00:32.782041+00:00"
        },
        {
            "subject": "Code you first Intro Bite!",
            "body": "Hey Manuel,\n\nWelcome to our Intro Bites \ud83c\udf89\r\n\r\nToday you will code a simple if/else and use an f-string. \r\n\r\nExplore with us if Bob, Julian and Tim are allowed to drive based on their ages ...\r\n\r\nLet's write some Python \ud83d\udc0d\r\n\r\n<a href=\"https://codechalleng.es/bites/101/\">Code the first Intro Bite</a>\r\n\r\n---\r\nLet us know if you have any questions along the way ... Although this email is automated, your reply goes straight to our inbox and we respond to each one of them personally, because we're passionate about helping you improve your Python and developer skills!\n\n<a href=\"https://codechalleng.es/settings/\">Opt out of (or pause) this email sequence.</a>\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-10 07:03:37.438067+00:00"
        },
        {
            "subject": "Welcome to the PyBites Platform",
            "body": "Hey Manuel,\n\nWe're excited you joined our platform.\n\nWith our 300+ exercise you can build up a daily HABIT of coding and it's this \"deliberate practice\" that will make you an effective Pythonista.\n\nCheck out our <strong><a href=\"https://codechalleng.es/start/\" title=\"PyBites Platform Introduction\" target=\"_blank\">introduction video</a></strong> and start coding:\n\n<a href=\"https://codechalleng.es/start/\" target=\"_blank\"><img src=\"https://bites-data.s3.us-east-2.amazonaws.com/platform-intro.png\" alt=\"PyBites Platform Introduction\" width=\"100%\" style=\"max-width: 600px;\"></a>\n\nOver the coming days we will send you some valuable pointers that will help you in your Python journey, stay tuned ...\n\n- Bob & Julian\n\nPS. We'd love to hear from you: what brings you to PyBites and our platform?  Reply to this message and let us know ...\n",
            "from_user": "pybites",
            "to_user": "mhered8b899449424048c5",
            "sent_date": "2022-09-09 12:13:08.997828+00:00"
        }
    ],
    "bites": [
        {
            "bite": "Bite 1. Sum n numbers",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-09 15:11:36.240049+00:00",
            "passing_code": "def sum_numbers(numbers=None):\r\n    if numbers is None:\r\n        numbers = list(range(1,101))\r\n    return sum(numbers)\r\n    \r\nlst= list(range(1,10))\r\nprint(lst)\r\nprint(sum_numbers(lst))\r\nprint(sum_numbers(None))\r\nprint(sum_numbers([]))\r\n",
            "score": 2,
            "number_code_submits": 2,
            "tags": "default args, freebie, None, range, sum",
            "in_paths": "Python Beginner"
        },
        {
            "bite": "Bite 2. Regex Fun",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-25 23:11:25.604570+00:00",
            "passing_code": "import re\r\n\r\nCOURSE = ('Introduction 1 Lecture 01:47'\r\n          'The Basics 4 Lectures 32:03'\r\n          'Getting Technical!  4 Lectures 41:51'\r\n          'Challenge 2 Lectures 27:48'\r\n          'Afterword 1 Lecture 05:02')\r\nTWEET = ('New PyBites article: Module of the Week - Requests-cache '\r\n         'for Repeated API Calls - http://pybit.es/requests-cache.html '\r\n         '#python #APIs')\r\nHTML = ('<p>pybites != greedy</p>'\r\n        '<p>not the same can be said REgarding ...</p>')\r\n\r\n\r\ndef extract_course_times(course=COURSE):\r\n    \"\"\"Return the course timings from the passed in\r\n       course string. Timings are in mm:ss (minutes:seconds)\r\n       format, so taking COURSE above you would extract:\r\n       ['01:47', '32:03', '41:51', '27:48', '05:02']\r\n       Return this list.\r\n    \"\"\"\r\n    return re.findall(r'(\\d\\d:\\d\\d)', course)\r\n\r\n\r\ndef get_all_hashtags_and_links(tweet=TWEET):\r\n    \"\"\"Get all hashtags and links from the tweet text\r\n       that is passed into this function. So for TWEET\r\n       above you need to extract the following list:\r\n       ['http://pybit.es/requests-cache.html',\r\n        '#python',\r\n        '#APIs']\r\n       Return this list.\r\n    \"\"\"\r\n    return re.findall(r'http://\\S*|#\\S*',tweet)\r\n\r\n\r\ndef match_first_paragraph(html=HTML):\r\n    \"\"\"Extract the first paragraph of the passed in\r\n       html, so for HTML above this would be:\r\n       'pybites != greedy' (= content of first paragraph).\r\n       Return this string.\r\n    \"\"\"\r\n    return re.findall(r'<p>(.*?)</p>',html)[0]\r\n    \r\n    \r\ntest_tweet = ('PyBites My Reading List | 12 Rules for Life - #books '\r\n             'that expand the mind! '\r\n             'http://pbreadinglist.herokuapp.com/books/'\r\n             'TvEqDAAAQBAJ#.XVOriU5z2tA.twitter'\r\n             ' #psychology #philosophy')\r\n\r\n\r\n# print(extract_course_times())\r\n# print(match_first_paragraph())\r\n# print(get_all_hashtags_and_links(test_tweet))",
            "score": 4,
            "number_code_submits": 4,
            "tags": "findall, freebie, re, regular expressions",
            "in_paths": "Regular Expressions"
        },
        {
            "bite": "Bite 3. Word Values",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-20 19:29:09.612043+00:00",
            "passing_code": "#!/usr/bin/env python\r\n\r\nimport os\r\nimport urllib.request\r\nfrom operator import itemgetter\r\n\r\n# PREWORK\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nS3 = 'https://bites-data.s3.us-east-2.amazonaws.com/'\r\nDICT = 'dictionary.txt'\r\nDICTIONARY = os.path.join(TMP, DICT)\r\nurllib.request.urlretrieve(f'{S3}{DICT}', DICTIONARY)\r\n\r\nscrabble_scores = [(1, \"E A O I N R T L S U\"), (2, \"D G\"), (3, \"B C M P\"),\r\n                   (4, \"F H V W Y\"), (5, \"K\"), (8, \"J X\"), (10, \"Q Z\")]\r\nLETTER_SCORES = {letter: score for score, letters in scrabble_scores\r\n                 for letter in letters.split()}\r\n\r\n# start coding\r\n\r\n\r\ndef load_words():\r\n    \"\"\"Load the words dictionary (DICTIONARY constant) into a list and return it\"\"\"\r\n    lst = []\r\n    with open(DICTIONARY) as dict:\r\n        for word in dict:\r\n            lst.append(word.strip())\r\n    return lst\r\n\r\n\r\ndef calc_word_value(word):\r\n    \"\"\"Given a word calculate its value using the LETTER_SCORES dict\"\"\"\r\n    score = 0\r\n    for letter in word.strip().upper():\r\n        for group in scrabble_scores:\r\n            if letter in group[1]:\r\n                score += group[0]\r\n    return score\r\n\r\n\r\ndef max_word_value(words):\r\n    \"\"\"Given a list of words calculate the word with the maximum value and return it\"\"\"\r\n    lst = [(word, calc_word_value(word)) for word in words]\r\n    return max(lst, key=itemgetter(1))[0]\r\n\r\n\r\nprint(list(load_words()))\r\n\r\nprint(f\"{calc_word_value('bob')} should be == 7\")\r\nprint(f\"{calc_word_value('JuliaN')} should be == 13\")\r\nprint(f\"{calc_word_value('PyBites')} should be == 14\")\r\nprint(f\"{calc_word_value('benzalphenylhydrazone')} should be == 56\")\r\n\r\nprint(max_word_value(['bob', 'benzalphenylhydrazone', 'julian', 'pybites']))\r\n",
            "score": 3,
            "number_code_submits": 2,
            "tags": "freebie, max, Scrabble, sum",
            "in_paths": ""
        },
        {
            "bite": "Bite 4. Top 10 PyBites tags",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-20 10:42:30.949188+00:00",
            "passing_code": "import os\r\nfrom collections import Counter\r\nimport urllib.request\r\nimport xml.etree.ElementTree as ET\r\n\r\n# prep\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\ntempfile = os.path.join(tmp, 'feed')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/feed',\r\n    tempfile\r\n)\r\n\r\nwith open(tempfile) as f:\r\n    content = f.read().lower()\r\n\r\ndef get_pybites_top_tags(n=10):\r\n    \"\"\"use Counter to get the top 10 PyBites tags from the feed\r\n       data already loaded into the content variable\"\"\"\r\n    lst=[]\r\n    for elem in ET.fromstring(content)[0]:\r\n        if elem.tag == 'item':\r\n            for attrb in elem:\r\n                if attrb.tag == 'category':\r\n                    lst.append(attrb.text)\r\n    return Counter(lst).most_common(n)\r\n\r\nprint(get_pybites_top_tags(10))",
            "score": 3,
            "number_code_submits": 3,
            "tags": "Counter, xml",
            "in_paths": "Collections Module, Data Analysis, Web Scraping"
        },
        {
            "bite": "Bite 5. Parse a list of names",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-10 13:17:08.468941+00:00",
            "passing_code": "from operator import itemgetter\r\n\r\nNAMES = ['arnold schwarzenegger', 'alec baldwin', 'bob belderbos',\r\n         'julian sequeira', 'sandra bullock', 'keanu reeves',\r\n         'julbob pybites', 'bob belderbos', 'julian sequeira',\r\n         'al pacino', 'brad pitt', 'matt damon', 'brad pitt']\r\n\r\n\r\ndef dedup_and_title_case_names(names):\r\n    \"\"\"Should return a list of title cased names,\r\n       each name appears only once\"\"\"\r\n    processed_names= []\r\n    for name in names:\r\n        name = name.title()\r\n        if name not in processed_names:\r\n            processed_names.append(name)\r\n    return processed_names\r\n\r\n\r\ndef sort_by_surname_desc(names):\r\n    \"\"\"Returns names list sorted desc by surname\"\"\"\r\n    names = dedup_and_title_case_names(names)\r\n    names_list= []\r\n    for name in names:\r\n        name=name.split()\r\n        names_list.append([name[0],name[1]])\r\n    names_list.sort(key=lambda x:x[1], reverse=True)\r\n    processed_names=[]\r\n    for name_surname in names_list:\r\n        processed_names.append(\" \".join(name_surname))\r\n    return processed_names\r\n\r\n\r\ndef shortest_first_name(names):\r\n    \"\"\"Returns the shortest first name (str).\r\n       You can assume there is only one shortest name.\r\n    \"\"\"\r\n    clean_names = dedup_and_title_case_names(names)\r\n    shortest_name= \"\"\r\n    shortest_length=len(names)+1\r\n    for name in clean_names:\r\n        name=name.split()\r\n        if len(name[0])<shortest_length:\r\n            shortest_name= name[0]\r\n            shortest_length= len(shortest_name) \r\n    return shortest_name\r\n\r\n    \r\nprint(dedup_and_title_case_names(NAMES))\r\nprint(sort_by_surname_desc(NAMES))\r\nprint(shortest_first_name(NAMES))\r\n",
            "score": 2,
            "number_code_submits": 2,
            "tags": "freebie, lambda, list comprehensions, min, sorting",
            "in_paths": "Python Beginner"
        },
        {
            "bite": "Bite 6. PyBites Die Hard",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-21 18:48:20.643925+00:00",
            "passing_code": "from collections import Counter, namedtuple\r\nimport os\r\nimport urllib.request\r\n\r\n# prep\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\ntempfile = os.path.join(tmp, 'dirnames')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/dirnames.txt',\r\n    tempfile\r\n)\r\n\r\nIGNORE = ['static', 'templates', 'data', 'pybites', 'bbelderbos', 'hobojoe1848']\r\n\r\nStats = namedtuple('Stats', 'user challenge')\r\n\r\n\r\n# code\r\n\r\ndef gen_files(tempfile=tempfile):\r\n    \"\"\"\r\n    Parse the tempfile passed in, filtering out directory names\r\n    (first column) using the last \"is_dir\" column.\r\n\r\n    Lowercase these directory names and return them as a generator.\r\n\r\n    \"tempfile\" has the following format:\r\n    challenge<int>/file_or_dir<str>,is_dir<bool>\r\n\r\n    For example:\r\n    03/rss.xml,False\r\n    03/tags.html,False\r\n    03/Mridubhatnagar,True\r\n    03/aleksandarknezevic,True\r\n\r\n    => Here you would return 03/mridubhatnagar (lowercased!)\r\n       followed by 03/aleksandarknezevic\r\n    \"\"\"\r\n    \r\n    with open(tempfile) as file:\r\n        for line in file:\r\n            split_line = line.strip().split(\",\")\r\n            if split_line[1] == \"True\":\r\n                yield split_line[0].lower()\r\n\r\n\r\ndef diehard_pybites(files=None):\r\n    \"\"\"\r\n    Return a Stats namedtuple (defined above) that contains:\r\n    1. the user that made the most pull requests (ignoring the users in IGNORE), and\r\n    2. a tuple of:\r\n        (\"most popular challenge id\", \"amount of pull requests for that challenge\")\r\n\r\n    Calling this function on the default dirnames.txt should return:\r\n\r\n    Stats(user='clamytoe', challenge=('01', 7))\r\n    \"\"\"\r\n\r\n    if files is None:\r\n        files = gen_files()\r\n    lst = [line.split(\"/\") for line in files]\r\n    users = Counter([item[1] for item in lst if item[1] not in IGNORE])\r\n    popular_challenges = Counter([item[0] for item in lst if item[1] not in IGNORE])\r\n\r\n    return Stats(user=users.most_common(1)[0][0],\r\n                 challenge=popular_challenges.most_common(1)[0])\r\n\r\n\r\nprint(diehard_pybites())\r\n",
            "score": 3,
            "number_code_submits": 5,
            "tags": "Counter, file processing, generators, namedtuple",
            "in_paths": "Collections Module"
        },
        {
            "bite": "Bite 7. Parsing dates from logs",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-25 11:47:55.515951+00:00",
            "passing_code": "from datetime import datetime\r\nimport os\r\nimport urllib.request\r\n\r\nSHUTDOWN_EVENT = 'Shutdown initiated'\r\n\r\n# prep: read in the logfile\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\nlogfile = os.path.join(tmp, 'log')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/messages.log',\r\n    logfile\r\n)\r\n\r\nwith open(logfile) as f:\r\n    loglines = f.readlines()\r\n\r\n\r\n# for you to code:\r\n\r\ndef convert_to_datetime(line):\r\n    \"\"\"TODO 1:\r\n       Extract timestamp from logline and convert it to a datetime object.\r\n       For example calling the function with:\r\n       INFO 2014-07-03T23:27:51 supybot Shutdown complete.\r\n       returns:\r\n       datetime(2014, 7, 3, 23, 27, 51)\r\n    \"\"\"\r\n    label, timestamp, msg = tuple (line.strip().split(\" \", maxsplit=2))\r\n    l_date, l_time = tuple(timestamp.split(\"T\", maxsplit=1))\r\n    year, month, day = tuple(l_date.split(\"-\", maxsplit=2))\r\n    hour, minute, second = tuple(l_time.split(\":\", maxsplit=2))\r\n    return datetime(int(year),int(month),int(day), int(hour),int(minute),int(second))\r\n    \r\n\r\ndef time_between_shutdowns(loglines):\r\n    \"\"\"TODO 2:\r\n       Extract shutdown events (\"Shutdown initiated\") from loglines and\r\n       calculate the timedelta between the first and last one.\r\n       Return this datetime.timedelta object.\r\n    \"\"\"\r\n    shutdown_lines=[line for line in loglines if SHUTDOWN_EVENT in line]\r\n    first_shutdown=convert_to_datetime(shutdown_lines[0])\r\n    last_shutdown=convert_to_datetime(shutdown_lines[-1])\r\n    return last_shutdown-first_shutdown\r\n\r\n\r\nprint(convert_to_datetime(\"       INFO 2014-07-03T23:27:51 supybot Shutdown complete.\"))\r\n\r\n\r\ntest_loglines =\"\"\"\r\nERROR 2014-07-03T23:24:31 supybot Invalid user dictionary file\r\nINFO 2015-10-03T10:12:51 supybot Shutdown initiated.\r\nINFO 2015-10-03T10:13:51 supybot Shutdown continued.\r\nINFO 2015-10-03T10:22:51 supybot Shutdown continued.\r\nINFO 2015-10-03T11:12:51 supybot Shutdown initiated.\r\nINFO 2016-09-03T02:11:22 supybot Shutdown complete.\r\n\"\"\".splitlines()\r\n\r\nprint(time_between_shutdowns(loglines))",
            "score": 3,
            "number_code_submits": 3,
            "tags": "datetime, file processing",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 8. Rotate string characters",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-11 00:36:13.593552+00:00",
            "passing_code": "def rotate(string, n):\r\n    \"\"\"Rotate characters in a string.\r\n       Expects string and n (int) for number of characters to move.\r\n    \"\"\"\r\n    l=len(string)\r\n    n = n % l\r\n    return (string * 3)[l + n : 2 * l + n]\r\n                    \r\nprint(\"5: \",rotate(\"0123456789\",5)) \r\nprint(\"-2: \",rotate(\"0123456789\",-2)) \r\nprint(\"-12: \",rotate(\"0123456789\",-12)) \r\nprint(\"10: \",rotate(\"0123456789\",10)) ",
            "score": 2,
            "number_code_submits": 3,
            "tags": "deque, slicing",
            "in_paths": "String Manipulation"
        },
        {
            "bite": "Bite 9. Palindromes",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-25 18:31:44.076834+00:00",
            "passing_code": "\"\"\"A palindrome is a word, phrase, number, or other sequence of characters\r\nwhich reads the same backward as forward\"\"\"\r\nimport os\r\nimport urllib.request\r\nimport string\r\n\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nDICTIONARY = os.path.join(TMP, 'dictionary_m_words.txt')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/dictionary_m_words.txt',\r\n    DICTIONARY\r\n)\r\n\r\n\r\ndef load_dictionary():\r\n    \"\"\"Load dictionary (sample) and return as generator (done)\"\"\"\r\n    with open(DICTIONARY) as f:\r\n        return (word.lower().strip() for word in f.readlines())\r\n\r\n\r\ndef _as_stripped_list(word):\r\n    return [letter for letter in word.lower() if letter in string.ascii_lowercase]\r\n\r\ndef is_palindrome(word):\r\n    \"\"\"Return if word is palindrome, 'madam' would be one.\r\n       Case insensitive, so Madam is valid too.\r\n       It should work for phrases too so strip all but alphanumeric chars.\r\n       So \"No 'x' in 'Nixon'\" should pass (see tests for more)\"\"\"\r\n    stripped_lst = _as_stripped_list(word)\r\n    return stripped_lst == list(reversed(stripped_lst))\r\n\r\n\r\ndef get_longest_palindrome(words=None):\r\n    \"\"\"Given a list of words return the longest palindrome\r\n       If called without argument use the load_dictionary helper\r\n       to populate the words list\"\"\"\r\n    if words is None:\r\n        words = load_dictionary()\r\n    \r\n    longest_palindrome =\"\" \r\n    length= 0\r\n    for word in words:\r\n        if is_palindrome(word):\r\n            len_lst = len(_as_stripped_list(word))\r\n            if len_lst > length:\r\n                longest_palindrome = word\r\n                length = len_lst\r\n    return longest_palindrome\r\n\r\nprint(is_palindrome(\"No 'x' in 'Nixon'\"))\r\n\r\nword_list =\"\"\"\r\nAibohphobia\r\n'Avid diva\r\nAvid diva. \r\nA Toyota\u2019s a Toyota.\r\nA man, a plan, a canal: Panama\r\nNo 'x in 'Nixon'\r\nmalayalam\r\nPyBites\r\ntoyota\r\npalindrome\r\n\"\"\"\r\nprint(get_longest_palindrome(word_list.splitlines()))\r\n",
            "score": 3,
            "number_code_submits": 4,
            "tags": "algorithms, list comprehensions, max, reverse",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 10. Practice exceptions",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-25 21:18:28.219728+00:00",
            "passing_code": "def positive_divide(numerator, denominator):\r\n    try: \r\n        result = numerator/denominator\r\n        if result < 0:\r\n            raise ValueError\r\n    except ZeroDivisionError:\r\n        return 0\r\n    except TypeError:\r\n        raise TypeError(\"I caught a TypeError\")\r\n    except ValueError:\r\n        raise ValueError(\"I caught a negative result\")\r\n    \r\n    return result\r\n\r\n# print(positive_divide(-1,2))\r\n# print(positive_divide(2,-1))\r\n# print(positive_divide(1, 's'))\r\n# print(positive_divide([], 2))\r\n# print(positive_divide(1,\"two\"))",
            "score": 3,
            "number_code_submits": 13,
            "tags": "exception handling, raise",
            "in_paths": ""
        },
        {
            "bite": "Bite 11. Enrich a class with dunder methods",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-28 21:54:56.670584+00:00",
            "passing_code": "class Account:\r\n\r\n    def __init__(self, name, start_balance=0):\r\n        self.name = name\r\n        self.start_balance = start_balance\r\n        self._transactions = []\r\n\r\n    @property\r\n    def balance(self):\r\n        return self.start_balance + sum(self._transactions)\r\n\r\n    #\u00a0add dunder methods below\r\n    def __len__(self):\r\n        return len(self._transactions)\r\n    \r\n    \r\n    def __lt__(self,account):\r\n        return self.balance <account.balance\r\n\r\n    def __le__(self,account):\r\n        return self.balance <=account.balance\r\n\r\n    def __gt__(self,account):\r\n        return self.balance >account.balance\r\n\r\n    def __ge__(self,account):\r\n        return self.balance >=account.balance\r\n\r\n    def __eq__(self,account):\r\n        return self.balance >=account.balance\r\n\r\n    \r\n    def __getitem__(self, index):\r\n        return self._transactions[index]\r\n        \r\n    def __iter__(self):\r\n        return iter(self._transactions)\r\n    \r\n    \r\n    def __add__(self, amount:int ):\r\n        if isinstance(amount,int):\r\n            self._transactions.append(amount)\r\n        else:\r\n            raise TypeError\r\n\r\n    def __sub__(self, amount:int ):\r\n        if isinstance(amount,int):\r\n            self._transactions.append(-amount)\r\n        else:\r\n            raise TypeError\r\n\r\n    def __str__(self):\r\n        return f\"{self.name} account - balance: {self.balance}\"\r\n        \r\nacc1 = Account('aac1', 100)\r\nacc2 = Account('aac2', 200)\r\n\r\nacc1-50\r\nacc1+20\r\nacc1+100\r\nacc1-70\r\n\r\nprint(acc1 == acc2)\r\n\r\nprint(acc1)\r\n    \r\nprint(list(acc1))\r\n\r\nprint(acc1[0])\r\n\r\n",
            "score": 4,
            "number_code_submits": 3,
            "tags": "dunder methods, functools, properties",
            "in_paths": "Object Oriented Programming"
        },
        {
            "bite": "Bite 12. Write a user validation function",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-25 21:53:05.732208+00:00",
            "passing_code": "from collections import namedtuple\r\n\r\nUser = namedtuple('User', 'name role expired')\r\nUSER, ADMIN = 'user', 'admin'\r\nSECRET = 'I am a very secret token'\r\n\r\njulian = User(name='Julian', role=USER, expired=False)\r\nbob = User(name='Bob', role=USER, expired=True)\r\npybites = User(name='PyBites', role=ADMIN, expired=False)\r\nUSERS = (julian, bob, pybites)\r\n\r\n# define exception classes here\r\nclass UserDoesNotExist(Exception):\r\n    \"\"\"Raised when the user does not exist\"\"\"\r\n    pass\r\n\r\nclass UserAccessExpired(Exception):\r\n    \"\"\"Raised when user access is expired\"\"\"\r\n    pass\r\n\r\nclass UserNoPermission(Exception):\r\n    \"\"\"Raised when the user is not Admin\"\"\"\r\n    pass\r\n\r\ndef get_secret_token(username):\r\n    try:\r\n        user=[user for user in USERS if user.name.lower() == username.lower()][0]\r\n    except:\r\n        raise UserDoesNotExist\r\n\r\n    if user.expired == True:\r\n        raise UserAccessExpired\r\n    if not user.role == ADMIN:\r\n        raise UserNoPermission\r\n    return SECRET\r\n    \r\n# get_secret_token('Bob')",
            "score": 3,
            "number_code_submits": 6,
            "tags": "classes, exception handling, namedtuple",
            "in_paths": ""
        },
        {
            "bite": "Bite 13. Convert dict to namedtuple/json",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-14 20:12:27.720062+00:00",
            "passing_code": "from collections import namedtuple\r\nfrom datetime import datetime\r\nimport json\r\nfrom pprint import pprint\r\n\r\n\r\nblog = dict(name='PyBites',\r\n            founders=('Julian', 'Bob'),\r\n            started=datetime(year=2016, month=12, day=19),\r\n            tags=['Python', 'Code Challenges', 'Learn by Doing'],\r\n            location='Spain/Australia',\r\n            site='https://pybit.es')\r\n\r\n# define namedtuple here\r\n\r\ndef dict2nt(dict_):\r\n    Blog = namedtuple('Blog', dict_.keys())\r\n    return Blog(**dict_)\r\n\r\n\r\ndef nt2json(nt):\r\n    return json.dumps(nt._asdict(), indent = 4, default=str) \r\n\r\n\r\nnt=dict2nt(blog)\r\npprint(nt2json(nt))\r\n\r\n",
            "score": 3,
            "number_code_submits": 2,
            "tags": "dict, json, namedtuple",
            "in_paths": "Collections Module, Data Formats"
        },
        {
            "bite": "Bite 14. Generate a table of n sequences",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-26 17:16:10.531207+00:00",
            "passing_code": "import random\r\nfrom pprint import pprint \r\n\r\nnames = ['Julian', 'Bob', 'PyBites', 'Dante', 'Martin', 'Rodolfo']\r\naliases = ['Pythonista', 'Nerd', 'Coder'] * 2\r\npoints = random.sample(range(81, 101), 6)\r\nawake = [True, False] * 3\r\nSEPARATOR = ' | '\r\n\r\n\r\ndef generate_table(*argv):\r\n    return (SEPARATOR.join([str(arg[i]) for arg in argv]) for i in range(0,len(argv[0])))\r\n        \r\n\r\npprint(list(generate_table(names, aliases,points,awake)))",
            "score": 3,
            "number_code_submits": 2,
            "tags": "generators, zip",
            "in_paths": ""
        },
        {
            "bite": "Bite 15. Enumerate 2 sequences",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-11 10:23:23.394322+00:00",
            "passing_code": "names = 'Julian Bob PyBites Dante Martin Rodolfo'.split()\r\ncountries = 'Australia Spain Global Argentina USA Mexico'.split()\r\n\r\n\r\ndef enumerate_names_countries():\r\n    \"\"\"Outputs:\r\n       1. Julian     Australia\r\n       2. Bob        Spain\r\n       3. PyBites    Global\r\n       4. Dante      Argentina\r\n       5. Martin     USA\r\n       6. Rodolfo    Mexico\"\"\"\r\n    for count, (name, country) in enumerate(zip (names,countries)):\r\n        print(f\"{count+1}. {name:11}{country}\")\r\n        \r\n\r\nenumerate_names_countries()",
            "score": 2,
            "number_code_submits": 5,
            "tags": "enumerate, string formatting",
            "in_paths": "Python Beginner"
        },
        {
            "bite": "Bite 16. PyBites date generator",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-11 15:25:13.605032+00:00",
            "passing_code": "from pprint import pprint\r\nfrom itertools import islice\r\nfrom datetime import datetime, timedelta\r\n\r\nPYBITES_BORN = datetime(year=2016, month=12, day=19)\r\n\r\n\r\ndef gen_special_pybites_dates():\r\n    special_date = PYBITES_BORN\r\n    while True:\r\n        special_date+=timedelta(days=100)\r\n        yield special_date\r\n        \r\n        \r\ngen = gen_special_pybites_dates()\r\npprint(list(islice(gen, 5)))",
            "score": 2,
            "number_code_submits": 2,
            "tags": "datetime, generators",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 17. Form teams from a group of friends",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-27 21:48:07.514474+00:00",
            "passing_code": "from itertools import permutations, combinations\r\n\r\ndef friends_teams(friends_list, team_size:int = 2, order_does_matter:bool = False):\r\n    if order_does_matter:\r\n        return permutations(friends_list,team_size)\r\n    else:\r\n        return combinations(friends_list,team_size)\r\n        \r\n        \r\nfriends = 'Bob Dante Julian Martin'.split()\r\n\r\nprint(list(friends_teams(friends, team_size = 3, order_does_matter = False)))",
            "score": 3,
            "number_code_submits": 3,
            "tags": "itertools",
            "in_paths": "Itertools"
        },
        {
            "bite": "Bite 18. Find the most common word",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-29 13:49:46.021443+00:00",
            "passing_code": "import os\r\nimport urllib.request\r\nimport re\r\nfrom collections import Counter\r\n\r\n# data provided\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\nstopwords_file = os.path.join(tmp, 'stopwords')\r\nharry_text = os.path.join(tmp, 'harry')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/stopwords.txt',\r\n    stopwords_file\r\n)\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/harry.txt',\r\n    harry_text\r\n)\r\n\r\ndef get_words(file):\r\n    with open(file) as f:  \r\n        words = f.read().split()\r\n    return [re.sub(r'[^a-z0-9 ]+', '', word.lower()) for word in words]\r\n\r\ndef get_harry_most_common_word():\r\n    words = get_words(harry_text)\r\n    stop_words = get_words(stopwords_file)\r\n    lst = [word for word in words if len(word)>0 and word not in stop_words]\r\n    return Counter(lst).most_common(1)[0]\r\n    \r\n    \r\nprint(harry_text)\r\nprint(get_harry_most_common_word())",
            "score": 3,
            "number_code_submits": 3,
            "tags": "Counter, data analysis, list comprehensions",
            "in_paths": "Collections Module, Data Analysis"
        },
        {
            "bite": "Bite 19. Write a property",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-14 00:13:52.935085+00:00",
            "passing_code": "from datetime import datetime, timedelta\r\nNOW = datetime.now()\r\n\r\n\r\nclass Promo:\r\n    def __init__(self, name:str, expires: datetime):\r\n        self.name = name\r\n        self.expires = expires\r\n        print(f\"{self.name} expires on {self.expires}\")\r\n        \r\n\r\n    @property\r\n    def expired(self):\r\n        return True if datetime.now() >= self.expires else False\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    test1 = Promo (\"Promo1\", datetime.now()-timedelta(days=2))\r\n    print(test1.expired)\r\n    test2 = Promo (\"Promo2\", datetime.now())\r\n    print(test2.expired)\r\n    test3 = Promo (\"Promo2\", datetime.now()+timedelta(days=2))\r\n    print(test3.expired)",
            "score": 2,
            "number_code_submits": 3,
            "tags": "datetime, properties",
            "in_paths": "Datetimes and Timezones, Object Oriented Programming"
        },
        {
            "bite": "Bite 20. Write a context manager",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-28 19:01:14.146103+00:00",
            "passing_code": "class Account:\r\n\r\n    def __init__(self):\r\n        self._transactions = []\r\n\r\n    @property\r\n    def balance(self):\r\n        return sum(self._transactions)\r\n\r\n    def __add__(self, amount):\r\n        self._transactions.append(amount)\r\n\r\n    def __sub__(self, amount):\r\n        self._transactions.append(-amount)\r\n\r\n    # add 2 dunder methods here to turn this class \r\n    # into a 'rollback' context manager\r\n        \r\n    def __enter__(self):\r\n        return self\r\n        \r\n    def __exit__(self, exc_type, exc_value, exc_traceback):\r\n        if self.balance<0:\r\n            self._transactions.pop(-1)\r\n            \r\n        \r\n\r\n",
            "score": 4,
            "number_code_submits": 4,
            "tags": "context managers, dunder methods, operator overloading, with statement",
            "in_paths": "Decorators and Context Managers, Object Oriented Programming"
        },
        {
            "bite": "Bite 21. Query a nested data structure",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-11 23:30:34.539712+00:00",
            "passing_code": "from typing import Dict, List\r\n\r\ncars = {\r\n    'Ford': ['Falcon', 'Focus', 'Festiva', 'Fairlane'],\r\n    'Holden': ['Commodore', 'Captiva', 'Barina', 'Trailblazer'],\r\n    'Nissan': ['Maxima', 'Pulsar', '350Z', 'Navara'],\r\n    'Honda': ['Civic', 'Accord', 'Odyssey', 'Jazz'],\r\n    'Jeep': ['Grand Cherokee', 'Cherokee', 'Trailhawk', 'Trackhawk']\r\n}\r\nDEFAULT_SEARCH = \"trail\"\r\nCarsType = Dict[str, List[str]]\r\n\r\n\r\ndef get_all_jeeps(cars: CarsType = cars) -> str:\r\n    \"\"\"\r\n    Retrieve the 'Jeep' models from the cars dict and join them by a\r\n    comma and space (', '). Leave the original ordering intact.\r\n    \"\"\"\r\n    return \", \".join(cars[\"Jeep\"])\r\n\r\n\r\ndef get_first_model_each_manufacturer(cars: CarsType = cars) -> List[str]:\r\n    \"\"\"\r\n    Loop through the cars dict filtering out the first model for each\r\n    manufacturer. Return the matching models in a list leaving the original\r\n    ordering intact.\r\n    \"\"\"\r\n    return [cars[item][0] for item in cars]\r\n\r\n\r\ndef get_all_matching_models(\r\n    cars: CarsType = cars, grep: str = DEFAULT_SEARCH\r\n) -> List[str]:\r\n    \"\"\"\r\n    Return a list of all models containing the case insensitive\r\n    'grep' string which defaults to DEFAULT_SEARCH ('trail').\r\n    Sort the resulting sequence alphabetically\r\n    \"\"\"\r\n    model_lst = sum([cars[manuf] for manuf in cars],[])  # get flattened list of all models\r\n    # [f(x) for x in sequence if condition]\r\n    return sorted([item for item in model_lst if grep.lower() in item.lower() ])  # get the ones containing the grep\r\n\r\n\r\ndef sort_car_models(cars: CarsType = cars) -> CarsType:\r\n    \"\"\"\r\n    Loop through the cars dict returning a new dict with the\r\n    same keys and the values sorted alphabetically.\r\n    \"\"\"\r\n    \r\n    return dict([(item, sorted(cars[item])) for item in cars])\r\n\r\n\r\nprint(get_all_jeeps())\r\nprint(get_first_model_each_manufacturer())\r\nprint(get_all_matching_models())\r\nprint(sort_car_models())",
            "score": 2,
            "number_code_submits": 4,
            "tags": "data structures, dictionary comprehensions, list comprehensions, sorting",
            "in_paths": "Python Beginner"
        },
        {
            "bite": "Bite 22. Write a decorator with argument",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-27 22:22:15.481106+00:00",
            "passing_code": "from functools import wraps\r\n\r\n\r\ndef make_html(element):\r\n    \r\n    def decorate(fn):\r\n        @wraps(fn)\r\n        def wrapper(*args, **kwargs):\r\n            return f\"<{element}>\" + fn(*args, **kwargs) + f\"</{element}>\"\r\n        return wrapper\r\n    return decorate\r\n\r\n\r\n@make_html('p')\r\n@make_html('strong')\r\ndef get_text(text='I code with PyBites'):\r\n    return text\r\n    \r\nprint(get_text(\"a test\"))",
            "score": 3,
            "number_code_submits": 2,
            "tags": "decorators",
            "in_paths": "Decorators and Context Managers"
        },
        {
            "bite": "Bite 23. Find words that are > 95% similar",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-02 11:52:09.136996+00:00",
            "passing_code": "import os\r\nimport re\r\nfrom difflib import SequenceMatcher\r\nimport itertools\r\nfrom urllib.request import urlretrieve\r\nimport string\r\n\r\n# prep\r\nTAG_HTML = re.compile(r'<category>([^<]+)</category>')\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nTEMPFILE = os.path.join(TMP, 'feed')\r\nMIN_TAG_LEN = 10\r\nIDENTICAL = 1.0\r\nSIMILAR = 0.95\r\n\r\nurlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/tags.xml',\r\n    TEMPFILE\r\n)\r\n\r\n\r\ndef _get_tags(tempfile=TEMPFILE):\r\n    \"\"\"Helper to parse all tags from a static copy of PyBites' feed,\r\n       providing this here so you can focus on difflib\"\"\"\r\n    with open(tempfile) as f:\r\n        content = f.read().lower()\r\n    # take a small subset to keep it performant\r\n    tags = TAG_HTML.findall(content)\r\n    tags = [tag for tag in tags if len(tag) > MIN_TAG_LEN]\r\n    return set(tags)\r\n\r\n\r\ndef get_similarities(tags=None):\r\n    \"\"\"Should return a list of similar tag pairs (tuples)\"\"\"\r\n    tags = tags or _get_tags()\r\n    # do your thing ...\r\n    JUNK = string.punctuation + string.whitespace\r\n    pairs = [\r\n        pair for pair in itertools.combinations(tags, 2) \r\n        if SequenceMatcher(\r\n            lambda x: x in JUNK, pair[0], pair[1]\r\n            ).ratio() >= SIMILAR\r\n        ]\r\n    return pairs\r\n    \r\n\r\n# get_similarities()\r\n\r\n",
            "score": 4,
            "number_code_submits": 3,
            "tags": "difflib, file processing, findall, itertools, SequenceMatcher",
            "in_paths": ""
        },
        {
            "bite": "Bite 25. No promo twice, keep state in a class",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-27 22:59:53.112316+00:00",
            "passing_code": "import random\r\n\r\nBITES = {6: 'PyBites Die Hard',\r\n         7: 'Parsing dates from logs',\r\n         9: 'Palindromes',\r\n         10: 'Practice exceptions',\r\n         11: 'Enrich a class with dunder methods',\r\n         12: 'Write a user validation function',\r\n         13: 'Convert dict in namedtuple/json',\r\n         14: 'Generate a table of n sequences',\r\n         15: 'Enumerate 2 sequences',\r\n         16: 'Special PyBites date generator',\r\n         17: 'Form teams from a group of friends',\r\n         18: 'Find the most common word',\r\n         19: 'Write a simple property',\r\n         20: 'Write a context manager',\r\n         21: 'Query a nested data structure'}\r\nBITES_DONE = {6, 10, 16, 18, 21}\r\n\r\n\r\nclass NoBitesAvailable(Exception):\r\n    \"\"\"There are no more Bites available to pick from\"\"\"\r\n\r\n\r\nclass Promo:\r\n\r\n    def __init__(self):\r\n        # updated Bite to make local copies (avoid globals!)\r\n        self.all_bites = BITES.copy()\r\n        self.bites_done = BITES_DONE.copy()\r\n\r\n    def _pick_random_bite(self):\r\n        \"\"\"Pick a random Bite that is not done yet, if all\r\n           Bites are done, raise a NoBitesAvailable exception\"\"\"\r\n        pending_bites = self.all_bites.keys()-self.bites_done\r\n        if len(pending_bites)==0:\r\n            raise NoBitesAvailable\r\n        return random.choice(list(pending_bites))\r\n\r\n    def new_bite(self):\r\n        \"\"\"Get  a random Bite using _pick_random_bite,\r\n           add it to self.bites_done, then return it\"\"\"\r\n        bite = self._pick_random_bite()\r\n        self.bites_done.add(bite)\r\n        return bite\r\n\r\nif __name__ == \"__main__\":\r\n    promo=Promo()\r\n    for _ in range(11):\r\n        next_bite=promo.new_bite()\r\n        print(f\"{next_bite=}\")\r\n        print(f\"{promo.bites_done=}\")\r\n",
            "score": 3,
            "number_code_submits": 2,
            "tags": "classes, exception handling, properties",
            "in_paths": "Object Oriented Programming"
        },
        {
            "bite": "Bite 26. Dictionary comprehensions are awesome",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-16 14:38:21.765369+00:00",
            "passing_code": "from typing import Dict, Set\r\n\r\nDEFAULT_BITES = {\r\n    6: \"PyBites Die Hard\",\r\n    7: \"Parsing dates from logs\",\r\n    9: \"Palindromes\",\r\n    10: \"Practice exceptions\",\r\n    11: \"Enrich a class with dunder methods\",\r\n    12: \"Write a user validation function\",\r\n    13: \"Convert dict in namedtuple/json\",\r\n    14: \"Generate a table of n sequences\",\r\n    15: \"Enumerate 2 sequences\",\r\n    16: \"Special PyBites date generator\",\r\n    17: \"Form teams from a group of friends\",\r\n    18: \"Find the most common word\",\r\n    19: \"Write a simple property\",\r\n    20: \"Write a context manager\",\r\n    21: \"Query a nested data structure\",\r\n}\r\nEXCLUDE_BITES = {6, 10, 16, 18, 21}\r\n\r\n\r\ndef filter_bites(\r\n    bites: Dict[int, str] = DEFAULT_BITES,\r\n    bites_done: Set[int] = EXCLUDE_BITES\r\n) -> Dict[int, str]:\r\n    \"\"\"\r\n    Return the bites dict with bites_done filtered out.\r\n    \"\"\"\r\n    return {key:value for key,value in bites.items() if key not in bites_done}\r\n\r\n\r\nprint(filter_bites())",
            "score": 2,
            "number_code_submits": 2,
            "tags": "dictionary comprehensions",
            "in_paths": "Python Beginner"
        },
        {
            "bite": "Bite 27. Parse omdb movie json data",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-30 20:35:19.433667+00:00",
            "passing_code": "import os\r\nimport urllib.request\r\nimport json\r\nimport ast\r\nfrom pprint import pprint \r\n\r\n# this needed to do my testing with print, I am such a loser\r\n# download file\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\nomdb_json = os.path.join(tmp, 'omdb')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/omdb_data',\r\n    omdb_json)\r\n\r\n# load file in list of dicts\r\nwith open(omdb_json,) as f:\r\n    list_dicts = [ast.literal_eval(line) for line in f.readlines()]\r\n\r\n# create JSON files from list of dicts\r\nlist_of_files=[]\r\nfor i, movie_dict in enumerate(list_dicts):\r\n    filename = f\"{tmp}/file_{i}.json\" \r\n    with open(filename, \"w\") as outfile:\r\n        json.dump(movie_dict, outfile)\r\n    list_of_files.append(filename)\r\n\r\n# print(list_of_files)\r\n\r\n\r\ndef get_movie_data(files: list) -> list:\r\n    \"\"\"Parse movie json files into a list of dicts\"\"\"\r\n    lst=[]\r\n    for file in files:\r\n        with open(file) as f:\r\n            lst.append(json.load(f)) \r\n    return lst\r\n    \r\n\r\ndef get_single_comedy(movies: list) -> str:\r\n    \"\"\"return the movie with Comedy in Genres\"\"\"\r\n    for movie in movies:\r\n        if 'Comedy' in movie['Genre']:\r\n            return movie['Title']\r\n\r\n\r\ndef _parse_num_nominations(string):\r\n    return int(string.strip().split('&')[1].split()[0])\r\n    \r\n    \r\ndef get_movie_most_nominations(movies: list) -> str:\r\n    \"\"\"Return the movie that had the most nominations\"\"\"\r\n    \r\n    nominations=dict((movie['Title'], _parse_num_nominations(movie['Awards']) ) for movie in movies)\r\n    # print(runtimes)\r\n    return max(nominations, key=nominations.get)\r\n\r\ndef _parse_runtime(string):\r\n    return int(string.split()[0].strip())\r\n\r\n\r\ndef get_movie_longest_runtime(movies: list) -> str:\r\n    \"\"\"Return the movie that has the longest runtime\"\"\"\r\n    runtimes=dict((movie['Title'], _parse_runtime(movie['Runtime']) ) for movie in movies)\r\n    # print(runtimes)\r\n    return max(runtimes, key=runtimes.get)\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    lst=get_movie_data(list_of_files)\r\n    print(lst)\r\n    print(get_single_comedy(lst))\r\n    print(get_movie_most_nominations(lst))\r\n    print(get_movie_longest_runtime(lst))",
            "score": 3,
            "number_code_submits": 2,
            "tags": "APIs, glob, json, movie data",
            "in_paths": "Data Analysis, Data Formats"
        },
        {
            "bite": "Bite 28. Converting date strings to datetimes",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-01 22:14:46.630185+00:00",
            "passing_code": "import collections\r\nfrom datetime import datetime\r\nimport os\r\nimport re\r\nfrom urllib.request import urlretrieve\r\n\r\nBASE_URL = 'https://bites-data.s3.us-east-2.amazonaws.com/'\r\nRSS_FEED = 'pybites_feed.rss.xml'\r\nPUB_DATE = re.compile(r'<pubDate>(.*?)</pubDate>')\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\n\r\n\r\ndef _get_dates():\r\n    \"\"\"Downloads PyBites feed and parses out all pub dates returning\r\n       a list of date strings, e.g.: ['Sun, 07 Jan 2018 12:00:00 +0100',\r\n       'Sun, 07 Jan 2018 11:00:00 +0100', ... ]\"\"\"\r\n    remote = os.path.join(BASE_URL, RSS_FEED)\r\n    local = os.path.join(TMP, RSS_FEED)\r\n    urlretrieve(remote, local)\r\n\r\n    with open(local) as f:\r\n        return PUB_DATE.findall(f.read())\r\n\r\n\r\ndef convert_to_datetime(date_str):\r\n    \"\"\"Receives a date str and convert it into a datetime object\"\"\"\r\n    date_str_clean = re.findall(',(.+)\\+',date_str)[0]\r\n    return datetime.strptime(date_str_clean.strip(), \"%d %b %Y %H:%M:%S\")\r\n\r\n\r\ndef get_month_most_posts(dates):\r\n    \"\"\"Receives a list of datetimes and returns the month (format YYYY-MM)\r\n       that occurs most\"\"\"\r\n    return collections.Counter([date.strftime(\"%Y-%m\") for date in dates]).most_common(1)[0][0]\r\n\r\n\r\nif __name__==\"__main__\":\r\n    test_str=\"Thu, 04 May 2017 20:46:00 +0200.\"\r\n    test_lst =[\r\n        datetime(year=2021, month=10, day=1),\r\n        datetime(year=2022, month=10, day=10),\r\n        datetime(year=2023, month=10, day=11),\r\n        datetime(year=2021, month=11, day=12),\r\n        datetime(year=2022, month=10, day=2),\r\n        datetime(year=2022, month=10, day=3),\r\n        datetime(year=2021, month=9, day=6)\r\n        ]\r\n    \r\n    date = convert_to_datetime(test_str)\r\n    print(date.strftime(\"%Y-%d\"))\r\n    print(get_month_most_posts(test_lst))\r\n",
            "score": 3,
            "number_code_submits": 3,
            "tags": "Counter, datetime, findall",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 29. Martin's IQ test",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-17 09:03:05.920752+00:00",
            "passing_code": "from collections import Counter\r\n\r\nalphanumeric = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\r\n\r\ntest1= ['A', 'f', '.', 'Q', 2] \r\ntest2= ['.', '{', ' ^', '%', 'a'] \r\ntest3 = ['=', '=', '', '/', '/', 9, ':', ';', '?', '\u00a1']\r\n\r\ndef get_index_different_char(chars):\r\n    is_alphanumeric = [str(char) in alphanumeric and len(str(char))>0 for char in chars]\r\n    counter = Counter(is_alphanumeric).most_common(1)\r\n    least_common = not counter[0][0]\r\n    return [i for i,item in enumerate(is_alphanumeric) if item==least_common][0]\r\n\r\n    \r\n    \"\"\" alternative that also works\r\n    is_alphanumeric = [(i, str(char) in alphanumeric and len(str(char))>0) for i, char in enumerate(chars)]\r\n\r\n    if Counter([item[1] for item in is_alphanumeric])[True] == 1:\r\n        # alphanumeric is the different one\r\n        index = [item[0] for item in is_alphanumeric if item[1]==True]\r\n    else:\r\n        # non-alphanumeric is the different one\r\n        index = [item[0] for item in is_alphanumeric if item[1]==False]\r\n    return is_alphanumeric[index[0]][0]\r\n    \"\"\"\r\n\r\n\r\n\r\nprint(get_index_different_char(test1))\r\nprint(get_index_different_char(test2))\r\nprint(get_index_different_char(test3))",
            "score": 2,
            "number_code_submits": 7,
            "tags": "enumerate, string module",
            "in_paths": ""
        },
        {
            "bite": "Bite 30. Movie data analysis",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-05 21:12:25.381506+00:00",
            "passing_code": "import csv\r\nfrom collections import defaultdict, namedtuple\r\nimport os\r\nfrom urllib.request import urlretrieve\r\nfrom pprint import pprint\r\nfrom operator import itemgetter\r\n\r\n\r\nBASE_URL = 'https://bites-data.s3.us-east-2.amazonaws.com/'\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\n\r\nfname = 'movie_metadata.csv'\r\nremote = os.path.join(BASE_URL, fname)\r\nlocal = os.path.join(TMP, fname)\r\nurlretrieve(remote, local)\r\n\r\nMOVIE_DATA = local\r\nMIN_MOVIES = 4\r\nMIN_YEAR = 1960\r\n\r\nMovie = namedtuple('Movie', 'title year score')\r\n\r\n\r\ndef get_movies_by_director():\r\n    \"\"\"Extracts all movies from csv and stores them in a dict,\r\n    where keys are directors, and values are a list of movies,\r\n    use the defined Movie namedtuple\"\"\"\r\n    \r\n    with open(local, newline='') as f:\r\n        data = csv.DictReader(f)\r\n        result = {}\r\n        for row in data:\r\n            director = row['director_name']\r\n            year = row['title_year']\r\n            title = row['movie_title'].strip()\r\n            score = row['imdb_score']\r\n            result.setdefault(director,[])\r\n\r\n            if year and title and score:\r\n                year = int(year)\r\n                score = float(score)\r\n                if year >= MIN_YEAR:    \r\n                    result[director].append(\r\n                        Movie(title=title, year=year, score=score))\r\n                \r\n    return result\r\n        \r\n\r\ndef calc_mean_score(movies):\r\n    \"\"\"Helper method to calculate mean of list of Movie namedtuples,\r\n       round the mean to 1 decimal place\"\"\"\r\n    tmp = [movie.score for movie in movies]\r\n    return round(sum(tmp)/len(tmp),1)\r\n\r\ndef get_average_scores(directors):\r\n    \"\"\"Iterate through the directors dict (returned by get_movies_by_director),\r\n       return a list of tuples (director, average_score) ordered by highest\r\n       score in descending order. Only take directors into account\r\n       with >= MIN_MOVIES\"\"\"\r\n    result= [(name, calc_mean_score(movies)) for name, movies in directors.items() \\\r\n    if len(movies) >= MIN_MOVIES]\r\n    result.sort(key=lambda tup: tup[1], reverse=True)\r\n    return result\r\n\r\nif __name__ == \"__main__\":\r\n    \r\n    a= get_movies_by_director()\r\n    \r\n    pprint(a['Sergio Leone'])\r\n    print(calc_mean_score(a['Sergio Leone']))\r\n    \r\n    pprint(get_average_scores(a)[:8])",
            "score": 3,
            "number_code_submits": 7,
            "tags": "data analysis, defaultdict, freebie, mean, movie data, namedtuple, sorting",
            "in_paths": "Collections Module, Data Analysis, Data Formats"
        },
        {
            "bite": "Bite 31. Matrix multiplication / @ operator",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "dunder methods, __matmul__, operator overloading",
            "in_paths": "Object Oriented Programming"
        },
        {
            "bite": "Bite 32. Don't let mutability fool you",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-18 11:11:43.348892+00:00",
            "passing_code": "from copy import deepcopy\r\n\r\nitems = [{'id': 1, 'name': 'laptop', 'value': 1000},\r\n         {'id': 2, 'name': 'chair', 'value': 300},\r\n         {'id': 3, 'name': 'book', 'value': 20}]\r\n\r\n\r\ndef duplicate_items(items):\r\n    return deepcopy(items)\r\n    \r\n",
            "score": 2,
            "number_code_submits": 2,
            "tags": "deepcopy, mutability",
            "in_paths": ""
        },
        {
            "bite": "Bite 33. Transpose a data structure",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-03 17:26:22.343756+00:00",
            "passing_code": "from collections import namedtuple\r\nfrom pprint import pprint\r\n\r\ndef transpose(data):\r\n    \"\"\"Transpose a data structure\r\n    1. dict\r\n    data = {'2017-8': 19, '2017-9': 13}\r\n    In:  transpose(data)\r\n    Out: [('2017-8', '2017-9'), (19, 13)]\r\n\r\n    2. list of (named)tuples\r\n    data = [Member(name='Bob', since_days=60, karma_points=60,\r\n                   bitecoin_earned=56),\r\n            Member(name='Julian', since_days=221, karma_points=34,\r\n                   bitecoin_earned=78)]\r\n    In: transpose(data)\r\n    Out: [('Bob', 'Julian'), (60, 221), (60, 34), (56, 78)]\r\n    \"\"\"\r\n    \r\n    if type(data) is dict:\r\n        data = data.items()\r\n\r\n    return list(zip(*data))\r\n    \r\n    \r\n# data = {'2017-8': 19, '2017-9': 13}\r\n\r\n# Declaring namedtuple()\r\nMember = namedtuple('Member', ['name','since_days', 'karma_points',\r\n                   'bitecoin_earned'])\r\ndata = [Member(name='Bob', since_days=60, karma_points=60,\r\n                   bitecoin_earned=56),\r\n            Member(name='Julian', since_days=221, karma_points=34,\r\n                   bitecoin_earned=78)]\r\n\r\n\r\n\r\npprint(transpose(data))",
            "score": 3,
            "number_code_submits": 2,
            "tags": "dict, zip",
            "in_paths": ""
        },
        {
            "bite": "Bite 36. Having fun with *args and **kwargs",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-06 21:38:23.314268+00:00",
            "passing_code": "def get_profile(name: str, age: int, *sports, **awards):\r\n    if not isinstance(age, int):\r\n        raise ValueError\r\n    if len(sports) > 5:\r\n        raise ValueError\r\n    result = {'name': name,\r\n              'age': age\r\n              }\r\n    if sports:\r\n        result['sports'] = sorted(list(sports))\r\n    if awards:\r\n        result['awards'] = awards\r\n    return result\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    print(get_profile('manolo', 47, 'ski', 'scuba diving', 'triathlon', participant='half ironman'))\r\n    ",
            "score": 3,
            "number_code_submits": 2,
            "tags": "args, function arguments, kwargs",
            "in_paths": ""
        },
        {
            "bite": "Bite 37. Rewrite a for loop using recursion",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-12 19:52:35.885461+00:00",
            "passing_code": "def countdown_for(start=10):\r\n    for i in reversed(range(1, start + 1)):\r\n        print(i)\r\n    print('time is up')\r\n\r\n\r\ndef countdown_recursive(start=10):\r\n    if start == 0:\r\n        print('time is up')\r\n        return             # Terminate recursion\r\n    else:\r\n        print(start)\r\n        countdown_recursive(start - 1)   # Recursive call\r\n\r\n\r\ncountdown_recursive(0)\r\n",
            "score": 2,
            "number_code_submits": 3,
            "tags": "recursion, reverse",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 38. Using ElementTree to parse XML",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-20 08:17:14.490682+00:00",
            "passing_code": "import xml.etree.ElementTree as ET\r\nfrom pprint import pprint\r\nfrom operator import itemgetter\r\n\r\n# from OMDB\r\nxmlstring = '''<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<root response=\"True\">\r\n  <movie title=\"The Prestige\" year=\"2006\" rated=\"PG-13\" released=\"20 Oct 2006\" runtime=\"130 min\" genre=\"Drama, Mystery, Sci-Fi\" director=\"Christopher Nolan\" />\r\n  <movie title=\"The Dark Knight\" year=\"2008\" rated=\"PG-13\" released=\"18 Jul 2008\" runtime=\"152 min\" genre=\"Action, Crime, Drama\" director=\"Christopher Nolan\" />\r\n  <movie title=\"The Dark Knight Rises\" year=\"2012\" rated=\"PG-13\" released=\"20 Jul 2012\" runtime=\"164 min\" genre=\"Action, Thriller\" director=\"Christopher Nolan\" />\r\n  <movie title=\"Dunkirk\" year=\"2017\" rated=\"PG-13\" released=\"21 Jul 2017\" runtime=\"106 min\" genre=\"Action, Drama, History\" director=\"Christopher Nolan\" />\r\n  <movie title=\"Interstellar\" year=\"2014\" rated=\"PG-13\" released=\"07 Nov 2014\" runtime=\"169 min\" genre=\"Adventure, Drama, Sci-Fi\" director=\"Christopher Nolan\"/>\r\n</root>'''  # noqa E501\r\n\r\n\r\ndef get_tree():\r\n    \"\"\"You probably want to use ET.fromstring\"\"\"\r\n    return ET.fromstring(xmlstring)\r\n\r\n\r\ndef get_movies():\r\n    \"\"\"Call get_tree and retrieve all movie titles, return a list or generator\"\"\"\r\n    for child in get_tree():\r\n        yield child.attrib['title']\r\n\r\ndef get_movie_longest_runtime():\r\n    \"\"\"Call get_tree again and return the movie title for the movie with the longest\r\n       runtime in minutes, for latter consider adding a _get_runtime helper\"\"\"\r\n    \r\n    lst = [ (_get_runtime(child.attrib['runtime']), child.attrib['title']) for child in get_tree() ] \r\n    longest_title= max(lst, key=itemgetter(0))[1] \r\n    return longest_title\r\n\r\n    \"\"\" this also works\r\n    longest_title=''\r\n    longest_t=0\r\n    for child in get_tree():\r\n        t = _get_runtime(child.attrib['runtime'])\r\n        if t > longest_t:\r\n            longest_t =t\r\n            longest_title = child.attrib['title']\r\n    return longest_title\r\n    \"\"\"\r\n\r\ndef _get_runtime(runtime_label):\r\n    return int(runtime_label.split()[0])\r\n    \r\n    \r\nprint(get_movie_longest_runtime())\r\n",
            "score": 2,
            "number_code_submits": 3,
            "tags": "movie data, xml",
            "in_paths": "Data Formats"
        },
        {
            "bite": "Bite 39. Calculate the total duration of a course",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-13 10:53:35.565920+00:00",
            "passing_code": "from datetime import datetime, timedelta\r\nimport os\r\nimport re\r\nfrom typing import List\r\nimport urllib.request\r\n\r\n# getting the data\r\nCOURSE_TIMES = os.path.join(\r\n    os.getenv(\"TMP\", \"/tmp\"),\r\n    'course_timings'\r\n)\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/course_timings',\r\n    COURSE_TIMES\r\n)\r\n\r\n\r\ndef get_all_timestamps() -> List[str]:\r\n    \"\"\"Read in the COURSE_TIMES and extract all MM:SS timestamps.\r\n       Here is a snippet of the input file:\r\n\r\n       Start  What is Practical JavaScript? (3:47)\r\n       Start  The voice in your ear (4:41)\r\n       Start  Is this course right for you? (1:21)\r\n       ...\r\n\r\n        Return a list of MM:SS timestamps\r\n    \"\"\"\r\n    with open(COURSE_TIMES) as f:\r\n        raw_list = [re.findall(\"\\((.+)\\)$\", line.lstrip()) for line in f.readlines()]\r\n    return [timestamp[0] for timestamp in raw_list if timestamp]\r\n\r\n\r\ndef calc_total_course_duration(timestamps) -> str:\r\n    \"\"\"Takes timestamps list as returned by get_all_timestamps\r\n       and calculates the total duration as HH:MM:SS\"\"\"\r\n    lst = []\r\n    for item in timestamps:\r\n        mm_ss = item.split(\":\")\r\n        lst.append(timedelta(minutes=int(mm_ss[0]), seconds=int(mm_ss[1])))\r\n    return str(sum(lst, timedelta()))\r\n    \r\n\r\nprint(calc_total_course_duration(get_all_timestamps()))",
            "score": 3,
            "number_code_submits": 3,
            "tags": "datetime, findall, numbers, timedelta",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 40. Write a binary search algorithm",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-17 13:00:10.747504+00:00",
            "passing_code": "import string \r\n\r\ndef binary_search(sequence, target):\r\n    start = 0\r\n    end = len(sequence)\r\n\r\n    while start<=end:\r\n        midp=(end+start)//2\r\n\r\n        if sequence[midp]==target: \r\n            return midp\r\n\r\n        if sequence[midp]<target: \r\n            start = midp+1\r\n            continue\r\n\r\n        if sequence[midp]>target: \r\n            end = midp-1\r\n            continue\r\n        \r\n    return None\r\n",
            "score": 4,
            "number_code_submits": 10,
            "tags": "algorithms, binary search",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 41. Write a login_required decorator",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-05 21:38:49.488657+00:00",
            "passing_code": "from functools import wraps\r\n\r\nknown_users = ['bob', 'julian', 'mike', 'carmen', 'sue']\r\nloggedin_users = ['mike', 'sue']\r\n\r\n\r\ndef login_required(func):\r\n    @wraps(func)\r\n    def wrapped(*args, **kwargs):\r\n        # do stuff before the original function gets called\r\n        user=args[0]\r\n        if user not in known_users:\r\n            return 'please create an account'\r\n        elif user not in loggedin_users:\r\n            return 'please login'\r\n        else:\r\n            # call function\r\n            return func(*args, **kwargs)\r\n        # do stuff after function call \r\n    # return wrapper as a decorated function\r\n    return wrapped\r\n\r\n\r\n@login_required\r\ndef welcome(user):\r\n    '''Return a welcome message if logged in'''\r\n    return f'welcome back {user}'\r\n    \r\nif __name__ == \"__main__\":\r\n    print(welcome('anonimous'))",
            "score": 3,
            "number_code_submits": 3,
            "tags": "decorators, functools",
            "in_paths": "Decorators and Context Managers"
        },
        {
            "bite": "Bite 43. Force keyword arguments",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-16 15:33:38.801985+00:00",
            "passing_code": "def get_profile(*,name:str = \"julian\", profession:str = \"programmer\") -> str :\r\n    return f\"{name} is a {profession}\"\r\n    \r\n    \r\n    \r\nprint(get_profile(name=\"manolo\", profession=\"wannabe programmer\"))\r\n",
            "score": 2,
            "number_code_submits": 3,
            "tags": "function arguments, kwargs",
            "in_paths": ""
        },
        {
            "bite": "Bite 44. License key generator",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-22 20:29:24.794713+00:00",
            "passing_code": "# use one or more Standard Library modules\r\nimport string\r\nimport secrets\r\n\r\ndef gen_key(parts: int = 4, chars_per_part: int = 8) -> str:\r\n    \"\"\"\r\n    Generate and return a random license key containing\r\n    upper case characters and digits.\r\n\r\n    Example with default \"parts\" and \"chars_per_part\"\r\n    being 4 and 8: KI80OMZ7-5OGYC1AC-735LDPT1-4L11XU1U\r\n\r\n    If parts = 3 and chars_per_part = 4 a random license\r\n    key would look like this: 54N8-I70K-2JZ7\r\n    \"\"\"\r\n    alphabet = string.ascii_uppercase + string.digits\r\n    return '-'.join(''.join(secrets.choice(alphabet) for j in range(chars_per_part)) for i in range(parts))\r\n\r\nprint(gen_key(4,8))\r\n",
            "score": 2,
            "number_code_submits": 2,
            "tags": "list comprehensions, secrets, string module",
            "in_paths": "Python Beginner"
        },
        {
            "bite": "Bite 45. Keep a queue of last n items",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-23 08:38:15.701627+00:00",
            "passing_code": "from collections import deque\r\nimport queue\r\n\r\ndef my_queue(n=5):\r\n    return deque([],n)\r\n\r\n\r\nif __name__ == '__main__':\r\n    mq = my_queue()\r\n    for i in range(10):\r\n        mq.append(i)\r\n        print((i, list(mq)))\r\n\r\n    \"\"\"Queue size does not go beyond n int, this outputs:\r\n    (0, [0])\r\n    (1, [0, 1])\r\n    (2, [0, 1, 2])\r\n    (3, [0, 1, 2, 3])\r\n    (4, [0, 1, 2, 3, 4])\r\n    (5, [1, 2, 3, 4, 5])\r\n    (6, [2, 3, 4, 5, 6])\r\n    (7, [3, 4, 5, 6, 7])\r\n    (8, [4, 5, 6, 7, 8])\r\n    (9, [5, 6, 7, 8, 9])\r\n    \"\"\"",
            "score": 2,
            "number_code_submits": 4,
            "tags": "deque",
            "in_paths": "Collections Module"
        },
        {
            "bite": "Bite 46. You are a programmer! Code Fizz Buzz",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-23 23:28:44.055828+00:00",
            "passing_code": "from typing import Union\r\n\r\n\r\ndef fizzbuzz(num: int) -> Union[str, int]:\r\n    if num%5 == 0 and num%3 == 0:\r\n        result = \"Fizz Buzz\"\r\n    elif num%3 == 0:\r\n        result = \"Fizz\"\r\n    elif num%5 == 0:\r\n        result = \"Buzz\"\r\n    else: \r\n        result = num\r\n    return result\r\n\r\nprint(\", \".join(str(fizzbuzz(i)) for i in range(1,30)))\r\n\r\n",
            "score": 2,
            "number_code_submits": 2,
            "tags": "fizzbuzz",
            "in_paths": "Python Beginner"
        },
        {
            "bite": "Bite 48. Make a bar chart of new Safari books",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-23 16:45:56.828395+00:00",
            "passing_code": "import os\r\nimport urllib.request\r\nimport time\r\nimport sys\r\n\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nDATA = 'safari.logs'\r\nSAFARI_LOGS = os.path.join(TMP, DATA)\r\nPY_BOOK, OTHER_BOOK = '\ud83d\udc0d', '.'\r\nBOOK_SENT_TO_SLACK=\"sending to slack channel\"\r\nPYTHON = \"python\"\r\n\r\nurllib.request.urlretrieve(\r\n    f'https://bites-data.s3.us-east-2.amazonaws.com/{DATA}',\r\n    SAFARI_LOGS\r\n)\r\n\r\ndef create_chart():\r\n    last_date = \"00-00\"\r\n    with open(SAFARI_LOGS) as f:\r\n        for line in f:\r\n            date, rest = line.split(\" \", 1)\r\n            _, book_title = rest.split(\"-\", 1)\r\n\r\n            if BOOK_SENT_TO_SLACK in next(f):\r\n                if date != last_date:\r\n                    sys.stdout.write(\"\\n\"+date+\" \")\r\n                    last_date = date\r\n                sys.stdout.write(PY_BOOK if PYTHON in book_title.lower() else OTHER_BOOK)\r\n\r\n                    \r\ncreate_chart()",
            "score": 3,
            "number_code_submits": 3,
            "tags": "bar chart, data analysis",
            "in_paths": "Data Analysis"
        },
        {
            "bite": "Bite 49. Scrape Packt's html with BeautifulSoup",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-02 22:08:15.820750+00:00",
            "passing_code": "from collections import namedtuple\r\n\r\nfrom bs4 import BeautifulSoup as Soup\r\nimport requests\r\n\r\nPACKT = 'https://bites-data.s3.us-east-2.amazonaws.com/packt.html'\r\nCONTENT = requests.get(PACKT).text\r\n\r\nBook = namedtuple('Book', 'title description image link')\r\n\r\n\r\ndef get_book():\r\n    \"\"\"make a Soup object, parse the relevant html sections, and return a Book namedtuple\"\"\"\r\n    soup = Soup(CONTENT, 'html.parser')\r\n    \r\n    dotd_title_div = soup.find_all('div', class_=\"dotd-title\")\r\n    title = [element.find(\"h2\").text.strip() for element in dotd_title_div][0]\r\n    \r\n    dotd_description_parent_div = soup.find('div', class_=\"dotd-main-book-summary\")\r\n    description = list(dotd_description_parent_div.children)[7]\r\n    description = description.text.strip()\r\n\r\n    dotd_link_div = soup.find_all('div', class_=\"dotd-main-book-image\")\r\n    for element in dotd_link_div:\r\n        link = element.find(\"a\")\r\n    link = link[\"href\"]\r\n\r\n    dotd_image_img = soup.find('img', class_=\"imagecache-dotd_main_image\")\r\n    image = dotd_image_img[\"src\"]\r\n    \r\n    book = Book(title, description, image, link)\r\n    return book\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    print(get_book())",
            "score": 3,
            "number_code_submits": 3,
            "tags": "beautifulsoup, namedtuple, requests",
            "in_paths": "Web Scraping"
        },
        {
            "bite": "Bite 50. Make a little PyBites search engine (feedparser)",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-12 17:32:52.665416+00:00",
            "passing_code": "from collections import namedtuple\r\nfrom datetime import date\r\n\r\nimport feedparser\r\nimport re\r\nfrom pprint import pprint\r\n\r\nFEED = 'https://bites-data.s3.us-east-2.amazonaws.com/all.rss.xml'\r\n\r\nEntry = namedtuple('Entry', 'date title link tags')\r\n\r\n\r\ndef _convert_struct_time_to_dt(stime):\r\n    \"\"\"Convert a time.struct_time as returned by feedparser into a\r\n    datetime.date object, so:\r\n    time.struct_time(tm_year=2016, tm_mon=12, tm_mday=28, ...)\r\n    -> date(2016, 12, 28)\r\n    \"\"\"\r\n    year, month, day, *_ = stime\r\n    return date(year=year,month=month,day=day)\r\n\r\n\r\ndef get_feed_entries(feed=FEED):\r\n    \"\"\"Use feedparser to parse PyBites RSS feed.\r\n       Return a list of Entry namedtuples (date = date, drop time part)\r\n    \"\"\"\r\n    feed = feedparser.parse(feed)\r\n    lst = []\r\n    for entry in feed.entries:\r\n        \r\n        entry_tags = [tag['term'].lower() for tag in entry.tags]\r\n        # print(entry_date, entry.title, entry.link, entry_tags)\r\n        lst.append(Entry(_convert_struct_time_to_dt(entry.published_parsed), entry.title, entry.link, entry_tags))\r\n    return lst\r\n\r\ndef filter_entries_by_tag(search, entry):\r\n    \"\"\"Check if search matches any tags as stored in the Entry namedtuple\r\n       (case insensitive, only whole, not partial string matches).\r\n       Returns bool: True if match, False if not.\r\n       Supported searches:\r\n       1. If & in search do AND match,\r\n          e.g. flask&api should match entries with both tags\r\n       2. Elif | in search do an OR match,\r\n          e.g. flask|django should match entries with either tag\r\n       3. Else: match if search is in tags\r\n    \"\"\"\r\n    if '&' in search:\r\n        words = search.split('&')\r\n        return all(filter_entries_by_tag(word,entry) for word in words)\r\n    elif '|' in search:\r\n        words = search.split('|')\r\n        return any(filter_entries_by_tag(word,entry) for word in words)\r\n    else:\r\n        return any(search.lower() == tag.lower() for tag in entry.tags)\r\n        \r\n\r\ndef main():\r\n    \"\"\"Entry point to the program\r\n       1. Call get_feed_entries and store them in entries\r\n       2. Initiate an infinite loop\r\n       3. Ask user for a search term:\r\n          - if enter was hit (empty string), print 'Please provide a search term'\r\n          - if 'q' was entered, print 'Bye' and exit/break the infinite loop\r\n       4. Filter/match the entries (see filter_entries_by_tag docstring)\r\n       5. Print the title of each match ordered by date ascending\r\n       6. Secondly, print the number of matches: 'n entries matched'\r\n          (use entry if only 1 match)\r\n    \"\"\"\r\n    \r\n    entries  = get_feed_entries()\r\n    \r\n    while True:\r\n    \r\n        usr_input = input('Search for (q for exit):')\r\n    \r\n        if not usr_input:\r\n            print('Please provide a search term')\r\n            continue\r\n\r\n        if usr_input.lower() =='q':\r\n            print('Bye')\r\n            break\r\n        else:\r\n            filtered_entries = [entry for entry in entries if filter_entries_by_tag(usr_input, entry)]\r\n            if filtered_entries:\r\n                for entry in  sorted(filtered_entries, key=lambda x:x.date):\r\n                    print(f'{entry.date} | {entry.title:<42} | {entry.link}')\r\n\r\n            entrx = 'entry' if len(filtered_entries)==1 else 'entries'\r\n\r\n            print(f'\\n\\t{len(filtered_entries)} {entrx} matched \"{usr_input}\"\\n')\r\n                \r\n\r\nif __name__ == '__main__':\r\n    main()",
            "score": 4,
            "number_code_submits": 8,
            "tags": "any, feedparser, list comprehensions, namedtuple, search",
            "in_paths": "Web Scraping"
        },
        {
            "bite": "Bite 51. When does Python 2 die on Planet Miller?",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-30 10:18:16.023139+00:00",
            "passing_code": "from datetime import datetime\r\n\r\n# https://pythonclock.org/\r\nPY2_DEATH_DT = datetime(year=2020, month=1, day=1)\r\nBITE_CREATED_DT = datetime.strptime('2018-02-26 23:24:04', '%Y-%m-%d %H:%M:%S')\r\n\r\n\r\ndef py2_earth_hours_left(start_date=BITE_CREATED_DT):\r\n    \"\"\"Return how many hours, rounded to 2 decimals, Python 2 has\r\n       left on Planet Earth (calculated from start_date)\"\"\"\r\n    earth_tdelta = PY2_DEATH_DT - start_date\r\n    return round(earth_tdelta.total_seconds()/3600, 2)\r\n\r\ndef py2_miller_min_left(start_date=BITE_CREATED_DT):\r\n    \"\"\"Return how many minutes, rounded to 2 decimals, Python 2 has\r\n       left on Planet Miller (calculated from start_date)\"\"\"\r\n    earth_hours = py2_earth_hours_left(start_date)\r\n    return round(60*earth_hours/(7*365*24), 2)\r\n\r\n# print(py2_earth_hours_left())\r\n# print(py2_miller_min_left())",
            "score": 3,
            "number_code_submits": 2,
            "tags": "datetime",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 53. Convert text into multiple columns",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-12 19:37:58.336810+00:00",
            "passing_code": "import textwrap\r\nimport itertools \r\nfrom pprint import pprint \r\n\r\nCOL_WIDTH = 20\r\nCOL_MARGIN = 4\r\n\r\n\r\ndef text_to_columns(text):\r\n    \"\"\"Split text (input arg) to columns, the amount of double\r\n       newlines (\\n\\n) in text determines the amount of columns.\r\n       Return a string with the column output like:\r\n       line1\\nline2\\nline3\\n ... etc ...\r\n       See also the tests for more info.\"\"\"\r\n\r\n    paragraphs = text.split('\\n\\n')\r\n    \r\n    paragraphs_wrapped = [textwrap.wrap(par.strip(), width=COL_WIDTH) for par in paragraphs]\r\n\r\n    lines_zipped_by_column= list(itertools.zip_longest(*paragraphs_wrapped, fillvalue=\"\"))\r\n\r\n    result = []\r\n    for line in lines_zipped_by_column:\r\n        result.append(\"\".join(col.ljust(COL_WIDTH+COL_MARGIN) for col in line))\r\n    return \"\\n\".join(result)\r\n    \r\n    \r\ntext = \"\"\"My house is small but cosy.\r\n\r\n    It has a white kitchen and an empty fridge.\"\"\"\r\n    \r\npprint(text_to_columns(text))",
            "score": 4,
            "number_code_submits": 3,
            "tags": "string manipulation",
            "in_paths": "String Manipulation"
        },
        {
            "bite": "Bite 54. Nicer formatting of a poem or text",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-25 10:51:51.928793+00:00",
            "passing_code": "INDENTS = 4\r\nrosetti_unformatted = \"\"\"\r\n                      Remember me when I am gone away,\r\n                      Gone far away into the silent land;\r\n                      When you can no more hold me by the hand,\r\n\r\n                      Nor I half turn to go yet turning stay.\r\n\r\n                      Remember me when no more day by day\r\n                      You tell me of our future that you planned:\r\n                      Only remember me; you understand\r\n\"\"\"\r\n\r\nshakespeare_unformatted = \"\"\"\r\n                          To be, or not to be, that is the question:\r\n                          Whether 'tis nobler in the mind to suffer\r\n\r\n                          The slings and arrows of outrageous fortune,\r\n                          Or to take Arms against a Sea of troubles,\r\n                          \"\"\"\r\n\r\n\r\ndef print_hanging_indents(poem):\r\n\r\n    indent =\"\"\r\n    for line in poem.splitlines():\r\n        if len(line.lstrip())==0:\r\n            indent = \"\"\r\n        else:\r\n            print(indent+line.lstrip())\r\n            indent=INDENTS*\" \"\r\n            \r\nprint_hanging_indents(shakespeare_unformatted)",
            "score": 2,
            "number_code_submits": 2,
            "tags": "string manipulation, textwrap",
            "in_paths": "String Manipulation"
        },
        {
            "bite": "Bite 55. Get the latest game releases from Steam's RSS feed",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-14 16:21:29.350716+00:00",
            "passing_code": "from pprint import pprint\r\nfrom collections import namedtuple\r\n\r\nimport feedparser\r\n\r\n# cached version to have predictable results for testing\r\nFEED_URL = \"https://bites-data.s3.us-east-2.amazonaws.com/steam_gaming.xml\"\r\n\r\nGame = namedtuple('Game', 'title link')\r\n\r\n\r\ndef get_games():\r\n    \"\"\"Parses Steam's RSS feed and returns a list of Game namedtuples\"\"\"\r\n    feed = feedparser.parse(FEED_URL)\r\n    lst = []\r\n    for entry in feed.entries:\r\n        lst.append(Game(entry.title, entry.link))\r\n            \r\n    # pprint(lst)\r\n    return lst\r\n    \r\nif __name__==\"__main__\":\r\n    get_games()",
            "score": 2,
            "number_code_submits": 5,
            "tags": "feedparser, namedtuple",
            "in_paths": "Web Scraping"
        },
        {
            "bite": "Bite 56. Add a command line interface to our BMI calculator",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-27 09:37:14.686252+00:00",
            "passing_code": "import argparse\r\n\r\n\r\ndef calc_bmi(weight, length):\r\n    \"\"\"Provided/DONE:\r\n       Calc BMI give a weight in kg and length in cm, return the BMI\r\n       rounded on 2 decimals\"\"\"\r\n    bmi = int(weight) / ((int(length) / 100) ** 2)\r\n    return round(bmi, 2)\r\n\r\n\r\ndef create_parser():\r\n    \"\"\"TODO:\r\n       Create an ArgumentParser adding the right arguments to pass the tests,\r\n       returns a argparse.ArgumentParser object\"\"\"\r\n\r\n    parser = argparse.ArgumentParser(description=\"Calculate your BMI.\")\r\n    parser.add_argument(\"-w\", \"--weight\", type=float, help=\"Your weight in kg\")\r\n    parser.add_argument(\"-l\", \"--length\", type=float, help=\"Your length in cm\")\r\n    return parser\r\n\r\n\r\ndef handle_args(args=None):\r\n    \"\"\"Provided/DONE:\r\n       Call calc_bmi with provided args object.\r\n       If args are not provided get them from create_parser\"\"\"\r\n    if args is None:\r\n        parser = create_parser()\r\n        args = parser.parse_args()\r\n\r\n    if args.weight and args.length:\r\n        bmi = calc_bmi(args.weight, args.length)\r\n        print(f\"Your BMI is: {bmi}\")\r\n    else:\r\n        # could enforce SystemExit in create_parser/add_argument, but argparse\r\n        # docs are not clear how to do it, so raising the exception here manually\r\n        raise SystemExit\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    handle_args()",
            "score": 2,
            "number_code_submits": 3,
            "tags": "argparse",
            "in_paths": ""
        },
        {
            "bite": "Bite 63. Use an infinite iterator to simulate a traffic light",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-18 19:25:57.244861+00:00",
            "passing_code": "from collections import namedtuple\r\nfrom itertools import cycle, islice\r\nfrom time import sleep\r\n\r\nState = namedtuple('State', 'color command timeout')\r\n\r\n\r\ndef traffic_light():\r\n    \"\"\"Returns an itertools.cycle iterator that\r\n       when iterated over returns State namedtuples\r\n       as shown in the Bite's description\"\"\"\r\n    states = [\r\n                State(color='red', command='Stop', timeout=2),\r\n                State(color='green', command='Go', timeout=2),\r\n                State(color='amber', command='Caution', timeout=0.5)\r\n            ]\r\n    for state in cycle(states):\r\n            yield state\r\n\r\n\r\nif __name__ == '__main__':\r\n    # print a sample of 10 states if run as standalone program\r\n    for state in islice(traffic_light(), 10):\r\n        print(f'{state.command}! The light is {state.color}')\r\n        sleep(state.timeout)",
            "score": 4,
            "number_code_submits": 2,
            "tags": "iterators, itertools, namedtuple",
            "in_paths": "Itertools"
        },
        {
            "bite": "Bite 64. Fix a truncating zip function",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-15 16:11:47.408451+00:00",
            "passing_code": "import itertools\r\n\r\nnames = 'Tim Bob Julian Carmen Sofia Mike Kim Andre'.split()\r\nlocations = 'DE ES AUS NL BR US'.split()\r\nconfirmed = [False, True, True, False, True]\r\n\r\n\r\ndef get_attendees():\r\n    for participant in itertools.zip_longest(names, locations, confirmed, fillvalue=\"-\"):\r\n        print(participant)\r\n\r\n\r\nif __name__ == '__main__':\r\n   print(get_attendees())",
            "score": 2,
            "number_code_submits": 2,
            "tags": "itertools, zip",
            "in_paths": "Itertools"
        },
        {
            "bite": "Bite 65. Get all valid dictionary words for a draw of letters",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-08 11:49:47.187504+00:00",
            "passing_code": "import itertools\r\nimport os\r\nimport urllib.request\r\n\r\nimport functools\r\nimport operator\r\nfrom pprint import pprint\r\n\r\n# PREWORK\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nDICT = 'dictionary.txt'\r\nDICTIONARY = os.path.join(TMP, DICT)\r\nurllib.request.urlretrieve(\r\n    f'https://bites-data.s3.us-east-2.amazonaws.com/{DICT}',\r\n    DICTIONARY\r\n)\r\n\r\nwith open(DICTIONARY) as f:\r\n    dictionary = set([word.strip().lower() for word in f.read().split()])\r\n# pprint(list(word for word in dictionary if len(word)==2))\r\n\r\ndef get_possible_dict_words(draw):\r\n    \"\"\"Get all possible words from a draw (list of letters) which are\r\n       valid dictionary words. Use _get_permutations_draw and provided\r\n       dictionary\"\"\"\r\n       \r\n    return [word for word in _get_permutations_draw(draw) if word.lower() in dictionary]\r\n\r\ndef _get_permutations_draw(draw):\r\n    \"\"\"Helper to get all permutations of a draw (list of letters), hint:\r\n       use itertools.permutations (order of letters matters)\"\"\"\r\n    draw = list(map(lambda x: x.lower(), draw))\r\n    nested_lst= [itertools.permutations(draw,r=l) for l in range(2,len(draw)+1)]\r\n    lst_of_tups = functools.reduce(operator.iconcat, nested_lst, [])\r\n    return [\"\".join(elem) for elem in lst_of_tups]\r\n    \r\n\r\n\"\"\"\r\ndraw= ['G', 'A', 'R', 'Y', 'T', 'E', 'V' ]\r\nprint(_get_permutations_draw(draw))\r\nprint(get_possible_dict_words(draw))\r\n\"\"\"",
            "score": 3,
            "number_code_submits": 2,
            "tags": "itertools, Scrabble, set",
            "in_paths": "Itertools"
        },
        {
            "bite": "Bite 66. Calculate the running average of a sequence",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-26 17:59:20.460356+00:00",
            "passing_code": "from itertools import accumulate\r\nimport operator\r\n\r\ndef running_mean(sequence):\r\n    \"\"\"Calculate the running mean of the sequence passed in,\r\n       returns a sequence of same length with the averages.\r\n       You can assume all items in sequence are numeric.\"\"\"\r\n    return (round(part_sum/(i+1),2) for i, part_sum in enumerate(accumulate(sequence, operator.add)))\r\n\r\n# print(list(running_mean([1,2,4,9,11,26])))",
            "score": 2,
            "number_code_submits": 5,
            "tags": "enumerate, itertools, mean",
            "in_paths": "Itertools"
        },
        {
            "bite": "Bite 67. Working with datetimes",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-30 05:55:26.074829+00:00",
            "passing_code": "from datetime import date, timedelta\r\n\r\nstart_100days = date(2017, 3, 30)\r\npybites_founded = date(2016, 12, 19)\r\npycon_date = date(2018, 5, 8)\r\n\r\n\r\ndef get_hundred_days_end_date():\r\n    \"\"\"Return a string of yyyy-mm-dd\"\"\"\r\n    end_challenge=start_100days + timedelta(days=100)\r\n    return(str(end_challenge))\r\n\r\n\r\ndef get_days_between_pb_start_first_joint_pycon():\r\n    \"\"\"Return the int number of days\"\"\"\r\n    days=pycon_date - pybites_founded\r\n    return days.days\r\n\r\nprint(get_hundred_days_end_date())\r\nprint(get_days_between_pb_start_first_joint_pycon())",
            "score": 2,
            "number_code_submits": 2,
            "tags": "datetime, timedelta",
            "in_paths": "Datetimes and Timezones, Python Beginner"
        },
        {
            "bite": "Bite 68. Remove punctuation characters from a string",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-01 21:26:54.912870+00:00",
            "passing_code": "PUNCTUATION = '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~'\r\n\r\ndef remove_punctuation(input_string):\r\n    \"\"\"Return a str with punctuation chars stripped out\"\"\"\r\n    return \"\".join([letter for letter in input_string if letter not in PUNCTUATION])\r\n\r\nprint(remove_punctuation(\"Some other (chars) |:-^, let's delete them\"))",
            "score": 2,
            "number_code_submits": 2,
            "tags": "string manipulation, string module",
            "in_paths": "Python Beginner, String Manipulation"
        },
        {
            "bite": "Bite 69. Regex Fun - part II",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-06 21:39:23.811003+00:00",
            "passing_code": "import re\r\n\r\n\r\ndef has_timestamp(text):\r\n    \"\"\"Return True if text has a timestamp of this format:\r\n       2014-07-03T23:30:37\"\"\"\r\n    return bool(\r\n        re.match(r'.+[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.+', text)\r\n    )\r\n\r\n# 2014-07-03T23:27:51\r\n\r\n\r\ndef is_integer(number):\r\n    \"\"\"Return True if number is an integer\"\"\"\r\n    return bool(\r\n        re.match(r'^-*[0-9]+$', str(number))\r\n    )\r\n\r\n\r\ndef has_word_with_dashes(text):\r\n    \"\"\"Returns True if text has one or more words with dashes\"\"\"\r\n    return bool(\r\n        re.match(r'.*[a-z0-9]+?-[a-z0-9]+?.*', text.lower())\r\n    )\r\n\r\n\r\ndef remove_all_parenthesis_words(text):\r\n    \"\"\"Return text but without any words or phrases in parenthesis:\r\n       'Good morning (afternoon)' -> 'Good morning' (so don't forget\r\n       leading spaces)\"\"\"\r\n    return re.sub(r\"\\s\\(.+?\\)\", \"\", text)\r\n\r\n\r\ndef split_string_on_punctuation(text):\r\n    \"\"\"Split on ?!.,; - e.g. \"hi, how are you doing? blabla\" ->\r\n       ['hi', 'how are you doing', 'blabla']\r\n       (make sure you strip trailing spaces)\"\"\"\r\n    return re.findall(r\"\\s*([^?!.,;]+)\\s*\", text)\r\n\r\n\r\ndef remove_duplicate_spacing(text):\r\n    \"\"\"Replace multiple spaces by one space\"\"\"\r\n    return re.sub(r\"[ ]+\", \" \", text)\r\n\r\n\r\ndef has_three_consecutive_vowels(word):\r\n    \"\"\"Returns True if word has at least 3 consecutive vowels\"\"\"\r\n    return bool(\r\n        re.match('.+([aeiou]){3}.+', word.lower())\r\n    )\r\n\r\n\r\ndef convert_emea_date_to_amer_date(date):\r\n    \"\"\"Convert dd/mm/yyyy (EMEA date format) to mm/dd/yyyy\r\n       (AMER date format)\"\"\"\r\n    date_lst = re.findall(r\"^(\\d{2})/(\\d{2})/(\\d{4})$\", date)\r\n    if date_lst:\r\n        return f\"{date_lst[0][1]}/{date_lst[0][0]}/{date_lst[0][2]}\"\r\n    return date\r\n\r\n\r\nprint(has_timestamp('INFO 2014-07-03T23:27:51 Shutdown initiated.'))\r\nprint(is_integer(-29))\r\nprint(has_word_with_dashes(\"hola caracola speak-up hola\"))\r\n\r\nprint(remove_all_parenthesis_words('Good morning (afternoon)'))\r\nprint(split_string_on_punctuation(\"hi, how are you doing? blabla   \"))\r\nprint(remove_duplicate_spacing(\"  hello    how are   you   \"))\r\n\r\nprint(has_three_consecutive_vowels(\"sioux\"))\r\nprint(convert_emea_date_to_amer_date(\"31/12/2022\"))\r\n",
            "score": 4,
            "number_code_submits": 5,
            "tags": "re, regular expressions",
            "in_paths": "Regular Expressions"
        },
        {
            "bite": "Bite 71. Keep state in a class + make its instance callable",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-07 16:42:33.752754+00:00",
            "passing_code": "class RecordScore():\r\n    \"\"\"Class to track a game's maximum score\"\"\"\r\n\r\n\r\n    def __init__(self):\r\n        self.top_score = None\r\n\r\n    \r\n    def __call__(self, new_score):\r\n        if not self.top_score or new_score > self.top_score:\r\n            self.top_score = new_score\r\n        return self.top_score\r\n\r\n\r\nrecord = RecordScore()\r\nprint(record(-5))\r\nprint(record(-9))\r\nprint(record(-2))\r\n",
            "score": 3,
            "number_code_submits": 2,
            "tags": "classes, dunder methods",
            "in_paths": "Object Oriented Programming"
        },
        {
            "bite": "Bite 72. Retrieve the right Ninja Belt based on score",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-08 12:21:26.117863+00:00",
            "passing_code": "from bisect import bisect\r\n\r\nscores = [10, 50, 100, 175, 250, 400, 600, 800, 1000]\r\nbelts = 'white yellow orange green blue brown black paneled red'.split()\r\n\r\n\r\ndef get_belt(user_score, scores=scores, belts=belts):\r\n    # scores_belts= list(zip(scores,belts))\r\n    ind= bisect(scores, user_score)\r\n    if ind==0:\r\n        return None\r\n    elif ind>=len(belts):\r\n        return belts[-1]\r\n    else:\r\n        return belts[ind-1]\r\n\r\nfor score, expected in [(3,'None'),(10,'white'),(12,'white'),(900,'paneled'),(1000,'red'),(1001,'red')]:\r\n    print(f\"{score=} {expected=} result={get_belt(score)}\")",
            "score": 3,
            "number_code_submits": 3,
            "tags": "itertools, OrderedDict",
            "in_paths": "Itertools"
        },
        {
            "bite": "Bite 73. Organize a meeting between timezones (pytz)",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-05 12:15:14.277001+00:00",
            "passing_code": "import pytz\r\n\r\nMIN_MEETING_HOUR = 6\r\nMAX_MEETING_HOUR = 22\r\nTIMEZONES = set(pytz.all_timezones)\r\n\r\n\r\ndef within_schedule(utc, *timezones):\r\n    \"\"\"\r\n    Receive a utc datetime and one or more timezones and check if\r\n    they are all within MIN_MEETING_HOUR and MAX_MEETING_HOUR\r\n    (both included).\r\n    \"\"\"\r\n    \r\n    # make naive utc aware\r\n    utc_aware = utc.replace(tzinfo=pytz.utc)\r\n    \r\n    for zone in timezones:\r\n        if zone not in TIMEZONES:\r\n            raise ValueError\r\n        local_time=utc_aware.astimezone(pytz.timezone(zone))\r\n        if not (MIN_MEETING_HOUR <= local_time.hour <= MAX_MEETING_HOUR):\r\n            return False\r\n    return True\r\n",
            "score": 3,
            "number_code_submits": 6,
            "tags": "pytz, timezones",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 74. What day of the week were you born on?",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-02 14:39:11.940237+00:00",
            "passing_code": "import calendar\r\nimport datetime\r\nWEEKDAYS = ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday']\r\n\r\ndef weekday_of_birth_date(date):\r\n    \"\"\"Takes a date object and returns the corresponding weekday string\"\"\"\r\n    weekday_index = calendar.weekday(date.year,date.month,date.day)\r\n    return WEEKDAYS[weekday_index]\r\n\r\nif __name__ ==\"__main__\":\r\n    date = datetime.datetime(year=2022,month=1,day=1)\r\n    print(weekday_of_birth_date(date))",
            "score": 2,
            "number_code_submits": 3,
            "tags": "calendar",
            "in_paths": ""
        },
        {
            "bite": "Bite 75. Parse Unix cal to a weekday mapping",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-13 18:12:49.552264+00:00",
            "passing_code": "def get_weekdays(calendar_output):\r\n    \"\"\"Receives a multiline Unix cal output and returns a mapping (dict) where\r\n       keys are int days and values are the 2 letter weekdays (Su Mo Tu ...)\"\"\"\r\n    \r\n    cal_lines= calendar_output.splitlines()\r\n    weekdays=[item.strip() for item in cal_lines[1].split()]\r\n    \r\n    result ={}\r\n    for line in cal_lines[2:]:\r\n        cal_days= [line[i:i+3] for i in range(0, len(line), 3)]\r\n        for i, day in enumerate(cal_days):\r\n            label = day.strip()\r\n            if label:\r\n                result[int(label)]=weekdays[i]\r\n    return result\r\n\r\napril_1981 = \"\"\"     April 1981\r\nSu Mo Tu We Th Fr Sa\r\n          1  2  3  4\r\n 5  6  7  8  9 10 11\r\n12 13 14 15 16 17 18\r\n19 20 21 22 23 24 25\r\n26 27 28 29 30\r\n\"\"\"\r\n\r\n\r\nprint(get_weekdays(april_1981))",
            "score": 4,
            "number_code_submits": 4,
            "tags": "re, Unix, zip",
            "in_paths": "String Manipulation"
        },
        {
            "bite": "Bite 77. New places to travel to",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-03 16:49:41.717248+00:00",
            "passing_code": "def uncommon_cities(my_cities, other_cities):\r\n    \"\"\"Compare my_cities and other_cities and return the number of different\r\n       cities between the two\"\"\"\r\n    return len(set(my_cities) ^ set(other_cities))\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    a = ['1','2','3','4','5','6']\r\n    b= ['3','4','5','6','7','8']\r\n    \r\n    print(uncommon_cities(a,b))",
            "score": 2,
            "number_code_submits": 2,
            "tags": "set, set operations",
            "in_paths": ""
        },
        {
            "bite": "Bite 78. Find programmers with common languages",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-03 18:38:10.866214+00:00",
            "passing_code": "def common_languages(programmers):\r\n    \"\"\"Receive a dict of keys -> names and values -> a sequence of\r\n       of programming languages, return the common languages\"\"\"\r\n    languages = list(programmers.values())\r\n    return list(set(languages[0]).intersection(*languages))\r\n\r\n",
            "score": 3,
            "number_code_submits": 3,
            "tags": "set, set operations",
            "in_paths": ""
        },
        {
            "bite": "Bite 79. Parse a csv file and create a bar chart",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-01 22:10:12.259911+00:00",
            "passing_code": "import csv\r\nfrom collections import Counter\r\n\r\nimport requests\r\n\r\nCSV_URL = 'https://bites-data.s3.us-east-2.amazonaws.com/community.csv'\r\n\r\n\r\ndef get_csv():\r\n    \"\"\"Use requests to download the csv and return the\r\n       decoded content\"\"\"\r\n\r\n    with requests.Session() as s:\r\n        data = s.get(CSV_URL)\r\n\r\n    return data.content.decode('utf-8')\r\n    \r\n\r\ndef create_user_bar_chart(content):\r\n    \"\"\"Receives csv file (decoded) content and print a table of timezones\r\n       and their corresponding member counts in pluses to standard output\r\n    \"\"\"\r\n    lst = list(csv.reader(content.splitlines(), delimiter=','))\r\n    \r\n    count = Counter([row[2] for row in lst[1:]])\r\n    \r\n    for timezone in sorted(count.keys()):\r\n        print(f\"{timezone:20s}| \"+ \"+\"*count[timezone])\r\n\r\n# create_user_bar_chart(get_csv())",
            "score": 3,
            "number_code_submits": 3,
            "tags": "bar chart, community, csv, requests",
            "in_paths": "Data Formats"
        },
        {
            "bite": "Bite 80. Check equality of two lists",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-04 07:00:30.411786+00:00",
            "passing_code": "from enum import Enum\r\nfrom collections import Counter\r\n\r\nclass Equality(Enum):\r\n    SAME_REFERENCE = 4\r\n    SAME_ORDERED = 3\r\n    SAME_UNORDERED = 2\r\n    SAME_UNORDERED_DEDUPED = 1\r\n    NO_EQUALITY = 0\r\n\r\n\r\ndef check_equality(list1, list2):\r\n    \"\"\"Check if list1 and list2 are equal returning the kind of equality.\r\n       Use the values in the Equality Enum:\r\n       - return SAME_REFERENCE if both lists reference the same object\r\n       - return SAME_ORDERED if they have the same content and order\r\n       - return SAME_UNORDERED if they have the same content unordered\r\n       - return SAME_UNORDERED_DEDUPED if they have the same unordered content\r\n         and reduced to unique items\r\n       - return NO_EQUALITY if none of the previous cases match\"\"\"\r\n    if list1 is list2:\r\n        return Equality.SAME_REFERENCE\r\n    if list1 == list2:\r\n        return Equality.SAME_ORDERED\r\n    if Counter(list1) == Counter(list2):\r\n        return Equality.SAME_UNORDERED\r\n    if set(list1) == set(list2):\r\n        return Equality.SAME_UNORDERED_DEDUPED\r\n    return Equality.NO_EQUALITY\r\n    \r\n\r\nlist0 = [1, 2, 3, 4, 4]\r\nlist1 = list0\r\nlist2 = [1, 2, 3, 4, 4]\r\nlist3 = [4, 1, 2, 3, 4]\r\nlist4 = [4, 2, 3, 1]\r\nlist5 = [4, 2, 3, 5]\r\n\r\nprint(check_equality(list0, list1))\r\nprint(check_equality(list0, list2))\r\nprint(check_equality(list0, list3))\r\nprint(check_equality(list0, list4))\r\nprint(check_equality(list0, list5))",
            "score": 2,
            "number_code_submits": 3,
            "tags": "enum, equality, list",
            "in_paths": ""
        },
        {
            "bite": "Bite 83. At what time does PyBites live?",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-05 13:12:02.967189+00:00",
            "passing_code": "#!/usr/bin/env python\r\n\r\nfrom datetime import datetime\r\nfrom pytz import timezone, utc\r\n\r\nAUSTRALIA = timezone('Australia/Sydney')\r\nSPAIN = timezone('Europe/Madrid')\r\n\r\n\r\ndef what_time_lives_pybites(naive_utc_dt):\r\n    \"\"\"Receives a naive UTC datetime object and returns a two element\r\n       tuple of Australian and Spanish (timezone aware) datetimes\"\"\"\r\n    utc_dt = utc.localize(naive_utc_dt)\r\n    return (utc_dt.astimezone(AUSTRALIA), utc_dt.astimezone(SPAIN))\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    print(what_time_lives_pybites(datetime(2018, 11, 1, 14, 10, 0)))\r\n",
            "score": 2,
            "number_code_submits": 2,
            "tags": "pytz, timezones",
            "in_paths": ""
        },
        {
            "bite": "Bite 84. Flatten lists recursively (Droste Bite)",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-02 12:09:17.238878+00:00",
            "passing_code": "def flatten(list_of_lists):\r\n    flat = []\r\n    for item in list_of_lists:\r\n        if isinstance(item, list) or isinstance(item,tuple):\r\n            for subitem in flatten(item):\r\n                flat.append(subitem) \r\n        else:\r\n            flat.append(item)\r\n    return flat\r\n\r\ntest =[1, [2, 3], [4, 5, [6, 7, [8, 9, 10]]]]\r\n\r\nprint(flatten(test))",
            "score": 3,
            "number_code_submits": 2,
            "tags": "list, recursion",
            "in_paths": ""
        },
        {
            "bite": "Bite 86. Create a RGB-to-Hex converter",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-25 18:15:17.076080+00:00",
            "passing_code": "def rgb_to_hex(rgb):\r\n    \"\"\"Receives (r, g, b)  tuple, checks if each rgb int is within RGB\r\n       boundaries (0, 255) and returns its converted hex, for example:\r\n       Silver: input tuple = (192,192,192) -> output hex str = #C0C0C0\"\"\"\r\n    if all(0<=col<=255 for col in rgb):\r\n        return f\"#{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}\".upper()\r\n    raise ValueError\r\n\r\n# print(rgb_to_hex((128, 128, 0)))",
            "score": 3,
            "number_code_submits": 5,
            "tags": "string formatting",
            "in_paths": "String Manipulation"
        },
        {
            "bite": "Bite 87. Convert Decimal to Roman Numerals",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-17 17:29:07.940628+00:00",
            "passing_code": "def romanize(decimal_number):\r\n    \"\"\"Takes a decimal number int and converts its Roman Numeral str\"\"\"\r\n    UNITS = {0: '', 1:'I', 2: 'II', 3: 'III', 4: 'IV', 5: 'V', 6: 'VI', 7: 'VII', 8:'VIII', 9:'IX' }\r\n    TENS = {0: '', 1:'X', 2: 'XX', 3: 'XXX', 4: 'XL', 5: 'L', 6: 'LX', 7: 'LXX', 8:'LXXX', 9:'XC' }\r\n    HUNDREDS = {0: '', 1:'C', 2: 'CC', 3: 'CCC', 4: 'CD', 5: 'D', 6: 'DC', 7: 'DCC', 8:'DCCC', 9:'CM' }\r\n    \r\n    if not isinstance(decimal_number,int) or not 0<=decimal_number<=4000:\r\n        raise ValueError\r\n    \r\n    figures = [int(c) for c in str(decimal_number)[::-1]]\r\n    \r\n    result = ''\r\n    result+='M'*figures[3] if len(figures)>3 else '' \r\n    result+=HUNDREDS[figures[2]] if len(figures)>2 else ''\r\n    result+=TENS[figures[1]] if len(figures)>1 else ''\r\n    result+=UNITS[figures[0]] if len(figures)>0 else ''  \r\n    return result\r\n\r\n",
            "score": 3,
            "number_code_submits": 2,
            "tags": "numbers, OrderedDict",
            "in_paths": ""
        },
        {
            "bite": "Bite 88. Write a performance monitoring context manager",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "context managers, Counter",
            "in_paths": "Decorators and Context Managers"
        },
        {
            "bite": "Bite 90. What South Park characters talk most?",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-05 11:26:14.762243+00:00",
            "passing_code": "from collections import Counter, defaultdict\r\nimport csv\r\n\r\nimport requests\r\n\r\nfrom pprint import pprint\r\n\r\nCSV_URL = 'https://raw.githubusercontent.com/pybites/SouthParkData/master/by-season/Season-{}.csv' # noqa E501\r\n\r\n\r\ndef get_season_csv_file(season):\r\n    \"\"\"Receives a season int, and downloads loads in its\r\n       corresponding CSV_URL\"\"\"\r\n    with requests.Session() as s:\r\n        download = s.get(CSV_URL.format(season))\r\n        return download.content.decode('utf-8')\r\n\r\n\r\ndef get_num_words_spoken_by_character_per_episode(content):\r\n    \"\"\"Receives loaded csv content (str) and returns a dict of\r\n       keys=characters and values=Counter object,\r\n       which is a mapping of episode=>words spoken\"\"\"\r\n    result = defaultdict(Counter)\r\n    \r\n    reader = csv.DictReader(content.splitlines(), delimiter=',')\r\n    for row in reader:\r\n        result[row['Character']][row['Episode']] += len(row['Line'].split())\r\n    return(result)    \r\n    \r\n\"\"\"    \r\ncontent=get_season_csv_file(1)\r\npprint(get_num_words_spoken_by_character_per_episode(content))\r\n\"\"\"",
            "score": 3,
            "number_code_submits": 2,
            "tags": "Counter, csv, data analysis, defaultdict, requests",
            "in_paths": "Collections Module, Data Analysis, Data Formats"
        },
        {
            "bite": "Bite 91. Matching multiple strings",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-05 21:50:39.368729+00:00",
            "passing_code": "import string\r\n\r\nVOWELS = 'aeiou'\r\nPYTHON = 'python'\r\n\r\ndef contains_only_vowels(input_str):\r\n    \"\"\"Receives input string and checks if all chars are\r\n       VOWELS. Match is case insensitive.\"\"\"\r\n    return all(letter.lower() in VOWELS for letter in input_str)\r\n\r\n\r\ndef contains_any_py_chars(input_str):\r\n    \"\"\"Receives input string and checks if any of the PYTHON\r\n       chars are in it. Match is case insensitive.\"\"\"\r\n    return any(letter.lower() in PYTHON for letter in input_str)\r\n\r\n\r\ndef contains_digits(input_str):\r\n    \"\"\"Receives input string and checks if it contains\r\n       one or more digits.\"\"\"\r\n    return any(letter in string.digits for letter in input_str)\r\n    \r\nif __name__== \"__main__\":\r\n    \r\n    print(contains_any_py_chars('pygjas'))\r\n    print(contains_any_py_chars('gella'))\r\n    \r\n    print(contains_only_vowels('aaeiouu'))\r\n    print(contains_only_vowels('aaerio'))\r\n    \r\n    print(contains_digits('12wer'))\r\n    print(contains_digits('fghwer'))",
            "score": 2,
            "number_code_submits": 2,
            "tags": "all, any, string matching",
            "in_paths": "Python Beginner"
        },
        {
            "bite": "Bite 92. Humanize a datetime",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-21 17:36:53.002553+00:00",
            "passing_code": "from collections import namedtuple\r\nfrom datetime import datetime, timedelta\r\nimport bisect\r\n\r\nTimeOffset = namedtuple('TimeOffset', 'offset date_str divider')\r\n\r\nNOW = datetime.now()\r\nMINUTE, HOUR, DAY = 60, 60*60, 24*60*60\r\nTIME_OFFSETS = (\r\n    TimeOffset(10, 'just now', None),\r\n    TimeOffset(MINUTE, '{} seconds ago', 1),\r\n    TimeOffset(2*MINUTE, 'a minute ago', None),\r\n    TimeOffset(HOUR, '{} minutes ago', MINUTE),\r\n    TimeOffset(2*HOUR, 'an hour ago', None),\r\n    TimeOffset(DAY, '{} hours ago', HOUR),\r\n    TimeOffset(2*DAY, 'yesterday', None),\r\n)\r\n\r\n\r\ndef pretty_date(date):\r\n    \"\"\"Receives a datetime object and converts/returns a readable string\r\n       using TIME_OFFSETS\"\"\"\r\n    \r\n    if not isinstance(date, datetime) or date > NOW:\r\n        raise ValueError\r\n        \r\n    offset= NOW - date\r\n    secs = offset.total_seconds()\r\n\r\n    idx = bisect.bisect([item.offset for item in TIME_OFFSETS], secs)\r\n    if idx>=len(TIME_OFFSETS):\r\n        return date.strftime('%m/%d/%y')\r\n    result = TIME_OFFSETS[idx]\r\n    return result.date_str.format(round(secs/result.divider)) if result.divider else result.date_str\r\n    \r\n",
            "score": 3,
            "number_code_submits": 2,
            "tags": "datetime, namedtuple",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 94. Parse PyCon talk data from YouTube",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-12 18:27:38.910721+00:00",
            "passing_code": "from collections import namedtuple\r\nimport os\r\nimport pickle\r\nimport urllib.request\r\nimport re\r\nfrom datetime import timedelta\r\n\r\n\r\n# prework\r\n# download pickle file and store it in a tmp file\r\npkl_file = 'pycon_videos.pkl'\r\ndata = f'https://bites-data.s3.us-east-2.amazonaws.com/{pkl_file}'\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\npycon_videos = os.path.join(tmp, pkl_file)\r\nurllib.request.urlretrieve(data, pycon_videos)\r\n\r\nfrom pprint import pprint\r\n\r\n# the pkl contains a list of Video namedtuples\r\nVideo = namedtuple('Video', 'id title duration metrics')\r\n\r\n\r\ndef load_pycon_data(pycon_videos=pycon_videos):\r\n    \"\"\"Load the pickle file (pycon_videos) and return the data structure\r\n       it holds\"\"\"\r\n    with open(pycon_videos, 'rb') as f:\r\n        return pickle.load(f)\r\n\r\n\r\ndef get_most_popular_talks_by_views(videos):\r\n    \"\"\"Return the pycon video list sorted by viewCount\"\"\"\r\n    return sorted(videos, key=lambda x:int(x.metrics['viewCount']),reverse=True)    \r\n\r\n\r\ndef get_most_popular_talks_by_like_ratio(videos):\r\n    \"\"\"Return the pycon video list sorted by most likes relative to\r\n       number of views, so 10 likes on 175 views ranks higher than\r\n       12 likes on 300 views. Discount the dislikeCount from the likeCount.\r\n       Return the filtered list\"\"\"\r\n       \r\n    fun = lambda x: (int(x.metrics['likeCount']) - int(x.metrics['dislikeCount']))/ int(x.metrics['viewCount'])\r\n    return sorted(videos, key=fun,reverse=True)    \r\n\r\n\r\ndef _video_duration(duration_str):\r\n    \r\n    hours=int(re.search('[0-9]+(?=H)', duration_str).group(0)) if 'H' in duration_str else 0\r\n    minutes=int(re.search('[0-9]+(?=M)', duration_str).group(0)) if 'M' in duration_str else 0\r\n    seconds=int(re.search('[0-9]+(?=S)', duration_str).group(0)) if 'S' in duration_str else 0\r\n    return timedelta(hours=hours, minutes=minutes, seconds=seconds)\r\n\r\ndef get_talks_gt_one_hour(videos):\r\n    \"\"\"Filter the videos list down to videos of > 1 hour\"\"\"\r\n    return [video for video in videos if _video_duration(video.duration) > timedelta(hours=1)] \r\n\r\n\r\ndef get_talks_lt_twentyfour_min(videos):\r\n    \"\"\"Filter videos list down to videos that have a duration of less than\r\n       24 minutes\"\"\"\r\n    return [video for video in videos if _video_duration(video.duration) < timedelta(minutes=24)] \r\n\r\n\r\nif __name__ =='__main__':\r\n    top=10\r\n    videos = load_pycon_data()\r\n    print(\" \".join([item.metrics['viewCount'] for item in videos[0:top] ]))\r\n    popular_videos = get_most_popular_talks_by_views(videos)\r\n    print(\" \".join([item.metrics['viewCount'] for item in popular_videos[0:top]]))\r\n    \r\n    liked_videos = get_most_popular_talks_by_like_ratio(videos)\r\n    print(\" \".join([\r\n                    str(\r\n                        100*((int(item.metrics['likeCount'])-int(item.metrics['dislikeCount'])) / \r\n                        int(item.metrics['viewCount']))) for item in liked_videos[0:top]]\r\n                )\r\n        )\r\n\r\n    print(_video_duration('PT3H17M9S'))",
            "score": 4,
            "number_code_submits": 5,
            "tags": "list comprehensions, max, namedtuple",
            "in_paths": "Web Scraping"
        },
        {
            "bite": "Bite 95. Subclass the dict built-in",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-09 10:43:02.362475+00:00",
            "passing_code": "from datetime import date\r\nMSG = 'Hey {}, there are more people with your birthday!'\r\n\r\n\r\nclass BirthdayDict(dict):\r\n    \"\"\"Override dict to print a message every time a new person is added that has\r\n       the same birthday (day+month) as somebody already in the dict\"\"\"\r\n\r\n\r\n    def __setitem__(self, name, birthday):\r\n        for bday in self.values():\r\n            if birthday.day == bday.day and birthday.month == bday.month:\r\n                # match\r\n                print(MSG.format(name))\r\n        super().__setitem__(name, birthday)\r\n\r\n\r\nbd = BirthdayDict()\r\nbd['bob'] = date(1987, 6, 15)\r\nbd['tim'] = date(1984, 7, 15)\r\nprint(bd)\r\nbd['mary'] = date(1987, 6, 15)  # whole date match\r\n# Hey mary, there are more people with your birthday!\r\nbd['sara'] = date(1987, 6, 14)\r\nbd['mike'] = date(1981, 7, 15)  # day + month match\r\n# Hey mike, there are more people with your birthday!\r\n",
            "score": 3,
            "number_code_submits": 4,
            "tags": "classes, inheritance",
            "in_paths": "Object Oriented Programming"
        },
        {
            "bite": "Bite 96. Build Unix' wc program in Python",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-07 16:16:42.322694+00:00",
            "passing_code": "def wc(file_):\r\n    \"\"\"Takes an absolute file path/name, calculates the number of\r\n       lines/words/chars, and returns a string of these numbers + file, e.g.:\r\n       3 12 60 /tmp/somefile\r\n       (both tabs and spaces are allowed as separator)\"\"\"\r\n\r\n    line_count = 0\r\n    word_count = 0\r\n    char_count = 0\r\n\r\n    with open(file_) as f:\r\n        for line in f.readlines():\r\n            line_count += 1\r\n            char_count += len(line)\r\n            word_count += len(line.split())\r\n\r\n    return f\"   {line_count}    {word_count}    {char_count}    {file_}\"\r\n\r\n\r\nif __name__ == '__main__':\r\n    # make it work from cli like original unix wc\r\n    import sys\r\n    print(wc(sys.argv[1]))",
            "score": 2,
            "number_code_submits": 3,
            "tags": "file processing, tempfile, Unix",
            "in_paths": "Python Beginner"
        },
        {
            "bite": "Bite 97. BeautifulSoup II - scrape US holidays",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-07 18:26:45.898117+00:00",
            "passing_code": "from collections import defaultdict\r\nimport os\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup\r\nfrom pprint import pprint\r\nfrom datetime import datetime\r\n\r\n# prep data\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\npage = \"us_holidays.html\"\r\nholidays_page = os.path.join(tmp, page)\r\nurlretrieve(f\"https://bites-data.s3.us-east-2.amazonaws.com/{page}\", holidays_page)\r\n\r\nwith open(holidays_page) as f:\r\n    content = f.read()\r\n\r\nholidays = defaultdict(list)\r\n\r\n\r\ndef get_us_bank_holidays(content=content):\r\n    \"\"\"Receive scraped html output, make a BS object, parse the bank\r\n       holiday table (css class = list-table), and return a dict of\r\n       keys -> months and values -> list of bank holidays\"\"\"\r\n    result = {}\r\n    soup = BeautifulSoup(content, \"html.parser\")\r\n    table = soup.find(\"table\", {\"class\": \"list-table\"})\r\n    table_body = table.find(\"tbody\")\r\n    for row in table_body.find_all(\"tr\"):\r\n        holiday_date = row.find(\"time\").get(\"datetime\")\r\n        holiday_month = datetime.strptime(holiday_date, \"%Y-%m-%d\").strftime(\"%m\")\r\n        holiday_name = row.find(\"a\").text.strip()\r\n        holidays[holiday_month].append(holiday_name)\r\n    return holidays\r\n\r\n",
            "score": 3,
            "number_code_submits": 4,
            "tags": "beautifulsoup, defaultdict, dict",
            "in_paths": "Collections Module, Web Scraping"
        },
        {
            "bite": "Bite 98. Code your way out of a grid",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-22 18:39:50.908161+00:00",
            "passing_code": "import re\r\nfrom pprint import pprint\r\n\r\nDOWN, UP, LEFT, RIGHT = '\u21d3', '\u21d1', '\u21d0', '\u21d2'\r\nSTART_VALUE = 1\r\n\r\ndef _find_value(value, matrix_2d):\r\n    nrows = len(matrix_2d)\r\n    ncols = len(matrix_2d[0])\r\n    for i in range(nrows):\r\n        for j in range(ncols):\r\n            if matrix_2d[i][j] == value:\r\n                return [i, j]\r\n\r\ndef _search(value, i,j, matrix_2d):\r\n    nrows = len(matrix_2d)\r\n    ncols = len(matrix_2d[0])\r\n    if i>0:\r\n        if matrix_2d[i-1][j] == value:\r\n            return UP, i-1, j\r\n    if i<nrows-1:\r\n        if matrix_2d[i+1][j] == value:\r\n            return DOWN, i+1, j\r\n    if j>0:\r\n        if matrix_2d[i][j-1] == value:\r\n            return LEFT, i, j-1\r\n    if j<ncols-1:\r\n        if matrix_2d[i][j+1] == value:\r\n            return RIGHT, i, j+1\r\n    return None, i, j\r\n\r\n\r\n\r\n\r\ndef print_sequence_route(grid, start_coordinates=None):\r\n    \"\"\"Receive grid string, convert to 2D matrix of ints, find the\r\n       START_VALUE coordinates and move through the numbers in order printing\r\n       them.  Each time you turn append the grid with its corresponding symbol\r\n       (DOWN / UP / LEFT / RIGHT). See the TESTS for more info.\"\"\"\r\n    data=[]\r\n    for line in grid.splitlines():\r\n        row= re.findall('[0-9]+',line)\r\n        if row:\r\n            data.append([int(n) for n in row])\r\n    # pprint(data)\r\n    \r\n    nrows, ncols = len(data), len(row)\r\n    \r\n    if not start_coordinates:\r\n        start_coordinates = _find_value(START_VALUE, data)\r\n    i,j= tuple(start_coordinates)\r\n    # print(f\"Starting at {i} {j}\")\r\n\r\n    value = data[i][j]\r\n    direction = new_direction = RIGHT\r\n    \r\n    print(f\"{value}\",end=\" \")\r\n    \r\n    while True:\r\n# look up for N+1\r\n        value+=1\r\n        new_direction, i,j = _search(value, i,j, data)\r\n        if not new_direction:\r\n            break\r\n        # update direction and print\r\n        if new_direction != direction:\r\n            direction = new_direction\r\n            print(new_direction)         \r\n        # print value\r\n        print(f\"{value}\",end=\" \")\r\n    \r\ntest =\"\"\"\r\n21 - 22 - 23 - 24 - 25\r\n |\r\n20    7 -  8 -  9 - 10\r\n |    |              |\r\n19    6    1 -  2   11\r\n |    |         |    |\r\n18    5 -  4 -  3   12\r\n |                   |\r\n17 - 16 - 15 - 14 - 13\r\n\"\"\"\r\n\r\nprint_sequence_route(test)\r\n\r\n\r\n\"\"\"\r\n1 2 \u21d3\r\n3 \u21d0\r\n4 5 \u21d1\r\n6 7 \u21d2\r\n8 9 10 \u21d3\r\n11 12 13 \u21d0\r\n14 15 16 17 \u21d1\r\n18 19 20 21 \u21d2\r\n22 23 24 25\r\n\"\"\"",
            "score": 4,
            "number_code_submits": 2,
            "tags": "looping, namedtuple, numbers, tuple unpacking",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 99. Write an infinite sequence generator",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-18 19:11:28.719891+00:00",
            "passing_code": "import string\r\nfrom itertools import cycle\r\n\r\ndef sequence_generator():\r\n    lst=zip(enumerate(string.ascii_uppercase,1))\r\n    lst=list(sum(lst,())) # flatten tuples\r\n    lst=list(sum(lst,())) # flatten tuples again\r\n    \r\n    for item in cycle(lst):\r\n        yield item\r\n\r\na=sequence_generator()\r\n\r\nfor _ in range(60):\r\n    print(next(a))\r\n",
            "score": 3,
            "number_code_submits": 2,
            "tags": "generators, itertools, string module, zip",
            "in_paths": "Itertools"
        },
        {
            "bite": "Bite 100. Display the last part of a file (Unix tail)",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-08 10:35:21.690493+00:00",
            "passing_code": "from pathlib import Path\r\nfrom typing import List\r\n\r\n\r\ndef tail(filepath: Path, n: int) -> List[str]:\r\n    \"\"\"\r\n    Simulate Unix' \"tail -n\" command:\r\n    - Read in the file (\"filepath\").\r\n    - Parse it into a list of lines, stripping trailing newlines.\r\n    - Return the last \"n\" lines.\r\n    \"\"\"\r\n    with open(filepath) as f:\r\n        lines = f.read().splitlines()\r\n    return lines[-n:]",
            "score": 2,
            "number_code_submits": 4,
            "tags": "file processing, slicing, strip, Unix",
            "in_paths": "Python Beginner"
        },
        {
            "bite": "Intro Bite 01. F-strings and a simple if/else",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-09 12:43:47.694101+00:00",
            "passing_code": "MIN_DRIVING_AGE = 18\r\n\r\n\r\ndef allowed_driving(name, age):\r\n    \"\"\"Print '{name} is allowed to drive' or '{name} is not allowed to drive'\r\n       checking the passed in age against the MIN_DRIVING_AGE constant\"\"\"\r\n    if age >= MIN_DRIVING_AGE:\r\n        print (f\"{name} is allowed to drive\")\r\n    else:\r\n        print (f\"{name} is not allowed to drive\")       ",
            "score": 1,
            "number_code_submits": 1,
            "tags": "freebie, f-strings, if/else",
            "in_paths": ""
        },
        {
            "bite": "Intro Bite 02. Infinite loop, input, continue and break",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-09 12:58:36.512748+00:00",
            "passing_code": "VALID_COLORS = ['blue', 'yellow', 'red']\r\n\r\n\r\ndef print_colors():\r\n    \"\"\"In the while loop ask the user to enter a color,\r\n       lowercase it and store it in a variable. Next check: \r\n       - if 'quit' was entered for color, print 'bye' and break. \r\n       - if the color is not in VALID_COLORS, print 'Not a valid color' and continue.\r\n       - otherwise print the color in lower case.\"\"\"\r\n    while True:\r\n        try:\r\n            user_input = input(\"Enter a color (blue/yellow/red) or quit to exit\")\r\n        except EOFError:\r\n            break    \r\n        user_input = user_input.lower()\r\n        if user_input == \"quit\":\r\n            print(\"bye\")\r\n            break\r\n        if user_input not in VALID_COLORS:\r\n            print(\"Not a valid color\")\r\n            continue\r\n        print(user_input)\r\n\r\n\r\nprint_colors()\r\n",
            "score": 1,
            "number_code_submits": 1,
            "tags": "break, continue, freebie, input, mock.patch, while",
            "in_paths": ""
        },
        {
            "bite": "Intro Bite 03. Loop through a dictionary and pluralise a word",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-09 13:08:36.804892+00:00",
            "passing_code": "GAME_STATS = dict(sara=0, bob=1, tim=5, julian=3, jim=1)\r\n\r\n\r\ndef print_game_stats(games_won):\r\n    \"\"\"Loop through games_won's dict (key, value) pairs (dict.items)\r\n       printing (print, not return) how many games each person has won,\r\n       pluralize 'game' based on number.\r\n\r\n       Expected output (ignore the docstring's indentation):\r\n\r\n       sara has won 0 games\r\n       bob has won 1 game\r\n       tim has won 5 games\r\n       julian has won 3 games\r\n       jim has won 1 game\r\n\r\n       (Note that as of Python 3.7 - which we're using atm - dict insert order\r\n       is retained so no sorting is required for this Bite.)\r\n    \"\"\"\r\n    for name, number in games_won.items():\r\n        if number ==1:\r\n            game_x = \"game\"\r\n        else:\r\n            game_x = \"games\"\r\n        print(f\"{name} has won {number} {game_x}\")\r\n        \r\n\r\nprint_game_stats(GAME_STATS)",
            "score": 1,
            "number_code_submits": 1,
            "tags": "dict, freebie, looping",
            "in_paths": ""
        },
        {
            "bite": "Intro Bite 04. Split and join",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-09 13:18:03.027758+00:00",
            "passing_code": "MESSAGE = \"\"\"Hello world!\r\nWe hope that you are learning a lot of Python.\r\nHave fun with our Bites of Py.\r\nKeep calm and code in Python!\r\nBecome a PyBites ninja!\"\"\"\r\n\r\ndef split_in_columns(message=MESSAGE):\r\n    \"\"\"Split the message by newline (\\n) and join it together on '|'\r\n       (pipe), return the obtained output string\"\"\"\r\n    return \"|\".join(message.split(\"\\n\"))\r\n\r\n\r\na=split_in_columns()\r\nprint(a)",
            "score": 1,
            "number_code_submits": 1,
            "tags": "freebie, join, split",
            "in_paths": ""
        },
        {
            "bite": "Intro Bite 05. Slice and dice",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-09 13:52:56.693207+00:00",
            "passing_code": "from typing import List\r\n\r\nfrom string import ascii_lowercase\r\n\r\nTEXT = \"\"\"\r\nOne really nice feature of Python is polymorphism: using the same operation\r\non different types of objects.\r\nLet's talk about an elegant feature: slicing.\r\nYou can use this on a string as well as a list for example\r\n'pybites'[0:2] gives 'py'.\r\n The first value is inclusive and the last one is exclusive so\r\nhere we grab indexes 0 and 1, the letter p and y.\r\n  When you have a 0 index you can leave it out so can write this as 'pybites'[:2]\r\nbut here is the kicker: you can use this on a list too!\r\n['pybites', 'teaches', 'you', 'Python'][-2:] would gives ['you', 'Python']\r\nand now you know about slicing from the end as well :)\r\nkeep enjoying our bites!\r\n\"\"\"\r\n\r\n\r\ndef slice_and_dice(text: str = TEXT) -> List[str]:\r\n    \"\"\"\r\n    Get a list of words from the passed in text.\r\n    See the Bite description for step by step instructions\r\n    \"\"\"\r\n    results = []\r\n    text = text.strip()\r\n    lines = text.split(\"\\n\")\r\n    for line in lines:\r\n        line = line.strip()\r\n        if line[0:1].islower():\r\n            words = line.split()\r\n            last_word = words[-1]\r\n            if  last_word[-1:]  in [\".\", \"!\"]:\r\n                last_word=last_word[0:-1]\r\n            results.append(last_word) \r\n\r\n    return results\r\n    \r\nprint(slice_and_dice())",
            "score": 1,
            "number_code_submits": 1,
            "tags": "freebie, replace, slicing, split, string module, strip",
            "in_paths": "String Manipulation"
        },
        {
            "bite": "Intro Bite 06. Strip out vowels and count the number of replacements",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-09 14:42:59.600401+00:00",
            "passing_code": "from typing import Tuple\r\n\r\nTEXT = \"\"\"\r\nThe Zen of Python, by Tim Peters\r\nBeautiful is better than ugly.\r\nExplicit is better than implicit.\r\nSimple is better than complex.\r\nComplex is better than complicated.\r\nFlat is better than nested.\r\nSparse is better than dense.\r\nReadability counts.\r\nSpecial cases aren't special enough to break the rules.\r\nAlthough practicality beats purity.\r\nErrors should never pass silently.\r\nUnless explicitly silenced.\r\nIn the face of ambiguity, refuse the temptation to guess.\r\nThere should be one-- and preferably only one --obvious way to do it.\r\nAlthough that way may not be obvious at first unless you're Dutch.\r\nNow is better than never.\r\nAlthough never is often better than *right* now.\r\nIf the implementation is hard to explain, it's a bad idea.\r\nIf the implementation is easy to explain, it may be a good idea.\r\nNamespaces are one honking great idea -- let's do more of those!\r\n\"\"\"\r\nVOWELS = 'aeiou'\r\n\r\n\r\ndef strip_vowels(text: str = TEXT) -> Tuple[str, int]:\r\n    \"\"\"\r\n    Replace all vowels in the input text string by a star\r\n    character (*).\r\n    Return a tuple of (replaced_text, number_of_vowels_found)\r\n\r\n    So if this function is called like:\r\n    strip_vowels('hello world')\r\n\r\n    ... it would return:\r\n    ('h*ll* w*rld', 3)\r\n\r\n    str/int/Tuple in the function definition are type hints, see:\r\n    https://docs.python.org/3/library/typing.html\r\n    and:\r\n    https://pybit.es/articles/code-better-with-type-hints-part-1/\r\n    \"\"\"\r\n    \r\n    number_of_vowels_found =0\r\n    char_list = []\r\n    for character in text:\r\n        if character.lower() in VOWELS:\r\n            char_list.append(\"*\")\r\n            number_of_vowels_found+=1\r\n        else:\r\n            char_list.append(character)\r\n           \r\n    replaced_text = \"\".join(char_list)\r\n    return (replaced_text, number_of_vowels_found)\r\n    \r\nprint(strip_vowels(TEXT))\r\n        ",
            "score": 1,
            "number_code_submits": 1,
            "tags": "counting, freebie, regular expressions, replace, string manipulation, Zen of Python",
            "in_paths": "Regular Expressions, String Manipulation"
        },
        {
            "bite": "Intro Bite 07. Filter numbers with a list comprehension",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-09 14:47:41.169645+00:00",
            "passing_code": "def filter_positive_even_numbers(numbers):\r\n    \"\"\"Receives a list of numbers, and returns a filtered list of only the\r\n       numbers that are both positive and even (divisible by 2), try to use a\r\n       list comprehension.\"\"\"\r\n    return [x for x in numbers if x>0 and (x%2)==0 ]\r\n    \r\n    \r\n\r\nprint(filter_positive_even_numbers([-2, -1, 0, 1, 2, 3, 4]))",
            "score": 1,
            "number_code_submits": 1,
            "tags": "freebie, list comprehensions, modulo",
            "in_paths": ""
        },
        {
            "bite": "Intro Bite 08. Loop over a dict of namedtuples calculating a total score",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-10 20:43:24.461270+00:00",
            "passing_code": "from collections import namedtuple\r\n\r\nBeltStats = namedtuple('BeltStats', 'score ninjas')\r\n\r\nninja_belts = {'yellow': BeltStats(50, 11),\r\n               'orange': BeltStats(100, 7),\r\n               'green': BeltStats(175, 1),\r\n               'blue': BeltStats(250, 5)}\r\n\r\n\r\ndef get_total_points(belts=ninja_belts):\r\n    \"\"\"Calculate the amount of points rewarded on PyBites given the\r\n       ninja_belts dictionary, formula: belt score x belt owners (aka ninjas)\r\n       (of course there are more points but let's keep it simple)\r\n\r\n       Make your code generic so if we update ninja_belts to include\r\n       more belts (which we do in the tests) it will still work.\r\n\r\n       Ah and you can get score and ninjas from the namedtuple with nice\r\n       attribute access: belt.score / belt.ninjas (reason why we get\r\n       you familiar with namedtuple here, because we love them and use\r\n       them all over the place!)\r\n\r\n       Return the total number of points int from the function.\"\"\"\r\n    total = 0\r\n    print(belts)\r\n    print(belts['yellow'])\r\n    for item in belts:\r\n        total += int(belts[item].score) * int(belts[item].ninjas)\r\n    return total\r\n    \r\nprint(get_total_points())\r\n",
            "score": 1,
            "number_code_submits": 1,
            "tags": "counting, dict, freebie, namedtuple",
            "in_paths": "Collections Module"
        },
        {
            "bite": "Intro Bite 09. Workout dictionary lookups",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-10 20:52:52.591086+00:00",
            "passing_code": "WORKOUT_SCHEDULE = {'Friday': 'Shoulders',\r\n                    'Monday': 'Chest+biceps',\r\n                    'Saturday': 'Rest',\r\n                    'Sunday': 'Rest',\r\n                    'Thursday': 'Legs',\r\n                    'Tuesday': 'Back+triceps',\r\n                    'Wednesday': 'Core'}\r\nREST, CHILL_OUT, TRAIN = 'Rest', 'Chill out!', 'Go train {}'\r\nINVALID_DAY = 'Not a valid day'\r\n\r\n\r\ndef get_workout_motd(day):\r\n    \"\"\"First title case the passed in day argument\r\n       (so monday or MONDAY both result in Monday).\r\n\r\n       If day is not in WORKOUT_SCHEDULE, return INVALID_DAY\r\n\r\n       If day is in WORKOUT_SCHEDULE retrieve the value (workout)\r\n       and return the following:\r\n       - weekday, return TRAIN with the workout value interpolated\r\n       - weekend day (value 'Rest'), return CHILL_OUT\r\n\r\n       Examples:\r\n       - if day is Monday -> function returns 'Go train Chest+biceps'\r\n       - if day is Thursday -> function returns 'Go train Legs'\r\n       - if day is Saturday -> function returns 'Chill out!'\r\n       - if day is nonsense -> function returns 'Not a valid day'\r\n\r\n       Trivia: /etc/motd is a file on Unix-like systems that contains\r\n       a 'message of the day'\r\n    \"\"\"\r\n    day = day.title()\r\n    if day not in WORKOUT_SCHEDULE:\r\n        return INVALID_DAY\r\n    if WORKOUT_SCHEDULE[day] == REST:\r\n        return CHILL_OUT\r\n    return TRAIN.format(WORKOUT_SCHEDULE[day])\r\n    \r\nprint(get_workout_motd(\"pepe\"))\r\nprint(get_workout_motd(\"monday\"))\r\nprint(get_workout_motd(\"sunday\"))",
            "score": 1,
            "number_code_submits": 1,
            "tags": "dict, exception handling, format, freebie, string manipulation, ternary",
            "in_paths": ""
        },
        {
            "bite": "Intro Bite 10. Type conversion and exception handling",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-10 22:24:03.323986+00:00",
            "passing_code": "def divide_numbers(numerator, denominator):\r\n    \"\"\"For this exercise you can assume numerator and denominator are of type\r\n       int/str/float.\r\n       Try to convert numerator and denominator to int types, if that raises a\r\n       ValueError reraise it. Following do the division and return the result.\r\n       However if denominator is 0 catch the corresponding exception Python\r\n       throws (cannot divide by 0), and return 0\"\"\"\r\n    try:\r\n        num=int(numerator)\r\n        den=int(denominator)\r\n    except ValueError:\r\n        print(\"numerator and denominator cannot be casted to int\")\r\n        raise\r\n    \r\n    try:\r\n        result = num/den\r\n    except ZeroDivisionError:\r\n        print(\"cannot divide by zero\")\r\n        result = 0\r\n    \r\n    return result",
            "score": 1,
            "number_code_submits": 1,
            "tags": "exception handling, freebie, raise, type casting",
            "in_paths": ""
        },
        {
            "bite": "Bite 111. Use the ipinfo API to lookup IP country",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-05 17:16:09.714489+00:00",
            "passing_code": "import requests\r\n\r\nIPINFO_URL = 'http://ipinfo.io/{ip}/json'\r\n\r\n\r\ndef get_ip_country(ip_address):\r\n    \"\"\"Receives ip address string, use IPINFO_URL to get geo data,\r\n       parse the json response returning the country code of the IP\"\"\"\r\n    pass\r\n    # send get request and save the response as response object\r\n    response = requests.get(url = IPINFO_URL.format(ip=ip_address))\r\n\r\n    # extract data in json format\r\n    data = response.json()\r\n    \r\n    return data['country']\r\n    \r\n\r\nprint(get_ip_country('8.8.8.8'))\r\n\r\n",
            "score": 3,
            "number_code_submits": 2,
            "tags": "APIs, json, mock.patch, requests",
            "in_paths": "Data Formats"
        },
        {
            "bite": "Bite 113. Filter words with non-ascii characters",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-30 23:46:45.713485+00:00",
            "passing_code": "import string\r\nimport unicodedata\r\n\r\ndef _non_ascii_char(c):\r\n    # non-ascii number: it is a number but not an ascii number \r\n    if unicodedata.category(c) in ['Nd'] and c not in string.digits:\r\n            return True\r\n    # non-ascii letter: it is not punctuation or number (i.e. it is a letter) but not an ascii letter\r\n    if unicodedata.category(c) not in ['Po', 'Pd', 'Nd'] and c.lower() not in string.ascii_lowercase:\r\n            return True\r\n    return False\r\n    \r\ndef extract_non_ascii_words(text):\r\n    \"\"\"Filter a text returning a list of non-ascii words\"\"\"\r\n    return [word for word in text.split() if any(_non_ascii_char(c) for c in word.strip())]\r\n\r\n",
            "score": 3,
            "number_code_submits": 19,
            "tags": "all, ascii, ord, unicode",
            "in_paths": ""
        },
        {
            "bite": "Bite 114. Implement a Color class with staticmethod",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-18 19:02:52.214399+00:00",
            "passing_code": "import os\r\nimport sys\r\nimport urllib.request\r\nimport string\r\n\r\n# PREWORK (don't modify): import colors, save to temp file and import\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\ncolor_values_module = os.path.join(tmp, 'color_values.py')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/color_values.py',\r\n    color_values_module\r\n)\r\nsys.path.append(tmp)\r\n\r\n# should be importable now\r\nfrom color_values import COLOR_NAMES  # noqa E402\r\n\r\n\r\nclass Color:\r\n    \"\"\"Color class.\r\n\r\n    Takes the string of a color name and returns its RGB value.\r\n    \"\"\"\r\n\r\n    \r\n    def __init__(self, color):\r\n        self.color = color\r\n        self.rgb = COLOR_NAMES.get(color.upper(), None)\r\n\r\n    @staticmethod\r\n    def hex2rgb(h):\r\n        \"\"\"Class method that converts a hex value into an rgb one\"\"\"\r\n        if isinstance(h,str) and h[0]==\"#\" and len(h[1:])==6 and all(c in string.hexdigits for c in h[1:]):\r\n            return tuple(int(h[i:i+2], 16) for i in (1, 3, 5))\r\n        else:\r\n            raise ValueError\r\n        \r\n    @staticmethod\r\n    def rgb2hex(r):\r\n        \"\"\"Class method that converts an rgb value into a hex one\"\"\"\r\n        if isinstance(r, tuple) and len(r) == 3 and all(isinstance(n,int) and 0<=n<=255 for n in r): \r\n            return '#%02x%02x%02x' % r\r\n        else:\r\n            raise ValueError\r\n            \r\n\r\n    def __repr__(self):\r\n        \"\"\"Returns the repl of the object\"\"\"\r\n        return f\"Color('{self.color}')\"\r\n\r\n    def __str__(self):\r\n        \"\"\"Returns the string value of the color object\"\"\"\r\n        return str(self.rgb) if self.rgb else \"Unknown\"\r\n        \r\nprint(COLOR_NAMES['white'.upper()])",
            "score": 3,
            "number_code_submits": 7,
            "tags": "hex, __repr__, staticmethod, __str__, string module",
            "in_paths": "Object Oriented Programming"
        },
        {
            "bite": "Bite 115. Count leading spaces",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-09 10:14:40.770873+00:00",
            "passing_code": "def count_indents(text: str) -> int:\r\n    \"\"\"\r\n    Count and return the number of leading white space characters (' ').\r\n    \"\"\"\r\n    for i,letter in enumerate(text):\r\n        if letter !=\" \":\r\n            return i\r\n    # only spaces found\r\n    return len(text)\r\n    \r\nprint(count_indents(\"   n\"))",
            "score": 2,
            "number_code_submits": 2,
            "tags": "counting, string matching",
            "in_paths": "Python Beginner"
        },
        {
            "bite": "Bite 117. Round a number even (a.k.a. banker's rounding)",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-10 20:41:55.648722+00:00",
            "passing_code": "def round_even(number):\r\n    \"\"\"Takes a number and returns it rounded even\"\"\"\r\n    decimal_part = number % 1\r\n    int_part = number - decimal_part\r\n    if decimal_part < 0.5:\r\n        return int_part\r\n    if decimal_part > 0.5:\r\n        return int_part + 1\r\n    if decimal_part == 0.5:\r\n        if int_part%2 == 0:\r\n            return int_part\r\n        return int_part + 1\r\n\r\n    \r\n    \r\n",
            "score": 2,
            "number_code_submits": 7,
            "tags": "Decimal, rounding",
            "in_paths": ""
        },
        {
            "bite": "Bite 120. Write a numbers validation decorator",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-10 22:06:16.794931+00:00",
            "passing_code": "from functools import wraps\r\n\r\n\r\ndef int_args(func):\r\n    @wraps(func)\r\n    def wrapped(*args):\r\n        # do stuff before the original function gets called\r\n\r\n        for arg in args:\r\n            if not isinstance(arg,int):\r\n                raise TypeError\r\n            if arg < 0:\r\n                raise ValueError\r\n        return func(*args)\r\n\r\n    # return wrapper as a decorated function\r\n    return wrapped\r\n\r\n@int_args\r\ndef test_int(*args):\r\n    for arg in args: \r\n        print(arg)\r\n\r\nif __name__ == \"__main__\":\r\n    test_int(1,2,3,4,-5)",
            "score": 3,
            "number_code_submits": 3,
            "tags": "decorators",
            "in_paths": "Decorators and Context Managers"
        },
        {
            "bite": "Bite 122. Check if two words are anagrams",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-02 18:16:29.452143+00:00",
            "passing_code": "from collections import Counter \r\n\r\ndef is_anagram(word1, word2):\r\n    \"\"\"Receives two words and returns True/False (boolean) if word2 is\r\n       an anagram of word1, ignore case and spacing.\r\n       About anagrams: https://en.wikipedia.org/wiki/Anagram\"\"\"\r\n    return _letters(word1) == _letters(word2) \r\n        \r\ndef _letters(word):\r\n    return Counter([letter.lower() for letter in word if letter.isalnum() ])\r\n\r\n\"\"\"\r\ntests=[\r\n    (\"rail safety\", \"fairy tales\"),\r\n    (\"roast beef\", \"eat for BSE\"),\r\n    (\"restful\", \"fluster\"),\r\n    (\"funeral\", \"real fun\"),\r\n    (\"adultery\", \"true lady\"),\r\n    (\"customers\", \"store scum\"),\r\n    (\"forty five\", \"over fifty\"),\r\n    (\"William Shakespeare\", \"I am a weakish speller\"),\r\n    (\"Madam Curie\", \"Radium came\"),\r\n    ]\r\n    \r\nfor word1, word2 in tests:\r\n    print(is_anagram(word1, word2))\r\n    \r\n\"\"\"",
            "score": 3,
            "number_code_submits": 3,
            "tags": "anagram, string matching",
            "in_paths": "String Manipulation"
        },
        {
            "bite": "Bite 124. Marvel data analysis",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-03 16:37:26.064309+00:00",
            "passing_code": "from collections import Counter, namedtuple, defaultdict\r\nimport csv\r\nimport re\r\n\r\nimport requests\r\n\r\nfrom pprint import pprint\r\n\r\nMARVEL_CSV = 'https://raw.githubusercontent.com/pybites/marvel_challenge/master/marvel-wikia-data.csv'  # noqa E501\r\n\r\nCharacter = namedtuple('Character', 'pid name sid align sex appearances year')\r\n\r\nMALE, FEMALE, AGENDER, GENDERFLUID = 'male characters', 'female characters', 'agender characters', 'genderfluid characters'\r\nVALID_GENDERS = [MALE, FEMALE, AGENDER, GENDERFLUID ]\r\n\r\n# csv parsing code provided so this Bite can focus on the parsing\r\n\r\ndef _get_csv_data():\r\n    \"\"\"Download the marvel csv data and return its decoded content\"\"\"\r\n    with requests.Session() as session:\r\n        return session.get(MARVEL_CSV).content.decode('utf-8')\r\n\r\n\r\ndef load_data():\r\n    \"\"\"Converts marvel.csv into a sequence of Character namedtuples\r\n       as defined above\"\"\"\r\n    content = _get_csv_data()\r\n    reader = csv.DictReader(content.splitlines(), delimiter=',')\r\n    for row in reader:\r\n        name = re.sub(r'(.*?)\\(.*', r'\\1', row['name']).strip()\r\n        yield Character(pid=row['page_id'],\r\n                        name=name,\r\n                        sid=row['ID'],\r\n                        align=row['ALIGN'],\r\n                        sex=row['SEX'],\r\n                        appearances=row['APPEARANCES'],\r\n                        year=row['Year'])\r\n\r\n\r\ncharacters = list(load_data())\r\n\r\n\r\n# start coding\r\n\r\ndef most_popular_characters(characters=characters, top=5):\r\n    \"\"\"Get the most popular character by number of appearances,\r\n       return top n characters (default 5)\r\n    \"\"\"\r\n    \r\n    \"\"\"\r\n    # this works but results differ. Note e.g. Benjamin Grimm appears \r\n    # several times with the same name, this code adds them all together\r\n    \r\n    char_appears = defaultdict(int)\r\n    for character in characters:\r\n         if character.appearances:\r\n            char_appears[character.name]+= int(character.appearances)\r\n\r\n    count = Counter(char_appears).most_common(top)\r\n    return [name for name, appears in count]\r\n    \"\"\"\r\n    \r\n    # wrote this to mimic results in the tests. Now every line of 'Benjamin Grimm'\r\n    # is considered separately\r\n    \r\n    char_appears= {c.pid: int(c.appearances) for c in characters if c.appearances}\r\n    top_chars_by_pid = Counter(char_appears).most_common(top)\r\n    return [c.name for pid,appears in top_chars_by_pid for c in characters if c.pid ==pid]\r\n        \r\n\r\n\r\n\r\ndef max_and_min_years_new_characters(characters=characters):\r\n    \"\"\"Get the year with most and least new characters introduced respectively,\r\n       use either the 'FIRST APPEARANCE' or 'Year' column in the csv\r\n       characters, or the 'year' attribute of the namedtuple, return a tuple\r\n       of (max_year, min_year)\r\n    \"\"\"\r\n    new_chars_per_year = defaultdict(int)\r\n    for character in characters:\r\n        if character.year:\r\n            new_chars_per_year[character.year]+=1\r\n    count = Counter(new_chars_per_year).most_common()\r\n    return count[0][0],count[-1][0]\r\n\r\n\r\n\r\ndef get_percentage_female_characters(characters=characters):\r\n    \"\"\"Get the percentage of female characters as percentage of all genders\r\n       over all appearances.\r\n       Ignore characters that don't have gender ('sex' attribue) set\r\n       (in your characters data set you should only have Male, Female,\r\n       Agender and Genderfluid Characters.\r\n       Return the result rounded to 2 digits\r\n    \"\"\"\r\n\r\n    \"\"\"\r\n    appearances_by_gender = defaultdict(int)\r\n    for character in characters:\r\n        if character.sex.lower() in VALID_GENDERS:\r\n            appearances_by_gender[character.sex.lower()]+=int(character.appearances or 0)\r\n        \r\n        else:\r\n            print(character.sex +\" : \"+ character.appearances)\r\n        \r\n    total = sum(value for value in appearances_by_gender.values())\r\n    return round(100*appearances_by_gender[FEMALE]/total,2)\r\n    \"\"\"\r\n    \r\n    chars_by_gender = defaultdict(int)\r\n    for character in characters:\r\n        if character.sex.lower():\r\n            chars_by_gender[character.sex.lower()]+=1\r\n\r\n    total = sum(value for key, value in chars_by_gender.items() if key.lower() in VALID_GENDERS)\r\n    return round(100*chars_by_gender[FEMALE]/total,2)\r\n    \r\n\r\n\r\nprint(most_popular_characters(top=10))\r\nprint(max_and_min_years_new_characters())\r\nprint(get_percentage_female_characters())\r\n",
            "score": 4,
            "number_code_submits": 13,
            "tags": "Counter, csv, data analysis, list comprehensions, rounding, sum",
            "in_paths": "Data Analysis, Data Formats"
        },
        {
            "bite": "Bite 125. Get the most recommended books",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-12 12:04:03.077861+00:00",
            "passing_code": "from collections import Counter\r\n\r\nfrom bs4 import BeautifulSoup\r\nimport requests\r\n\r\nAMAZON = \"amazon.com\"\r\n# static copy\r\nTIM_BLOG = ('https://bites-data.s3.us-east-2.amazonaws.com/'\r\n            'tribe-mentors-books.html')\r\nMIN_COUNT = 3\r\n\r\n\r\ndef load_page():\r\n    \"\"\"Download the blog html and return its decoded content\"\"\"\r\n    with requests.Session() as session:\r\n        return session.get(TIM_BLOG).content.decode('utf-8')\r\n\r\n\r\ndef get_top_books(content=None):\r\n    \"\"\"Make a BeautifulSoup object loading in content,\r\n       find all links that contain AMAZON, extract the book title\r\n       (stripping spacing characters), and count them.\r\n       Return a list of (title, count) tuples where\r\n       count is at least MIN_COUNT\r\n    \"\"\"\r\n    if content is None:\r\n        content = load_page()\r\n\r\n    soup = BeautifulSoup(content, 'html.parser')\r\n    entry = soup.find(\"div\", class_=\"entry-content\")\r\n    links = entry.find_all(\"a\")\r\n    result = []\r\n    for link in links:\r\n        # get text in the span/em inside a if href contains AMAZON\r\n        if AMAZON in link.get(\"href\"): \r\n            book_title = link.find({\"span\",\"em\"}).text.strip()\r\n            result.append(book_title)\r\n    count_books = Counter(result)\r\n    return sorted([ (title, count) for title, count in count_books.items() if count >= MIN_COUNT ] , \\\r\n            key=lambda tup: tup[1], reverse=True)\r\n\r\nprint(get_top_books())",
            "score": 3,
            "number_code_submits": 3,
            "tags": "beautifulsoup, Counter, default args, list comprehensions, requests",
            "in_paths": "Web Scraping"
        },
        {
            "bite": "Bite 128. Work with datetime's strptime and strftime",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-06 21:53:32.954083+00:00",
            "passing_code": "from datetime import datetime\r\n\r\nTHIS_YEAR = 2018\r\n\r\n\r\ndef years_ago(date):\r\n    \"\"\"Receives a date string of 'DD MMM, YYYY', for example: 8 Aug, 2015\r\n       Convert this date str to a datetime object (use strptime).\r\n       Then extract the year from the obtained datetime object and subtract\r\n       it from the THIS_YEAR constant above, returning the int difference.\r\n       So in this example you would get: 2018 - 2015 = 3\"\"\"\r\n    date = datetime.strptime(date, \"%d %b, %Y\")\r\n    return THIS_YEAR - date.year \r\ndef convert_eu_to_us_date(date):\r\n    \"\"\"Receives a date string in European format of dd/mm/yyyy, e.g. 11/03/2002\r\n       Convert it to an American date: mm/dd/yyyy (in this case 03/11/2002).\r\n       To enforce the use of datetime's strptime / strftime (over slicing)\r\n       the tests check if a ValueError is raised for invalid day/month/year\r\n       ranges (no need to code this, datetime does this out of the box)\"\"\"\r\n    date_obj = datetime.strptime(date, \"%d/%m/%Y\")\r\n    return date_obj.strftime(\"%m/%d/%Y\")\r\nprint(years_ago(\"1 Aug, 2012\"))",
            "score": 2,
            "number_code_submits": 5,
            "tags": "datetime, strftime, strptime",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 129. Analyze Stock Data",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-11 22:27:53.367761+00:00",
            "passing_code": "import requests\r\nfrom collections import Counter\r\n\r\nSTOCK_DATA = 'https://bites-data.s3.us-east-2.amazonaws.com/stocks.json'\r\n\r\n# pre-work: load JSON data into program\r\n\r\nwith requests.Session() as s:\r\n    data = s.get(STOCK_DATA).json()\r\n\r\n\r\n# your turn:\r\n\r\ndef _cap_str_to_mln_float(cap):\r\n    \"\"\"If cap = 'n/a' return 0, else:\r\n       - strip off leading '$',\r\n       - if 'M' in cap value, strip it off and return value as float,\r\n       - if 'B', strip it off, multiply by 1,000 and return\r\n         value as float\"\"\"\r\n    if cap == \"n/a\":\r\n        return 0.0\r\n    num=float(cap[1:-1])\r\n    if cap[-1].lower() == 'b':\r\n        num*=1000\r\n    return round(num,2)\r\n\r\n\r\ndef get_industry_cap(industry):\r\n    \"\"\"Return the sum of all cap values for given industry, use\r\n       the _cap_str_to_mln_float to parse the cap values,\r\n       return a float with 2 digit precision\"\"\"\r\n    result =sum(_cap_str_to_mln_float(item['cap']) for item in data if item['industry'] == industry)\r\n    return round(result,2)\r\n\r\n\r\ndef get_stock_symbol_with_highest_cap():\r\n    \"\"\"Return the stock symbol (e.g. PACD) with the highest cap, use\r\n       the _cap_str_to_mln_float to parse the cap values\"\"\"\r\n    symbol_and_cap_dict = dict((item['symbol'], _cap_str_to_mln_float(item['cap'])) for item in data )\r\n    # print(symbol_and_cap_dict)\r\n    return max(symbol_and_cap_dict, key=symbol_and_cap_dict.get)\r\n\r\n\r\ndef get_sectors_with_max_and_min_stocks():\r\n    \"\"\"Return a tuple of the sectors with most and least stocks,\r\n       discard n/a\"\"\"\r\n    sectors_sorted_per_size = Counter(item['sector'] for item in data if item['sector'] != \"n/a\").most_common()\r\n    return sectors_sorted_per_size[0][0], sectors_sorted_per_size[-1][0]\r\n\r\ntest = ['$1M', '$1B', 'n/a']\r\nfor item in test: \r\n    print(_cap_str_to_mln_float(item))\r\n    \r\nprint(get_industry_cap(\"Medical/Dental Instruments\"))\r\nprint(get_stock_symbol_with_highest_cap())\r\nprint(get_sectors_with_max_and_min_stocks())",
            "score": 3,
            "number_code_submits": 4,
            "tags": "counting, data analysis, json, requests, sorting, string manipulation",
            "in_paths": "Data Analysis, Data Formats, String Manipulation"
        },
        {
            "bite": "Bite 130. Analyze some basic Car Data",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-14 21:37:31.268332+00:00",
            "passing_code": "from collections import Counter\r\nfrom operator import itemgetter\r\n\r\nimport requests\r\n\r\nCAR_DATA = 'https://bites-data.s3.us-east-2.amazonaws.com/cars.json'\r\n\r\n# pre-work: load JSON data into program\r\n\r\nwith requests.Session() as s:\r\n    data = s.get(CAR_DATA).json()\r\n\r\n\r\n# your turn:\r\ndef most_prolific_automaker(year):\r\n    \"\"\"Given year 'year' return the automaker that released\r\n       the highest number of new car models\"\"\"\r\n    automakers_in_year = set([item['automaker'] for item in data if item['year'] == year])\r\n    models_per_automaker = [(automaker, len(get_models(automaker, year))) for automaker in automakers_in_year]\r\n    return max(models_per_automaker, key=itemgetter(1))[0]\r\n\r\n\r\ndef get_models(automaker, year):\r\n    \"\"\"Filter cars 'data' by 'automaker' and 'year',\r\n       return a set of models (a 'set' to avoid duplicate models)\"\"\"\r\n    filtered_list = [item['model'] for item in data if item['automaker'].lower() == automaker.lower() and item['year'] == year]\r\n    return set(filtered_list)\r\n\r\n\r\nprint(most_prolific_automaker(2013))",
            "score": 2,
            "number_code_submits": 3,
            "tags": "Counter, data analysis, list comprehensions, set",
            "in_paths": "Data Analysis, Data Formats"
        },
        {
            "bite": "Bite 131. Screen scraper",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-13 19:15:47.405226+00:00",
            "passing_code": "output = \"\"\"\r\n                                       mohh@SERENiTY\r\n MMMMMMMMMMMMMMMMMMMMMMMMMmds+.        OS: Mint 19 tara\r\n MMm----::-://////////////oymNMd+'     Kernel: x86_64 Linux 4.15.0-34-generic\r\n MMd      /++                -sNMd:    Uptime: 1d 4m\r\n MMNso/'  dMM    '.::-. .-::.' .hMN:   Packages: 2351\r\n ddddMMh  dMM   :hNMNMNhNMNMNh: 'NMm   Shell: zsh 5.4.2\r\n     NMm  dMM  .NMN/-+MMM+-/NMN' dMM   Resolution: 1366x768\r\n     NMm  dMM  -MMm  'MMM   dMM. dMM   DE: Cinnamon 3.8.9\r\n     NMm  dMM  -MMm  'MMM   dMM. dMM   WM: Muffin\r\n     NMm  dMM  .mmd  'mmm   yMM. dMM   WM Theme: Linux Mint (Mint-Y)\r\n     NMm  dMM'  ..'   ...   ydm. dMM   GTK Theme: Mint-Y [GTK2/3]\r\n     hMM- +MMd/-------...-:sdds  dMM   Icon Theme: Mint-Y\r\n     -NMm- :hNMNNNmdddddddddy/'  dMM   Font: Noto Sans 9\r\n      -dMNs-''-::::-------.''    dMM   CPU: AMD A10-7400P Radeon R6, 10 Compute Cores 4C+6G @ 4x 2.5GHz [101.0\u00b0C]\r\n       '/dMNmy+/:-------------:/yMMM   GPU: AMD KAVERI (DRM 2.50.0 / 4.15.0-34-generic, LLVM 6.0.0)\r\n          ./ydNMMMMMMMMMMMMMMMMMMMMM   RAM: 1886MiB / 6915MiB\r\n             \\.MMMMMMMMMMMMMMMMMMM    \r\n\"\"\"\r\n\r\ndef sysinfo_scrape(output):\r\n    \"\"\"Scrapes the output from screenfetch and returns a dictionary\"\"\"\r\n    lines=output.splitlines()\r\n    graph, name_raw = lines[1].rsplit(' ',1)\r\n    graph_width=len(graph)\r\n\r\n    result= {}\r\n    result['Name']=name_raw.strip()\r\n\r\n    for line in lines[2:]:\r\n        if line[graph_width:].strip():\r\n            key_raw, value_raw = line[graph_width:].split(':',1)\r\n            result[key_raw.strip()] = value_raw.strip()\r\n    return result\r\n\r\n# print(sysinfo_scrape(output))",
            "score": 4,
            "number_code_submits": 9,
            "tags": "dict, index, regular expressions, slicing, string manipulation",
            "in_paths": "String Manipulation"
        },
        {
            "bite": "Bite 132. Find the word with the most vowels",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-15 23:29:10.225935+00:00",
            "passing_code": "VOWELS = list(\"aeiou\")\r\n\r\n\r\ndef get_word_max_vowels(text):\r\n    \"\"\"Get the case insensitive word in text that has most vowels.\r\n       Return a tuple of the matching word and the vowel count, e.g.\r\n       ('object-oriented', 6)\"\"\"\r\n\r\n    tuples = [\r\n        (word, sum(c in VOWELS for c in word)) for word in text.casefold().split()\r\n    ]\r\n\r\n    return max(tuples, key=lambda x: x[1])\r\n\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    test_text = \"\"\"\r\n    Python is an easy to learn, powerful programming language. It has efficient high-level data structures\r\n    and a simple but effective approach to object-oriented programming. Python\u2019s elegant syntax and dynamic \r\n    typing, together with its interpreted nature, make it an ideal language for scripting and rapid \r\n    application development in many areas on most platforms.\r\n    \"\"\"\r\n\r\n    print(get_word_max_vowels(test_text))",
            "score": 3,
            "number_code_submits": 4,
            "tags": "counting, lambda, list comprehensions, string matching",
            "in_paths": ""
        },
        {
            "bite": "Bite 133. Convert an Amazon URL into an affiliation link",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-11 18:26:01.637377+00:00",
            "passing_code": "def generate_affiliation_link(url):\r\n    code = url.split(\"/dp/\")[1].split(\"/\")[0]\r\n    return f\"http://www.amazon.com/dp/{code}/?tag=pyb0f-20\"\r\n    \r\n\r\nif __name__ == \"__main__\":\r\n    links=\"\"\"https://www.amazon.com/War-Art-Through-Creative-Battles/dp/1936891026/?keywords=war+of+art\r\nhttps://amazon.com/War-Art-Through-Creative-Battles/dp/1936891026/ref=sr_1_1\r\nhttps://www.amazon.es/War-Art-Through-Creative-Battles/dp/1936891026/?qid=1537226234\r\nhttps://www.amazon.co.uk/Pragmatic-Programmer-Andrew-Hunt/dp/020161622X\r\nhttps://www.amazon.com.au/Python-Cookbook-3e-David-Beazley/dp/1449340377/\r\n\"\"\"\r\n    for url in links.splitlines():\r\n        print(generate_affiliation_link(url))",
            "score": 2,
            "number_code_submits": 2,
            "tags": "regular expressions, string manipulation",
            "in_paths": "Python Beginner, String Manipulation"
        },
        {
            "bite": "Bite 136. Bloodtypes",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-14 17:31:09.213464+00:00",
            "passing_code": "\"\"\"\r\nWrite a function which checks the red blood cell compatibility between donor and recipient.\r\nhttps://en.wikipedia.org/wiki/Blood_type#Red_blood_cell_compatibility\r\nFor simplicity, the appearance of 8 basic types of blood is considered.\r\nThe input of blood type can be in the form of:\r\n    pre defined Bloodtype enum e.g.: Bloodtype.ZERO_NEG\r\n    value of the pre-defined Bloodtype 0..7\r\n    pre defined text  e.g. \"0-\", \"B+\", \"AB+\", ...\r\n    If input value is not a required type TypeError is raised.\r\n    If input value is not in defined interval ValueError is raised.\r\nKeywords: enum, exception handling, multi type input\r\n\"\"\"\r\n\r\nfrom enum import Enum\r\n\r\n\r\nclass Bloodtype(Enum):\r\n    ZERO_NEG = 0\r\n    ZERO_POS = 1\r\n    B_NEG = 2\r\n    B_POS = 3\r\n    A_NEG = 4\r\n    A_POS = 5\r\n    AB_NEG = 6\r\n    AB_POS = 7\r\n\r\n\r\nblood_type_text = {\r\n    \"0-\": Bloodtype.ZERO_NEG,\r\n    \"0+\": Bloodtype.ZERO_POS,\r\n    \"B-\": Bloodtype.B_NEG,\r\n    \"B+\": Bloodtype.B_POS,\r\n    \"A-\": Bloodtype.A_NEG,\r\n    \"A+\": Bloodtype.A_POS,\r\n    \"AB-\": Bloodtype.AB_NEG,\r\n    \"AB+\": Bloodtype.AB_POS,\r\n}\r\n\r\n# complete :\r\ndef check_bt(donor, recipient):\r\n    \"\"\" Checks red blood cell compatibility based on 8 blood types\r\n        Args:\r\n        donor (int | str | Bloodtype): red blood cell type of the donor\r\n        recipient (int | str | Bloodtype): red blood cell type of the recipient\r\n        Returns:\r\n        bool: True for compatability, False otherwise.\r\n    \"\"\"\r\n    return all(antigen>=0 for antigen in _particular_antigen_comp(_validated(donor), _validated(recipient)))\r\n\r\n\r\ndef _validated(blood_type):\r\n    if isinstance(blood_type, Bloodtype):\r\n        return blood_type.value\r\n    if isinstance(blood_type, int):\r\n        if 0<= blood_type <=7:\r\n            return blood_type\r\n        else:\r\n            raise ValueError\r\n    if isinstance(blood_type, str):\r\n        if blood_type in blood_type_text:\r\n            return blood_type_text[blood_type].value\r\n        else:\r\n            raise ValueError\r\n    raise TypeError\r\n\r\n# hint\r\ndef _particular_antigen_comp(donor: int, recipient: int) -> tuple:\r\n    \"\"\"Returns a particalar antigen compatibility, where each tuple member\r\n    marks a compatibility for a particular antigen  (A, B, Rh-D).\r\n    If tuple member is non-negative there is a compatibility.\r\n    For red blood cell compatibility is required that \r\n    all tuple members are non-negative (i.e. compatibility for all 3 antigens).\r\n    0- bloodtype is represented as 0 ; AB+ is represented as 7; see Bloodtype enum\r\n    Examples:\r\n    _particular_antigen_comp(0, 7) -> (1, 1, 1)    0- can donate to AB+\r\n    _particular_antigen_comp(1, 3) -> (0, 1, 0)    0+ can donate to B+\r\n    _particular_antigen_comp(2, 5) -> (1, -1, 1)   B+ cannot donate to A+\r\n    _particular_antigen_comp(7, 0) -> (-1, -1, -1) AB+ cannot donate to 0-\r\n    \"\"\"\r\n    return (\r\n        ((recipient // 4) % 2) - ((donor // 4) % 2),\r\n        ((recipient // 2) % 2) - ((donor // 2) % 2),\r\n        (recipient % 2) - (donor % 2),\r\n    )\r\n    \r\nprint(check_bt(2, 5))",
            "score": 2,
            "number_code_submits": 9,
            "tags": "enum, exception handling, multi type input",
            "in_paths": ""
        },
        {
            "bite": "Bite 138. OOP fun at the Zoo",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-01 21:39:56.083862+00:00",
            "passing_code": "from pprint import pprint\r\n\r\nclass Animal:\r\n    sequence=10000\r\n    animals = []\r\n    \r\n    def __init__(self, name):\r\n        self.__class__.sequence +=1\r\n        self.id = self.__class__.sequence\r\n        self.name  = name.title()\r\n        self.__class__.animals.append(self)\r\n\r\n    def __str__(self):\r\n        return f\"{self.id}. {self.name}\"\r\n        \r\n    @classmethod\r\n    def zoo(cls):\r\n        return \"\\n\".join([str(item) for item in cls.animals])\r\n            ",
            "score": 3,
            "number_code_submits": 2,
            "tags": "classes, classmethod, itertools, __str__",
            "in_paths": "Object Oriented Programming"
        },
        {
            "bite": "Bite 139. Calculate a coding streak in days",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-14 17:58:27.024520+00:00",
            "passing_code": "from datetime import datetime, timedelta, date\r\n\r\nTODAY = date(2018, 11, 12)\r\n\r\n\r\ndef extract_dates(data):\r\n    \"\"\"Extract unique dates from DB table representation as shown in Bite\"\"\"\r\n    lines=data.strip().splitlines()\r\n    result=[]\r\n    for line in lines[3:-1]:\r\n        _,date_str,*_=line.split('|')\r\n        date_obj=datetime.strptime(date_str.strip(), \"%Y-%m-%d\").date()\r\n        result.append(date_obj)\r\n    return sorted(list(set(result)), reverse=True)\r\n\r\n\r\ndef calculate_streak(dates):\r\n    \"\"\"Receives sequence (set) of dates and returns number of days\r\n       on coding streak.\r\n\r\n       Note that a coding streak is defined as consecutive days coded\r\n       since yesterday, because today is not over yet, however if today\r\n       was coded, it counts too of course.\r\n\r\n       So as today is 12th of Nov, having dates 11th/10th/9th of Nov in\r\n       the table makes for a 3 days coding streak.\r\n\r\n       See the tests for more examples that will be used to pass your code.\r\n    \"\"\"\r\n    dates.insert(0, TODAY)\r\n    intervals= [(dates[n-1]-dates[n]).days for n in range(1,len(dates))]\r\n    streak_breaks= list(filter(lambda i: i> 1, intervals))\r\n    if streak_breaks:\r\n        return intervals.index(streak_breaks[0])\r\n    else:\r\n        return len(intervals)\r\n    \r\n\r\n    print(dates)\r\n    print(intervals)\r\n    \r\n\r\ndata = \"\"\"\r\n    +------------+------------+---------+\r\n    | date       | activity   | count   |\r\n    |------------+------------+---------|\r\n    | 2018-11-11 | pcc        | 1       |\r\n    | 2018-11-10 | 100d       | 1       |\r\n    | 2018-11-09 | 100d       | 2       |\r\n    | 2018-10-23 | pcc        | 1       |\r\n    | 2018-10-15 | pcc        | 1       |\r\n    | 2018-10-05 | bite       | 1       |\r\n    | 2018-09-21 | bite       | 4       |\r\n    | 2018-09-18 | bite       | 2       |\r\n    | 2018-09-18 | bite       | 4       |\r\n    +------------+------------+---------+\r\n\"\"\"\r\n\r\ndates=extract_dates(data)\r\nprint(dates)\r\nprint(calculate_streak(dates))\r\n",
            "score": 4,
            "number_code_submits": 5,
            "tags": "datetime, string manipulation, timedelta",
            "in_paths": "Datetimes and Timezones, String Manipulation"
        },
        {
            "bite": "Bite 141. Primitive date format inferrer",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-01 19:05:56.056461+00:00",
            "passing_code": "from enum import Enum\r\nfrom datetime import datetime\r\nfrom collections import Counter\r\nimport itertools\r\n\r\nclass DateFormat(Enum):\r\n    DDMMYY = 0  # dd/mm/yy\r\n    MMDDYY = 1  # mm/dd/yy\r\n    YYMMDD = 2  # yy/mm/dd\r\n    NONPARSABLE = -999\r\n\r\n\r\n    @classmethod\r\n    def get_d_parse_formats(cls, val=None):\r\n        \"\"\" Arg:\r\n        val(int | None) enum member value\r\n        Returns:\r\n        1. for val=None a list of explicit format strings \r\n            for all supported date formats in this enum\r\n        2. for val=n an explicit format string for a given enum member value\r\n        \"\"\"\r\n        d_parse_formats = [\"%d/%m/%y\", \"%m/%d/%y\", \"%y/%m/%d\"]\r\n        if val is None:\r\n            return d_parse_formats\r\n        if 0 <= val <= len(d_parse_formats):\r\n            return d_parse_formats[val]\r\n        raise ValueError\r\n\r\n\r\nclass InfDateFmtError(Exception):\r\n    \"\"\"custom exception when it is not possible to infer a date format\r\n    e.g. too many NONPARSABLE or a tie \"\"\"\r\n    pass\r\n\r\ndef _maybe_DateFormats(date_str):\r\n    \"\"\" Args:\r\n    date_str (str) string representing a date in unknown format\r\n    Returns:\r\n    a list of enum members, where each member represents\r\n    a possible date format for the input date_str\r\n    \"\"\"\r\n    d_parse_formats = DateFormat.get_d_parse_formats()\r\n    maybe_formats = []\r\n    for idx, d_parse_fmt in enumerate(d_parse_formats):\r\n        try:\r\n            _parsed_date = datetime.strptime(date_str, d_parse_fmt) # pylint: disable=W0612\r\n            maybe_formats.append(DateFormat(idx))\r\n        except ValueError:\r\n            pass\r\n    if len(maybe_formats) == 0:\r\n        maybe_formats.append(DateFormat.NONPARSABLE)\r\n    return maybe_formats\r\n\r\n\r\ndef get_dates(dates):\r\n    \"\"\" Args:\r\n    dates (list) list of date strings\r\n    where each list item represents a date in unknown format\r\n    Returns:\r\n    list of date strings, where each list item represents\r\n    a date in yyyy-mm-dd format. Date format of input date strings is\r\n    inferred based on the most prevalent format in the dates list.\r\n    Allowed/supported date formats are defined in a DF enum class.\r\n    \"\"\"\r\n    # complete this method\r\n\r\n    lst_of_guesses = [_maybe_DateFormats(date) for date in dates]\r\n    most_probable_formats = Counter(itertools.chain.from_iterable(lst_of_guesses)).most_common()\r\n\r\n    # dates are non parsable-> raise exception\r\n    if most_probable_formats[0][0] == DateFormat.NONPARSABLE:\r\n        raise InfDateFmtError\r\n    \r\n    # there are two most frequent formats with the same frequency -> raise exception\r\n    if len(most_probable_formats)>1 and most_probable_formats[0][1]== most_probable_formats[1][1]:\r\n        raise InfDateFmtError\r\n        \r\n    format_str = DateFormat.get_d_parse_formats(most_probable_formats[0][0].value)\r\n    \r\n    result=[]\r\n    for date in dates:\r\n        try:\r\n            result.append(datetime.strftime(datetime.strptime(date,format_str),'%Y-%m-%d'))\r\n        except:\r\n            result.append('Invalid')\r\n    return result\r\n\r\ntest_dates=['11/12/23','23/01/75', '09/04/75', '01/12/22','99/99/99']\r\n\r\nprint(get_dates(test_dates))",
            "score": 3,
            "number_code_submits": 4,
            "tags": "classmethod, datetime, enum, exception handling",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 143. Look up a value in 3 dictionaries",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-15 20:03:12.695925+00:00",
            "passing_code": "NOT_FOUND = \"Not found\"\r\n\r\ngroup1 = {'tim': 30, 'bob': 17, 'ana': 24}\r\ngroup2 = {'ana': 26, 'thomas': 64, 'helen': 26}\r\ngroup3 = {'brenda': 17, 'otto': 44, 'thomas': 46}\r\n\r\n\r\ndef get_person_age(name):\r\n    \"\"\"Look up name (case insensitive search) and return age.\r\n       If name in > 1 dict, return the match of the group with\r\n       greatest N (so group3 > group2 > group1)\r\n    \"\"\"\r\n    if isinstance(name,str):\r\n        for group in [group3, group2, group1]:\r\n            if name.lower() in group:\r\n                return group[name.lower()]    \r\n    return NOT_FOUND\r\n",
            "score": 2,
            "number_code_submits": 5,
            "tags": "collections, dict",
            "in_paths": "Python Beginner"
        },
        {
            "bite": "Bite 144. Calculate the Number of Months Passed",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-25 00:04:45.810004+00:00",
            "passing_code": "from datetime import date\r\n\r\nfrom dateutil.relativedelta import relativedelta\r\n\r\nSTART_DATE = date(2018, 11, 1)\r\nMIN_DAYS_TO_COUNT_AS_MONTH = 10\r\nMONTHS_PER_YEAR = 12\r\n\r\n\r\ndef calc_months_passed(year, month, day):\r\n    \"\"\"Construct a date object from the passed in arguments.\r\n       If this fails due to bad inputs reraise the exception.\r\n       Also if the new date is < START_DATE raise a ValueError.\r\n\r\n       Then calculate how many months have passed since the\r\n       START_DATE constant. We suggest using dateutil.relativedelta!\r\n\r\n       One rule: if a new month is >= 10 (MIN_DAYS_TO_COUNT_AS_MONTH)\r\n       days in, it counts as an extra  month.\r\n\r\n       For example:\r\n       date(2018, 11, 10) = 9 days in => 0 months\r\n       date(2018, 11, 11) = 10 days in => 1 month\r\n       date(2018, 12, 11) = 1 month + 10 days in => 2 months\r\n       date(2019, 12, 11) = 1 year + 1 month + 10 days in => 14 months\r\n       etc.\r\n\r\n       See the tests for more examples.\r\n\r\n       Return the number of months passed int.\r\n    \"\"\"\r\n    try:\r\n        my_date=date(year,month,day)\r\n    except (TypeError, ValueError) as error:\r\n        raise error\r\n    \r\n    if my_date <START_DATE:\r\n        raise ValueError\r\n        \r\n    time_passed=relativedelta(my_date,START_DATE)\r\n    print(time_passed)\r\n    return time_passed.years*12 + time_passed.months + (1 if time_passed.days >= 10 else 0)\r\n    ",
            "score": 3,
            "number_code_submits": 4,
            "tags": "datetime, dateutil, exception handling",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 145. Record Breakers",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "csv, data analysis, pandas",
            "in_paths": "Data Analysis"
        },
        {
            "bite": "Bite 147. 100 WEEKDays of Code Date Range",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-01 18:08:22.130222+00:00",
            "passing_code": "from datetime import date\r\n\r\nimport dateutil.rrule as RR\r\n\r\nTODAY = date(year=2018, month=11, day=29)\r\nWEEKDAYS=[RR.MO,RR.TU,RR.WE,RR.TH, RR.FR]\r\n\r\ndef get_hundred_weekdays(start_date=TODAY):\r\n    \"\"\"Return a list of hundred date objects starting from\r\n       start_date up till 100 weekdays later, so +100 days\r\n       skipping Saturdays and Sundays\"\"\"\r\n    \r\n    return [d.date() for d in RR.rrule(freq=RR.DAILY, count=100, dtstart=start_date, byweekday=WEEKDAYS)]\r\n\r\n\r\nprint(get_hundred_weekdays(start_date=date.today()))",
            "score": 3,
            "number_code_submits": 4,
            "tags": "datetime, dateutil",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 148. Print Car Data Grouped by Manufacturer",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-19 12:16:57.576300+00:00",
            "passing_code": "from itertools import groupby\r\n\r\ncars = [\r\n    # need mock data? -> https://www.mockaroo.com == awesome\r\n    ('Mercedes-Benz', '300D'), ('Mercedes-Benz', '600SEL'),\r\n    ('Toyota', 'Avalon'), ('Ford', 'Bronco'),\r\n    ('Chevrolet', 'Cavalier'), ('Chevrolet', 'Corvette'),\r\n    ('Mercedes-Benz', 'E-Class'), ('Hyundai', 'Elantra'),\r\n    ('Volkswagen', 'GTI'), ('Toyota', 'Highlander'),\r\n    ('Chevrolet', 'Impala'), ('Nissan', 'Maxima'),\r\n    ('Ford', 'Mustang'), ('Kia', 'Optima'),\r\n    ('Volkswagen', 'Passat'), ('Nissan', 'Pathfinder'),\r\n    ('Volkswagen', 'Routan'), ('Hyundai', 'Sonata'),\r\n    ('Kia', 'Sorento'), ('Kia', 'Sportage'),\r\n    ('Ford', 'Taurus'), ('Nissan', 'Titan'),\r\n    ('Toyota', 'Tundra'), ('Hyundai', 'Veracruz'),\r\n]\r\n\r\n\r\ndef group_cars_by_manufacturer(cars):\r\n    \"\"\"Iterate though the list of (manufacturer, model) tuples\r\n       of the cars list defined above and generate the output as described\r\n       in the Bite description (see the tests for the full output).\r\n       \r\n       No return here, just print to the console. We use pytest > capfd to\r\n       validate your output :)\r\n    \"\"\"\r\n    for key, group in groupby(sorted(cars), lambda x: x[0]):\r\n        print(key.upper())\r\n        for car in group:\r\n            print(f\"- {car[1]}\")\r\n        print(\"\")        \r\n\r\ngroup_cars_by_manufacturer(cars)",
            "score": 3,
            "number_code_submits": 3,
            "tags": "data structures, itertools, operator, sorting",
            "in_paths": "Itertools"
        },
        {
            "bite": "Bite 149. Sorting words with constraint",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-16 08:51:55.021390+00:00",
            "passing_code": "import string\r\n\r\ndef sort_words_case_insensitively(words):\r\n    \"\"\"Sort the provided word list ignoring case, and numbers last\r\n       (1995, 19ab = numbers / Happy, happy4you = strings, hence for\r\n        numbers you only need to check the first char of the word)\r\n    \"\"\"\r\n    numbers=sorted([word for word in words if word[0] in string.digits], key=str.casefold)\r\n    return sorted([word for word in words if word not in numbers], key=str.casefold)+numbers\r\n    \r\nwords = \"It's almost Holidays and PyBites wishes You a Merry Christmas and a Happy 2019\".split()\r\n\r\nprint(sort_words_case_insensitively(words))",
            "score": 2,
            "number_code_submits": 3,
            "tags": "lambda, sorting, string manipulation",
            "in_paths": "Python Beginner"
        },
        {
            "bite": "Bite 150. Turn messy CSV into JSON",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-11 22:51:28.105432+00:00",
            "passing_code": "import json\r\nimport re\r\nfrom pprint import pprint\r\n\r\nmembers = \"\"\"\r\nid,first_name,last_name,email\r\n1,Junie,Kybert;jkybert0@army.mil\r\n2,Sid,Churching|schurching1@tumblr.com\r\n3,Cherry;Dudbridge,cdudbridge2@nifty.com\r\n4,Merrilee,Kleiser;mkleiser3@reference.com\r\n5,Umeko,Cray;ucray4@foxnews.com\r\n6,Jenifer,Dale|jdale@hubpages.com\r\n7,Deeanne;Gabbett,dgabbett6@ucoz.com\r\n8,Hymie,Valentin;hvalentin7@blogs.com\r\n9,Alphonso,Berwick|aberwick8@symantec.com\r\n10,Wyn;Serginson,wserginson9@naver.com\r\n\"\"\"\r\n\r\n\r\ndef convert_to_json(members=members):\r\n    \r\n    data=[]\r\n    for i,line in enumerate(members.lstrip().splitlines()):\r\n        words = re.split('[,;|]',line)\r\n        if i==0:\r\n            headers=words\r\n        else:\r\n            item=dict((key,value) for key, value in zip(headers,words))\r\n            data.append(item)\r\n    \r\n    return json.dumps(data, indent=4)\r\n\r\npprint(convert_to_json())",
            "score": 3,
            "number_code_submits": 3,
            "tags": "csv, json, pandas, re, string manipulation",
            "in_paths": "Data Formats, String Manipulation"
        },
        {
            "bite": "Bite 151. Contemporary Composers",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-03 15:41:29.088223+00:00",
            "passing_code": "from collections import namedtuple\r\nfrom datetime import datetime\r\n\r\nComposer = namedtuple('Composer', 'name born died')\r\nOpera = namedtuple('Opera', 'author play date')\r\n\r\ncomposers = {\r\n    \"beethoven\": Composer(\"Ludwig van Beethoven\",\r\n                          \"17 December 1770\", \"26 March 1827\"),\r\n    \"wagner\": Composer(\"Richard Wagner\",\r\n                       \"22 May 1813\", \"13 February 1883\"),\r\n    \"verdi\": Composer(\"Giuseppe Verdi\",\r\n                      \"9 October 1813\", \"27 January 1901\"),\r\n    \"mozart\": Composer(\"Wolfgang Amadeus Mozart\",\r\n                       \"27 January 1756\", \"5 December 1791\"),\r\n}\r\n\r\noperas = [\r\n    Opera(\"mozart\", \"Apollo and Hyacinth\", \"13 May 1767\"),\r\n    Opera(\"mozart\", \"Marriage of Figaro\", \"1 May 1786\"),\r\n    Opera(\"mozart\", \"Don Giovanni\", \"29 October 1787\"),\r\n    Opera(\"mozart\", \"Cos\u00ec fan tutte\", \"6 January 1790\"),\r\n    Opera(\"mozart\", \"The Clemency of Titus\", \"6 September 1791\"),\r\n    Opera(\"mozart\", \"The Magic Flute\", \"30 September 1791\"),\r\n    Opera(\"wagner\", \"The Fairies\", \"29 June 1888\"),\r\n    Opera(\"wagner\", \"Rienzi\", \"20 October 1842\"),\r\n    Opera(\"wagner\", \"The Flying Dutchman\", \"2 January 1843\"),\r\n    Opera(\"wagner\", \"Tannh\u00e4user\", \"19 October 1845\"),\r\n    Opera(\"wagner\", \"Lohengrin\", \"28 August 1850\"),\r\n    Opera(\"wagner\", \"The Rhinegold\", \"22 September 1869\"),\r\n    Opera(\"wagner\", \"The Valkyrie\", \"26 June 1870\"),\r\n    Opera(\"wagner\", \"Siegfried\", \"16 August 1876\"),\r\n    Opera(\"wagner\", \"Twilight of the Gods\", \"17 August 1876\"),\r\n    Opera(\"wagner\", \"Tristan and Isolde\", \"10 June 1865\"),\r\n    Opera(\"wagner\", \"The Master-Singers of Nuremberg\", \"21 June 1868\"),\r\n    Opera(\"wagner\", \"Parsifal\", \"26 July 1882\"),\r\n    Opera(\"beethoven\", \"Fidelio\", \"20 November 1805\"),\r\n    Opera(\"verdi\", \"Nabucco\", \"9 March 1842\"),\r\n    Opera(\"verdi\", \"Ernani\", \"9 March 1844\"),\r\n    Opera(\"verdi\", \"Macbeth\", \"14 March 1847\"),\r\n    Opera(\"verdi\", \"Il corsaro\", \"25 October 1848\"),\r\n    Opera(\"verdi\", \"Rigoletto\", \"11 March 1851\"),\r\n    Opera(\"verdi\", \"La traviata\", \"6 March 1853\"),\r\n    Opera(\"verdi\", \"Aroldo\", \"16 August 1857\"),\r\n    Opera(\"verdi\", \"Macbeth\", \"21 April 1865\"),\r\n    Opera(\"verdi\", \"Don Carlos\", \"11 March 1867\"),\r\n    Opera(\"verdi\", \"Aida\", \"24 December 1871\"),\r\n    Opera(\"verdi\", \"Otello\", \"5 February 1887\"),\r\n    Opera(\"verdi\", \"Falstaff\", \"9 February 1893\"),\r\n]\r\n\r\n\r\ndef _get_date(date_str):\r\n    return datetime.date(datetime.strptime(date_str, \"%d %B %Y\"))\r\n\r\n\r\ndef operas_both_at_premiere(guest, composer):\r\n    \"\"\"Retrieves a list of titles of operas, where the guest and the composer\r\n       could have been together at premiere.\r\n\r\n       That is the Opera.author matches the composer passed in, and both guest\r\n       and composer are alive at the time of Opera.date.\r\n\r\n       If guest and/or composer are not in the composers dict, raise a\r\n       ValueError\r\n\r\n       Args:\r\n       guest (str): one of the composers but not the author of an opera\r\n       composer (str): the author of an opera\r\n\r\n       Returns a list (or generator) of titles of operas.\r\n    \"\"\"\r\n    try:\r\n        _guest = composers[guest]\r\n        _composer = composers[composer]\r\n    except KeyError:\r\n        raise ValueError(f'Input not in composers list')\r\n\r\n    start = max(_get_date(_guest.born), _get_date(_composer.born))\r\n    end = min(_get_date(_guest.died), _get_date(_composer.died))\r\n    \r\n    if start > end:\r\n        return []\r\n\r\n    return [opera.play for opera in operas if start < _get_date(opera.date) < end and opera.author == composer]\r\n    \r\n\r\nprint(operas_both_at_premiere('verdi','wagner'))",
            "score": 3,
            "number_code_submits": 5,
            "tags": "datetime, dict, exception handling, generators, namedtuple",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 153. Round a sequence of numbers",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-17 21:02:17.109275+00:00",
            "passing_code": "import math\r\n\r\ndef round_up_or_down(transactions, up=True):\r\n    \"\"\"Round the list of transactions passed in.\r\n       If up=True (default) round up, else round down.\r\n       Return a new list of rounded values\r\n    \"\"\"\r\n    func=math.ceil if up else math.floor\r\n    return list(func(item) for item in transactions)\r\n    \r\n\r\n# t1 = [2.05, 3.55, 4.50, 10.76, 100.25]\r\n# print(round_up_or_down(t1, False))",
            "score": 2,
            "number_code_submits": 2,
            "tags": "list comprehensions, math, rounding",
            "in_paths": ""
        },
        {
            "bite": "Bite 154. Write your own Data Class",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-08 09:39:39.647505+00:00",
            "passing_code": "from dataclasses import dataclass\r\n\r\n@dataclass(order=True)\r\nclass Bite:\r\n    \"\"\"Class for describing PyBites.\"\"\"\r\n    number: int\r\n    title: str\r\n    level: str = \"Beginner\"\r\n\r\n    def __post_init__(self):\r\n        self.title = self.title.capitalize()\r\n",
            "score": 3,
            "number_code_submits": 3,
            "tags": "dataclasses, data structures, hashable, sorting, type hinting",
            "in_paths": "Object Oriented Programming"
        },
        {
            "bite": "Bite 155. Split a string by spaces or quoted text",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-13 17:53:54.890244+00:00",
            "passing_code": "import re\r\ndef split_words_and_quoted_text(text):\r\n    \"\"\"Split string text by space unless it is\r\n       wrapped inside double quotes, returning a list\r\n       of the elements.\r\n\r\n       For example\r\n       if text =\r\n       'Should give \"3 elements only\"'\r\n\r\n       the resulting list would be:\r\n       ['Should', 'give', '3 elements only']\r\n    \"\"\"\r\n    matches = re.findall('\"(.+?)\"|([\\w-]+)', text)\r\n    return [\"\".join(item) for item in matches]\r\n\r\n\r\ntext = 'Should give \"3 elements only\"'\r\n       \r\nprint(split_words_and_quoted_text(text))",
            "score": 3,
            "number_code_submits": 2,
            "tags": "split, string manipulation",
            "in_paths": "String Manipulation"
        },
        {
            "bite": "Bite 156. Make an index of story characters",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-12 12:57:41.088171+00:00",
            "passing_code": "import re \r\nfrom collections import defaultdict\r\n\r\nCHARACTERS = ['Red Riding Hood',\r\n              # we're omitting 'mother' here for simplicity\r\n              #\u00a0(= substring grandmother)\r\n              ('Grandmother', 'Grandma', 'Granny'),\r\n              'wolf', 'woodsman']\r\n\r\ntext = \"\"\"\r\nOnce upon a time, there was a little girl who lived in a village near the forest.  Whenever she went out, the little girl wore a red riding cloak, so everyone in the village called her Little Red Riding Hood.\r\nOne morning, Little Red Riding Hood asked her mother if she could go to visit her grandmother as it had been awhile since they'd seen each other.\r\n\"That's a good idea,\" her mother said.  So they packed a nice basket for Little Red Riding Hood to take to her grandmother.\r\nWhen the basket was ready, the little girl put on her red cloak and kissed her mother goodbye.\r\n\"Remember, go straight to Grandma's house,\" her mother cautioned.  \"Don't dawdle along the way and please don't talk to strangers!  The woods are dangerous.\"\r\n\"Don't worry, mommy,\" said Little Red Riding Hood, \"I'll be careful.\"\r\nBut when Little Red Riding Hood noticed some lovely flowers in the woods, she forgot her promise to her mother.  She picked a few, watched the butterflies flit about for awhile, listened to the frogs croaking and then picked a few more.\r\nLittle Red Riding Hood was enjoying the warm summer day so much, that she didn't notice a dark shadow approaching out of the forest behind her...\r\nSuddenly, the wolf appeared beside her.\r\n\"What are you doing out here, little girl?\" the wolf asked in a voice as friendly as he could muster.\r\n\"I'm on my way to see my Grandma who lives through the forest, near the brook,\"  Little Red Riding Hood replied.\r\nThen she realized how late she was and quickly excused herself, rushing down the path to her Grandma's house.\r\nThe wolf, in the meantime, took a shortcut...\r\nThe wolf, a little out of breath from running, arrived at Grandma's and knocked lightly at the door.\r\n\"Oh thank goodness dear!  Come in, come in!  I was worried sick that something had happened to you in the forest,\" said Grandma thinking that the knock was her granddaughter.\r\nThe wolf let himself in.  Poor Granny did not have time to say another word, before the wolf gobbled her up!\r\nThe wolf let out a satisfied burp, and then poked through Granny's wardrobe to find a nightgown that he liked.  He added a frilly sleeping cap, and for good measure, dabbed some of Granny's perfume behind his pointy ears.\r\nA few minutes later, Red Riding Hood knocked on the door.  The wolf jumped into bed and pulled the covers over his nose.  \"Who is it?\" he called in a cackly voice.\r\n\"It's me, Little Red Riding Hood.\"\r\n\"Oh how lovely!  Do come in, my dear,\" croaked the wolf.\r\nWhen Little Red Riding Hood entered the little cottage, she could scarcely recognize her Grandmother.\r\n\"Grandmother!  Your voice sounds so odd.  Is something the matter?\" she asked.\r\n\"Oh, I just have touch of a cold,\" squeaked the wolf adding a cough at the end to prove the point.\r\n\"But Grandmother!  What big ears you have,\" said Little Red Riding Hood as she edged closer to the bed.\r\n\"The better to hear you with, my dear,\" replied the wolf.\r\n\"But Grandmother!  What big eyes you have,\" said Little Red Riding Hood.\r\n\"The better to see you with, my dear,\" replied the wolf.\r\n\"But Grandmother!  What big teeth you have,\" said Little Red Riding Hood her voice quivering slightly.\r\n\"The better to eat you with, my dear,\" roared the wolf and he leapt out of the bed and began to chase the little girl.\r\nAlmost too late, Little Red Riding Hood realized that the person in the bed was not her Grandmother, but a hungry wolf.\r\nShe ran across the room and through the door, shouting, \"Help!  Wolf!\" as loudly as she could.\r\nA woodsman who was chopping logs nearby heard her cry and ran towards the cottage as fast as he could.\r\nHe grabbed the wolf and made him spit out the poor Grandmother who was a bit frazzled by the whole experience, but still in one piece.\"Oh Grandma, I was so scared!\"  sobbed Little Red Riding Hood, \"I'll never speak to strangers or dawdle in the forest again.\"\r\n\"There, there, child.  You've learned an important lesson.  Thank goodness you shouted loud enough for this kind woodsman to hear you!\"\r\nThe woodsman knocked out the wolf and carried him deep into the forest where he wouldn't bother people any longer.\r\nLittle Red Riding Hood and her Grandmother had a nice lunch and a long chat.\r\n\"\"\"\r\n\r\n\r\ndef _is_char_in_text(line, character):\r\n\r\n    line = line.lower()\r\n\r\n    if isinstance(character, str):\r\n        character = character,\r\n    return any([synonym.lower() in line for synonym in character])\r\n\r\n\r\ndef _label(character):\r\n    \r\n    if isinstance(character, tuple):\r\n        character= character[0]\r\n    return character.lower()\r\n\r\ndef make_character_index(text=text, characters=CHARACTERS):\r\n    \"\"\"Return a dict with keys are characters (lowercased) and values\r\n       the lines they appear in sorted order.\r\n       Matches should be case insensitive.\r\n       If a character has multiple synonyms\r\n       - e.g. ('Grandmother', 'Grandma', 'Granny') -\r\n       then return the former as key.\r\n    \"\"\"\r\n    result=defaultdict(list)\r\n    for idx,line in enumerate(text.splitlines()):\r\n        # print(line)\r\n        for character in characters:\r\n            if _is_char_in_text(line, character):\r\n                result[_label(character)].append(idx)\r\n\r\n    return result \r\n\r\n\r\n# print(make_character_index())\r\n",
            "score": 3,
            "number_code_submits": 5,
            "tags": "collections, defaultdict, enumerate, sorting, string matching",
            "in_paths": "Collections Module"
        },
        {
            "bite": "Bite 157. Filter out accented characters",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-15 18:15:38.361450+00:00",
            "passing_code": "import unicodedata \r\nimport string\r\n\r\ndef filter_accents(text):\r\n    \"\"\"Return a sequence of accented characters found in\r\n       the passed in lowercased text string\r\n    \"\"\"\r\n    all_accented_chars= [c for c in text.lower() if unicodedata.category(c)=='Ll' and c not in string.ascii_lowercase]\r\n    return sorted(list(set(all_accented_chars)))\r\ntxt= (\"The 5 French accents;\"\r\n     \"The c\u00e9dille (cedilla) \u00c7 ...\"\r\n     \"The accent aigu (acute accent) \u00e9 ...\"\r\n     \"The accent circonflexe (circumflex) \u00e2, \u00ea, \u00ee, \u00f4, \u00fb ...\"\r\n     \"The accent grave (grave accent) \u00e0, \u00e8, \u00f9 ...\"\r\n     \"The accent tr\u00e9ma (dieresis/umlaut) \u00eb, \u00ef, \u00fc\")\r\n\r\n\r\nprint(filter_accents(txt))\r\n\r\n#    ['\u00e1', '\u00e9', '\u00ed', '\u00f1'],\r\n#    ['\u00e0', '\u00e2', '\u00e7', '\u00e8', '\u00e9', '\u00ea', '\u00eb', '\u00ee', '\u00ef', '\u00f4', '\u00f9', '\u00fb', '\u00fc'],\r\n",
            "score": 3,
            "number_code_submits": 4,
            "tags": "string matching, unicode",
            "in_paths": "String Manipulation"
        },
        {
            "bite": "Bite 160. 15-way Rock Paper Scissors",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-04 20:52:37.281476+00:00",
            "passing_code": "import csv\r\nimport os\r\nfrom urllib.request import urlretrieve\r\n\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nDATA = 'battle-table.csv'\r\nBATTLE_DATA = os.path.join(TMP, DATA)\r\nif not os.path.isfile(BATTLE_DATA):\r\n    urlretrieve(\r\n        f'https://bites-data.s3.us-east-2.amazonaws.com/{DATA}',\r\n        BATTLE_DATA\r\n    )\r\n\r\n\r\n\r\ndef _create_defeat_mapping():\r\n    \"\"\"Parse battle-table.csv building up a defeat_mapping dict\r\n       with keys = attackers / values = who they defeat.\r\n    \"\"\"\r\n    with open(BATTLE_DATA) as f:\r\n        reader = csv.DictReader(f)\r\n        headers = reader.fieldnames\r\n        defeat_mapping = {}\r\n        for i,row in enumerate(reader):\r\n            gesture = row['Attacker']\r\n            defeats_lst = [key for key,val in row.items() if val =='win']\r\n            defeat_mapping[gesture]=defeats_lst\r\n        return defeat_mapping\r\n\r\n\r\ndef get_winner(player1, player2, defeat_mapping=None):\r\n    \"\"\"Given player1 and player2 determine game output returning the\r\n       appropriate string:\r\n       Tie\r\n       Player1\r\n       Player2\r\n       (where Player1 and Player2 are the names passed in)\r\n\r\n       Raise a ValueError if invalid player strings are passed in.\r\n    \"\"\"\r\n    defeat_mapping = defeat_mapping or _create_defeat_mapping()\r\n    # ...\r\n    if player1 not in defeat_mapping or player2 not in defeat_mapping:\r\n        raise ValueError('Invalid gesture')\r\n    if player1 ==player2:\r\n        return 'Tie'\r\n    if player2 in defeat_mapping[player1]:\r\n        return player1\r\n    if player1 in defeat_mapping[player2]:\r\n        return player2\r\n",
            "score": 4,
            "number_code_submits": 2,
            "tags": "csv, dict, exception handling, games",
            "in_paths": "Data Formats"
        },
        {
            "bite": "Bite 161. Count the number of files and directories",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-18 13:09:28.123032+00:00",
            "passing_code": "import os\r\n\r\n\r\ndef count_dirs_and_files(directory='.'):\r\n    \"\"\"Count the amount of of directories and files in passed in \"directory\" arg.\r\n       Return a tuple of (number_of_directories, number_of_files)\r\n    \"\"\"\r\n    contents = list(os.walk(directory, topdown=True))\r\n    return len(contents)-1, sum(len(item[2]) for item in contents)\r\n",
            "score": 2,
            "number_code_submits": 2,
            "tags": "counting, directories, files, os module",
            "in_paths": ""
        },
        {
            "bite": "Bite 165. Parse an /etc/passwd file output",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-19 21:17:14.655629+00:00",
            "passing_code": "from typing import List\r\nimport re\r\n\r\nDEFAULT_SHELL = 'bash'\r\n# https://github.com/avar/git-anyonecanedit-etc/blob/master/passwd\r\nPASSWD_OUTPUT = \"\"\"root:x:0:0:root:/root:/bin/bash\r\ndaemon:x:1:1:daemon:/usr/sbin:/bin/sh\r\nbin:x:2:2:bin:/bin:/bin/sh\r\nsys:x:3:3:sys:/dev:/bin/sh\r\nsync:x:4:65534:sync:/bin:/bin/sync\r\ngames:x:5:60:games:/usr/games:/bin/sh\r\nman:x:6:12:man:/var/cache/man:/bin/sh\r\nlp:x:7:7:lp:/var/spool/lpd:/bin/sh\r\nmail:x:8:8:mail:/var/mail:/bin/sh\r\nnews:x:9:9:news:/var/spool/news:/bin/sh\r\nuucp:x:10:10:uucp:/var/spool/uucp:/bin/sh\r\nproxy:x:13:13:proxy:/bin:/bin/sh\r\nwww-data:x:33:33:www-data:/var/www:/bin/sh\r\nbackup:x:34:34:backup:/var/backups:/bin/sh\r\nlist:x:38:38:Mailing List Manager:/var/list:/bin/sh\r\nirc:x:39:39:ircd:/var/run/ircd:/bin/sh\r\ngnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/sh\r\nnobody:x:65534:65534:nobody:/nonexistent:/bin/sh\r\nlibuuid:x:100:101::/var/lib/libuuid:/bin/sh\r\nDebian-exim:x:101:103::/var/spool/exim4:/bin/false\r\nstatd:x:102:65534::/var/lib/nfs:/bin/false\r\nsshd:x:103:65534::/var/run/sshd:/usr/sbin/nologin\r\nftp:x:104:65534::/home/ftp:/bin/false\r\nmessagebus:x:105:106::/var/run/dbus:/bin/false\r\nmysql:x:106:107:MySQL Server,,,:/var/lib/mysql:/bin/false\r\navar:x:1000:1000::/home/avar:/bin/bash\r\nchad:x:1001:1001::/home/chad:/bin/bash\r\ngit-svn-mirror:x:1002:1002:Git mirror,,,:/home/git-svn-mirror:/bin/bash\r\ngerrit2:x:1003:1003:Gerrit User,,,:/home/gerrit2:/bin/bash\r\navahi:x:107:108:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/bin/false\r\npostfix:x:108:112::/var/spool/postfix:/bin/false\r\nssh-rsa:x:1004:1004::/home/ssh-rsa:/bin/bash\r\nartagnon:x:1005:1005:Ramkumar R,,,,Git GSOC:/home/artagnon:/bin/bash\"\"\"\r\n\r\n\r\ndef get_users_for_shell(passwd_output: str = PASSWD_OUTPUT,\r\n                        grep_shell: str = DEFAULT_SHELL) -> List[str]:\r\n    \"\"\"Match the passwd_output string for users with grep_shell.\r\n       Return a list of users.\r\n    \"\"\"\r\n    lst = []\r\n    for line in passwd_output.splitlines():\r\n        usr, rest = line.split(\":\",1)\r\n        if re.search(f\"/bin/{grep_shell}\",rest):\r\n            lst.append(usr)\r\n    return lst\r\n        \r\n# print(get_users_for_shell())\r\n",
            "score": 2,
            "number_code_submits": 5,
            "tags": "split, string manipulation, tuple unpacking",
            "in_paths": "String Manipulation"
        },
        {
            "bite": "Bite 166. Complete a tox ini file parser class",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-15 20:31:46.313661+00:00",
            "passing_code": "import configparser\r\nimport re\r\n\r\nclass ToxIniParser:\r\n\r\n    def __init__(self, ini_file):\r\n        \"\"\"Use configparser to load ini_file into self.config\"\"\"\r\n        self.config = configparser.ConfigParser()\r\n        self.config.read(ini_file)\r\n\r\n    @property\r\n    def number_of_sections(self):\r\n        \"\"\"Return the number of sections in the ini file.\r\n           New to properties? -> https://pybit.es/property-decorator.html\r\n        \"\"\"\r\n        return len(self.config.sections())\r\n\r\n    @property\r\n    def environments(self):\r\n        \"\"\"Return a list of environments\r\n           (= \"envlist\" attribute of [tox] section)\"\"\"\r\n        envlist_raw = self.config['tox']['envlist']\r\n        return [item.strip() for item in re.split('\\n|,',envlist_raw) if item.strip()]\r\n        \r\n    @property\r\n    def base_python_versions(self):\r\n        \"\"\"Return a list of all basepython across the ini file\"\"\"\r\n        basepython_raw = [self.config[section].get('basepython') for section in self.config.sections()]\r\n        return list(set(item for item in basepython_raw if item)) \r\n    \r\n\r\nsample_ini_file = django = \"\"\"[tox]\r\nenvlist = py27, py34, py35, py36, pypy, flake8\r\n\r\n[testenv]\r\npassenv = LC_ALL, LANG, HOME\r\ncommands = pytest --cov=cookiecutter {posargs:tests}\r\ndeps = -rtest_requirements.txt\r\n\r\n[testenv:flake8]\r\ndeps =\r\n    flake8==3.5.0\r\ncommands =\r\n    flake8 cookiecutter tests setup.py\r\n\r\n[testenv:cov-report]\r\ncommands = pytest --cov=cookiecutter --cov-report=term --cov-report=html\"\"\"\r\n    \r\n    \r\nfilename = \"/tmp/test_file.ini\"\r\nwith open(filename,'w') as f:\r\n    f.write(sample_ini_file)\r\n\r\n\r\n\r\ntox = ToxIniParser(filename)\r\nprint(tox.number_of_sections)\r\nprint(tox.environments)\r\nprint(tox.base_python_versions)\r\n",
            "score": 3,
            "number_code_submits": 7,
            "tags": "classes, configparser, properties, string matching, string parsing, tox",
            "in_paths": "Object Oriented Programming, String Manipulation"
        },
        {
            "bite": "Bite 167. Complete a User class: properties and representation dunder methods",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-18 11:52:26.672323+00:00",
            "passing_code": "class User:\r\n    \"\"\"A User class\r\n       (Django's User model inspired us)\r\n    \"\"\"\r\n\r\n    def __init__(self, first_name, last_name):\r\n        \"\"\"Constructor, base values\"\"\"\r\n        self.first_name = first_name\r\n        self.last_name = last_name\r\n\r\n    @property\r\n    def get_full_name(self):\r\n        \"\"\"Return first and last name separated by a whitespace\r\n           and using title case for both.\r\n        \"\"\"\r\n        # TODO 1: you code\r\n        return \" \".join([self.first_name.title(), self.last_name.title()])\r\n\r\n    @property\r\n    def username(self):\r\n        \"\"\"A username consists of the first char of\r\n           the user's first_name and the first 7 chars\r\n           of the user's last_name, both lowercased.\r\n\r\n           If this is your first property, check out:\r\n           https://pybit.es/property-decorator.html\r\n        \"\"\"\r\n        # TODO 2: you code\r\n        return self.first_name[0].lower()+ self.last_name[0:7].lower()\r\n\r\n    # TODO 3: you code\r\n    #\r\n    # add a __str__ and a __repr__\r\n    # see: https://stackoverflow.com/a/1438297\r\n    # \"__repr__ is for devs, __str__ is for customers\"\r\n    #\r\n    # see also TESTS for required output\r\n\r\n    def __str__(self):\r\n        return f\"{self.get_full_name} ({self.username})\" \r\n\r\n    def __repr__(self):\r\n        \"\"\"Don't hardcode the class name, hint: use a\r\n           special attribute of self.__class__ ...\r\n        \"\"\"\r\n        return f\"{self.__class__.__name__}('{self.first_name}', '{self.last_name}')\"\r\n        \r\n        \r\nnoah = User(\"Noah\", \"Kagan\")\r\nprint(noah.get_full_name)\r\nprint(noah.username)\r\nprint(str(noah))\r\nprint(repr(noah))",
            "score": 2,
            "number_code_submits": 9,
            "tags": "classes, dunder methods, f-strings, properties, __repr__, __str__, string manipulation",
            "in_paths": "Object Oriented Programming"
        },
        {
            "bite": "Bite 169. Simple length converter",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-21 19:29:38.022075+00:00",
            "passing_code": "CM_PER_INCH=2.54\r\ndef convert(value: float, fmt: str) -> float:\r\n    \"\"\"Converts the value to the designated format.\r\n\r\n    :param value: The value to be converted must be numeric or raise a TypeError\r\n    :param fmt: String indicating format to convert to\r\n    :return: Float rounded to 4 decimal places after conversion\r\n    \"\"\"\r\n    if type(value) not in [int, float]:\r\n        raise TypeError\r\n    if not isinstance(fmt,str):\r\n        raise ValueError\r\n    if fmt.lower() == \"cm\":\r\n        k = CM_PER_INCH\r\n    elif fmt.lower() == \"in\":\r\n        k = 1 / CM_PER_INCH\r\n    else: \r\n        raise ValueError\r\n    \r\n    return round(k*value,4)",
            "score": 2,
            "number_code_submits": 5,
            "tags": "exception handling, numbers, rounding",
            "in_paths": ""
        },
        {
            "bite": "Bite 174. String manipulation and metrics",
            "completed": true,
            "cheated": true,
            "date_first_completed": "2022-11-19 22:30:34.715765+00:00",
            "passing_code": "import string\r\nfrom collections import Counter\r\nfrom dataclasses import dataclass, field\r\nfrom typing import List, Set, Tuple\r\n\r\nSTOPWORDS: set = {\r\n    \"she's\", \"wasn\", \"through\", \"won\", \"that'll\", \"his\", \"once\", \"this\",\r\n    \"you\", \"ll\", \"has\", \"because\", \"m\", \"ours\", \"doing\", \"any\", \"aren't\",\r\n    \"they\", \"shouldn't\", \"being\", \"out\", \"is\", \"our\", \"it\", \"don\", \"had\",\r\n    \"nor\", \"your\", \"she\", \"you've\", \"themselves\", \"or\", \"y\", \"needn\", \"on\",\r\n    \"to\", \"at\", \"it's\", \"ve\", \"s\", \"too\", \"up\", \"didn't\", \"during\", \"haven\",\r\n    \"can\", \"haven't\", \"each\", \"couldn\", \"isn't\", \"not\", \"against\", \"where\",\r\n    \"was\", \"aren\", \"all\", \"by\", \"why\", \"hers\", \"theirs\", \"have\", \"as\",\r\n    \"yourself\", \"their\", \"very\", \"who\", \"yourselves\", \"over\", \"and\",\r\n    \"again\", \"do\", \"weren't\", \"which\", \"ma\", \"in\", \"such\", \"herself\",\r\n    \"yours\", \"doesn\", \"if\", \"my\", \"after\", \"into\", \"just\", \"now\", \"isn\",\r\n    \"itself\", \"between\", \"will\", \"other\", \"its\", \"these\", \"should\", \"re\",\r\n    \"below\", \"having\", \"am\", \"both\", \"d\", \"you'll\", \"but\", \"should've\",\r\n    \"won't\", \"himself\", \"shan't\", \"the\", \"me\", \"weren\", \"further\", \"until\",\r\n    \"here\", \"myself\", \"whom\", \"were\", \"hasn\", \"don't\", \"wouldn't\", \"been\",\r\n    \"before\", \"above\", \"he\", \"than\", \"most\", \"shan\", \"them\", \"mustn't\",\r\n    \"couldn't\", \"you'd\", \"for\", \"of\", \"her\", \"those\", \"needn't\", \"you're\",\r\n    \"t\", \"hadn't\", \"down\", \"o\", \"did\", \"about\", \"from\", \"does\", \"wouldn\",\r\n    \"off\", \"then\", \"ain\", \"few\", \"hasn't\", \"some\", \"i\", \"ourselves\", \"an\",\r\n    \"when\", \"are\", \"under\", \"more\", \"with\", \"hadn\", \"what\", \"while\", \"didn\",\r\n    \"doesn't\", \"only\", \"him\", \"mightn\", \"be\", \"mightn't\", \"a\", \"how\", \"no\",\r\n    \"there\", \"that\", \"so\", \"we\", \"same\", \"mustn\", \"wasn't\", \"shouldn\", \"own\",\r\n}\r\nGETTYSBURG: str = \"\"\"Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.\r\n\r\nNow we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battlefield of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this.\r\n\r\nBut, in a larger sense, we cannot dedicate\u2014we cannot consecrate\u2014we cannot hallow\u2014this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us\u2014that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion\u2014that we here highly resolve that these dead shall not have died in vain\u2014that this nation, under God, shall have a new birth of freedom\u2014 and that government of the people, by the people, for the people, shall not perish from the earth.\"\"\"\r\n\r\n\r\n@dataclass\r\nclass Corpora:\r\n    \"\"\"Add the inital variables along with creating any methods that\r\n    will get this working as described in the bite's description.\r\n\r\n    * txt\r\n    * count\r\n    * tag\r\n    * extra\r\n    * stopwords\r\n    \"\"\"\r\n    txt: str\r\n    count: int = 5\r\n    tag: str = \"#\"\r\n    extra: List[str] = field(default_factory=list)\r\n    stopwords: Set[str] = field(default_factory=set)\r\n\r\n    def __post_init__(self):\r\n        self.extra = self.extra if self.extra else []\r\n        self.stopwords = STOPWORDS\r\n\r\n    @property\r\n    def cleaned(self) -> str:\r\n        \"\"\"Takes a corpus and cleans it up.\r\n\r\n        * All text is made lowercase\r\n        * All punctuations are removed\r\n        * If a list of extract objects were given, remove those too\r\n\r\n        :param txt: Corpus of text\r\n        :return: cleaned up corpus\r\n        \"\"\"\r\n        trans = str.maketrans(\"\", \"\", string.punctuation)\r\n        c_txt = \"\"\r\n        for line in self.txt.lower().splitlines():\r\n            c_txt += line.translate(trans) + \" \"\r\n\r\n        if self.extra:\r\n            for char in self.extra:\r\n                c_txt = c_txt.replace(char, \" \")\r\n\r\n        return c_txt\r\n\r\n    @property\r\n    def metrics(self) -> List[Tuple[str, int]]:\r\n        \"\"\"Generates word count metrics.\r\n\r\n        * Using the cleaned up corpus, count up how many times each word is used\r\n        * Exclude stop words using STOPWORDS\r\n        * Use count to return the requested amount of the top words, defaults to 5\r\n\r\n        :return: List of tuples, i.e. (\"word\", count)\r\n        \"\"\"\r\n        txt_lst = [w for w in self.cleaned.strip().split() if w not in self.stopwords]\r\n        return Counter(txt_lst).most_common(self.count)\r\n\r\n    @property\r\n    def graph(self) -> None:\r\n        \"\"\"Generates a textual graph of the words\r\n\r\n        * Prints out the words along with a \"tag\" bar graph, defaults to using\r\n          the # character\r\n        * The word is right-aligned and takes up 10 character spaces\r\n        * The tag is repeated the number of counts of the word\r\n\r\n        For example, the top 10 words in the Gettysburgh address would be\r\n        displayed in this manner:\r\n\r\n            nation #####\r\n         dedicated ####\r\n             great ###\r\n            cannot ###\r\n              dead ###\r\n                us ###\r\n             shall ###\r\n            people ###\r\n               new ##\r\n         conceived ##\r\n\r\n        :param metrics: List of tuples with word counts\r\n        :return: None\r\n        \"\"\"\r\n        for metric in self.metrics:\r\n            word, value = metric\r\n            print(f\"{word:>10} {self.tag * value}\")",
            "score": 1,
            "number_code_submits": 17,
            "tags": "Counter, dataclasses, list comprehensions, properties, string formatting, string manipulation, translate",
            "in_paths": "String Manipulation"
        },
        {
            "bite": "Bite 170. Analyze McDonald's food data",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "data analysis, pandas",
            "in_paths": "Data Analysis"
        },
        {
            "bite": "Bite 171. Make a terminal spinner animation",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-13 21:36:03.144816+00:00",
            "passing_code": "from itertools import cycle\r\nimport sys\r\nfrom time import time, sleep\r\n\r\nSPINNER_STATES = ['-', '\\\\', '|', '/']  # had to escape \\\r\nSTATE_TRANSITION_TIME = 0.1\r\n\r\n\r\ndef spinner(seconds):\r\n    \"\"\"Make a terminal loader/spinner animation using the imports above.\r\n       Takes seconds argument = time for the spinner to run.\r\n       Does not return anything, only prints to stdout.\"\"\"\r\n\r\n    start = time()\r\n    print(\" \", end='', flush=True)\r\n    # Back up one character then print our next frame in the animation\r\n    for frame in cycle(SPINNER_STATES):\r\n        print('\\r', frame, sep='', end='', flush=True)\r\n        sleep(STATE_TRANSITION_TIME)\r\n        if time()-start > seconds:\r\n            break\r\n    print('\\r ')\r\n\r\n\r\nif __name__ == '__main__':\r\n    spinner(2)",
            "score": 4,
            "number_code_submits": 5,
            "tags": "command line, itertools, stdout, sys, time",
            "in_paths": "Itertools"
        },
        {
            "bite": "Bite 172. Having fun with Python Partials",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-22 10:41:18.539342+00:00",
            "passing_code": "from functools import partial\r\n\r\n# create 2 partials:\r\n# - 'rounder_int' rounds to int (0 places)\r\n# - 'rounder_detailed' rounds to 4 places\r\nrounder_int =  partial(round, ndigits=0) \r\nrounder_detailed = partial(round, ndigits=4) \r\n\r\n",
            "score": 2,
            "number_code_submits": 2,
            "tags": "functools, partial, rounding",
            "in_paths": ""
        },
        {
            "bite": "Bite 173. Set up future notifications",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-09 20:08:48.143511+00:00",
            "passing_code": "from datetime import datetime, timedelta\r\nimport re\r\n\r\nNOW = datetime(year=2019, month=2, day=6,\r\n               hour=22, minute=0, second=0)\r\n\r\n\r\ndef add_todo(delay_time: str, task: str,\r\n             start_time: datetime = NOW) -> str:\r\n    \"\"\"\r\n    Add a todo list item in the future with a delay time.\r\n\r\n    Parse out the time unit from the passed in delay_time str:\r\n    - 30d = 30 days\r\n    - 1h 10m = 1 hour and 10 min\r\n    - 5m 3s = 5 min and 3 seconds\r\n    - 45 or 45s = 45 seconds\r\n\r\n    Return the task and planned time which is calculated from\r\n    provided start_time (here default = NOW):\r\n    >>> add_todo(\"1h 10m\", \"Wash my car\")\r\n    >>> \"Wash my car @ 2019-02-06 23:10:00\"\r\n    \"\"\"\r\n    dt = timedelta()\r\n    for item in delay_time.split():\r\n        if 'd' in item:\r\n            dt+=timedelta(days=int(item.strip('d')))\r\n        elif 'h' in item:\r\n            dt+=timedelta(hours=int(item.strip('h')))\r\n        elif 'm' in item:\r\n            dt+=timedelta(minutes=int(item.strip('m')))\r\n        elif 's' in item:            \r\n            dt+=timedelta(seconds=int(item.strip('s')))\r\n        else:\r\n            dt+=timedelta(seconds=int(item))\r\n        \r\n    return f\"{task} @ {datetime.strftime(start_time+dt, '%Y-%m-%d %H:%M:%S')}\"       \r\n\r\n\r\nprint(add_todo(\"11h 10m\", \"Wash my car\"))\r\nprint(add_todo(\"30d\", \"Code a Bite\"))\r\nprint(add_todo(\"5m 3s\", \"Go to Bed\"))",
            "score": 3,
            "number_code_submits": 2,
            "tags": "datetime, findall, f-strings, timedelta",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 175. Find missing dates",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-21 17:51:55.217181+00:00",
            "passing_code": "import datetime\r\n\r\ndef get_missing_dates(dates):\r\n    \"\"\"Receives a range of dates and returns a sequence\r\n       of missing datetime.date objects (no worries about order).\r\n\r\n       You can assume that the first and last date of the\r\n       range is always present (assumption made in tests).\r\n\r\n       See the Bite description and tests for example outputs.\r\n    \"\"\"\r\n    start, end = min(dates), max(dates)\r\n    \r\n    all_dates_in_range = [start + datetime.timedelta(days=x) for x in range((end-start).days)]\r\n    \r\n    return [date for date in all_dates_in_range if date not in dates]\r\n    \r\n",
            "score": 3,
            "number_code_submits": 2,
            "tags": "datetime, dateutil, pandas",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 176. Create a variable length chessboard",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-23 17:09:43.763507+00:00",
            "passing_code": "WHITE, BLACK = ' ', '#'\r\n\r\n\r\ndef create_chessboard(size=8):\r\n    \"\"\"Create a chessboard with of the size passed in.\r\n       Don't return anything, print the output to stdout\"\"\"\r\n    odd_row = (WHITE + BLACK)*(size // 2)\r\n    even_row = (BLACK + WHITE)*(size // 2)\r\n    if size%2:\r\n        odd_row+=WHITE\r\n        even_row+=BLACK\r\n    odd_row+=\"\\n\"\r\n    even_row+=\"\\n\"\r\n    board =  (odd_row + even_row)*(size // 2)\r\n    if size%2:\r\n        board+=odd_row\r\n    print(board)\r\n\r\ncreate_chessboard(8)",
            "score": 2,
            "number_code_submits": 2,
            "tags": "modulo, range, stdout",
            "in_paths": "Python Beginner"
        },
        {
            "bite": "Bite 178. Parse PyBites blog git commit log",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-19 13:21:36.544352+00:00",
            "passing_code": "from collections import Counter, defaultdict\r\nimport os\r\nfrom typing import Tuple\r\nfrom urllib.request import urlretrieve\r\nimport re\r\n\r\nfrom dateutil.parser import parse\r\n\r\ncommits = os.path.join(os.getenv(\"TMP\", \"/tmp\"), 'commits')\r\nurlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/git_log_stat.out',\r\n    commits\r\n)\r\n\r\n# you can use this constant as key to the yyyymm:count dict\r\nYEAR_MONTH = '{y}-{m:02d}'\r\n\r\n\r\ndef get_min_max_amount_of_commits(\r\n    commit_log: str = commits,\r\n    year: int = None\r\n) -> Tuple[str, str]:\r\n    \"\"\"\r\n    Calculate the amount of inserts / deletes per month from the\r\n    provided commit log.\r\n\r\n    Takes optional year arg, if provided only look at lines for\r\n    that year, if not, use the entire file.\r\n\r\n    Returns a tuple of (least_active_month, most_active_month)\r\n    \"\"\"\r\n    \r\n    result=defaultdict(int)\r\n    \r\n    with open(commit_log) as f:\r\n        lines=f.readlines()\r\n    \r\n    for line in lines:\r\n\r\n        date, changes = line.split('|')\r\n\r\n        date=parse(date.strip(),ignoretz=True, fuzzy_with_tokens=True)[0]\r\n        if year and year!=date.year:\r\n            continue\r\n\r\n        key=date.strftime(\"%Y-%m\")\r\n\r\n        insertions = re.findall('([0-9]+) insertion',changes) or [0]\r\n        deletions = re.findall('([0-9]+) deletion',changes) or [0]\r\n        count=int(deletions[0])+int(insertions[0])\r\n\r\n        result[key]+=count\r\n        \r\n    sorted_count = Counter(result).most_common()\r\n\r\n    return sorted_count[-1][0],sorted_count[0][0]\r\n    \r\n\r\nprint(get_min_max_amount_of_commits(commits,2019))\r\n    ",
            "score": 3,
            "number_code_submits": 2,
            "tags": "Counter, data analysis, datetime, dateutil, string parsing",
            "in_paths": "Data Analysis, Datetimes and Timezones, String Manipulation"
        },
        {
            "bite": "Bite 179. Strip comments from Python code",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-16 21:59:55.682190+00:00",
            "passing_code": "SINGLE_LINE = '#'\r\nINLINE = '  # '\r\nMULTI_LINE = '\"\"\"'\r\n\r\ndef strip_comments(code):\r\n    # see Bite description\r\n    result=[]\r\n    inside_multiline=False\r\n    for line in code.splitlines():\r\n        if inside_multiline:\r\n            if MULTI_LINE in line:\r\n                inside_multiline= False\r\n            continue\r\n        if line.lstrip().startswith(SINGLE_LINE):\r\n            continue\r\n        if INLINE in line:\r\n            result.append(line[:line.find(INLINE)])\r\n            continue\r\n        if line.lstrip().startswith(MULTI_LINE):\r\n            if MULTI_LINE in line.lstrip()[3:]:\r\n                continue\r\n            inside_multiline=True\r\n            continue\r\n       \r\n        result.append(line)\r\n    return \"\\n\".join(result)\r\n\r\n\r\ncode = '''\"\"\"this is\r\nmy awesome script\r\n\"\"\"\r\n# importing modules\r\nimport re\r\n\r\ndef hello(name):\r\n    \"\"\"my function docstring\"\"\"\r\n    return f'hello {name}'  # my inline comment\r\n'''   \r\n    \r\n    \r\nprint(strip_comments(code))",
            "score": 4,
            "number_code_submits": 2,
            "tags": "comments, regular expressions, string parsing",
            "in_paths": "Regular Expressions, String Manipulation"
        },
        {
            "bite": "Bite 180. Group names by country",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-24 21:45:42.909595+00:00",
            "passing_code": "from collections import defaultdict\r\nfrom pprint import pprint \r\n\r\n# fake data from https://www.mockaroo.com\r\ndata = \"\"\"last_name,first_name,country_code\r\nWatsham,Husain,ID\r\nHarrold,Alphonso,BR\r\nApdell,Margo,CN\r\nTomblings,Deerdre,RU\r\nWasielewski,Sula,ID\r\nJeffry,Rudolph,TD\r\nBrenston,Luke,SE\r\nParrett,Ines,CN\r\nBraunle,Kermit,PL\r\nHalbard,Davie,CN\"\"\"\r\n\r\n\r\ndef group_names_by_country(data: str = data) -> defaultdict:\r\n    countries = defaultdict(list)\r\n    # your code\r\n    for line in data.splitlines():\r\n        surname, name, country = tuple(line.split(\",\"))\r\n        if country != \"country_code\":\r\n            countries[country].append(\" \".join([name,surname]))\r\n    return countries\r\n    \r\npprint(group_names_by_country())",
            "score": 2,
            "number_code_submits": 2,
            "tags": "collections, defaultdict, groupby",
            "in_paths": "Collections Module, Python Beginner"
        },
        {
            "bite": "Bite 181. Keep a list sorted upon insert",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-25 17:54:04.714120+00:00",
            "passing_code": "import bisect\r\n\r\n\r\nclass OrderedList:\r\n\r\n    def __init__(self):\r\n        self._numbers = []\r\n\r\n    def add(self, num):\r\n        bisect.insort(self._numbers, num) # you complete\r\n\r\n    def __str__(self):\r\n        return ', '.join(str(num) for num in self._numbers)\r\n\r\nif __name__ == \"__main__\":\r\n    order = OrderedList()\r\n    order.add(10)\r\n    print(order)  # __str__ already provided\r\n    order.add(1)\r\n    print(order)\r\n    order.add(16)\r\n    print(order)\r\n    order.add(5)\r\n    print(order)\r\n",
            "score": 2,
            "number_code_submits": 3,
            "tags": "bisect, classes, data structures, __str__",
            "in_paths": ""
        },
        {
            "bite": "Bite 182. Parse a bunch of quotes from HTML",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-06 16:47:04.901027+00:00",
            "passing_code": "import re\r\nfrom pprint import pprint\r\n\r\n# source: https://www.virgin.com/richard-branson/my-top-10-quotes-living-life-better\r\nHTML = \"\"\"<!DOCTYPE html>\r\n<head>\r\n  <meta charset=\"utf-8\" />\r\n  <title>My top 10 quotes on living life better | Virgin</title>\r\n</head>\r\n<body>\r\n  <div class=\"content\">\r\n    <p>I\u2019m striving this year to maintain my fitness and to always be learning new things. The new theme on Virgin.com is Live Life Better \u2013 a series shining a spotlight on how we can all lead happier, healthier and more fulfilled lives. Virgin has always wanted to make things better for our team and customers and to improve their experiences.</p>\r\n    <p>Here are my top 10 quotes on living life better for some New Year inspiration:</p>\r\n    <p>10. \"The beautiful thing about learning is nobody can take it away from you.\" - B.B King</p>\r\n    <p>9. \"Inexperience is an asset. Embrace it.\" - Wendy Kopp</p>\r\n    <p>8. \"Change will not come if we wait for some other person, or if we wait for some other time. We are the ones we\u2019ve been waiting for. We are the change that we seek.\" - Barack Obama</p>\r\n    <p>7. \"The sky is not my limit\u2026 I am.\" - T.F. Hodge</p>\r\n    <p>6. \"Life is either a daring adventure or nothing at all.\" - Helen Keller</p>\r\n    <p>5. \"It does not matter how slowly you go as long as you do not stop.\" - Confucius</p>\r\n    <p>4. \"Too many of us are not living our dreams because we are living our fears.\" - Les Brown</p>\r\n    <p>3. \"Continuous efforts \u2013 not strength or intelligence \u2013 is the key to unlocking our potential.\" - Winston Churchill</p>\r\n    <p>2. \"Believe you can and you\u2019re halfway there.\" - Theodore Roosevelt</p>\r\n    <p>1. \"Success means doing the best we can with what we have. Success is the doing, not the getting; in the trying, not the triumph. Success is a personal standard, reaching for the highest that is in us, becoming all that we can be.\" - Zig Ziglar</p>\r\n    <p>How do you try and live a healthier, happier life?</p>\r\n  </div>\r\n</body>\r\n</html>\"\"\"\r\n\r\n\r\ndef extract_quotes(html: str = HTML) -> dict:\r\n    \"\"\"See instructions in the Bite description\"\"\"\r\n    lst = [re.findall('<p>[0-9]+\\. \"(.+)\" - (.+)</p>', line) for line in html.splitlines()]\r\n    result = {item[0][1]:item[0][0] for item in lst if item}\r\n    return result\r\n\r\ntest_str = '\\n    <p>7. \"quote\" - A. U. Thor</p>\\n'\r\n\r\npprint(extract_quotes())\r\n\r\n",
            "score": 3,
            "number_code_submits": 2,
            "tags": "dict, regular expressions, string manipulation, string parsing",
            "in_paths": "Regular Expressions, String Manipulation"
        },
        {
            "bite": "Bite 184. Analyze some Bite stats data",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-12 13:30:48.872859+00:00",
            "passing_code": "from csv import DictReader\r\nimport os\r\nfrom urllib.request import urlretrieve\r\nfrom collections import Counter\r\n\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nLOGS = 'bite_output_log.txt'\r\nDATA = os.path.join(TMP, LOGS)\r\nS3 = 'https://bites-data.s3.us-east-2.amazonaws.com'\r\nif not os.path.isfile(DATA):\r\n    urlretrieve(f'{S3}/{LOGS}', DATA)\r\n\r\n\r\nclass BiteStats:\r\n\r\n    def __init__(self, data=DATA):\r\n        self.rows = []\r\n        # you code ...\r\n        with open(data, newline='') as csvfile:\r\n            for row in DictReader(csvfile):\r\n                self.rows.append(row)\r\n        print(self.rows)\r\n\r\n    @property\r\n    def number_bites_accessed(self) -> int:\r\n        \"\"\"Get the number of unique Bites accessed\"\"\"\r\n        return len(set([row['bite'] for row in self.rows]))\r\n\r\n    @property\r\n    def number_bites_resolved(self) -> int:\r\n        \"\"\"Get the number of unique Bites resolved (completed=True)\"\"\"\r\n        return len(set([row['bite'] for row in self.rows if row['completed']=='True']))\r\n\r\n    @property\r\n    def number_users_active(self) -> int:\r\n        \"\"\"Get the number of unique users in the data set\"\"\"\r\n        return len(set([row['user'] for row in self.rows]))\r\n\r\n    @property\r\n    def number_users_solving_bites(self) -> int:\r\n        \"\"\"Get the number of unique users that resolved\r\n           one or more Bites\"\"\"\r\n        return len(set([row['user'] for row in self.rows if row['completed']=='True']))\r\n\r\n    @property\r\n    def top_bite_by_number_of_clicks(self) -> str:\r\n        \"\"\"Get the Bite that got accessed the most\r\n           (= in most rows)\"\"\"\r\n        bites_accessed_most=Counter([row['bite'] for row in self.rows]).most_common()\r\n        return bites_accessed_most[0][0]\r\n\r\n    @property\r\n    def top_user_by_bites_completed(self) -> str:\r\n        \"\"\"Get the user that completed the most Bites\"\"\"\r\n        bites_completed_most=Counter([row['user'] for row in self.rows if row['completed']=='True']).most_common()\r\n        return bites_completed_most[0][0]\r\n    \r\na=BiteStats()\r\nprint(a.number_bites_accessed)\r\nprint(a.number_bites_resolved)\r\nprint(a.number_users_active)\r\nprint(a.number_users_solving_bites)\r\nprint(a.top_bite_by_number_of_clicks)\r\nprint(a.top_user_by_bites_completed)",
            "score": 3,
            "number_code_submits": 2,
            "tags": "Counter, csv, data analysis, set",
            "in_paths": "Data Analysis, Data Formats"
        },
        {
            "bite": "Bite 186. Calculate number of books to have read at date ...",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-09 20:31:41.009838+00:00",
            "passing_code": "from datetime import datetime\r\n\r\nfrom dateutil.parser import parse\r\n\r\n# work with a static date for tests, real use = datetime.now()\r\nNOW = datetime(2019, 3, 17, 16, 28, 42, 966663)\r\nWEEKS_PER_YEAR = 52\r\n\r\n\r\ndef get_number_books_read(books_per_year_goal: int,\r\n                          at_date: str = None) -> int:\r\n    \"\"\"Based on books_per_year_goal and at_date, return the\r\n       number of books that should have been read.\r\n       If books_per_year_goal negative or 0, or at_date is in the\r\n       past, raise a ValueError.\"\"\"\r\n    at_date = at_date or str(NOW)\r\n    # TODOs\r\n\r\n    # 1. use dateutil's parse to convert at_date into a\r\n    # datetime object\r\n\r\n    # 2. check books_per_year_goal and at_date and raise\r\n    # a ValueError if goal <= 0 or at_date in the past (< NOW)\r\n\r\n    # 3. check the offset of at_date in the year (\"week of the\r\n    # year\" - e.g. whatweekisit.com) and based on the books_per_year_goal,\r\n    # calculate the number of books that should have been read / completed\r\n    \r\n    if isinstance(at_date, str):\r\n        at_date = parse(at_date, fuzzy=True)\r\n    \r\n    if books_per_year_goal<=0 or at_date < NOW:\r\n        raise ValueError('Should have positive goal and future date')\r\n        \r\n    at_week= at_date.isocalendar()[1]\r\n    return int(at_week/WEEKS_PER_YEAR *books_per_year_goal)\r\n   \r\n\"\"\" \r\nprint(get_number_books_read(100, 'Sunday, March 25th, 2019'))\r\nprint(get_number_books_read(52, 'Sunday, March 18th, 2019'))\r\nprint(get_number_books_read(52, '5-20-2018'))\r\n\"\"\"",
            "score": 3,
            "number_code_submits": 4,
            "tags": "datetime, dateutil, exception handling",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 187. Actor/actress age at movie release",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-09 20:58:18.828044+00:00",
            "passing_code": "from dataclasses import dataclass\r\n\r\nfrom dateutil.relativedelta import relativedelta\r\nfrom dateutil.parser import parse\r\n\r\n@dataclass\r\nclass Actor:\r\n    name: str\r\n    born: str\r\n\r\n\r\n@dataclass\r\nclass Movie:\r\n    title: str\r\n    release_date: str\r\n\r\n\r\ndef get_age(actor: Actor, movie: Movie) -> str:\r\n    \"\"\"Calculates age of actor / actress when movie was released,\r\n       return a string like this:\r\n\r\n       {name} was {age} years old when {movie} came out.\r\n       e.g.\r\n       Wesley Snipes was 28 years old when New Jack City came out.\r\n    \"\"\"\r\n    actor_born=parse(actor.born, fuzzy=True)\r\n    movie_released=parse(movie.release_date, fuzzy=True)\r\n    \r\n    age=relativedelta(movie_released,actor_born).years\r\n    return f\"{actor.name} was {age} years old when {movie.title} came out.\"\r\n    \r\n    \r\n\"\"\"\r\nactor=Actor('Michelle Pfeiffer', 'April 29, 1958')\r\nmovie=Movie('New Jack City', 'January 17, 1991')\r\nprint(get_age(actor, movie) )\r\n\"\"\"",
            "score": 3,
            "number_code_submits": 7,
            "tags": "dataclasses, dateutil, f-strings",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 188. Get statistics from PyBites test code",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-19 16:33:12.104730+00:00",
            "passing_code": "import os\r\nimport statistics\r\nfrom urllib.request import urlretrieve\r\n\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nS3 = 'https://bites-data.s3.us-east-2.amazonaws.com/'\r\nDATA = 'testfiles_number_loc.txt'\r\nSTATS = os.path.join(TMP, DATA)\r\nif not os.path.isfile(STATS):\r\n    urlretrieve(os.path.join(S3, DATA), STATS)\r\n\r\nSTATS_OUTPUT = \"\"\"\r\nBasic statistics:\r\n- count     : {count:7d}\r\n- min       : {min_:7d}\r\n- max       : {max_:7d}\r\n- mean      : {mean:7.2f}\r\n\r\nPopulation variance:\r\n- pstdev    : {pstdev:7.2f}\r\n- pvariance : {pvariance:7.2f}\r\n\r\nEstimated variance for sample:\r\n- count     : {sample_count:7.2f}\r\n- stdev     : {sample_stdev:7.2f}\r\n- variance  : {sample_variance:7.2f}\r\n\"\"\"\r\n\r\n\r\ndef get_all_line_counts(data: str = STATS) -> list:\r\n    \"\"\"Get all 186 line counts from the STATS file,\r\n       returning a list of ints\"\"\"\r\n    # TODO 1: get the 186 ints from downloaded STATS file\r\n    with open(STATS) as file:\r\n        lines= file.readlines()\r\n    lst = []\r\n    for line in lines:\r\n        num = int(line.split()[0]) \r\n        lst.append(num)\r\n    return lst\r\n\r\n\r\n\r\ndef create_stats_report(data=None):\r\n    if data is None:\r\n        # converting to a list in case a generator was returned\r\n        data = list(get_all_line_counts())\r\n\r\n    # taking a sample for the last section\r\n    sample = list(data)[::2]\r\n\r\n    # TODO 2: complete this dict, use data list and\r\n    # for the last 3 sample_ variables, use sample list\r\n    stats = dict(count=len(data),\r\n                 min_=min(data),\r\n                 max_=max(data),\r\n                 mean=statistics.mean(data),\r\n                 pstdev=statistics.pstdev(data),\r\n                 pvariance=statistics.pvariance(data),\r\n                 sample_count=len(sample),\r\n                 sample_stdev=statistics.stdev(sample),\r\n                 sample_variance=statistics.variance(sample),\r\n                 )\r\n\r\n    return STATS_OUTPUT.format(**stats)\r\n    \r\n    \r\nprint(create_stats_report())\r\n\r\n",
            "score": 2,
            "number_code_submits": 2,
            "tags": "data analysis, file processing, statistics",
            "in_paths": "Data Analysis"
        },
        {
            "bite": "Bite 189. Filter a list of names",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-27 18:00:05.012446+00:00",
            "passing_code": "import string\r\nIGNORE_CHAR = 'b'\r\nQUIT_CHAR = 'q'\r\nMAX_NAMES = 5\r\n\r\n\r\ndef filter_names(names):\r\n    lst=[] \r\n    for name in names:\r\n        if name.startswith(IGNORE_CHAR) or any(char.isdigit() for char in name):\r\n            continue\r\n        if name.startswith(QUIT_CHAR):\r\n            break\r\n        lst.append(name)\r\n        if len(lst) >= MAX_NAMES:\r\n            break\r\n    return lst\r\n\r\nlst=['pet1e', 'milly', 'quit', 'me', 'you' ]\r\nprint(filter_names(lst))",
            "score": 2,
            "number_code_submits": 4,
            "tags": "break, continue, generators, looping",
            "in_paths": "Python Beginner"
        },
        {
            "bite": "Bite 192. Some logging practice",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-28 13:26:30.317864+00:00",
            "passing_code": "import logging\r\nfrom typing import Callable\r\n\r\nlogger=logging.getLogger(\"pybites_logger\")\r\n\r\nDEBUG = logger.debug\r\nINFO = logger.info\r\nWARNING = logger.warning\r\nERROR = logger.error\r\nCRITICAL = logger.critical\r\n\r\n\r\ndef log_it(level: Callable, msg: str) -> None:\r\n    level(msg)\r\n\r\nif __name__ == \"__main__\":\r\n    log_it(DEBUG, \"This is a debug message.\")\r\n    log_it(INFO, \"This is an info message.\")\r\n    log_it(WARNING, \"This is a warning message.\")\r\n    log_it(ERROR, \"This is an error message.\")\r\n    log_it(CRITICAL, \"This is a critical message.\")",
            "score": 2,
            "number_code_submits": 12,
            "tags": "callable, logging",
            "in_paths": ""
        },
        {
            "bite": "Bite 190. Parse income distribution from Latin America XML",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-02 19:19:59.021200+00:00",
            "passing_code": "import os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\n\r\nimport xml.etree.ElementTree as ET\r\nfrom collections import defaultdict\r\n\r\n# import the countries xml file\r\ntmp = Path(os.getenv(\"TMP\", \"/tmp\"))\r\ncountries = tmp / 'countries.xml'\r\n\r\nif not countries.exists():\r\n    urlretrieve(\r\n        'https://bites-data.s3.us-east-2.amazonaws.com/countries.xml',\r\n        countries\r\n    )\r\n\r\n\r\ndef get_income_distribution(xml=countries):\r\n    \"\"\"\r\n    - Read in the countries xml as stored in countries variable.\r\n    - Parse the XML\r\n    - Return a dict of:\r\n      - keys = incomes (wb:incomeLevel)\r\n      - values = list of country names (wb:name)\r\n    \"\"\"\r\n    result = defaultdict(list)\r\n\r\n    for country in ET.parse(xml).getroot():\r\n        name = country.find('{http://www.worldbank.org}name').text\r\n        income = country.find('{http://www.worldbank.org}incomeLevel').text\r\n        result[income].append(name) \r\n\r\n    return result\r\n    ",
            "score": 3,
            "number_code_submits": 2,
            "tags": "data analysis, defaultdict, xml",
            "in_paths": "Data Formats, Web Scraping"
        },
        {
            "bite": "Bite 191. Starwars character with highest BMI",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-02 23:24:43.133618+00:00",
            "passing_code": "data = \"\"\"Luke Skywalker,172,77\r\n          C-3PO,167,75\r\n          R2-D2,96,32\r\n          Darth Vader,202,136\r\n          Leia Organa,150,49\r\n          Owen Lars,178,120\r\n          Beru Whitesun lars,165,75\r\n          R5-D4,97,32\r\n          Biggs Darklighter,183,84\r\n          Obi-Wan Kenobi,182,77\r\n          Anakin Skywalker,188,84\r\n          Chewbacca,228,112\r\n          Han Solo,180,80\r\n          Greedo,173,74\r\n          Jek Tono Porkins,180,110\r\n          Yoda,66,17\r\n          Palpatine,170,75\r\n          Boba Fett,183,78.2\r\n          IG-88,200,140\r\n          Bossk,190,113\r\n\"\"\"\r\n\r\n\r\ndef person_max_bmi(data=data):\r\n    \"\"\"Return (name, BMI float) of the character in data that\r\n       has the highest BMI (rounded on 2 decimals)\"\"\"\r\n    max_BMI = 0\r\n    for line in data.splitlines():\r\n        name, height, weight = line.split(\",\") \r\n        BMI =  round(float(weight) / ((int(height) / 100) ** 2), 2)\r\n        if BMI > max_BMI:\r\n            max_BMI, max_name = BMI, name\r\n    return (max_name.strip(), max_BMI)\r\n    \r\nprint(person_max_bmi())",
            "score": 3,
            "number_code_submits": 3,
            "tags": "max, operator, string manipulation, tuple unpacking",
            "in_paths": ""
        },
        {
            "bite": "Bite 193. Most upvoted StackOverflow Python questions",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-26 14:34:47.920998+00:00",
            "passing_code": "import requests\r\nfrom bs4 import BeautifulSoup\r\nfrom collections import namedtuple\r\nfrom pprint import pprint\r\n\r\n\r\ncached_so_url = 'https://bites-data.s3.us-east-2.amazonaws.com/so_python.html'\r\n\r\nQuestion = namedtuple('Question', 'question votes views')\r\n\r\ndef top_python_questions(url=cached_so_url):\r\n    \"\"\"Use requests to retrieve the url / html,\r\n       parse the questions out of the html with BeautifulSoup,\r\n       filter them by >= 1m views (\"..m views\").\r\n       Return a list of (question, num_votes) tuples ordered\r\n       by num_votes descending (see tests for expected output).\r\n    \"\"\"\r\n    CONTENT = requests.get(url).text\r\n    soup = BeautifulSoup(CONTENT, 'html.parser')\r\n    \r\n    list_questions = soup.find_all(\"div\", class_=\"question-summary\")\r\n\r\n    result = []\r\n    \r\n    for q in list_questions:\r\n        question = q.find('a', {'class': 'question-hyperlink'}).text\r\n        votes = int(q.find('span', {'class': 'vote-count-post'}).text)\r\n        views = q.find('div', {'class': 'views'}).text.strip()\r\n        result.append(Question(question=question,\r\n                votes=votes,\r\n                views=views,\r\n                ))\r\n    \r\n    filtered = [(q.question, q.votes) for q in result if 'm' in q.views]\r\n    return sorted(filtered, key=lambda x:x[1], reverse=True)\r\n    \r\npprint(top_python_questions())\r\n",
            "score": 3,
            "number_code_submits": 2,
            "tags": "beautifulsoup, requests, sorting, string matching, web scraping",
            "in_paths": "Web Scraping"
        },
        {
            "bite": "Bite 195. Analyze NBA Data with sqlite3",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-04 10:17:51.182684+00:00",
            "passing_code": "from collections import namedtuple\r\nimport csv\r\nimport os\r\nfrom pathlib import Path\r\nimport sqlite3\r\nimport random\r\nimport string\r\n\r\nimport requests\r\n\r\nDATA_URL = 'https://query.data.world/s/ezwk64ej624qyverrw6x7od7co7ftm'\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\n\r\nsalt = ''.join(\r\n    random.choice(string.ascii_lowercase) for i in range(20)\r\n)\r\nDB = TMP / f'nba_{salt}.db'\r\n\r\nPlayer = namedtuple('Player', ('name year first_year team college active '\r\n                               'games avg_min avg_points'))\r\n\r\nconn = sqlite3.connect(DB)\r\ncur = conn.cursor()\r\n\r\n\r\ndef import_data():\r\n    with requests.Session() as session:\r\n        content = session.get(DATA_URL).content.decode('utf-8')\r\n\r\n    reader = csv.DictReader(content.splitlines(), delimiter=',')\r\n\r\n    players = []\r\n    for row in reader:\r\n        players.append(Player(name=row['Player'],\r\n                              year=row['Draft_Yr'],\r\n                              first_year=row['first_year'],\r\n                              team=row['Team'],\r\n                              college=row['College'],\r\n                              active=row['Yrs'],\r\n                              games=row['Games'],\r\n                              avg_min=row['Minutes.per.Game'],\r\n                              avg_points=row['Points.per.Game']))\r\n\r\n    cur.execute('''CREATE TABLE IF NOT EXISTS players\r\n                  (name, year, first_year, team, college, active,\r\n                  games, avg_min, avg_points)''')\r\n    cur.executemany('INSERT INTO players VALUES (?,?,?,?,?,?,?,?,?)', players)\r\n    conn.commit()\r\n\r\n\r\nimport_data()\r\n\r\n\r\n# you code:\r\n\r\ndef player_with_max_points_per_game():\r\n    \"\"\"The player with highest average points per game (don't forget to CAST to\r\n       numeric in your SQL query)\"\"\"\r\n       \r\n    rows = cur.execute(\"SELECT name FROM players ORDER BY CAST(avg_points AS FLOAT) DESC\").fetchone()\r\n    return rows[0]\r\n\r\n\r\n\r\ndef number_of_players_from_duke():\r\n    \"\"\"Return the number of players with college == Duke University\"\"\"\r\n    target_college = \"Duke University\"\r\n    count = cur.execute(\"SELECT COUNT(name) FROM players WHERE college = ? \",(target_college,)).fetchone()\r\n    return count[0]\r\n\r\n\r\ndef avg_years_active_players_stanford():\r\n    \"\"\"Return the average years that players from \"Stanford University\r\n       are active (\"active\" column)\"\"\"\r\n    target_college = \"Stanford University\"\r\n    rows = cur.execute(\"SELECT CAST(active AS FLOAT) FROM players WHERE college = ? \",(target_college,)).fetchall()\r\n    return round(sum(row[0] for row in rows)/len(rows),2)\r\n\r\n\r\ndef year_with_most_new_players():\r\n    \"\"\"Return the year with the most new players.\r\n       Hint: you can use GROUP BY on the year column.\r\n    \"\"\"\r\n    \r\n    \"\"\"this works\r\n    rows = cur.execute(\"SELECT year, COUNT(name) FROM players GROUP BY CAST(year AS INT)\").fetchall()\r\n    return max(rows, key=lambda x: x[1])[0]\r\n    \"\"\"\r\n    \r\n    rows = cur.execute(\"SELECT CAST(year AS INT) FROM players GROUP BY CAST(year AS INT) ORDER BY COUNT(name) DESC\").fetchone()\r\n    return rows[0]\r\n    \r\n\r\nprint(player_with_max_points_per_game())\r\nprint(number_of_players_from_duke())\r\nprint(avg_years_active_players_stanford())\r\nprint(year_with_most_new_players())",
            "score": 3,
            "number_code_submits": 2,
            "tags": "data analysis, databases, SQL, sqlite3",
            "in_paths": "Data Analysis, Data Formats"
        },
        {
            "bite": "Bite 197. What date is Mother's Day celebrated?",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-10 20:33:13.527118+00:00",
            "passing_code": "from datetime import date\r\nimport dateutil.relativedelta as rd\r\n\r\n\r\ndef get_mothers_day_date(year):\r\n    \"\"\"Given the passed in year int, return the date Mother's Day\r\n       is celebrated assuming it's the 2nd Sunday of May.\"\"\"\r\n    start=date(year=year, month=4, day=30)\r\n    return start+rd.relativedelta(days=+1, weekday=rd.SU(+2))\r\n    \r\nfor year in range(2018,2028,1):\r\n    print(get_mothers_day_date(year))\r\n",
            "score": 3,
            "number_code_submits": 2,
            "tags": "datetime, dateutil",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 198. Calculate my Mac's longest uptime",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-11 00:20:46.639815+00:00",
            "passing_code": "from datetime import date, datetime\r\n\r\n\r\nMAC1 = \"\"\"\r\nreboot    ~                         Wed Apr 10 22:39\r\nreboot    ~                         Wed Mar 27 16:24\r\nreboot    ~                         Wed Mar 27 15:01\r\nreboot    ~                         Sun Mar  3 14:51\r\nreboot    ~                         Sun Feb 17 11:36\r\nreboot    ~                         Thu Jan 17 21:54\r\nreboot    ~                         Mon Jan 14 09:25\r\n\"\"\"\r\n\r\nYEAR=date.today().year\r\n\r\ndef calc_max_uptime(reboots):\r\n    \"\"\"Parse the passed in reboots output,\r\n       extracting the datetimes.\r\n\r\n       Calculate the highest uptime between reboots =\r\n       highest diff between extracted reboot datetimes.\r\n\r\n       Return a tuple of this max uptime in days (int) and the\r\n       date (str) this record was hit.\r\n\r\n       For the output above it would be (30, '2019-02-17'),\r\n       but we use different outputs in the tests as well ...\r\n    \"\"\"\r\n    time_objects=[]\r\n    for line in reboots.strip().splitlines():\r\n        _, timestamp_raw =line.split('~')\r\n        timestamp=f'{YEAR} {timestamp_raw.strip()[4:]}'\r\n        time_objects.append(datetime.strptime(timestamp,'%Y %b %d %H:%M'))\r\n        # print(timestamp, str(time_object))\r\n    \r\n    durations = [(\r\n                    (time_objects[i]-time_objects[i+1]).days, \r\n                    datetime.strftime(time_objects[i],'%Y-%m-%d')\r\n                    ) for i in range(len(time_objects)-1)\r\n                ]\r\n    return max(durations, key=lambda x:x[0])\r\n        \r\n        \r\nprint(calc_max_uptime(MAC1))",
            "score": 4,
            "number_code_submits": 3,
            "tags": "data wrangling, datetime, dateutil, string parsing",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 200. \ud83e\udd73 Minecraft Enchantable Items",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-11 22:54:22.994332+00:00",
            "passing_code": "import os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup as Soup\r\nimport re\r\nfrom pprint import pprint\r\n\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nHTML_FILE = TMP / \"enchantment_list_pc.html\"\r\n\r\n# source:\r\n# https://www.digminecraft.com/lists/enchantment_list_pc.php\r\nURL = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n       \"minecraft-enchantment.html\")\r\n\r\n\r\nclass Enchantment:\r\n    \"\"\"Minecraft enchantment class\r\n    \r\n    Implements the following: \r\n        id_name, name, max_level, description, items\r\n    \"\"\"\r\n    \r\n    LEVEL={'I':1, 'II':2, 'III':3, 'IV':4 , 'V':5}\r\n    \r\n    def __init__(self, id_name, name, max_level, description, items = None):\r\n        \r\n        self.id_name = id_name  # Internal name of the enchantment\r\n        self.name = name  # User friendly name of the enchantment\r\n        self.max_level = max_level  # Enchantment level. Original is in Roman numerals; they need to be converted to integers\r\n        self.description = description  # Summary of what the enchantment does\r\n        self.items = items or [] # List of item names that are typically enchanted with this enchantment.\r\n\r\n    def __repr__(self):\r\n        return f'{self.name.title()} ({self.max_level}): {self.description}'\r\n\r\nclass Item:\r\n    \"\"\"Minecraft enchantable item class\r\n    \r\n    Implements the following: \r\n        name, enchantments\r\n    \"\"\"\r\n\r\n    def __init__(self, name, enchantments = None):\r\n        \r\n        self.name = name\r\n        self.enchantments = enchantments or []\r\n        \r\n    def __repr__(self):\r\n        result= f'{self.name.title()}: \\n'\r\n        for enchantment in sorted(self.enchantments,key=lambda x:x.id_name):\r\n            result+=f'  [{enchantment.max_level}] {enchantment.id_name}\\n'\r\n        return result\r\n\r\n\r\ndef _get_items(string):\r\n    \r\n    filename=string.split('/')[-1].split('.')[0]\r\n    # replace fishing_rod fishing-rod\r\n    filename=filename.replace('fishing_rod', 'fishing-rod')\r\n    items_raw=filename.split('_')\r\n    items = [item for item in items_raw if item.lower() not in ['enchanted','iron', 'sm']]\r\n    return list(map(lambda x: x.replace('fishing-rod','fishing_rod'),items))\r\n\r\ndef generate_enchantments(soup):\r\n    \"\"\"Generates a dictionary of Enchantment objects\r\n    \r\n    With the key being the id_name of the enchantment.\r\n    \"\"\"\r\n    table = soup.find('table',{'id':'minecraft_items'})\r\n    rows = table.find_all('tr')\r\n    enchantments={}\r\n    for row in rows[1:]:\r\n        # print(row)\r\n        cols = row.find_all('td')\r\n        id_name = cols[0].em.text\r\n        # id_name = re.search('(?<=/enchantments/)[A-Za-z_]+(?=\\.php)',id_name_raw).group(0)\r\n        # print(id_name_raw, id_name)\r\n        name = cols[0].a.text\r\n        max_level = Enchantment.LEVEL[cols[1].text.upper()] \r\n        description = cols[2].text\r\n        items = _get_items(cols[4].find('img',{'class':'img-rounded'})['data-src'])\r\n        enchantments[id_name]=Enchantment(id_name, name, max_level, description,items)\r\n    return enchantments\r\n\r\n\r\ndef _get_item_name(item_id):\r\n    return \" \".join(item_id.split('_')).title()\r\n\r\n\r\ndef generate_items(data):\r\n    \"\"\"Generates a dictionary of Item objects\r\n    \r\n    With the key being the item name.\r\n    \"\"\"\r\n    items_dict= {}\r\n    \r\n    for enchantment in data.values():\r\n        for item_id in enchantment.items:\r\n            #create Item object with this enchantment or append enchantment if Item exists\r\n            if item_id in items_dict:\r\n                items_dict[item_id].enchantments.append(enchantment)\r\n            else:\r\n                items_dict[item_id] = Item(_get_item_name(item_id),[enchantment])\r\n    return items_dict\r\n    \r\n\r\n\r\ndef get_soup(file=HTML_FILE):\r\n    \"\"\"Retrieves/takes source HTML and returns a BeautifulSoup object\"\"\"\r\n    if isinstance(file, Path):\r\n        if not file.is_file():\r\n            urlretrieve(URL, file)\r\n\r\n        with file.open() as html_source:\r\n            soup = Soup(html_source, \"html.parser\")\r\n    else:\r\n        soup = Soup(file, \"html.parser\")\r\n\r\n    return soup\r\n\r\n\r\ndef main():\r\n    \"\"\"This function is here to help you test your final code.\r\n    \r\n    Once complete, the print out should match what's at the bottom of this file\"\"\"\r\n    soup = get_soup()\r\n    enchantment_data = generate_enchantments(soup)\r\n    print(enchantment_data)\r\n    minecraft_items = generate_items(enchantment_data)\r\n    for item in minecraft_items:\r\n        print(minecraft_items[item], \"\\n\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n    \r\n    mock_html = \"\"\"\r\n<table id=\"minecraft_items\" class=\"std_table\">\r\n<tr>\r\n<th data-search=\"1\" width=\"175\">Enchantment<br>(<em>Minecraft ID Name</em>)</th>\r\n<th data-search=\"1\">Max Level</th>\r\n<th class=\"hidden-xs\">Description</th>\r\n<th data-search=\"1\"><span class=\"hidden-xs\">Minecraft </span>ID</th>\r\n<th class=\"hidden-xs\">Items</th>\r\n<th>Version</th>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/aqua_affinity.php\">Aqua Affinity</a><br>(<em>aqua_<wbr>affinity</em>)</td>\r\n<td>I</td>\r\n<td class=\"hidden-xs\">Speeds up how fast you can mine blocks underwater</td>\r\n<td>6</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/armor_recipes/images/enchanted_iron_helmet.png\" alt=\"aqua affinity\" width=\"40\" height=\"40\"></td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/bane_of_arthropods.php\">Bane of Arthropods</a><br>(<em>bane_<wbr>of_<wbr>arthropods</em>)</td>\r\n<td>V</td>\r\n<td class=\"hidden-xs\">Increases attack damage against arthropods</td>\r\n<td>18</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/enchantments/images/sword_axe_sm.png\" alt=\"bane of arthropods\" width=\"40\" height=\"40\"></td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/blast_protection.php\">Blast Protection</a><br>(<em>blast_<wbr>protection</em>)</td>\r\n<td>IV</td>\r\n<td class=\"hidden-xs\">Reduces blast and explosion damage</td>\r\n<td>3</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/enchantments/images/armor_sm.png\" alt=\"blast protection\" width=\"40\" height=\"40\"></td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/channeling.php\">Channeling</a><br>(<em>channeling</em>)</td>\r\n<td>I</td>\r\n<td class=\"hidden-xs\">Summons a lightning bolt at a targeted mob when enchanted item is thrown (targeted mob must be standing in raining)</td>\r\n<td>68</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/weapon_recipes/images/enchanted_trident.png\" alt=\"channeling\" width=\"40\" height=\"40\"></td>\r\n<td>1.13</td>\r\n</tr>\r\n</table>\r\n\"\"\"\r\n    pprint(generate_enchantments(get_soup(mock_html)))\r\n    \r\n    \r\n\"\"\"\r\nArmor: \r\n  [1] binding_curse\r\n  [4] blast_protection\r\n  [4] fire_protection\r\n  [4] projectile_protection\r\n  [4] protection\r\n  [3] thorns \r\n\r\nAxe: \r\n  [5] bane_of_arthropods\r\n  [5] efficiency\r\n  [3] fortune\r\n  [5] sharpness\r\n  [1] silk_touch\r\n  [5] smite \r\n\r\nBoots: \r\n  [3] depth_strider\r\n  [4] feather_falling\r\n  [2] frost_walker \r\n\r\nBow: \r\n  [1] flame\r\n  [1] infinity\r\n  [5] power\r\n  [2] punch \r\n\r\nChestplate: \r\n  [1] mending\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nCrossbow: \r\n  [1] multishot\r\n  [4] piercing\r\n  [3] quick_charge \r\n\r\nFishing Rod: \r\n  [3] luck_of_the_sea\r\n  [3] lure\r\n  [1] mending\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nHelmet: \r\n  [1] aqua_affinity\r\n  [3] respiration \r\n\r\nPickaxe: \r\n  [5] efficiency\r\n  [3] fortune\r\n  [1] mending\r\n  [1] silk_touch\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nShovel: \r\n  [5] efficiency\r\n  [3] fortune\r\n  [1] silk_touch \r\n\r\nSword: \r\n  [5] bane_of_arthropods\r\n  [2] fire_aspect\r\n  [2] knockback\r\n  [3] looting\r\n  [1] mending\r\n  [5] sharpness\r\n  [5] smite\r\n  [3] sweeping\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nTrident: \r\n  [1] channeling\r\n  [5] impaling\r\n  [3] loyalty\r\n  [3] riptide\r\n\"\"\"\r\n\r\n\r\n",
            "score": 9,
            "number_code_submits": 14,
            "tags": "beautifulsoup, web scraping",
            "in_paths": "Web Scraping"
        },
        {
            "bite": "Newbie Bite 01. Assigning Objects",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-09 12:27:43.774812+00:00",
            "passing_code": "# Enter your code below this line:\r\nbobs_age = 86",
            "score": 0,
            "number_code_submits": 1,
            "tags": "freebie, newbie, variables",
            "in_paths": "Bioinformatics"
        },
        {
            "bite": "Newbie Bite 02. Basic Data Types",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-09 12:31:21.937500+00:00",
            "passing_code": "# Enter your code below this line\r\nmy_integer = 29\r\nmy_float = 400.68\r\nmy_lie = \"I love data types!\"",
            "score": 0,
            "number_code_submits": 1,
            "tags": "data types, freebie, newbie",
            "in_paths": "Web Scraping"
        },
        {
            "bite": "Newbie Bite 03. Basic Printing",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-09 12:36:34.619221+00:00",
            "passing_code": "# Enter your code below this line:\r\nprint(\"I find it unbearable that there are people out there who think DC is better than Marvel!\")",
            "score": 0,
            "number_code_submits": 1,
            "tags": "freebie, newbie, print",
            "in_paths": ""
        },
        {
            "bite": "Newbie Bite 04. Printing Objects",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-11 01:22:19.904190+00:00",
            "passing_code": "year = 2016\r\nmonth = \"December\"\r\nname = \"PyBites\"\r\n\r\n# Type your print statement below this line\r\nprint(f\"{name} was founded in {month} {year}.\")\r\n",
            "score": 0,
            "number_code_submits": 5,
            "tags": "newbie, print",
            "in_paths": ""
        },
        {
            "bite": "Newbie Bite 05. Basic Maths",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-12 19:59:23.690021+00:00",
            "passing_code": "# As per the instructions, assign the requested integer to the below objects, a and b,\r\n# then assign the calculation to the object \"answer\".\r\na = 7\r\nb = 3\r\nanswer = a + b",
            "score": 0,
            "number_code_submits": 2,
            "tags": "math, newbie",
            "in_paths": "Bioinformatics"
        },
        {
            "bite": "Newbie Bite 06. Additional Maths",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-14 20:15:25.246352+00:00",
            "passing_code": "# In the same way as the previous Bite, assign the relative calculations of a and b\r\n# to the objects as per the above instructions\r\na = 10\r\nb = 5\r\n\r\n# Enter your code below this line\r\n\r\nsubtraction = a - b\r\nmultiplication = a * b\r\ndivision = a/b",
            "score": 0,
            "number_code_submits": 2,
            "tags": "math, newbie",
            "in_paths": ""
        },
        {
            "bite": "Bite 202. Analyze some Bite stats data - part II",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-27 21:28:03.063476+00:00",
            "passing_code": "import csv\r\nimport os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\nimport re\r\nfrom collections import defaultdict, Counter\r\n\r\ndata = 'https://bites-data.s3.us-east-2.amazonaws.com/bite_levels.csv'\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nstats = TMP / 'bites.csv'\r\n\r\nif not stats.exists():\r\n    urlretrieve(data, stats)\r\n\r\n\r\ndef get_most_complex_bites(N=10, stats=stats):\r\n    \"\"\"Parse the bites.csv file (= stats variable passed in), see example\r\n       output in the Bite description.\r\n       Return a list of Bite IDs (int or str values are fine) of the N\r\n       most complex Bites.\r\n    \"\"\"\r\n    with open(stats,encoding=\"utf-8-sig\") as f:\r\n        result=defaultdict(float)\r\n        bites = [(row['Bite'], row['Difficulty']) for row in csv.DictReader(f.read().splitlines(), delimiter=';')]\r\n        for bite, difficulty in bites:\r\n            bite_stripped = re.search('(?<=Bite )[0-9]+(?=\\.)', bite)\r\n            if not bite_stripped: # exclude three special PyCon19 bites which use : not . - Difficulty is None anyway \r\n                # print(bite, difficulty)\r\n                continue\r\n            if difficulty == 'None': # exclude bites with Difficulty None\r\n                continue\r\n            result[bite_stripped[0]]=float(difficulty)\r\n    return [int(item[0]) for item in Counter(result).most_common(N)]  \r\n\r\n\r\nif __name__ == '__main__':\r\n    res = get_most_complex_bites()\r\n    print(res)",
            "score": 3,
            "number_code_submits": 4,
            "tags": "csv, data analysis, sorting",
            "in_paths": "Data Analysis, Data Formats"
        },
        {
            "bite": "Bite 203. Type hinting practice",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "classes, dataclasses, type hinting",
            "in_paths": ""
        },
        {
            "bite": "Bite 205. Female speakers @ Pycon US",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-26 15:11:55.979353+00:00",
            "passing_code": "from urllib.request import urlretrieve\r\nimport os\r\nfrom pathlib import Path\r\n\r\nimport gender_guesser.detector as gender\r\nfrom bs4 import BeautifulSoup as Soup\r\nfrom pprint import pprint\r\nimport re\r\nfrom collections import Counter\r\n\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nPYCON_HTML = TMP / \"pycon2019.html\"\r\nPYCON_PAGE = ('https://bites-data.s3.us-east-2.amazonaws.com/'\r\n              'pycon2019.html')\r\n\r\nif not PYCON_HTML.exists():\r\n    urlretrieve(PYCON_PAGE, PYCON_HTML)\r\n\r\n\r\ndef _get_soup(html=PYCON_HTML):\r\n    return Soup(html.read_text(encoding=\"utf-8\"), \"html.parser\")\r\n\r\n\r\ndef get_pycon_speaker_first_names(soup=None):\r\n    \"\"\"Parse the PYCON_HTML using BeautifulSoup, extracting all\r\n       speakers (class \"speaker\"). Note that some items contain\r\n       multiple speakers so you need to extract them.\r\n       Return a list of first names\r\n    \"\"\"\r\n    if not soup:\r\n        soup=_get_soup()\r\n    list_speakers=soup.find_all('span', class_='speaker')\r\n    return [name.strip().split()[0] for item in list_speakers for name in re.split(',|/',item.text.strip()) ]\r\n\r\n\r\ndef get_percentage_of_female_speakers(first_names):\r\n    \"\"\"Run gender_guesser on the names returning a percentage\r\n       of female speakers (female and mostly_female),\r\n       rounded to 2 decimal places.\"\"\"\r\n    d = gender.Detector()\r\n    count = Counter(1 for name in first_names if d.get_gender(name) in {'female', 'mostly_female'})[1]\r\n    return round(100*count/len(first_names),2)\r\n\r\nif __name__ == '__main__':\r\n    names = get_pycon_speaker_first_names()\r\n    # pprint(names)\r\n    perc = get_percentage_of_female_speakers(names)\r\n    print(perc)\r\n",
            "score": 3,
            "number_code_submits": 2,
            "tags": "beautifulsoup, counting, data wrangling, gender_guesser",
            "in_paths": "Web Scraping"
        },
        {
            "bite": "Bite 206. Calculate and evenly split the bill",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-16 19:23:10.089826+00:00",
            "passing_code": "import decimal\r\n\r\ndef check_split(item_total, tax_rate, tip, people):\r\n    \"\"\"Calculate check value and evenly split.\r\n\r\n       :param item_total: str (e.g. '$8.68')\r\n       :param tax_rate: str (e.g. '4.75%)\r\n       :param tip: str (e.g. '10%')\r\n       :param people: int (e.g. 3)\r\n\r\n       :return: tuple of (grand_total: str, splits: list)\r\n                e.g. ('$10.00', [3.34, 3.33, 3.33])\r\n    \"\"\"\r\n    \r\n    \r\n    \"\"\"ctx = decimal.getcontext()\r\n    ctx.rounding = decimal.ROUND_HALF_EVEN\r\n    \"\"\"\r\n    \r\n    item_total = decimal.Decimal(item_total.lstrip('$'))\r\n    tax = item_total * decimal.Decimal(tax_rate.rstrip('%'))/decimal.Decimal('100')\r\n    tax = tax.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_HALF_EVEN)\r\n\r\n    after_tax= item_total + tax\r\n    \r\n    tip = after_tax * decimal.Decimal(tip.rstrip('%'))/decimal.Decimal('100')\r\n    tip = tip.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_HALF_EVEN)\r\n\r\n    grand_total= after_tax + tip\r\n    grand_total = grand_total.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_HALF_EVEN)\r\n    \r\n    per_person= grand_total / people\r\n    per_person = per_person.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_HALF_EVEN)\r\n    \r\n    split=[per_person for _ in range(people)]\r\n    split[0]+=grand_total-sum(split)\r\n    \r\n    grand_total=f'${grand_total}'\r\n    \r\n    return (grand_total, split)\r\n    \r\n    \r\nprint(check_split('$9.99', '3.25%', '10%', 2))  # ('$9.99', '3.25%', '10%', 2), expected = '$11.34' vs '$11.35'\r\nprint(check_split('$186.70', '6.75%', '18%', 6))  # ('$186.70', '6.75%', '18%', 6), expected = '$235.17' vs '$235.18'\r\nprint(check_split('$141.86', '2%', '18%', 9))  # ('$141.86', '2%', '18%', 9), expected = '$170.75' vs '$170.74'\r\n\r\n\r\n",
            "score": 3,
            "number_code_submits": 14,
            "tags": "Decimal, numbers, rounding",
            "in_paths": ""
        },
        {
            "bite": "Bite 208. Find the number pairs summing up N",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-18 19:25:32.007038+00:00",
            "passing_code": "def find_number_pairs(numbers, N=10):\r\n\r\n    return [(n1,n2) for i,n1 in enumerate(numbers) for n2 in numbers[i+1:] if n1+n2 == N]\r\n\r\n    \"\"\" this works \r\n    lst = []\r\n    for i,n1 in enumerate(numbers):\r\n        for n2 in numbers[i+1:]:\r\n            # print(f\"{n1},{n2}\")\r\n            if n1+n2 == N:\r\n                lst.append((n1,n2))\r\n                \r\n    return lst\r\n    \"\"\"\r\n    \r\ntest2 = [0.24, 0.36, 0.04, 0.06, 0.33, 0.08, 0.20, 0.27, 0.3, 0.31, 0.76, 0.05, 0.08, 0.08, 0.67, 0.09, 0.66, 0.79, 0.95]\r\nprint(find_number_pairs(test2, N=1))\r\n\r\n\r\n",
            "score": 2,
            "number_code_submits": 4,
            "tags": "itertools, looping, numbers",
            "in_paths": "Itertools"
        },
        {
            "bite": "Newbie Bite 07. User Input",
            "completed": true,
            "cheated": true,
            "date_first_completed": "2022-09-14 20:22:18.372259+00:00",
            "passing_code": "# Enter your code below this line\r\nmonth = input(\"What's the name of the 12th month of the calendar year? \")",
            "score": 0,
            "number_code_submits": 10,
            "tags": "input, newbie",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Newbie Bite 08. String Manipulation",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-15 15:50:58.497366+00:00",
            "passing_code": "autobot = \"Optimus\"\r\ndecepticon = \"megatron\"\r\ntransformers = \"robots in disguise\"\r\n\r\n# Enter your code below this line\r\n\r\nlowercase_autobot = autobot.lower()\r\nuppercase_decepticon = decepticon.upper()\r\ntitlecase_transformers = transformers.title()",
            "score": 0,
            "number_code_submits": 3,
            "tags": "newbie, string manipulation",
            "in_paths": ""
        },
        {
            "bite": "Newbie Bite 09. Lists",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-15 15:52:58.175134+00:00",
            "passing_code": "# Enter your code below this line\r\n\r\nninjabelts = [\"white\", \"yellow\", \"orange\", \"green\", \"blue\", \"brown\", \"black\"]",
            "score": 0,
            "number_code_submits": 3,
            "tags": "list, newbie",
            "in_paths": "Algorithms, Python Beginner"
        },
        {
            "bite": "Newbie Bite 10. Returning items by list index",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-15 15:54:59.415504+00:00",
            "passing_code": "ninjabelts = ['white', 'yellow', 'orange', 'green', 'blue', 'brown', 'black']\r\n\r\n# Code all three requirements below this line\r\n\r\nninjabelts[-1]\r\nninjabelts[4]\r\nninjabelts[0]",
            "score": 0,
            "number_code_submits": 2,
            "tags": "list, newbie",
            "in_paths": ""
        },
        {
            "bite": "Newbie Bite 11. Adding and Removing items from a list",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-15 15:56:12.016566+00:00",
            "passing_code": "ninjabelts = ['white', 'yellow', 'orange', 'green', 'blue', 'brown', 'black']\r\n\r\n# Add 'bronze' and remove 'blue' from the ninjabelts list. Code below this line:\r\n\r\n\r\nninjabelts.append('bronze')\r\nninjabelts.remove('blue')",
            "score": 0,
            "number_code_submits": 2,
            "tags": "list, newbie",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Newbie Bite 12. Dicts",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-26 21:56:54.766880+00:00",
            "passing_code": "# This is the old list of ninjabelts for your reference.\r\nninjabelts = [\"white\", \"yellow\", \"orange\", \"green\", \"blue\", \"brown\", \"black\"]\r\n\r\n# Create your dictionary below this line:\r\nninjabelt_scores = {\r\n    \"white\": 10,\r\n    \"yellow\": 20,\r\n    \"orange\": 30,\r\n    \"green\": 40,\r\n    \"blue\": 50,\r\n    \"brown\": 60,\r\n    \"black\": 70,\r\n}",
            "score": 0,
            "number_code_submits": 2,
            "tags": "dict, list, newbie",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Newbie Bite 13. Dict data retrieval methods",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-29 18:29:28.470614+00:00",
            "passing_code": "ninjabelt_scores = {'white': 10, 'yellow': 20, 'orange': 30, 'green': 40, 'blue': 50, 'brown': 60, 'black': 70}\r\n\r\n# Try the 3 functions against the ninjabelts_scores dict below this line:\r\nninjabelt_scores.items()\r\nninjabelt_scores.keys()\r\nninjabelt_scores.values()",
            "score": 0,
            "number_code_submits": 3,
            "tags": "newbie",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 209. Write a Sphinx docstring",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-30 09:52:15.023107+00:00",
            "passing_code": "def sum_numbers(numbers):\r\n    \"\"\"Sums numbers\r\n    \r\n    :param numbers: List of numbers to add, defaults to None\r\n    :type numbers: list, optional\r\n\r\n    :raises TypeError: not all numeric values passed in\r\n    \r\n    :return: Sum of numbers\r\n    :rtype: int\r\n    \"\"\"\r\n    pass",
            "score": 2,
            "number_code_submits": 5,
            "tags": "data types, docstring, sphinx",
            "in_paths": ""
        },
        {
            "bite": "Bite 210. Add Type Annotations",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-31 10:39:38.245492+00:00",
            "passing_code": "from typing import List\r\n\r\ndef sum_numbers(numbers: List[int]) -> int:\r\n    \"\"\"Sums numbers\r\n\r\n    :param numbers: a list of numbers\r\n    :type numbers: list\r\n    :raises TypeError: if not all numeric values passed in\r\n    :return: sum of numbers\r\n    :rtype: int\r\n    \"\"\"\r\n    pass",
            "score": 2,
            "number_code_submits": 3,
            "tags": "annotations, typing",
            "in_paths": ""
        },
        {
            "bite": "Bite 212. Suppressing exceptions",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-01 20:52:27.661156+00:00",
            "passing_code": "from contextlib import suppress\r\n\r\n\r\ndef sum_numbers(numbers):\r\n    \"\"\"This generator divides each number by its consecutive number.\r\n       So if it gets passed in [4, 2, 1] it yields 4/2 and 2/1.\r\n       It ignores ZeroDivisionError and TypeError exceptions (latter happens\r\n       when a string or other non-numeric data type is in numbers)\r\n\r\n       Task: use contextlib's suppress twice to make the code below more concise.\r\n    \"\"\"\r\n    for i, j in zip(numbers, numbers[1:]):\r\n        # replace the block below\r\n        with suppress(TypeError):\r\n            with suppress(ZeroDivisionError):\r\n                yield i/j\r\n    ",
            "score": 3,
            "number_code_submits": 3,
            "tags": "context managers, exception handling",
            "in_paths": "Decorators and Context Managers"
        },
        {
            "bite": "Bite 214. A countdown generator",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-01 20:43:15.792441+00:00",
            "passing_code": "def countdown():\r\n    \"\"\"Write a generator that counts from 100 to 1\"\"\"\r\n    COUNT = 100\r\n    for i in range(COUNT):\r\n        yield COUNT-i\r\n\r\n\"\"\"test for COUNT =5\r\n\r\ncd = countdown()\r\nprint(next(cd))\r\nprint(next(cd))\r\nprint(next(cd))\r\nprint(next(cd))\r\nprint(next(cd))\r\n\r\nnext(cd)\r\n\"\"\"",
            "score": 2,
            "number_code_submits": 3,
            "tags": "generators",
            "in_paths": ""
        },
        {
            "bite": "Bite 215. Validate a license key",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-06 17:04:22.831349+00:00",
            "passing_code": "import re\r\n\r\n\r\ndef validate_license(key: str) -> bool:\r\n    \"\"\"Write a regex that matches a PyBites license key\r\n       (e.g. PB-U8N435EH-PG65PW87-IXPWQG5T-898XSZI4)\r\n    \"\"\"\r\n    is_valid = re.match('^PB(-([A-Z0-9]){8}){4}$',key)\r\n    return bool(is_valid)\r\n    \r\n# print(validate_license('pb-uhszep2x-ra1jiwmc-j0t3bszn-9qhw6g1n'))",
            "score": 2,
            "number_code_submits": 4,
            "tags": "bool, regular expressions",
            "in_paths": "Regular Expressions"
        },
        {
            "bite": "Bite 217. Capture stdout",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-28 17:42:39.559932+00:00",
            "passing_code": "from contextlib import redirect_stdout\r\nfrom io import StringIO\r\nfrom types import BuiltinFunctionType\r\n\r\n\r\ndef get_len_help_text(builtin: BuiltinFunctionType) -> int:\r\n    \"\"\"Receives a builtin, and returns the length of its help text.\r\n       You need to redirect stdout from the help builtin.\r\n       If the the object passed in is not a builtin, raise a ValueError.\r\n    \"\"\"\r\n    if not isinstance(builtin, BuiltinFunctionType):\r\n        raise ValueError\r\n    \r\n    with redirect_stdout(StringIO()) as f:\r\n        help(builtin)\r\n    s = f.getvalue()\r\n    return len(s)",
            "score": 3,
            "number_code_submits": 3,
            "tags": "context managers, StringIO",
            "in_paths": "Decorators and Context Managers"
        },
        {
            "bite": "Bite 218. Create a sandwich decorator",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-15 17:05:53.519629+00:00",
            "passing_code": "from functools import wraps\r\n\r\nUPPER_SLICE = \"=== Upper bread slice ===\"\r\nLOWER_SLICE = \"=== Lower bread slice ===\"\r\n\r\n\r\ndef sandwich(func):\r\n    \"\"\"Write a decorator that prints UPPER_SLICE and\r\n       LOWER_SLICE before and after calling the function (func)\r\n       that is passed in  (@wraps is to preserve the original\r\n       func's docstring)\r\n    \"\"\"\r\n    @wraps(func)\r\n    def wrapped(*args, **kwargs):\r\n        # do stuff before the original function gets called\r\n        print(UPPER_SLICE)\r\n        # call function\r\n        func(*args, **kwargs)\r\n        # do stuff after function call \r\n        print(LOWER_SLICE)\r\n        # return the result\r\n        # return result\r\n    # return wrapper as a decorated function\r\n    return wrapped\r\n    \r\n    \r\nif __name__ == \"__main__\":\r\n    \r\n    @sandwich\r\n    def add_ingredients(ingredients):\r\n        print(' / '.join(ingredients))\r\n\r\n    ingredients = ['bacon', 'lettuce', 'tomato']\r\n    add_ingredients(ingredients)",
            "score": 2,
            "number_code_submits": 2,
            "tags": "decorators",
            "in_paths": "Decorators and Context Managers"
        },
        {
            "bite": "Bite 225. Swap case PyBites characters",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-04 07:37:39.052473+00:00",
            "passing_code": "PYBITES = \"pybites\"\r\n\r\n\r\ndef convert_pybites_chars(text):\r\n    \"\"\"Swap case all characters in the word pybites for the given text.\r\n       Return the resulting string.\"\"\"\r\n    result=[]\r\n    for letter in text:\r\n        if letter in PYBITES:\r\n            letter = letter.upper()\r\n        elif letter in PYBITES.upper():\r\n            letter = letter.lower()\r\n        result.append(letter)\r\n    return \"\".join(result)\r\n    \r\ntext = \"Today we added TWO NEW Bites to our Platform, exciting!\"\r\nprint(convert_pybites_chars(text))",
            "score": 2,
            "number_code_submits": 2,
            "tags": "looping, string manipulation, string parsing",
            "in_paths": ""
        },
        {
            "bite": "Bite 226. Get top titles from news.python.sc",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-11 14:15:28.058728+00:00",
            "passing_code": "from collections import namedtuple\r\n\r\nfrom bs4 import BeautifulSoup\r\nimport requests\r\nimport re\r\n\r\n# feed = https://news.python.sc/, to get predictable results we cached\r\n# first two pages - use these:\r\n# https://bites-data.s3.us-east-2.amazonaws.com/news.python.sc/index.html\r\n# https://bites-data.s3.us-east-2.amazonaws.com/news.python.sc/index2.html\r\n\r\nEntry = namedtuple('Entry', 'title points comments')\r\n\r\n\r\ndef _create_soup_obj(url):\r\n    \"\"\"Need utf-8 to properly parse emojis\"\"\"\r\n    resp = requests.get(url)\r\n    resp.encoding = \"utf-8\"\r\n    return BeautifulSoup(resp.text, \"html.parser\")\r\n\r\n\r\ndef get_top_titles(url, top=5):\r\n    \"\"\"Parse the titles (class 'title') using the soup object.\r\n       Return a list of top (default = 5) titles ordered descending\r\n       by number of points and comments.\r\n    \"\"\"\r\n    soup = _create_soup_obj(url)\r\n\r\n    # your code ...\r\n    lst=[]\r\n    \r\n    titles_spans=soup.find_all('span',{'class':'title'})\r\n    points_spans=soup.find_all('span',{'class':'controls'})\r\n    comments_spans=soup.find_all('span',{'class':'naturaltime'})\r\n\r\n    for title,points,comments in zip(titles_spans,points_spans,comments_spans):\r\n        title=f\"{title.text.strip()}\"\r\n        points=int(re.search('[0-9]+',points.span.text)[0])\r\n        comments=int(re.search('[0-9]+',comments.span.a.text)[0])\r\n        entry=Entry(title,points,comments)\r\n        lst.append(entry)\r\n        \r\n    return sorted(lst,key=lambda x:x.points+x.comments, reverse=True)[:top]\r\n    \r\n    \r\nurl = 'https://bites-data.s3.us-east-2.amazonaws.com/news.python.sc/index.html'\r\nprint(get_top_titles(url))",
            "score": 3,
            "number_code_submits": 4,
            "tags": "beautifulsoup, namedtuple, news, requests, sorting, string parsing, web scraping",
            "in_paths": "Web Scraping"
        },
        {
            "bite": "Bite 228. Create a Gravatar URL",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "gravatar, hashlib, string formatting",
            "in_paths": ""
        },
        {
            "bite": "Bite 229. Scrape best programming books",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-08 11:04:04.894873+00:00",
            "passing_code": "import os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup\r\nfrom pprint import pprint \r\n\r\nurl = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n       \"best-programming-books.html\")\r\ntmp = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nhtml_file = tmp / \"books.html\"\r\n\r\n\r\nif not html_file.exists():\r\n    urlretrieve(url, html_file)\r\n\r\n\r\nclass Book:\r\n    \"\"\"Book class should instantiate the following variables:\r\n\r\n    title - as it appears on the page\r\n    author - should be entered as lastname, firstname\r\n    year - four digit integer year that the book was published\r\n    rank - integer rank to be updated once the books have been sorted\r\n    rating - float as indicated on the page\r\n    \"\"\"\r\n    def __init__(self, title:str, author:str, year:int, rank: int, rating:float):\r\n        self.title = title # as it appears on the page\r\n        self.author = author # should be entered as lastname, firstname\r\n        self.year = year # four digit integer year that the book was published\r\n        self.rank = rank # integer rank to be updated once the books have been sorted\r\n        self.rating = float(rating) # float as indicated on the page\r\n\r\n\r\n    def __repr__(self):\r\n        return f'[{self.rank:03d}] {self.title} ({self.year})\\n      {self.author} {self.rating}'\r\n\r\ndef _get_soup(file):\r\n    return BeautifulSoup(file.read_text(), \"html.parser\")\r\n\r\n\r\ndef display_books(books, limit=10, year=None):\r\n    \"\"\"Prints the specified books to the console\r\n\r\n    :param books: list of all the books\r\n    :param limit: integer that indicates how many books to return\r\n    :param year: integer indicating the oldest year to include\r\n    :return: None\r\n    \"\"\"\r\n    books_until_year = [book for book in books if year is None or book.year >= year]\r\n    for book in books_until_year[:limit]:\r\n        print(book)\r\n\r\n\r\ndef load_data():\r\n    \"\"\"Loads the data from the html file\r\n\r\n    Creates the soup object and processes it to extract the information\r\n    required to create the Book class objects and returns a sorted list\r\n    of Book objects.\r\n\r\n    Books should be sorted by rating, year, title, and then by author's\r\n    last name. After the books have been sorted, the rank of each book\r\n    should be updated to indicate this new sorting order.The Book object\r\n    with the highest rating should be first and go down from there.\r\n    \"\"\"\r\n    soup = _get_soup(html_file)\r\n    books = soup.find_all('div', {'class': 'book accepted normal'})\r\n    result = []\r\n    for book in books:\r\n        try:\r\n            rank = book.find('div', {'class': 'rank'}).span.get_text()\r\n            title = book.find('h2', {'class':  'main'}).get_text()\r\n            authors = book.find('h3', {'class':  'authors'}).a.get_text()\r\n            year = book.find('span', {'class': 'date'}).get_text().strip('| ')\r\n            rating = book.find('span', {'class':  'our-rating'}).get_text()\r\n        except AttributeError:\r\n            continue\r\n        # format\r\n        rank = int(rank)\r\n        # assumes one author only and surname is last word only\r\n        names = authors.split()\r\n        name= \" \".join(names[:-1]) \r\n        surname = names[-1]\r\n        author = f'{surname}, {name}'\r\n        year = int(year) # why insists in 4 digits?\r\n        rating = float(rating)\r\n        if 'python' in title.lower():\r\n            result.append(Book(title, author, year, rank, rating))\r\n    # sort descending by rating \r\n    # ascending by year, \r\n    # by title case insensitive but don't change the original\r\n    # and then by author's last name\r\n    # in that order\r\n    result.sort(key=lambda x:x.author.split(',')[0])\r\n    result.sort(key=lambda x:x.title.lower())\r\n    result.sort(key=lambda x:x.year)\r\n    result.sort(key=lambda x:x.rating, reverse = True)\r\n    # update ranks\r\n    for i, book in enumerate(result):\r\n        book.rank = i+1\r\n    return result\r\n        \r\n\r\n\r\ndef main():\r\n    books = load_data()\r\n    display_books(books, limit=5, year=2017)\r\n    \"\"\"If done correctly, the previous function call should display the\r\n    output below.\r\n    \"\"\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n\"\"\"\r\n[001] Python Tricks (2017)\r\n      Bader, Dan 4.74\r\n[002] Mastering Deep Learning Fundamentals with Python (2019)\r\n      Wilson, Richard 4.7\r\n[006] Python Programming (2019)\r\n      Fedden, Antony Mc 4.68\r\n[007] Python Programming (2019)\r\n      Mining, Joseph 4.68\r\n[009] A Smarter Way to Learn Python (2017)\r\n      Myers, Mark 4.66\r\n\"\"\"",
            "score": 4,
            "number_code_submits": 22,
            "tags": "beautifulsoup, books, classes, data cleaning, data wrangling, sorting, web scraping",
            "in_paths": "Web Scraping"
        },
        {
            "bite": "Bite 231. Where are the emojis?",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-05 11:37:46.109883+00:00",
            "passing_code": "import re\r\nfrom typing import List\r\n\r\n# https://stackoverflow.com/a/43147265\r\n# just for exercise sake, real life use emoji lib\r\nIS_EMOJI = re.compile(r'[^\\w\\s,]')\r\n\r\n\r\ndef get_emoji_indices(text: str) -> List[int]:\r\n    \"\"\"Given a text return indices of emoji characters\"\"\"\r\n    return [i for i, ch in enumerate(text) if ch in IS_EMOJI.findall(text)]\r\n\r\n\r\ntext = \"We see more and more \ud83d\udc0d Python \ud83e\udd4b ninjas, keep it up \ud83d\udcaa\"\r\nprint(get_emoji_indices(text))",
            "score": 2,
            "number_code_submits": 2,
            "tags": "emojis, list, list comprehensions, looping, regular expressions",
            "in_paths": ""
        },
        {
            "bite": "Bite 233. Make a zipfile of the latest log files",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "datetime, os module, pathlib, zipfile",
            "in_paths": ""
        },
        {
            "bite": "Bite 238. Write tests for Fibonacci",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-14 00:40:39.733665+00:00",
            "passing_code": "from fibonacci import fib\r\n\r\nimport pytest\r\n\r\n# write one or more pytest functions below, they need to start with test_\r\n# 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144\r\n\r\n\r\ndef test_n_negative():\r\n    # fib(-1) ValueError\r\n    with pytest.raises(ValueError):\r\n        fib(-1)\r\n\r\n\r\ndef test_n_0():\r\n    fib_lst = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\r\n    for (i, expected) in enumerate(fib_lst):\r\n        assert fib(i) == expected\r\n\r\n\r\n\r\n",
            "score": 2,
            "number_code_submits": 2,
            "tags": "fibonacci, freebie, pytest",
            "in_paths": "Pytest"
        },
        {
            "bite": "Bite 239. Test FizzBuzz",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-22 10:59:41.278786+00:00",
            "passing_code": "from fizzbuzz import fizzbuzz\r\n\r\n# write one or more pytest functions below, they need to start with test_\r\ndef test_for_fizz():\r\n    for num in [3, 6, 9, 12]:\r\n        assert fizzbuzz(num) == \"Fizz\"\r\n\r\ndef test_for_buzz():\r\n    for num in [5, 10, 20, 25]:\r\n        assert fizzbuzz(num) == \"Buzz\"\r\n    \r\ndef test_for_fizzbuzz():\r\n    for num in [15, 45, 75, 225]:\r\n        assert fizzbuzz(num) == \"Fizz Buzz\"\r\n\r\ndef test_for_other():\r\n    for num in [1, 2, 4, 7, 8, 11, 13, 14, 16]:\r\n        assert fizzbuzz(num) == num",
            "score": 3,
            "number_code_submits": 2,
            "tags": "fizzbuzz, pytest",
            "in_paths": "Pytest"
        },
        {
            "bite": "Bite 241. Write tests for list_to_decimal",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-15 18:14:35.840031+00:00",
            "passing_code": "import pytest\r\n\r\nfrom numbers_to_dec import list_to_decimal\r\n\r\ndef test_valid_cases():\r\n    samples = [\r\n        {'input':[0,4,2,8], 'result':428},\r\n        {'input':[1,2], 'result':12},\r\n        {'input':[3], 'result':3},\r\n        {'input':[0,6,5,9], 'result':659},\r\n    ]\r\n    for sample in samples:\r\n        assert list_to_decimal(sample['input']) == sample['result']\r\n\r\ndef test_for_type_error():\r\n    invalid_samples = [\r\n        {'input':[6,2,True]},\r\n        {'input':[3.6,4,1]},\r\n        {'input':['4',5,3,1]},\r\n        {'input':[[5,3],1]},\r\n        {'input':['foo',1]},\r\n    ]\r\n    with pytest.raises(TypeError):\r\n        for sample in invalid_samples:\r\n            list_to_decimal(sample['input'])\r\n        \r\ndef test_for_value_error():\r\n    invalid_samples = [\r\n        {'input':[-3,0]},\r\n        {'input':[1,12,1]},\r\n        {'input':[2,0,32]},\r\n        {'input':[-1,4,2]},\r\n        {'input':[2,10,7]},\r\n    ]\r\n    with pytest.raises(ValueError):\r\n        for sample in invalid_samples:\r\n            list_to_decimal(sample['input'])\r\n            \r\ndef test_for_10():\r\n    with pytest.raises(ValueError):\r\n        list_to_decimal([10])\r\n        ",
            "score": 2,
            "number_code_submits": 11,
            "tags": "exception handling, freebie, pytest",
            "in_paths": "Pytest"
        },
        {
            "bite": "Bite 243. Test code that parses JSON and IP ranges",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-06 18:49:32.942371+00:00",
            "passing_code": "import os\r\nfrom pathlib import Path\r\nfrom ipaddress import IPv4Network\r\nfrom urllib.request import urlretrieve\r\n\r\nimport pytest\r\n\r\nfrom ips import (ServiceIPRange, parse_ipv4_service_ranges,\r\n                 get_aws_service_range)\r\n\r\nURL = \"https://bites-data.s3.us-east-2.amazonaws.com/ip-ranges.json\"\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nPATH = Path(TMP, \"ip-ranges.json\")\r\nIP = IPv4Network('192.0.2.8/29')\r\n\r\n\r\n@pytest.fixture(scope='module')\r\ndef json_file():\r\n    \"\"\"Import data into tmp folder\"\"\"\r\n    urlretrieve(URL, PATH)\r\n    return PATH\r\n\r\n\r\n# write your pytest code ...\r\n\r\n@pytest.mark.parametrize(\"service, region, cidr\", [\r\n    ('AMAZON', 'af-south-1', '3.2.34.0/26' ),\r\n])\r\ndef test_ServiceIPRange(service, region, cidr):\r\n    ip_range= ServiceIPRange(\r\n                service=service,\r\n                region=region,\r\n                cidr=IPv4Network(cidr))\r\n\r\n    expected_str = f\"{cidr} is allocated to the {service} service in the {region} region\"\r\n\r\n    assert str(ip_range) == expected_str\r\n\r\n\r\ndef test_ServiceIPRange_invalid_ip():\r\n    with pytest.raises(ValueError):\r\n        ip_range= ServiceIPRange(\r\n                service='foo',\r\n                region='bar',\r\n                cidr=IPv4Network('invalid'))\r\n\r\n\r\ndef test_parse_ipv4_service_ranges(json_file):\r\n    ip_ranges = parse_ipv4_service_ranges(json_file)\r\n    assert len(ip_ranges) == 1886\r\n    assert ip_ranges[0].cidr == IPv4Network(\"13.248.118.0/24\")\r\n    assert ip_ranges[0].region == \"eu-west-1\"\r\n    assert ip_ranges[0].service == \"AMAZON\"\r\n    assert ip_ranges[-1].cidr == IPv4Network(\"54.250.251.0/24\")\r\n    assert ip_ranges[-1].region == \"ap-northeast-1\"\r\n    assert ip_ranges[-1].service == \"WORKSPACES_GATEWAYS\"\r\n\r\n\r\n@pytest.mark.parametrize(\"address, expected\", [\r\n            ('0.0.0.0', []),\r\n            ('255.255.255.255', []),\r\n            ('54.153.254.10', [\r\n                            ServiceIPRange(\r\n                            service='AMAZON', \r\n                            region='ap-southeast-2', \r\n                            cidr=IPv4Network('54.153.128.0/17')), \r\n                        ServiceIPRange(\r\n                            service='EC2', \r\n                            region='ap-southeast-2', \r\n                            cidr=IPv4Network('54.153.128.0/17')), \r\n                        ServiceIPRange(\r\n                            service='WORKSPACES_GATEWAYS', \r\n                            region='ap-southeast-2', \r\n                            cidr=IPv4Network('54.153.254.0/24'))\r\n                        ]),\r\n    ])\r\ndef test_get_aws_service_range(address, expected, json_file):\r\n    service_range = get_aws_service_range(address, parse_ipv4_service_ranges(json_file))\r\n    assert service_range == expected\r\n    \r\n\r\ndef test_get_aws_service_range_invalid_ip(json_file):\r\n    with pytest.raises(ValueError,match=r\"Address must be a valid IPv4 address\"):\r\n        service_range = get_aws_service_range(\r\n            'invalid',\r\n            parse_ipv4_service_ranges(json_file))\r\n\r\n\r\n\"\"\"\r\nurlretrieve(URL, PATH)\r\nprint(get_aws_service_range('54.153.254.10', parse_ipv4_service_ranges(PATH)))\r\n\"\"\"\r\n",
            "score": 3,
            "number_code_submits": 20,
            "tags": "dataclasses, ipaddress, json, pytest",
            "in_paths": "Pytest"
        },
        {
            "bite": "Bite 246. Test print / standard output",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-07 17:10:23.986771+00:00",
            "passing_code": "import pytest\r\n\r\nfrom workouts import print_workout_days\r\n\r\n@pytest.mark.parametrize(\"test_input, expected\", [\r\n        (\"#1\", 'Mon, Tue\\n'), \r\n        (\"body\", 'Mon, Tue, Thu, Fri\\n'), \r\n        (\"cardio\", 'Wed\\n'),\r\n        (\"other\", 'No matching workout\\n')\r\n    ])\r\ndef test_print_workout_days(test_input, expected, capsys):\r\n    print_workout_days(test_input)\r\n    captured = capsys.readouterr()\r\n    assert captured.out == expected\r\n",
            "score": 2,
            "number_code_submits": 5,
            "tags": "capfd, capsys, list comprehensions, pytest, stdout",
            "in_paths": "Pytest"
        },
        {
            "bite": "Bite 247. Mocking a standard library function",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "mock.patch, pytest, random",
            "in_paths": "Pytest"
        },
        {
            "bite": "Bite 251. Introducing Pandas Series",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-09 20:14:50.497857+00:00",
            "passing_code": "import string\r\n\r\nimport pandas as pd\r\n\r\n\r\ndef basic_series() -> pd.Series:\r\n    \"\"\"Create a pandas Series containing the values 1, 2, 3, 4, 5\r\n    Don't worry about the indexes for now.\r\n    The name of the series should be 'Fred'\r\n    \"\"\"\r\n    return pd.Series([1, 2, 3, 4, 5], name=\"Fred\", dtype='int64')\r\n\r\n\r\ndef float_series() -> pd.Series:\r\n    \"\"\"Create a pandas Series containing the all the values\r\n    from 0.000 -> 1.000 e.g. 0.000, 0.001, 0.002... 0.999, 1.000\r\n    Don't worry about the indexes or the series name.\r\n    \"\"\"\r\n    PRECISION = 1000\r\n    lst=[i/PRECISION for i in range(PRECISION+1)]\r\n    return pd.Series(lst, dtype='float64')\r\n\r\n\r\ndef alpha_index_series() -> pd.Series:\r\n    \"\"\"Create a Series with values 1, 2, ... 25, 26 of type int64\r\n    and add an index with values a, b, ... y, z\r\n    so index 'a'=1, 'b'=2 ... 'y'=25, 'z'=26\r\n    Don't worry about the series name.\r\n    \"\"\"\r\n    gen=((label,value) for value, label in enumerate(string.ascii_lowercase, start=1))\r\n    return pd.Series(dict(gen), dtype='int64')\r\n\r\ndef object_values_series() -> pd.Series:\r\n    \"\"\"Create a Series with values A, B, ... Y, Z of type object\r\n    and add an index with values 101, 102, ... 125, 126\r\n    so index 101='A', 102='B' ... 125='Y', 126='Z'\r\n    Don't worry about the series name.\r\n    \"\"\"\r\n    gen=((label,value) for label,value in enumerate(string.ascii_uppercase, start=101))\r\n    return pd.Series(dict(gen), dtype='object')\r\n\r\n\r\nprint(float_series())\r\nprint(alpha_index_series())\r\nprint(object_values_series())",
            "score": 2,
            "number_code_submits": 2,
            "tags": "pandas, series, string module",
            "in_paths": ""
        },
        {
            "bite": "Bite 252. Let's play with Pandas Series",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-10 18:51:55.621974+00:00",
            "passing_code": "import numpy as np\r\nimport pandas as pd\r\n\r\n\r\ndef return_at_index(ser: pd.Series, idx: int) -> object:\r\n    \"\"\"Return the Object at the given index of the Series\r\n    If you want to be extra careful catch and raise an error if\r\n       the index does not exist.\r\n    \"\"\"\r\n    \r\n    try:\r\n        return ser.iloc[idx]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef get_slice(ser: pd.Series, start: int, end: int) -> pd.core.series.Series:\r\n    \"\"\"Return the slice of the given Series in the range between\r\n    start and end.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[start:end]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef get_slice_inclusive(ser: pd.Series,\r\n                        start: int, end: int) -> pd.core.series.Series:\r\n    \"\"\"Return the slice of the given Series in the range between\r\n    start and end inclusive.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[start:end+1]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef return_head(ser: pd.Series, num: int) -> pd.core.series.Series:\r\n    \"\"\"Return the first num elements of the given Series.\r\n    \"\"\"\r\n    return ser.head(num)\r\n\r\n\r\ndef return_tail(ser: pd.Series, num: int) -> pd.core.series.Series:\r\n    \"\"\"Return the last num elements of the given Series.\r\n    \"\"\"\r\n    return ser.tail(num)\r\n\r\n\r\ndef get_index(ser: pd.Series) -> pd.core.indexes.base.Index:\r\n    \"\"\"Return all indexes of the given Series.\r\n    \"\"\"\r\n    return ser.index\r\n\r\n\r\n\r\ndef get_values(ser: pd.Series) -> np.ndarray:\r\n    \"\"\"Return all the values of the given Series.\r\n    \"\"\"\r\n    return ser.values\r\n\r\n\r\ndef get_every_second_indexes(ser: pd.Series,\r\n                             even_index=True) -> pd.core.series.Series:\r\n    \"\"\"Return all rows where the index is either even or odd.\r\n    If even_index is True return every index where idx % 2 == 0\r\n    If even_index is False return every index where idx % 2 != 0\r\n    Assume default indexing i.e. 0 -> n\r\n    \"\"\"\r\n    if even_index:\r\n        rows = [idx%2==0 for idx in ser.index]\r\n    else:\r\n        rows = [idx%2!=0 for idx in ser.index]\r\n    return ser.iloc[rows]\r\n",
            "score": 2,
            "number_code_submits": 8,
            "tags": "numpy, pandas, series, slicing, type hinting",
            "in_paths": ""
        },
        {
            "bite": "Bite 253. More Pandas Series Practice",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "math, pandas, series, statistics",
            "in_paths": ""
        },
        {
            "bite": "Bite 254. Global vs local variables",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-11 21:39:27.204562+00:00",
            "passing_code": "num_hundreds = -1\r\n\r\n\r\ndef sum_numbers(numbers: list) -> int:\r\n    \"\"\"Sums passed in numbers returning the total, also\r\n       update the global variable num_hundreds with the amount\r\n       of times 100 fits in total\"\"\"\r\n    global num_hundreds\r\n    result = sum(numbers)\r\n    num_hundreds+= result//100\r\n    return result\r\n\r\n\r\n\"\"\"\r\nfor i in range(5):\r\n    print(sum_numbers([10, 50, 90]))\r\n    print(f\"{num_hundreds=}\")\r\n\"\"\"",
            "score": 2,
            "number_code_submits": 2,
            "tags": "global, sum",
            "in_paths": ""
        },
        {
            "bite": "Bite 255. Codon Usage",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-29 21:34:09.395254+00:00",
            "passing_code": "import os\r\nfrom urllib.request import urlretrieve\r\nfrom pprint import pprint\r\nfrom collections import Counter\r\n\r\n# Translation Table:\r\n# https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi#SG11\r\n# Each column represents one entry. Codon = {Base1}{Base2}{Base3}\r\n# All Base 'T's need to be converted to 'U's to convert DNA to RNA\r\nTRANSL_TABLE_11 = \"\"\"\r\n    AAs  = FFLLSSSSYY**CC*WLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\r\n  Starts = ---M------**--*----M------------MMMM---------------M------------\r\n  Base1  = TTTTTTTTTTTTTTTTCCCCCCCCCCCCCCCCAAAAAAAAAAAAAAAAGGGGGGGGGGGGGGGG\r\n  Base2  = TTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGG\r\n  Base3  = TCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAG\r\n\"\"\"\r\n\r\n# Converted from http://ftp.ncbi.nlm.nih.gov/genomes/archive/old_refseq/Bacteria/Staphylococcus_aureus_Newman_uid58839/NC_009641.ffn  # noqa E501\r\nURL = \"https://bites-data.s3.us-east-2.amazonaws.com/NC_009641.txt\"\r\n\r\n# Order of bases in the table\r\nBASE_ORDER = [\"U\", \"C\", \"A\", \"G\"]\r\n\r\n\r\ndef _preload_sequences(url=URL):\r\n    \"\"\"\r\n    Provided helper function\r\n    Returns coding sequences, one sequence each line\r\n    \"\"\"\r\n    filename = os.path.join(os.getenv(\"TMP\", \"/tmp\"), \"NC_009641.txt\")\r\n    if not os.path.isfile(filename):\r\n        urlretrieve(url, filename)\r\n    with open(filename, \"r\") as f:\r\n        return f.readlines()\r\n\r\ndef _preprocess_table(table_str):\r\n    \r\n    table_dict = dict((name.strip(), value.strip()) for name, value in \r\n        (tuple(line.split('=')) for line in table_str.strip().splitlines()))\r\n\r\n    table_dict['Base1']=table_dict['Base1'].replace('T','U')\r\n    table_dict['Base2']=table_dict['Base2'].replace('T','U')\r\n    table_dict['Base3']=table_dict['Base3'].replace('T','U')\r\n\r\n    return dict((''.join(line[1:4]), line[0]) for line in zip(\r\n        table_dict['AAs'],table_dict['Base1'],table_dict['Base2'],table_dict['Base3']))\r\n\r\n\r\ndef return_codon_usage_table(\r\n    sequences=_preload_sequences(), translation_table_str=TRANSL_TABLE_11\r\n):\r\n    \"\"\"\r\n    Receives a list of gene sequences and a translation table string\r\n    Returns a string with all bases and their frequencies in a table\r\n    with the following fields:\r\n    codon_triplet: amino_acid_letter frequency_per_1000 absolute_occurrences\r\n\r\n    Skip invalid coding sequences:\r\n       --> must consist entirely of codons (3-base triplet)\r\n    \"\"\"\r\n    chunks = []\r\n    n = 3\r\n    for sequence in sequences:\r\n        chunks += [sequence[i:i+n] for i in range(0, len(sequence), n)]\r\n    counter = Counter(chunks)\r\n    translation_table = _preprocess_table(translation_table_str)\r\n    unformatted_table = dict((codon, [aa, counter[codon]]) \\\r\n        for codon, aa in translation_table.items())\r\n\r\n    formatted_table = _format_table(unformatted_table, BASE_ORDER)\r\n    return formatted_table\r\n\r\ndef _format_table(table, base_order):\r\n    result = \"\"\"\r\n|  Codon AA  Freq  Count  |  Codon AA  Freq  Count  |  Codon AA  Freq  Count  |  Codon AA  Freq  Count  |\r\n---------------------------------------------------------------------------------------------------------\r\n|\"\"\"\r\n\r\n    ITEM_SEP=\"|\"\r\n    LINE_SEP=\"|\\n|\"\r\n    SEC_SEP=\"|\\n\"+105*\"-\"+\"\\n|\"\r\n    total = sum([item[1] for item in table.values()])\r\n    sections =[]\r\n    for i in base_order:\r\n        lines = []\r\n        for k in base_order:\r\n            items = []\r\n            for j in base_order:\r\n                codon=\"\".join([i,j,k])\r\n                aa=table[codon][0]\r\n                freq=1000*table[codon][1]/total \r\n                count=table[codon][1]\r\n                items.append(f\"  {codon}:  {aa} {freq:6.1f} {count:6}  \")\r\n            lines.append(ITEM_SEP.join(items))\r\n        sections.append(LINE_SEP.join(lines))\r\n    result+= SEC_SEP.join(sections) + \"|\\n\"+105*\"-\"+\"\\n\"\r\n    return result\r\nif __name__ == \"__main__\":\r\n    print(return_codon_usage_table())\r\n",
            "score": 3,
            "number_code_submits": 6,
            "tags": "bioinformatics, collections, textwrap",
            "in_paths": "Bioinformatics"
        },
        {
            "bite": "Bite 256. Scrape PyCon events",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-05 18:13:02.886289+00:00",
            "passing_code": "import json\r\nfrom collections import namedtuple\r\nfrom typing import List\r\n\r\nimport requests\r\nfrom bs4 import BeautifulSoup as Soup\r\nfrom dateutil.parser import parse\r\n\r\nfrom datetime import datetime\r\nfrom pprint import pprint\r\n\r\nPYCON_DATA = \"https://bites-data.s3.us-east-2.amazonaws.com/pycons.html\"\r\n\r\nPyCon = namedtuple(\"PyCon\", \"name city country start_date end_date url\")\r\n\r\ncountry_lookup = {\r\n    \"Africa\": [\r\n        \"Algeria\", \"Angola\", \"Benin\", \"Botswana\",\r\n        \"Burkina Faso\", \"Burundi\", \"Cameroon\", \"Cape Verde\",\r\n        \"Central African Republic\", \"Chad\", \"Comoros\",\r\n        \"Democratic Republic of the Congo\",\r\n        \"Djibouti\", \"Egypt\", \"Equatorial Guinea\", \"Eritrea\",\r\n        \"Ethiopia\", \"Gabon\", \"Ghana\", \"Guinea\", \"Guinea-Bissau\",\r\n        \"Ivory Coast\", \"Kenya\", \"Lesotho\", \"Liberia\",\r\n        \"Libya\", \"Madagascar\", \"Malawi\", \"Mali\",\r\n        \"Mauritania\", \"Mauritius\", \"Morocco\", \"Mozambique\",\r\n        \"Namibia\", \"Niger\", \"Nigeria\", \"Republic of the Congo\",\r\n        \"Rwanda\", \"S\u00e3o Tome and Principe\", \"Senegal\", \"Seychelles\",\r\n        \"Sierra Leone\", \"Somalia\", \"South Africa\", \"South Sudan\",\r\n        \"Sudan\", \"Swaziland\", \"Tanzania\", \"The Gambia\",\r\n        \"Togo\", \"Tunisia\", \"Uganda\", \"Zambia\", \"Zimbabwe\",\r\n    ],\r\n    \"Asia\": [\r\n        \"Afghanistan\", \"Armenia\", \"Azerbaijan\", \"Bahrain\",\r\n        \"Bangladesh\", \"Bhutan\", \"Brunei\", \"Cambodia\",\r\n        \"China\", \"East Timor\", \"Georgia\", \"India\",\r\n        \"Indonesia\", \"Iran\", \"Iraq\", \"Israel\",\r\n        \"Japan\", \"Jordan\", \"Kazakhstan\", \"Kuwait\",\r\n        \"Kyrgyzstan\", \"Laos\", \"Lebanon\", \"Malaysia\",\r\n        \"Maldives\", \"Mongolia\", \"Myanmar\", \"Nepal\",\r\n        \"North Korea\", \"Oman\", \"Pakistan\", \"Palestinian territories\",\r\n        \"Philippines\", \"Qatar\", \"Saudi Arabia\", \"Singapore\",\r\n        \"South Korea\", \"Sri Lanka\", \"Syria\", \"Taiwan\",\r\n        \"Tajikistan\", \"Thailand\", \"Turkey\", \"Turkmenistan\",\r\n        \"United Arab Emirates\", \"Uzbekistan\", \"Vietnam\",\r\n        \"Yemen\",\r\n    ],\r\n    \"Australia and Oceania\": [\r\n        \"Australia\", \"Federated States of Micronesia\", \"Fiji\",\r\n        \"Kiribati\", \"Marshall Islands\", \"Nauru\", \"New Zealand\",\r\n        \"Palau\", \"Papua New Guinea\", \"Samoa\", \"Solomon Islands\",\r\n        \"Tonga\", \"Tuvalu\", \"Vanuatu\",\r\n    ],\r\n    \"Europe\": [\r\n        \"Albania\", \"Andorra\", \"Austria\", \"Belarus\", \"Belgium\",\r\n        \"Bosnia and Herzegovina\", \"Bulgaria\", \"Croatia\", \"Cyprus\",\r\n        \"Czech Republic\", \"Denmark\", \"Estonia\", \"Finland\",\r\n        \"France\", \"Germany\", \"Greece\", \"Hungary\", \"Iceland\",\r\n        \"Italy\", \"Latvia\", \"Liechtenstein\", \"Lithuania\",\r\n        \"Luxembourg\", \"Malta\", \"Moldova\", \"Monaco\",\r\n        \"Montenegro\", \"Netherlands\", \"Norway\", \"Poland\",\r\n        \"Portugal\", \"Republic of Ireland\", \"Republic of Macedonia\",\r\n        \"Romania\", \"Russia\", \"San Marino\", \"Serbia\", \"Slovakia\",\r\n        \"Slovenia\", \"Spain\", \"Sweden\", \"Switzerland\",\r\n        \"Ukraine\", \"United Kingdom\", \"U.K.\", \"Vatican City\",\r\n    ],\r\n    \"North America\": [\r\n        \"Antigua and Barbuda\", \"Barbados\", \"Belize\",\r\n        \"Canada\", \"Costa Rica\", \"Cuba\", \"Dominica\",\r\n        \"Dominican Republic\", \"El Salvador\", \"Grenada\",\r\n        \"Guatemala\", \"Haiti\", \"Honduras\", \"Jamaica\",\r\n        \"Mexico\", \"Nicaragua\", \"Panama\", \"Saint Kitts and Nevis\",\r\n        \"Saint Lucia\", \"Saint Vincent and the Grenadines\",\r\n        \"The Bahamas\", \"Trinidad and Tobago\",\r\n        \"United States of America\", \"U.S.A.\",\r\n    ],\r\n    \"South America\": [\r\n        \"Argentina\", \"Bolivia\", \"Brazil\", \"Chile\",\r\n        \"Colombia\", \"Ecuador\", \"Guyana\", \"Paraguay\",\r\n        \"Peru\", \"Suriname\", \"Uruguay\", \"Venezuela\",\r\n    ],\r\n}\r\n\r\n\r\ndef get_continent(country: str) -> str:\r\n    \"\"\"\r\n    Given a country name returns the associated continent of the country.\r\n\r\n    :param country: The name of the country\r\n    :type country: str\r\n    :returns: The continent of the country\r\n    :rtype: str\r\n    \"\"\"\r\n    for continent, countries in country_lookup.items():\r\n        for c in countries:\r\n            if country.lower() in c.lower():\r\n                return continent\r\n\r\n\r\ndef _get_pycon_data():\r\n    \"\"\"Helper function that retrieves the required PyCon data\"\"\"\r\n    with requests.Session() as session:\r\n        return session.get(PYCON_DATA).content.decode(\"utf-8\")\r\n\r\n\r\ndef get_pycon_events(data=_get_pycon_data()) -> List[PyCon]:\r\n    \"\"\"\r\n    Scrape the PyCon events from the given website data and\r\n    return a list of PyCon namedtuples. Pay attention to the\r\n    application/ld+json data structure website data.\r\n    \"\"\"\r\n    result = []\r\n    soup = Soup(data, \"html.parser\")\r\n    scripts = soup.find_all(\"script\", {\"type\": \"application/ld+json\"})\r\n    for item in scripts:\r\n        script=json.loads(item.text)\r\n        name=script['name']\r\n        city=script['location']['address']['addressLocality']\r\n        country=script['location']['address']['addressCountry']\r\n        start_date=datetime.strptime(script['startDate'],'%Y-%m-%d')\r\n        end_date=datetime.strptime(script['endDate'],'%Y-%m-%d')\r\n        url=script['url']\r\n        conference=PyCon(name,city,country,start_date, end_date,url)\r\n\r\n        if 'pycon' in name.lower():\r\n            result.append(conference)\r\n    return result\r\n\r\n\r\ndef filter_pycons(pycons: List[PyCon],\r\n                  year: int = 2019,\r\n                  continent: str = \"Europe\") -> List[PyCon]:\r\n    \"\"\"\r\n    Given a list of PyCons a year and a continent return\r\n    a list of PyCons that take place in that year and on\r\n    that continent.\r\n    \"\"\"\r\n    return list(pycon for pycon in pycons if pycon.start_date.year == year and get_continent(pycon.country) == continent)\r\n        \r\n\r\npycons = get_pycon_events()\r\npprint(filter_pycons(pycons, 2019, \"Europe\"))",
            "score": 3,
            "number_code_submits": 3,
            "tags": "beautifulsoup, data analysis, json, namedtuple, pycon, requests, web scraping",
            "in_paths": "Web Scraping"
        },
        {
            "bite": "Bite 257. Extract users dict from a multiline string",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-12 09:25:58.140993+00:00",
            "passing_code": "import re        \r\n\r\ndef get_users(passwd: str) -> dict:\r\n    \"\"\"Split password output by newline,\r\n      extract user and name (1st and 5th columns),\r\n      strip trailing commas from name,\r\n      replace multiple commas in name with a single space\r\n      return dict of keys = user, values = name.\r\n    \"\"\"\r\n    result_dict={}\r\n    for line in passwd.strip().splitlines():\r\n        user, _, _, _, name, *_ =line.split(':')\r\n        name = re.sub(',+', ' ', name.rstrip(',')) or 'unknown'\r\n        result_dict[user]=name\r\n\r\n    return result_dict\r\n\r\n\r\ntest= \"\"\"\r\npostfix:x:108:112::/var/spool/postfix:/bin/false\r\nssh-rsa:x:1004:1004::/home/ssh-rsa:/bin/bash\r\nartagnon:x:1005:1005:Ramkumar R,,,,Git GSOC:/home/artagnon:/bin/bash\r\n\"\"\"\r\n\r\nprint(get_users(test))",
            "score": 2,
            "number_code_submits": 5,
            "tags": "dict, string parsing",
            "in_paths": ""
        },
        {
            "bite": "Bite 259. Reverse complement",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-10 21:50:39.678281+00:00",
            "passing_code": "# See tests for a more comprehensive complementary table\r\nSIMPLE_COMPLEMENTS_STR = \"\"\"#Reduced table with bases A, G, C, T\r\n Base\tComplementary Base\r\n A\tT\r\n T\tA\r\n G\tC\r\n C\tG\r\n\"\"\"\r\n\r\n\r\ndef _read_str_table(str_table):\r\n    \"\"\"\r\n    Takes a string defining a table of valid and comlementary bases \r\n    and returns a dict of base:complement\r\n    \"\"\"\r\n    lst = [line.split() for line in str_table.splitlines()[2:]]\r\n    return  {item[0].upper().strip(): item[-1].upper().strip() for item in lst}\r\n\r\n# Recommended helper function\r\ndef _clean_sequence(sequence, str_table):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns all sequences converted to upper case and remove invalid\r\n    characters\r\n    t!t%ttttAACCG --> TTTTTTAACCG\r\n    \"\"\"\r\n    base_table = _read_str_table(str_table)\r\n    return \"\".join([base for base in sequence.upper() if base in base_table])\r\n\r\n\r\ndef reverse(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a reversed string of sequence while removing all characters\r\n    not found in str_table characters\r\n    e.g. t!t%ttttAACCG --> GCCAATTTTTT\r\n    \"\"\"\r\n    return _clean_sequence(sequence, str_table)[::-1]\r\n\r\n\r\ndef complement(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a string containing complementary bases as defined in\r\n    str_table while removing non input_sequence characters\r\n    e.g. t!t%ttttAACCG --> AAAAAATTGGC\r\n    \"\"\"\r\n    base_table = _read_str_table(str_table)\r\n    return \"\".join([base_table[base] for base in _clean_sequence(sequence, str_table) ])\r\n    \r\n\r\ndef reverse_complement(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a string containing complementary bases as defined in str_table\r\n    while removing non input_sequence characters\r\n    e.g. t!t%ttttAACCG --> CGGTTAAAAAA\r\n    \"\"\"\r\n    return reverse(complement(sequence,str_table),str_table)\r\n\r\n\r\ntest_str = \"\"\"# Full table with ambigous bases\r\n Base\tName\tBases Represented\tComplementary Base\r\n A\tAdenine\tA\tT\r\n T\tThymidine\tT \tA\r\n U\tUridine(RNA only)\tU\tA\r\n G\tGuanidine\tG\tC\r\n C\tCytidine\tC\tG\r\n Y\tpYrimidine\tC T\tR\r\n R\tpuRine\tA G\tY\r\n S\tStrong(3Hbonds)\tG C\tS\r\n W\tWeak(2Hbonds)\tA T\tW\r\n K\tKeto\tT/U G\tM\r\n M\taMino\tA C\tK\r\n B\tnot A\tC G T\tV\r\n D\tnot C\tA G T\tH\r\n H\tnot G\tA C T\tD\r\n V\tnot T/U\tA C G\tB\r\n N\tUnknown\tA C G T\tN\r\n\"\"\"\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    print(_read_str_table(str_table=test_str))\r\n    print(_clean_sequence('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))\r\n    print(reverse('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))\r\n    print(complement('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))\r\n    print(reverse_complement('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))",
            "score": 3,
            "number_code_submits": 7,
            "tags": "bioinformatics, string manipulation, translate",
            "in_paths": "Bioinformatics"
        },
        {
            "bite": "Bite 262. GC content",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-13 12:43:01.951253+00:00",
            "passing_code": "def calculate_gc_content(sequence):\r\n    \"\"\"\r\n    Receives a DNA sequence (A, G, C, or T)\r\n    Returns the percentage of GC content (rounded to the last two digits)\r\n    \"\"\"\r\n    clean_sequence = \"\".join([letter for letter in sequence.upper() if letter in \"AGCT\"])\r\n    total = len(clean_sequence)\r\n    gc_count = len([letter for letter in clean_sequence if letter in \"GC\"])\r\n\r\n    return round(100 * gc_count / total , 2)\r\n\r\n\r\npercent = calculate_gc_content(\"a,G.c T\\nAGcT\")\r\nprint(f\"{percent:0.2f}\")\r\n",
            "score": 2,
            "number_code_submits": 2,
            "tags": "bioinformatics, collections",
            "in_paths": "Bioinformatics"
        },
        {
            "bite": "Bite 263. Count the number of islands in a grid",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-08 21:54:39.380415+00:00",
            "passing_code": "from pprint import pprint\r\n\r\nVERBOSE = False\r\n\r\ndef count_islands(grid):\r\n    \"\"\"\r\n    Input: 2D matrix, each item is [x, y] -> row, col.\r\n    Output: number of islands, or 0 if found none.\r\n    Notes: island is denoted by 1, ocean by 0 islands is counted by continuously\r\n        connected vertically or horizontally  by '1's.\r\n    It's also preferred to check/mark the visited islands:\r\n    - eg. using the helper function - mark_islands().\r\n    \"\"\"\r\n    \r\n    islands = 0         # var. for the counts\r\n    nrows = len(grid)\r\n    ncols = len(grid[0])\r\n    for i in range(nrows):\r\n        for j in range(ncols):\r\n            if grid[i][j] == 1:\r\n                islands += 1\r\n                if VERBOSE:\r\n                    print(f\"Found island number {islands}\")\r\n                mark_islands(i, j, grid)\r\n    print (f\"{islands} islands\")\r\n    return islands\r\n\r\n\r\ndef _print_grid(grid):\r\n    nrows = len(grid)\r\n    print(\"Exploring island:\")\r\n    for i in range(nrows):\r\n        print(\" \".join([str(el) for el in grid[i]]))\r\n    print(\"\\n\")\r\n    \r\n    \r\ndef mark_islands(i, j, grid):\r\n    \"\"\"\r\n    Input: the row, column and grid\r\n    Output: None. Just mark the visited islands as in-place operation.\r\n    \"\"\"\r\n    nrows = len(grid)\r\n    ncols = len(grid[0])\r\n    grid[i][j] = '#'      # one way to mark visited ones - suggestion.\r\n    if VERBOSE:\r\n        _print_grid(grid)\r\n    if i>0: \r\n        if grid[i-1][j] == 1:\r\n            mark_islands(i-1, j, grid)\r\n    if i<nrows-1:\r\n        if grid[i+1][j] == 1:\r\n            mark_islands(i+1, j, grid)\r\n    if j>0:\r\n        if grid[i][j-1] == 1:\r\n            mark_islands(i, j-1, grid)\r\n    if j<ncols-1:\r\n        if grid[i][j+1] == 1:\r\n            mark_islands(i, j+1, grid)\r\n\r\nif __name__ == \"__main__\":\r\n    \r\n    test_grid = [[1, 0, 0, 1],\r\n             [0, 0, 0, 0],\r\n             [0, 0, 0, 0],\r\n             [1, 0, 0, 1]]\r\n    \r\n    count_islands(test_grid)\r\n        ",
            "score": 3,
            "number_code_submits": 3,
            "tags": "algorithms, looping, string",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 265. Optimal fund raising",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-11 18:07:13.142913+00:00",
            "passing_code": "IMPOSSIBLE = 'Mission impossible. No one can contribute.'\r\n\r\n\r\ndef max_fund(village):\r\n    \"\"\"Find a contiguous subarray with the largest sum.\"\"\"\r\n    # Hint: while iterating, you could save the best_sum collected so far\r\n    # return total, starting, ending\r\n    start = 0\r\n    end = 0\r\n    max_donations= float('-inf')\r\n    for i in range(len(village)):\r\n        for j in range(i+1,len(village)+1):\r\n            donations = sum(village[i:j])\r\n            # print(f\"{i}:{j} ({village[i:j]})-> {donations}\")\r\n            if donations >= max_donations:\r\n                max_donations = donations\r\n                start = i\r\n                end = j\r\n                # print(f\"Found max!\")\r\n    if max_donations < 0:\r\n        print(IMPOSSIBLE)\r\n        return (0,0,0)\r\n    return (max_donations, start+1, end)\r\n    \r\n\r\nif __name__ == \"__main__\":\r\n    print(max_fund([0, -3, 2, 1, -7, 5, 3, -1, 6]))\r\n    print(max_fund([0, 1, -1, -5, 0, 4, -3, -2]))\r\n    print(max_fund([0, 0, 0, 0, 1, -5, -2, -1, -3]))\r\n    print(max_fund([-1, -2, -3, -4, -5]))\r\n\r\n",
            "score": 3,
            "number_code_submits": 2,
            "tags": "algorithms, looping, math",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 266. Composition, Inheritance, Abstract Base Class, what?",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-16 21:10:09.979041+00:00",
            "passing_code": "from abc import ABC, abstractmethod\r\nfrom collections import namedtuple\r\nfrom dataclasses import dataclass\r\nfrom datetime import date\r\nfrom os import getenv, path\r\nfrom pathlib import Path\r\nfrom typing import Any, List, Optional, NamedTuple\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup as Soup  # type: ignore\r\n\r\nTMP = getenv(\"TMP\", \"/tmp\")\r\nTODAY = date.today()\r\n\r\nCandidate = NamedTuple(\"Candidate\", [\r\n        ('name', str), \r\n        ('votes', int),\r\n    ]\r\n)\r\nLeaderBoard = NamedTuple(\r\n    \"LeaderBoard\", [\r\n        ('Candidate', str), \r\n        ('Average', str), \r\n        ('Delegates', str), \r\n        ('Contributions', str), \r\n        ('Coverage', str),\r\n    ]\r\n)\r\nPoll = NamedTuple(\r\n    \"Poll\",[\r\n        ('Poll', str),\r\n        ('Date', str),\r\n        ('Sample', int),\r\n        ('Sanders', float),\r\n        ('Biden', float),\r\n        ('Gabbard', float),\r\n        ('Spread', float),\r\n    ]\r\n)\r\n\r\n\r\ndef as_float(string):\r\n    try:\r\n        return float(string)\r\n    except ValueError:\r\n        return 0        \r\n\r\n@dataclass\r\nclass File:\r\n    \"\"\"File represents a filesystem path.\r\n\r\n    Variables:\r\n        name: str -- The filename that will be created on the filesystem.\r\n        path: Path -- Path object created from the name passed in.\r\n\r\n    Methods:\r\n        [property]\r\n        data: -> Optional[str] -- If the file exists, it returns its contents.\r\n            If it does not exist, it returns None.\r\n    \"\"\"\r\n    name: str\r\n    path: Path = ''\r\n    \r\n    def __post_init__(self):\r\n        if self.path:\r\n            self.path = Path(self_path , self.name)\r\n        else:\r\n            self.path = Path(TMP,f'{TODAY}_{self.name}')\r\n        \r\n    @property\r\n    def data(self) -> Optional[str]:\r\n        if path.isfile(self.path):\r\n            with open(self.path) as f:\r\n                return f.read()\r\n        else:\r\n            return None\r\n\r\n@dataclass\r\nclass Web:\r\n    \"\"\"Web object.\r\n\r\n    Web is an object that downloads the page from the url that is passed\r\n    to it and stores it in the File instance that is passed to it. If the\r\n    File already exists, it just reads the file, otherwise it downloads it\r\n    and stores it in File.\r\n\r\n    Variables:\r\n        url: str -- The url of the web page.\r\n        file: File -- The File object to store the page data into.\r\n\r\n    Methods:\r\n        [property]\r\n        data: -> Optional[str] -- Reads the text from File or retrieves it from the\r\n            web if it does not exists.\r\n\r\n        [property]\r\n        soup: -> Soup -- Parses the data from File and turns it into a BeautifulSoup\r\n            object.\r\n    \"\"\"\r\n    url: str\r\n    file: File\r\n\r\n    @property\r\n    def data(self) -> Optional[str]:\r\n        \"\"\"Reads the data from the File object.\r\n\r\n        First it checks if the File object has any data. If it doesn't, it retrieves\r\n        it and saves it to the File. It then reads it from the File and returns it.\r\n\r\n        Returns:\r\n            Optional[str] -- The string data from the File object.\r\n        \"\"\"\r\n        if not self.file.data:\r\n            urlretrieve(self.url, self.file.path)\r\n        return self.file.data\r\n\r\n    @property\r\n    def soup(self) -> Soup:\r\n        \"\"\"Converts string data from File into a BeautifulSoup object.\r\n\r\n        Returns:\r\n            Soup -- BeautifulSoup object created from the File.\r\n        \"\"\"\r\n        soup = Soup(self.data, 'html.parser')\r\n        return soup\r\n\r\n\r\nclass Site(ABC):\r\n    \"\"\"Site Abstract Base Class.\r\n\r\n    Defines the structure for the objects based on this class and defines the interfaces\r\n    that should be implemented in order to work properly.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        [abstractmethod]\r\n        parse_rows: -> Union[List[LeaderBoard], List[Poll]] -- Parses a BeautifulSoup\r\n            table element and returns the text found in the td elements as\r\n            namedtuples.\r\n\r\n        [abstractmethod]\r\n        polls: -> Union[List[LeaderBoard], List[Poll]] -- Does the parsing of the table\r\n            and rows for you. It takes the table index number if given, otherwise\r\n            parses table 0.\r\n\r\n        [abstractmethod]\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation.\r\n    \"\"\"\r\n    web: Web\r\n\r\n    def find_table(self, loc: int = 0) -> str:\r\n        \"\"\"Finds the table elements from the Soup object\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Parses the Web object for table elements and\r\n                returns the first one that it finds unless an integer representing\r\n                the required table is passed. (default: {0})\r\n\r\n        Returns:\r\n            str -- The html table\r\n        \"\"\"\r\n            \r\n        return self.web.soup.find_all('table')[loc or 0]\r\n\r\n    @abstractmethod\r\n    def parse_rows(self, table: Soup) -> List[Any]:\r\n        \"\"\"Abstract Method\r\n        \r\n        Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as NamedTuple.\r\n\r\n        Returns:\r\n            List[NamedTuple] -- List of NamedTuple that were created from the\r\n                table data.\r\n        \"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def polls(self, table: int = 0) -> List[Any]:\r\n        \"\"\"Abstract Method\r\n\r\n        Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[NamedTuple] -- List of NamedTuple that were created from the\r\n                table data.\r\n        \"\"\"\r\n        pass\r\n    \r\n    @abstractmethod\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Abstract Method\r\n        \r\n        Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n        \"\"\"\r\n        pass\r\n\r\n\r\n@dataclass\r\nclass RealClearPolitics(Site):\r\n    \"\"\"RealClearPolitics object.\r\n\r\n    RealClearPolitics is a custom class to parse a Web instance from the\r\n    realclearpolitics website.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        parse_rows: -> List[Poll] -- Parses a BeautifulSoup table element and\r\n            returns the text found in the td elements as Poll namedtuples.\r\n\r\n        polls: -> List[Poll] -- Does the parsing of the table and rows for you.\r\n            It takes the table index number if given, otherwise parses table 0.\r\n\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation:\r\n\r\n            Example:\r\n\r\n            RealClearPolitics\r\n            =================\r\n                Biden: 214.0\r\n              Sanders: 142.0\r\n              Gabbard: 6.0\r\n\r\n    \"\"\"\r\n\r\n    web:Web\r\n\r\n    def parse_rows(self, table: Soup) -> List[Poll]:\r\n        \"\"\"Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as Poll namedtuples.\r\n\r\n        Returns:\r\n            List[Poll] -- List of Poll namedtuples that were created from the\r\n                table data.\r\n        \"\"\"\r\n        lst=[]\r\n        for row in table.find_all('tr')[2:]:\r\n            tds=row.find_all('td')\r\n            poll=tds[0].text\r\n            date=tds[1].text\r\n            sample=as_float(tds[2].text)\r\n            biden=as_float(tds[3].text)\r\n            sanders=as_float(tds[4].text)\r\n            gabbard=as_float(tds[5].text)\r\n            spread=as_float(tds[5].text)\r\n            lst.append(Poll(poll, date, sample, sanders, biden, gabbard, spread))\r\n        # print(lst)\r\n        return lst\r\n\r\n    def polls(self, table: int = 0) -> List[Poll]:\r\n        \"\"\"Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[Poll] -- List of Poll namedtuples that were created from the\r\n                table data.\r\n        \"\"\"\r\n        return self.parse_rows(self.find_table(table))\r\n\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n\r\n        \"\"\"\r\n        output=\"\"\"\\nRealClearPolitics\\n=================\\n\"\"\"\r\n        for candidate in 'Biden', 'Sanders', 'Gabbard':\r\n            output+=f'{candidate:>9}: {sum(getattr(poll, candidate) for poll in self.polls(loc))}\\n'\r\n        print(output)\r\n\r\n\r\n@dataclass\r\nclass NYTimes(Site):\r\n    \"\"\"NYTimes object.\r\n\r\n    NYTimes is a custom class to parse a Web instance from the nytimes website.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        parse_rows: -> List[LeaderBoard] -- Parses a BeautifulSoup table element and\r\n            returns the text found in the td elements as LeaderBoard namedtuples.\r\n\r\n        polls: -> List[LeaderBoard] -- Does the parsing of the table and rows for you.\r\n            It takes the table index number if given, otherwise parses table 0.\r\n\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation:\r\n\r\n            Example:\r\n\r\n            NYTimes\r\n            =================================\r\n\r\n                               Pete Buttigieg\r\n            ---------------------------------\r\n            National Polling Average: 10%\r\n                   Pledged Delegates: 25\r\n            Individual Contributions: $76.2m\r\n                Weekly News Coverage: 3\r\n\r\n    \"\"\"\r\n\r\n    web: Web\r\n\r\n    def parse_rows(self, table: Soup) -> List[LeaderBoard]:\r\n        \"\"\"Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as LeaderBoard namedtuples.\r\n\r\n        Returns:\r\n            List[LeaderBoard] -- List of LeaderBoard namedtuples that were created from\r\n            the table data.\r\n        \"\"\"\r\n        lst=[]\r\n        for row in table.find_all('tr')[1:4]:\r\n            tds=row.find_all('td')\r\n            candidate=tds[0].text.strip()\r\n            average=tds[1].text.strip()\r\n            delegates=int(tds[2].text.strip())\r\n            contributions=tds[3].text.strip()\r\n            coverage=int(tds[4].text.strip('# '))\r\n            # print(\" # \".join([candidate, average, delegates, contributions, coverage]))\r\n            lst.append(LeaderBoard(candidate, average, delegates, contributions, coverage))\r\n        # print(lst)\r\n        return lst\r\n        \r\n\r\n    def polls(self, table: int = 0) -> List[LeaderBoard]:\r\n        \"\"\"Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[LeaderBoard] -- List of LeaderBoard namedtuples that were created from\r\n                the table data.\r\n        \"\"\"\r\n        return self.parse_rows(self.find_table(table))\r\n\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n        \"\"\"\r\n        output=f\"\\nNYTimes\\n{'='*33}\\n\\n\"\r\n        for item in self.polls(loc):\r\n            output+=f\"{item.Candidate:>33}\\n{'-'*33}\\n\"\r\n            output+=f'{\"National Polling Average\":>24}: {item.Average}\\n'\r\n            output+=f'{\"Pledged Delegates\":>24}: {item.Delegates}\\n'\r\n            output+=f'{\"Individual Contributions\":>24}: {item.Contributions}\\n'\r\n            output+=f'{\"Weekly News Coverage\":>24}: {item.Coverage}\\n\\n'            \r\n        print(output)\r\n\r\n\r\ndef gather_data():\r\n    rcp_file = File(\"realclearpolitics.html\")\r\n    rcp_url = (\r\n        \"https://bites-data.s3.us-east-2.amazonaws.com/2020-03-10_realclearpolitics.html\"\r\n    )\r\n    rcp_web = Web(rcp_url, rcp_file)\r\n    rcp = RealClearPolitics(rcp_web)\r\n    rcp.stats(3)\r\n\r\n    nyt_file = File(\"nytimes.html\")\r\n    nyt_url = (\r\n        \"https://bites-data.s3.us-east-2.amazonaws.com/2020-03-10_nytimes.html\"\r\n    )\r\n    nyt_web = Web(nyt_url, nyt_file)\r\n    nyt = NYTimes(nyt_web)\r\n    nyt.stats()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    gather_data()\r\n    \"\"\"url = \"https://bites-data.s3.us-east-2.amazonaws.com/pycon2019.html\"\r\n    test_file = 'test_file.html'\r\n    test_web = Web(url, File(test_file))\r\n    print(test_web.url)\r\n    print(test_web.file.name)\r\n    print(test_web.file.path)\r\n    print(test_web.file.data)\r\n    print(test_web.data)\r\n    print(test_web.soup)\r\n    \"\"\"\r\n    \r\n    \r\n\"\"\"\r\nassert \"National Polling Average: 29%\" in output\r\nassert \"       Pledged Delegates: 610\" in output\r\nassert \"Individual Contributions: $11.1m\" in output\r\nassert \"    Weekly News Coverage: 3\" in output\r\n\"\"\"    ",
            "score": 4,
            "number_code_submits": 20,
            "tags": "ABCs, abstractmethod, beautifulsoup, composition, dataclasses, inheritance, namedtuple, string formatting, typing, urllib, web scraping",
            "in_paths": "Object Oriented Programming, Web Scraping"
        },
        {
            "bite": "Bite 267. Measure the size of an island",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-27 18:37:23.038747+00:00",
            "passing_code": "# Hint:\r\n# You can define a helper funtion: get_others(map, row, col) to assist you.\r\n# Then in the main island_size function just call it when traversing the map.\r\n\r\n\r\ndef get_shores(map_, r, c):\r\n    \"\"\"Go through the map and check the size of the island\r\n       (= summing up all the 1s that are part of the island)\r\n\r\n       Input - the map, row, column position\r\n       Output - return the total number)\r\n    \"\"\"\r\n    nums = 0\r\n    rows= len(map_)\r\n    cols= (len(map_[0]))\r\n    # your code here\r\n    # print(f\"{r=},{c=}\")\r\n    #check N\r\n    if r==0:\r\n        nums+=1\r\n    else:\r\n        nums+=map_[r-1][c]==0\r\n    \r\n    #check S\r\n    if r==rows-1:\r\n        nums+=1\r\n    else:\r\n        nums+=map_[r+1][c]==0\r\n\r\n    #check E\r\n    if c==0:\r\n        nums+=1\r\n    else:\r\n        nums+=map_[r][c-1]==0\r\n\r\n    #check W\r\n    if c==cols-1:\r\n        nums+=1\r\n    else:\r\n        nums+=map_[r][c+1]==0\r\n    \r\n    return nums\r\n\r\n\r\ndef island_size(map_):\r\n    \"\"\"Hint: use the get_others helper\r\n\r\n    Input: the map\r\n    Output: the perimeter of the island\r\n    \"\"\"\r\n    perimeter = 0\r\n    rows= len(map_)\r\n    cols= (len(map_[0]))\r\n    # your code here\r\n    for i in range(rows):\r\n        for j in range(cols):\r\n            if map_[i][j] == 1:\r\n                perimeter +=get_shores(map_, i, j) \r\n    return perimeter\r\n    \r\n    \r\n",
            "score": 3,
            "number_code_submits": 2,
            "tags": "algorithms, looping, math",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 268. Number Transformers",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "algorithms, numbers",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 270. Most frequent digit in number",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-19 15:58:37.974546+00:00",
            "passing_code": "from collections import Counter\r\n\r\ndef freq_digit(num: int) -> int:\r\n    num_as_string = str(num)\r\n    most_common = Counter(num_as_string).most_common(1)\r\n    return int(most_common[0][0])\r\n\r\nprint(freq_digit(1121)+1-1)",
            "score": 2,
            "number_code_submits": 4,
            "tags": "Counter, counting, numbers",
            "in_paths": "Algorithms, Python Beginner"
        },
        {
            "bite": "Bite 272. Find common words",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-03 17:54:20.892081+00:00",
            "passing_code": "from collections import Counter\r\n\r\nfrom typing import List\r\n\r\n\r\ndef common_words(sentence1: List[str], sentence2: List[str]) -> List[str]:\r\n    \"\"\"\r\n    Input:  Two sentences - each is a  list of words in case insensitive ways.\r\n    Output: those common words appearing in both sentences. Capital and lowercase \r\n            words are treated as the same word. \r\n\r\n            If there are duplicate words in the results, just choose one word. \r\n            Returned words should be sorted by word's length.\r\n    \"\"\"\r\n    \r\n    # all lower() to make case insensitive\r\n    sentence2_lower = [word.lower() for word in sentence2]\r\n\r\n    # set() eliminates duplicates\r\n    result = set(word.lower() for word in sentence1 if word.lower() in sentence2_lower)\r\n    \r\n    return sorted(result,key=len)\r\n    \r\n\r\nS = ['You', 'can', 'do', 'anything', 'but', 'not', 'everything', 'do']\r\nT = ['We', 'are', 'what', 'we', 'repeatedly', 'do', 'is', 'not', 'an', 'act', 'do']\r\nprint(common_words(S,T))",
            "score": 3,
            "number_code_submits": 4,
            "tags": "algorithms, set operations, string matching",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 273. Shortest path (Graph Bite)",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "algorithms, computer science, graph",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 274. Number conversion problem",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-17 09:13:47.177069+00:00",
            "passing_code": "def dec_to_base(number, base):\r\n    \"\"\"\r\n    Input: number is the number to be converted\r\n           base is the new base  (eg. 2, 6, or 8)\r\n    Output: the converted number in the new base without the prefix (eg. '0b')\r\n    \"\"\"\r\n    # your code\r\n    if number <= base:\r\n        return int(str(number//base) +str(number%base))\r\n    else:\r\n        return int(str(dec_to_base(number//base, base)) +str(number%base))\r\n\r\nprint(dec_to_base(256,8))",
            "score": 3,
            "number_code_submits": 6,
            "tags": "algorithms, numbers, recursion",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 275. Get the most common email domains",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-08 07:50:31.208125+00:00",
            "passing_code": "from collections import Counter\r\n\r\nimport bs4\r\nimport requests\r\n\r\n\r\nCOMMON_DOMAINS = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n                  \"common-domains.html\")\r\nTARGET_DIV = {\"class\": \"middle_info_noborder\"}\r\n\r\ndef get_common_domains(url=COMMON_DOMAINS):\r\n    \"\"\"Scrape the url return the 100 most common domain names\"\"\"\r\n\r\n    content = requests.get(url).text\r\n\r\n    soup = bs4.BeautifulSoup(content, \"html.parser\")\r\n    target_div=soup.find('div', TARGET_DIV)\r\n    row_domains=target_div.find_all('tr')\r\n    return [row.td.next_sibling.next_sibling.get_text() for row in row_domains ]\r\n\r\ndef get_most_common_domains(emails, common_domains=None):\r\n    \"\"\"Given a list of emails return the most common domain names,\r\n       ignoring the list (or set) of common_domains\"\"\"\r\n    if common_domains is None:\r\n        common_domains = get_common_domains()\r\n\r\n    # your code\r\n    domains = [email.split('@')[1] for email in emails]\r\n    domains_filtered= [domain for domain in domains if domain not in common_domains]\r\n\r\n    return Counter(domains_filtered).most_common()\r\n\r\n\r\nlst= get_common_domains()\r\nprint(len(lst))\r\nprint(lst)\r\n\r\n# sample email list from mockaroo, edited manually\r\ntest_emails='''\r\nsally.sainsberry@bbb.org\r\ndcrauford1@gmail.com\r\nnmaccawley2@zdnet.com\r\ngsteinor3@vkontakte.ru\r\nn.mayer4@zdnet.com\r\nlaurent.lohrensen5@bbb.org\r\ntrich6@jigsy.com\r\nmbiggs7@linkedin.com\r\nraymond.jaquest@gmail.com\r\nedimitresco9@zdnet.com\r\nrvaraha@yahoo.com\r\n'''.strip().split()\r\nprint(get_most_common_domains(test_emails))\r\n",
            "score": 3,
            "number_code_submits": 9,
            "tags": "Counter, requests, set, string parsing, web scraping",
            "in_paths": ""
        },
        {
            "bite": "Bite 277. Number of coin changes",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "algorithms, dynamic programming",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 278. Major and minor numbers",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-14 17:03:20.870932+00:00",
            "passing_code": "from collections import Counter\r\n\r\ndef major_n_minor(numbers):\r\n    \"\"\"\r\n    Input: an array with integer numbers\r\n    Output: the majority and minority number\r\n    \"\"\"\r\n\r\n    # you code ...\r\n    cnt=Counter(numbers).most_common()\r\n    major = cnt[0][0]\r\n    minor = cnt[-1][0]\r\n    \r\n    return major, minor\r\n    \r\n    \r\nprint(major_n_minor([5,3,2,3,3,2,2,3,4,4]))\r\n    \r\n    ",
            "score": 2,
            "number_code_submits": 2,
            "tags": "collections, max, min, numbers",
            "in_paths": ""
        },
        {
            "bite": "Bite 279. Armstrong numbers",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-02 22:30:45.155235+00:00",
            "passing_code": "def is_armstrong(n: int) -> bool:\r\n    n_as_lst= [int(i) for i in str(n)]\r\n    # print(n_as_lst)\r\n    tmp = [i**len(n_as_lst) for i in n_as_lst]\r\n    # print(tmp)\r\n    return sum(tmp) == n\r\n\r\n    \r\n\r\nprint(is_armstrong(8))",
            "score": 2,
            "number_code_submits": 4,
            "tags": "algorithms, numbers",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 281. Generating sales reports from Github data",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "data analysis, pandas",
            "in_paths": "Data Analysis"
        },
        {
            "bite": "Bite 283. Like there's no tomorrow?",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-07 16:28:40.581535+00:00",
            "passing_code": "from datetime import date, timedelta\r\ndef tomorrow(today=None):\r\n    # Your code goes here\r\n    if not today:\r\n        today = date.today()\r\n        \r\n    return today + timedelta(days=1)\r\n    \r\n\r\nprint(tomorrow(date(year = 1975, month=4, day=8)))",
            "score": 2,
            "number_code_submits": 2,
            "tags": "datetime",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 284. Pascal triangle",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-22 16:33:08.554167+00:00",
            "passing_code": "from typing import List\r\nfrom math import factorial, ceil\r\n\r\ndef pascal(N: int) -> List[int]:\r\n    \"\"\"\r\n    Return the Nth row of Pascal triangle\r\n    \"\"\"\r\n    # you code ...\r\n    # return row\r\n    \r\n    row = N-1\r\n    result=[0 for _ in range(N)]\r\n\r\n    for col in range(ceil(N/2)):\r\n        result[col]=int(factorial(row)/(factorial(row-col)*factorial(col)))\r\n        result[-col-1]=result[col]\r\n    return result\r\n        \r\nprint(pascal(5))",
            "score": 3,
            "number_code_submits": 3,
            "tags": "algorithms, Pascal",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 288. Smallest number",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-18 12:04:54.871879+00:00",
            "passing_code": "from typing import List\r\nfrom itertools import permutations\r\n\r\ndef _int_from_digits(digits:tuple):\r\n    return int(\"\".join(str(n) for n in digits))\r\n    \r\n    \r\ndef minimum_number(digits: List[int]) -> int:\r\n    if digits:\r\n        return min(_int_from_digits(item) for item in list(permutations(set(digits))))\r\n    return 0\r\n    \r\ntest=[1,9,5,9,1]\r\nprint(minimum_number(test))",
            "score": 2,
            "number_code_submits": 3,
            "tags": "numbers",
            "in_paths": ""
        },
        {
            "bite": "Bite 289. Round to next number",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-19 12:04:08.562391+00:00",
            "passing_code": "from math import ceil\r\n\r\ndef round_to_next(number: int, multiple: int):\r\n    return ceil(number/multiple)*multiple\r\n    \r\n\r\nnums = [0,2,5,42,-6,-6]\r\nmults = [5,5,5,5,-10,-10]\r\n\r\nfor num,mult in zip(nums,mults):\r\n    print(f'{num=} -> {mult=} = {round_to_next(num,mult)}')",
            "score": 2,
            "number_code_submits": 2,
            "tags": "math",
            "in_paths": ""
        },
        {
            "bite": "Bite 291. Find the fastest speech",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-10 23:42:38.317096+00:00",
            "passing_code": "from datetime import timedelta, datetime\r\nfrom typing import List\r\n\r\n\r\ndef get_srt_section_ids(text: str) -> List[int]:\r\n    \"\"\"Parse a caption (srt) text passed in and return a\r\n       list of section numbers ordered descending by\r\n       highest speech speed\r\n       (= ratio of \"time past:characters spoken\")\r\n\r\n       e.g. this section:\r\n\r\n       1\r\n       00:00:00,000 --> 00:00:01,000\r\n       let's code\r\n\r\n       (10 chars in 1 second)\r\n\r\n       has a higher ratio then:\r\n\r\n       2\r\n       00:00:00,000 --> 00:00:03,000\r\n       code\r\n\r\n       (4 chars in 3 seconds)\r\n\r\n       You can ignore milliseconds for this exercise.\r\n    \"\"\"\r\n    lines=iter(text.lstrip().splitlines())\r\n    sections_speed=[]\r\n    for line in lines:\r\n        section=int(line)\r\n        timing=next(lines)\r\n        start,stop=timing.split(' --> ')\r\n        start=datetime.strptime(start.split(',')[0], '%H:%M:%S')\r\n        stop=datetime.strptime(stop.split(',')[0], '%H:%M:%S')\r\n        duration=stop-start\r\n        speech_lines=[]\r\n        speech_line=next(lines)\r\n        while speech_line:\r\n            speech_lines.append(speech_line)\r\n            try:\r\n                speech_line=next(lines)\r\n            except StopIteration:\r\n                speech_line =''\r\n        \r\n        speech='\\n'.join(speech_lines)\r\n        chars_per_second = len(speech)/duration.total_seconds()\r\n        sections_speed.append((section,chars_per_second))\r\n        # print('##'.join([str(section),str(duration),speech,str(chars_per_second)]))\r\n    # print(sections_speed)\r\n    return [item[0] for item in sorted(sections_speed, key=lambda x:x[1], reverse=True)]\r\n    \r\n    \r\n    \r\n    \r\ntext = \"\"\"\r\n1\r\n00:00:00,498 --> 00:00:02,827\r\nBeautiful is better than ugly.\r\n\r\n2\r\n00:00:02,827 --> 00:00:06,383\r\nExplicit is better than implicit.\r\n\r\n3\r\n00:00:06,383 --> 00:00:09,427\r\nSimple is better than complex.\r\n\"\"\"\r\n\r\nprint(get_srt_section_ids(text))",
            "score": 3,
            "number_code_submits": 4,
            "tags": "datetime, sorting, string manipulation",
            "in_paths": "Datetimes and Timezones"
        },
        {
            "bite": "Bite 293. N digit numbers",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-19 23:23:41.946032+00:00",
            "passing_code": "from typing import List, TypeVar\r\nT = TypeVar('T', int, float)\r\nimport re\r\n\r\ndef n_digit_numbers(numbers: List[T], n: int) -> List[int]:\r\n    result=[]\r\n    for num in numbers:\r\n        num_n_digit=int(re.sub('\\.|-','',str(num)).ljust(n,'0')[:n])\r\n        if num<0:\r\n            num_n_digit*=-1\r\n        result.append(num_n_digit)\r\n    return result\r\n    \r\n",
            "score": 2,
            "number_code_submits": 3,
            "tags": "numbers",
            "in_paths": ""
        },
        {
            "bite": "Bite 295. Join lists",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-22 12:38:21.138119+00:00",
            "passing_code": "from typing import List, Union\r\n\r\n\r\ndef join_lists(lst_of_lst: List[List[str]], sep: str) -> Union[List[str], None]:\r\n    if len(lst_of_lst)==0:\r\n        return None\r\n\r\n    joint_lst = [lst + [sep] for lst in lst_of_lst]\r\n    return [item for sublist in joint_lst for item in sublist][:-1]\r\n\r\nprint(join_lists([ ['a']], '&'))\r\nprint(join_lists([ ['a', 'b'], ['c'], ['d', 'e'] ], '+'))",
            "score": 2,
            "number_code_submits": 8,
            "tags": "iteration, joining, list",
            "in_paths": ""
        },
        {
            "bite": "Bite 296. Jagged list",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-15 23:09:07.821749+00:00",
            "passing_code": "from typing import List\r\nfrom itertools import zip_longest\r\n\r\ndef jagged_list(lst_of_lst: List[List[int]], fillvalue: int = 0) -> List[List[int]]:\r\n    zipped = zip_longest(*lst_of_lst, fillvalue = fillvalue)\r\n    return [list(item) for item in zip(*zipped)]\r\n\r\nprint(jagged_list([[1, 1, 1, 1], [0, 0, 0, 0], [1]], fillvalue=1))",
            "score": 3,
            "number_code_submits": 2,
            "tags": "iteration, itertools, list",
            "in_paths": ""
        },
        {
            "bite": "Bite 298. Fasta to 2-Line Fasta",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-06 14:29:29.411641+00:00",
            "passing_code": "import os\r\nimport urllib\r\nfrom Bio import SeqIO\r\n\r\n# Fetched and truncated from\r\n# https://www.uniprot.org/uniprot/?query=database%3A%28type%3Aembl+AE017195%29&format=fasta (Aug 01, 2020)\r\nURL = \"https://bites-data.s3.us-east-2.amazonaws.com/fasta_genes.fasta\"\r\nFASTA_FILE = os.path.join(os.getenv(\"TMP\", \"/tmp\"), \"fasta_genes.fasta\")\r\nif not os.path.isfile(FASTA_FILE):\r\n    urllib.request.urlretrieve(URL, FASTA_FILE)\r\n\r\ndef fasta_to_2line_fasta(fasta_file: str, fasta_2line_file: str) -> int:\r\n    \"\"\"\r\n    :param fasta_file: Filename of multi-line FASTA file\r\n    :param fasta_2line_file: Filename of 2-line FASTA file\r\n    :return: Number of records\r\n    \"\"\"\r\n    with open(fasta_file) as f:\r\n        content=f.read()\r\n    \r\n    result=[]\r\n    item=''\r\n    count =0\r\n    for line in content.splitlines():\r\n        if line.startswith(\">\"):\r\n            if item:\r\n                result.append(item+'\\n')    \r\n            item=line+\"\\n\"\r\n            count+=1\r\n        elif item:\r\n            item+=line\r\n    output=\"\".join(result)\r\n    print(output)\r\n    \r\n    with open(fasta_2line_file,'w') as f:\r\n        f.write(output)\r\n    \r\n    return count\r\n    \r\nif __name__ == \"__main__\":\r\n    fasta_to_2line_fasta(FASTA_FILE, f\"{FASTA_FILE}_converted.fasta\")",
            "score": 3,
            "number_code_submits": 8,
            "tags": "bioinformatics, biopython",
            "in_paths": "Bioinformatics"
        },
        {
            "bite": "Bite 300. \ud83e\udd73 PTO Calculator",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "calendar, datetime, exception handling, looping, numbers, string formatting",
            "in_paths": ""
        },
        {
            "bite": "Bite 304. Most identical letters in a word",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-15 01:15:07.257127+00:00",
            "passing_code": "from typing import Tuple\r\nimport string\r\nfrom collections import Counter\r\nNOT_LETTER = string.punctuation + string.digits\r\nimport unicodedata\r\n\r\n\r\ndef _strip_non_letters(word):\r\n    chars=[c for c in word]\r\n    for i,c in enumerate(chars):\r\n        if unicodedata.category(c) in ['Ll', 'Lu']:\r\n            start=i\r\n            break\r\n\r\n    for i,c in enumerate(chars[::-1]):\r\n        if unicodedata.category(c) in ['Ll', 'Lu']:\r\n            end=len(chars)-i\r\n            break\r\n    return word[start:end]\r\n\r\n    \r\n    \r\n    \r\ndef max_letter_word(text: str) -> Tuple[str, str, int]:\r\n    \"\"\"\r\n    Find the word in text with the most repeated letters. If more than one word\r\n    has the highest number of repeated letters choose the first one. Return a\r\n    tuple of the word, the (first) repeated letter and the count of that letter\r\n    in the word.\r\n    >>> max_letter_word('I have just returned from a visit...')\r\n    ('returned', 'r', 2)\r\n    >>> max_letter_word('$5000 !!')\r\n    ('', '', 0)\r\n    \"\"\"\r\n    if not isinstance(text, str):\r\n        raise ValueError\r\n        \r\n    lst=[]\r\n    for word in text.split():\r\n        if word: \r\n            word_stripped_as_lst=[c for c in word.casefold() if unicodedata.category(c) in ['Ll', 'Lu']]\r\n            if word_stripped_as_lst:\r\n                top_letter, count = Counter(word_stripped_as_lst).most_common()[0]\r\n                lst.append((_strip_non_letters(word), top_letter, count))\r\n    if lst:\r\n        return max(lst,key= lambda x:x[2])\r\n    else:\r\n        return ('', '', 0)\r\n\r\nif __name__== '__main__':\r\n    \r\n    \r\n    print(_strip_non_letters('\u00ab\u00bfTiene'))\r\n    \r\n    \"\"\"\r\n    test = ['emoji like \ud83d\ude03\ud83d\ude03\ud83d\ude03\ud83d\ude03 are not letters',\r\n    'Soci\u00e9t\u00e9 G\u00e9n\u00e9rale est une des principales banques fran\u00e7aises',\r\n    'Short Plays By Lady Gregory The Knickerbocker Press 1916',\r\n    'six-feet-two in height',\r\n    'der Schlo\u00df is riesig',\r\n    'the quick brown fox jumped over the lazy dog',\r\n    '\u00ab\u00bfTiene sentido la TV p\u00fablica?\u00bb',\r\n    \"but we've been there already!!!\",\r\n    '\"____\".isalpha() is True, thus this test text',\r\n    '99abc99 __abc__ --abc-- digits _ and - are not letters',\r\n    'test test test test test correct-answer.',\r\n    'They shouted \"Oh no she didn\\'t\"',\r\n    \"The brothers' feet were muddy.\",\r\n    '1, 2, 3',\r\n    '',\r\n    ]\r\n    \r\n    for item in test: \r\n        print(max_letter_word(item))\r\n        \r\n    \"\"\"",
            "score": 3,
            "number_code_submits": 12,
            "tags": "casefold, Counter, max, string matching",
            "in_paths": ""
        },
        {
            "bite": "Bite 306. Translate coding sequences to proteins",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-27 20:21:28.621316+00:00",
            "passing_code": "# TODO: Add imports\r\nfrom Bio.Seq import Seq, CodonTable\r\n\r\nimport string\r\n\r\ndef translate_cds(cds: str, translation_table: str) -> str:\r\n    \"\"\"\r\n    :param cds: str: DNA coding sequence (CDS)\r\n    :param translation_table: str: translation table as defined in Bio.Seq.Seq.CodonTable.ambiguous_generic_by_name\r\n    :return: str: Protein sequence\r\n    \"\"\"\r\n\r\n    # TODO: Put your code here\r\n    cds_clean = \"\".join([letter.upper() for letter in cds if letter.upper() in string.ascii_uppercase])\r\n    sequence=Seq(cds_clean)\r\n    tr_table=CodonTable.ambiguous_generic_by_name[translation_table]\r\n    return str(Seq.translate(sequence, table=tr_table, cds=True))\r\n    \r\n",
            "score": 3,
            "number_code_submits": 8,
            "tags": "bioinformatics, biopython",
            "in_paths": "Bioinformatics"
        },
        {
            "bite": "Bite 307. SQLite3 introduction",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "databases, SQL, sqlite3",
            "in_paths": ""
        },
        {
            "bite": "Bite 308. Calculate the median from a dictionary",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 3,
            "tags": "median, sorting, sum",
            "in_paths": ""
        },
        {
            "bite": "Bite 314. Print names to columns",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-16 23:01:26.768971+00:00",
            "passing_code": "from typing import List  # not needed when we upgrade to 3.9\r\n\r\n\r\ndef print_names_to_columns(names: List[str], cols: int = 2) -> None:\r\n    formatted=['| '+'{0: <10}'.format(name) for name in names]\r\n\r\n    n=len(names)\r\n    rows=n//cols\r\n    if rows:\r\n        for i in range(rows):\r\n            print(\"\".join(formatted[i*cols:(i+1)*cols]))\r\n    if n%cols:\r\n        print(\"\".join(formatted[rows*cols:n]))\r\n    \r\n    \r\n\r\nnames = 'Sara Tim Ana Julian Manolo Juan'.split()\r\nprint_names_to_columns(names,4)",
            "score": 2,
            "number_code_submits": 3,
            "tags": "f-strings, modulo, print",
            "in_paths": ""
        },
        {
            "bite": "Bite 315. More logging practice",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "exception handling, logging",
            "in_paths": ""
        },
        {
            "bite": "Bite 316. To rent or to stream movies?",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-23 18:44:58.258671+00:00",
            "passing_code": "from datetime import date\r\nfrom typing import Dict, Sequence, NamedTuple\r\nfrom collections import defaultdict, Counter\r\n\r\nclass MovieRented(NamedTuple):\r\n    title: str\r\n    price: int\r\n    date: date\r\n\r\n\r\nRentingHistory = Sequence[MovieRented]\r\nSTREAMING_COST_PER_MONTH = 12\r\nSTREAM, RENT = 'stream', 'rent'\r\n\r\ndef _best_option(amount):\r\n    return STREAM if amount>STREAMING_COST_PER_MONTH else RENT\r\n\r\ndef rent_or_stream(\r\n    renting_history: RentingHistory,\r\n    streaming_cost_per_month: int = STREAMING_COST_PER_MONTH\r\n) -> Dict[str, str]:\r\n    \"\"\"Function that calculates if renting movies one by one is\r\n       cheaper than streaming movies by months.\r\n\r\n       Determine this PER MONTH for the movies in renting_history.\r\n\r\n       Return a dict of:\r\n       keys = months (YYYY-MM)\r\n       values = 'rent' or 'stream' based on what is cheaper\r\n\r\n       Check out the tests for examples.\r\n    \"\"\"\r\n    monthly_spent=defaultdict(int)\r\n\r\n    for movie in renting_history:\r\n        monthly_spent[movie.date.strftime('%Y-%m')]+=movie.price \r\n\r\n    return {month:_best_option(amount) for month,amount in monthly_spent.items()}\r\n        \r\n",
            "score": 3,
            "number_code_submits": 2,
            "tags": "collections, datetime, dict, typing",
            "in_paths": "Data Analysis"
        },
        {
            "bite": "Bite 317. Pickling objects",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-12 15:59:24.324398+00:00",
            "passing_code": "from datetime import date\r\nimport os\r\n\r\nfrom pathlib import Path\r\nimport pickle\r\nfrom typing import Sequence, NamedTuple\r\nfrom urllib.request import urlretrieve\r\nfrom pprint import pprint\r\n\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nS3 = \"https://bites-data.s3.us-east-2.amazonaws.com\"\r\nPICKLE_INFILE = TMP / 'input.pkl'\r\nPICKLE_OUTFILE = TMP / 'output.pkl'\r\n\r\n\r\nclass MovieRented(NamedTuple):\r\n    title: str\r\n    price: int\r\n    date: date\r\n\r\n\r\ndef download_pickle_file():\r\n    \"\"\"download a pickle file we created with a\r\n       list of namedtuples\r\n    \"\"\"\r\n    urlretrieve(f'{S3}/bite317.pkl', PICKLE_INFILE)\r\n\r\n\r\ndef deserialize(pkl_file: Path = PICKLE_INFILE) -> Sequence[NamedTuple]:\r\n    \"\"\"Load the list of namedtuples from the pickle file passed in\"\"\"\r\n\r\n    if not os.path.exists(pkl_file):\r\n        download_pickle_file()\r\n        \r\n    with open(pkl_file, 'rb') as f:\r\n        return pickle.load(f)\r\n\r\n\r\ndef serialize(pkl_file: Path = PICKLE_OUTFILE,\r\n              data: Sequence[NamedTuple] = None) -> None:\r\n    \"\"\"Save the data passed in to the pickle file passed in\"\"\"\r\n    if data is None:\r\n        data = deserialize()\r\n    # you code ...\r\n    with open(pkl_file, 'wb') as f:\r\n        pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)\r\n",
            "score": 2,
            "number_code_submits": 2,
            "tags": "data wrangling, pickle, serialization",
            "in_paths": "Data Formats"
        },
        {
            "bite": "Bite 318. Decode base64 encoded data",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-24 22:37:37.261725+00:00",
            "passing_code": "import base64\r\nimport csv\r\nfrom typing import List  # will remove with 3.9\r\n\r\ndef get_credit_cards(data: bytes) -> List[str]:\r\n    \"\"\"Decode the base64 encoded data which gives you a csv\r\n    of \"first_name,last_name,credit_card\", from which you have\r\n    to extract the credit card numbers.\r\n    \"\"\"\r\n    string= base64.b64decode(data).decode(\"utf-8\")\r\n    reader = csv.DictReader(string.split('\\n'), delimiter=',')\r\n    return [row['credit_card'] for row in reader if row ]\r\n    \r\n\r\ndata = \"\"\"Zmlyc3RfbmFtZSxsYXN0X25hbWUsY3JlZGl0X2NhcmQKS2VlbGJ5LE1hY0NhZmZlcmt5LD\r\nYzOTM3MTk0MzMzMjk5MjQKTGlubmVsbCxDbGVtbWV0dCwzNTU1NTg0OTI0MDkzOTU0CkVs\r\neXNoYSxNZWlnaGFuLDYzODU3OTU3OTM4OTcxMDYKS2F0YWxpbixFdGhlcnRvbiwzNTg0Mj\r\nMwMDExNjgwNzAwCkZpbmEsUGFzZWssNTEwMDEzNjYzMTY2NDY4NwpBcmRlbGxhLEJyYXpp\r\nZXIsMjAxNzEyNjEzNjUzMzc0CkRvcnRoZWEsS2FycGluc2tpLDMwNTAyNjYxMjUxMTcyCl\r\nJhbm5hLER1ZmYsMzU3NjM5MzA1NjQ5MzMxMgpDaW5uYW1vbixLYWFzbWFuLDU0NDIwMjgx\r\nNTA4MDg1NzAKSmFjbGluLFRvbmdlLDM1NDk4NTIxMDQ3MjQ1MjcK\"\"\"\r\n\r\nprint(get_credit_cards(data))",
            "score": 2,
            "number_code_submits": 2,
            "tags": "base64, decode, encode",
            "in_paths": ""
        },
        {
            "bite": "Bite 319. Identity and equality",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-20 23:21:12.279574+00:00",
            "passing_code": "# TODO: Fix age and same_configuration functions (see test results)\r\nclass Car:\r\n    \"\"\"\r\n    Car class\r\n    -> Have a closer look at lines marked with '# *'\r\n    \"\"\"\r\n\r\n    def __init__(self, model, color):\r\n        self.model = model\r\n        self.color = color\r\n\r\n    def __eq__(self, other_car):\r\n        return (\r\n            self.model.lower() == other_car.model.lower()\r\n            and self.color.lower() == other_car.color.lower()\r\n        )\r\n\r\n    @staticmethod\r\n    def age(days):\r\n        \"\"\"if / elif / else for exercise sake, if there would\r\n           be more conditions we would use a dict / mapping\r\n        \"\"\"\r\n        if days == 7:  # *\r\n            return \"A week old\"\r\n        elif days == 365:  # *\r\n            return \"A year old\"\r\n        else:\r\n            return \"Neither a week, nor a year old\"\r\n\r\n    @staticmethod\r\n    def has_same_configuration(config1, config2):\r\n        if not isinstance(config1,list) or not isinstance(config2,list):  # *\r\n            raise TypeError()\r\n        return config1 == config2  # *\r\n\r\n\r\n# TODO: Complete function\r\ndef is_same_car_color_and_model(car1, car2):\r\n    \"\"\"\r\n    Returns true if car1 and car2 are the of same model and color\r\n    \"\"\"\r\n    return car1 == car2\r\n\r\n\r\n# TODO: Complete function\r\ndef is_same_instance_of_car(car1, car2):\r\n    \"\"\"\r\n    Returns true if car1 and car2 are exactly the same object (instance)\r\n    \"\"\"\r\n    return car1 is car2",
            "score": 2,
            "number_code_submits": 9,
            "tags": "equality, integer caching, staticmethod",
            "in_paths": ""
        },
        {
            "bite": "Bite 346. Getting started with the IRIS data set",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "data wrangling, machine learning, numpy, pandas, scikit-learn",
            "in_paths": ""
        },
        {
            "bite": "Bite 322. Reading progress",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-20 22:54:29.065157+00:00",
            "passing_code": "from datetime import datetime, date\r\nDAYS_IN_YEAR=365\r\n\r\ndef ontrack_reading(books_goal: int, books_read: int,\r\n                    day_of_year: int = None) -> bool:\r\n    if day_of_year is None:\r\n        today = date.today()\r\n        start_year= date(today.year, 1, 1)\r\n        day_of_year = (today - start_year).days\r\n    return books_read >= day_of_year*books_goal/DAYS_IN_YEAR\r\n    \r\n",
            "score": 2,
            "number_code_submits": 4,
            "tags": "datetime, numbers",
            "in_paths": ""
        },
        {
            "bite": "Bite 323. Iterables intersection",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-27 19:22:05.005222+00:00",
            "passing_code": "import functools\r\nfrom typing import Iterable, Set, Any\r\n\r\n\r\ndef intersection(*args: Iterable) -> Set[Any]:\r\n    sets=[set(arg) for arg in args if arg]\r\n    if not sets:\r\n        return set()\r\n    result=sets[0]\r\n    if len(sets)>1:\r\n        for set_i in sets[1:]:\r\n            result = result.intersection(set_i)\r\n    return result\r\n\r\nprint(intersection({1,2,3}, {2,3,4}, {3,4}))\r\nprint(intersection([1,2,3,\"1\"], {1,-1}, {}))\r\nprint(intersection(None, \"this is a string\"))\r\n",
            "score": 2,
            "number_code_submits": 3,
            "tags": "functools, set operations",
            "in_paths": ""
        },
        {
            "bite": "Bite 324. Pretty string",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-11 23:04:13.404093+00:00",
            "passing_code": "import pprint\r\nfrom typing import Any\r\n\r\n\r\ndef pretty_string(obj: Any) -> str:\r\n    # TODO: your code\r\n    return pprint.pformat(obj, width=60, depth = 2, sort_dicts= True)\r\n   \r\n\"\"\" \r\nd={\"Z\": \"Z\"*40,\r\n       \"B\": [1,[2,[3]]],\r\n       \"A\": \"A\"*40}\r\nprint(d)\r\nprint(pretty_string(d))\r\n\"\"\"",
            "score": 2,
            "number_code_submits": 2,
            "tags": "pprint",
            "in_paths": ""
        },
        {
            "bite": "Bite 325. Floating point arithmetic",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-13 21:04:45.921986+00:00",
            "passing_code": "from typing import Generator\r\n\r\nimport json\r\nimport decimal\r\n\r\nVALUES = \"[0.1, 0.2, 0.3, 0.005, 0.005, 2.67]\"\r\n\r\n\r\ndef calc_sums(values: str = VALUES) -> Generator[str, None, None]:\r\n    \"\"\"\r\n    Process the above JSON-encoded string of values and calculate the sum of each adjacent pair.\r\n\r\n    The output should be a generator that produces a string that recites the calculation for each pair, for example:\r\n\r\n        'The sum of 0.1 and 0.2, rounded to two decimal places, is 0.3.'\r\n    \"\"\"\r\n    \r\n    ctx = decimal.getcontext()\r\n    ctx.rounding = decimal.ROUND_HALF_UP\r\n\r\n    decimal_values = [decimal.Decimal(str(value)) for value in json.loads(values)]\r\n    for a,b in zip(decimal_values, decimal_values[1:]):\r\n        c = a + b\r\n        yield f\"The sum of {a} and {b}, rounded to two decimal places, is {c:.2f}.\"\r\n",
            "score": 3,
            "number_code_submits": 9,
            "tags": "arithmetic, floats, numbers, rounding",
            "in_paths": ""
        },
        {
            "bite": "Bite 329. Convert dict keys to snake case",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-23 18:21:30.522314+00:00",
            "passing_code": "from pprint import pprint\r\nimport string\r\nimport re\r\n    \r\ndef _make_snake(word):\r\n    # replace - with _\r\n    # make [0] lower\r\n    # replace upper with _lower\r\n    if len(word)<2:\r\n        return word.lower()\r\n    result = [word[0].lower()]\r\n    for letter in word[1:]:\r\n        if  letter =='-':\r\n            result.append('_')\r\n        elif letter in string.ascii_uppercase:\r\n            result.append('_'+letter.lower())\r\n        else:\r\n            result.append(letter)\r\n    word=\"\".join(result)\r\n    word=re.sub('(?<=[a-z])(?=[0-9])|(?<=[0-9])(?=[a-z])', '_', word)\r\n    return word\r\n\r\ndef snake_case_keys(data):\r\n    print(data)\r\n    if isinstance(data,str):\r\n        return data\r\n    if isinstance(data,list):\r\n        data_list = data\r\n    if isinstance(data, dict):\r\n        data_list = [data]\r\n\r\n    for i,data in enumerate(data_list):\r\n        if isinstance(data,str):\r\n            continue\r\n        if isinstance(data,list):\r\n            for j,item in enumerate(data):\r\n                data[j]=snake_case_keys(item)\r\n            \r\n        if isinstance(data,dict):    \r\n            data = {_make_snake(key): value for key,value in data.items()}\r\n            for key, value in data.items():\r\n                if isinstance(value, dict) or isinstance(value, list):\r\n                    data[key]= snake_case_keys(value)\r\n    \r\n            data_list[i] = data\r\n        \r\n    return data_list if len(data_list)>1 else data_list[0]\r\n        \r\n\r\ndata={\r\n    \"camelCase\": \"Value1\",\r\n    \"camelcase\": \"Value1\",\r\n    \"PascalCase\": \"Value2\",\r\n    \"kebab-case\": \"Value3\",\r\n    \"ACRONYM\": \"Value4\",\r\n    \"number22\": {\r\n                \"helmetColor\": \"black\",\r\n                \"armorColor\": \"black\",\r\n                \"capeColor\": \"black\",\r\n            },\r\n    \"nested_list\": [{\"firstName\": \"Luke\"},\r\n                     {\"firstName\": \"Leia\"}],\r\n    \"random\": [\r\n                \"Luke\",\r\n                [\r\n                    \"blowing up the death star\",\r\n                    {\"skillName\": \"bulls-eye womprats\",\r\n                     \"skillParameters\": \"with my T47\"},\r\n                ],\r\n            ]\r\n}\r\n\r\npprint(snake_case_keys(data))",
            "score": 4,
            "number_code_submits": 6,
            "tags": "algorithms, recursion, string manipulation",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 330. Simple Math Equation Solver",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-24 23:35:30.686501+00:00",
            "passing_code": "from itertools import permutations\r\nfrom operator import add, sub, mul\r\nfrom typing import List, Union, Iterable\r\n\r\nALLOWED_OPERATORS = \"+-*\"\r\nALLOWED_NUMBERS = [1,2,3,4,5,6,7,8,9]\r\n\r\ndef _eval(operator_path, numbers):\r\n    _operator_path = operator_path[:]\r\n    _numbers = numbers[:]\r\n\r\n    while '*' in _operator_path:\r\n        i = _operator_path.index('*')\r\n        op = _operator_path.pop(i)\r\n        _numbers[i]*=_numbers.pop(i+1)\r\n\r\n    while len(_operator_path)>0:\r\n        op = _operator_path.pop(0)\r\n        if op=='+':\r\n            _numbers[0]+=_numbers.pop(1)\r\n        if op=='-':\r\n            _numbers[0]-=_numbers.pop(1)\r\n    return _numbers[0]\r\n\r\n\r\ndef find_all_solutions(\r\n    operator_path: List[str], expected_result: int\r\n) -> Union[List[List[int]], Iterable[List[int]]]:\r\n    # TODO: blank canvas to fill\r\n    \r\n    if not isinstance(expected_result, int):\r\n        raise ValueError(\"Result must be of type int\")\r\n        \r\n    if not all(op in ALLOWED_OPERATORS for op in operator_path):\r\n        raise ValueError(\"Result must be of type int\")\r\n        \r\n    num_ops=len(operator_path) + 1\r\n    all_permutations = permutations(ALLOWED_NUMBERS, num_ops)\r\n    \r\n    return [list(perm) for perm in all_permutations if _eval(operator_path, list(perm)) == expected_result]\r\n",
            "score": 4,
            "number_code_submits": 12,
            "tags": "exception handling, itertools, list operations, math, operator",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 332. Searching for an apartment",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-21 18:16:39.467488+00:00",
            "passing_code": "from typing import List\r\n\r\nEAST = \"E\"\r\nWEST = \"W\"\r\n\r\n\r\ndef _has_a_view(i, buildings, direction):\r\n    if direction.upper() == 'W':\r\n        if i == 0:\r\n            return True\r\n        subset = buildings[:i]\r\n    elif direction.upper() == 'E':\r\n        if i == len(buildings):\r\n            return True\r\n        subset = buildings[i+1:]\r\n    else:\r\n        raise ValueError(\"Direction should be 'W' or 'E'\")\r\n        \r\n    return all(b<buildings[i] for b in subset)\r\n\r\ndef search_apartment(buildings: List[int], direction: str) -> List[int]:\r\n    \"\"\"\r\n    Find and return the indices of those building with\r\n    the desired view: EAST (E) or WEST (W).\r\n\r\n    See sample inputs / outputs below and in the tests.\r\n    \"\"\"\r\n    return [i for i in range(len(buildings)) if _has_a_view(i, buildings, direction)]\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    A = [3, 5, 4, 4, 7, 1, 3, 2]  # central tallest\r\n    B = [1, 1, 1, 1, 1, 2]  # almost flat\r\n    #\r\n    #  W <-                    ->  E(ast)\r\n    #\r\n    print(search_apartment(A, \"W\"))  # [0, 1, 4]\r\n    print(search_apartment(A, \"E\"))  # [4, 6, 7]\r\n    print(search_apartment(B, \"W\"))  # [0, 5]\r\n    print(search_apartment(B, \"E\"))  # [5]\r\n    \r\n    \r\n\r\n        \r\n",
            "score": 3,
            "number_code_submits": 3,
            "tags": "algorithms",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 333. Metropolis\u2013Hastings Algorithm",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "algorithms, Markov chain Monte Carlo, numpy, statistics",
            "in_paths": "Algorithms"
        },
        {
            "bite": "Bite 334. Simple TCP client",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "client, hashlib, multiprocessing, networking, secrets, socket, TCP/IP",
            "in_paths": ""
        },
        {
            "bite": "Bite 336. FastAPI Hello World",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-11 22:41:50.908860+00:00",
            "passing_code": "from fastapi import FastAPI # 1) import FastAPI\r\n\r\napp = FastAPI()  # 2) create a FastAPI instance in the variable my_app\r\n\r\n@app.get(\"/\")  # 3) define a path operation decorator for GET requests to the URL \"/\"\r\nasync def root():  # 4) write the path operation function\r\n    return {\"message\": \"Welcome to PyBites' FastAPI Learning Path \ud83d\udc0d \ud83c\udf89\"}  # 5) return the content",
            "score": 2,
            "number_code_submits": 3,
            "tags": "FastAPI, freebie",
            "in_paths": "FastAPI"
        },
        {
            "bite": "Bite 337. A little detour: Pydantic",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-09-13 12:13:37.354176+00:00",
            "passing_code": "from pydantic import BaseModel\r\nfrom typing import Optional\r\n\r\n# write a Food pydantic model\r\n\r\n\r\n\r\n\r\nclass Food(BaseModel):\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: Optional[float] = 0.0\r\n    \r\n\r\nif __name__ == \"__main__\":\r\n    food = Food(id = 3, name =\"spaghetti\", serving_size = \"100g\", kcal_per_serving=500, protein_grams =5.1)\r\n    print(food.name)\r\n    print(food.kcal_per_serving)\r\n    print(food.fibre_grams)",
            "score": 2,
            "number_code_submits": 3,
            "tags": "FastAPI, freebie, Pydantic",
            "in_paths": "FastAPI"
        },
        {
            "bite": "Bite 338. Create food objects",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-08 21:15:37.550477+00:00",
            "passing_code": "from typing import Dict\r\n\r\nfrom fastapi import FastAPI, Response, status\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n# write the Create endpoint\r\n@app.post(\"/\", status_code=200)\r\nasync def create_food(food: Food, response: Response):\r\n    foods[food.id] = food\r\n    response.status_code = status.HTTP_201_CREATED\r\n    return food",
            "score": 3,
            "number_code_submits": 10,
            "tags": "FastAPI, freebie",
            "in_paths": "FastAPI"
        },
        {
            "bite": "Bite 339. Retrieve food objects",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-22 11:38:09.095492+00:00",
            "passing_code": "from typing import Dict\r\n\r\nfrom fastapi import FastAPI\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n\r\n@app.post(\"/\", status_code=201)\r\nasync def create_food(food: Food):\r\n    \"\"\"Endpoint from Bite 03\"\"\"\r\n    foods[food.id] = food\r\n    return food\r\n\r\n\r\n# write the two Read endpoints\r\n@app.get(\"/\", status_code=200)\r\nasync def read_foods():\r\n    \"\"\"Endpoint to read all foods\"\"\"\r\n    return [food for food in foods.values()]\r\n\r\n\r\n@app.get(\"/{item_id}\", status_code=200)\r\nasync def read_food(item_id:int):\r\n    \"\"\"Endpoint to read a given food item\"\"\"\r\n    \r\n    return foods[item_id]\r\n",
            "score": 3,
            "number_code_submits": 5,
            "tags": "FastAPI, freebie",
            "in_paths": "FastAPI"
        },
        {
            "bite": "Bite 340. Update and delete food objects",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-22 12:10:56.579650+00:00",
            "passing_code": "from typing import Dict, List\r\n\r\nfrom fastapi import FastAPI, HTTPException\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n\r\n@app.post(\"/\", status_code=201)\r\nasync def create_food(food: Food):\r\n    \"\"\"Endpoint from Bite 03\"\"\"\r\n    foods[food.id] = food\r\n    return food\r\n\r\n\r\n@app.get(\"/\", response_model=List[Food])\r\nasync def read_foods():\r\n    \"\"\"Endpoints from Bite 04\"\"\"\r\n    return list(foods.values())\r\n\r\n\r\n@app.get(\"/{food_id}\", response_model=Food)\r\nasync def read_food(food_id: int):\r\n    \"\"\"Endpoints from Bite 04\"\"\"\r\n    return foods[food_id]\r\n\r\n\r\n# Create the update and delete endpoints here ...\r\n@app.put(\"/{food_id}\")\r\nasync def update_food(food_id: int, food: Food):\r\n    if food_id not in foods:\r\n        raise HTTPException(status_code=404, detail=\"Food not found\")\r\n    foods[food_id] = food\r\n    return foods[food_id]    \r\n\r\n\r\n@app.delete(\"/{food_id}\")\r\nasync def delete_food(food_id: int):\r\n    try:\r\n        foods.pop(food_id)\r\n    except:\r\n        raise HTTPException(404, detail=\"Food not found\")\r\n    return {\"ok\": True}",
            "score": 3,
            "number_code_submits": 6,
            "tags": "FastAPI, freebie",
            "in_paths": "FastAPI"
        },
        {
            "bite": "Bite 341. Pydantic part II",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-29 18:06:16.595853+00:00",
            "passing_code": "from datetime import datetime\r\nfrom typing import Any\r\n\r\nfrom passlib.context import CryptContext\r\nfrom pydantic import BaseModel\r\n\r\n\r\n# https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/\r\n# which we'll further explore in a later Bite\r\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\r\n\r\n\r\ndef get_password_hash(password):\r\n    return pwd_context.hash(password)\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n# Write the User and FoodEntry models here ...\r\n\r\nclass User(BaseModel):\r\n    id: int\r\n    username: str\r\n    password: str  # (needed for authentication later)\r\n\r\n    # For password override the constructor (__init__.py) to hash the password upon creation of the module. \r\n    # You can use the provided get_password_hash()\u00a0function for this.\r\n    \r\n    def __init__(self, *a, **kw):\r\n        super().__init__(*a, **kw)\r\n        self.password = get_password_hash(self.password)\r\n\r\n\r\nclass FoodEntry(BaseModel):\r\n    id: int  # (what in a DB would be the primary key)\r\n    user: User\r\n    food: Food\r\n    date_added: datetime = datetime.now()\r\n    number_servings: float\r\n\r\n    # add a property to calculate the total calories of a food entry \r\n    \r\n    @property\r\n    def total_calories(self):\r\n        return self.food.kcal_per_serving * self.number_servings\r\n        \r\n",
            "score": 3,
            "number_code_submits": 12,
            "tags": "FastAPI, freebie, Pydantic",
            "in_paths": "FastAPI"
        },
        {
            "bite": "Bite 342. Food logging CRUD",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-29 23:07:54.660981+00:00",
            "passing_code": "from datetime import datetime\r\nfrom typing import Any, Dict, List\r\n\r\nfrom fastapi import FastAPI, HTTPException\r\nfrom passlib.context import CryptContext\r\nfrom pydantic import BaseModel\r\n\r\n# https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/\r\n# We'll export authentication further in a later Bite\r\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\r\n\r\n\r\ndef get_password_hash(password):\r\n    return pwd_context.hash(password)\r\n\r\n\r\nclass Food(BaseModel):\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n\r\nclass User(BaseModel):\r\n    id: int\r\n    username: str\r\n    password: str\r\n\r\n    def __init__(self, **data: Any):\r\n        data[\"password\"] = get_password_hash(data[\"password\"])\r\n        super().__init__(**data)\r\n\r\n\r\nclass FoodEntry(BaseModel):\r\n    id: int\r\n    user: User\r\n    food: Food\r\n    date_added: datetime = datetime.now()\r\n    number_servings: float\r\n\r\n    @property\r\n    def total_calories(self):\r\n        return self.food.kcal_per_serving * self.number_servings\r\n\r\n\r\napp = FastAPI()\r\nfood_log: Dict[int, FoodEntry] = {}\r\n\r\n# We've hidden the previous Food CRUD to keep it compact and to force you to\r\n# repeat the API building process (deliberate practice is key!)\r\n\r\n# Create CRUD endpoints for FoodEntry below as per instructions in the Bite ...\r\n\r\n\r\n@app.post('/', status_code=201)\r\nasync def create_food_entry(food_entry: FoodEntry):\r\n    food_log[food_entry.id]=food_entry\r\n    return food_entry\r\n\r\n\r\n@app.get('/{user_id}', response_model=List[FoodEntry])\r\nasync def get_foods_for_user(user_id:int):\r\n    return [food_entry for food_entry in food_log.values() if food_entry.user.id == user_id]\r\n\r\n\r\n@app.put('/{entry_id}')\r\nasync def update_food_entry(entry_id:int, food_entry:FoodEntry):\r\n    if entry_id not in food_log:\r\n        raise HTTPException(404, detail='Food entry not found')\r\n    food_log[entry_id]=food_entry\r\n    return food_entry\r\n\r\n\r\n@app.delete('/{entry_id}')\r\nasync def delete_food_entry(entry_id:int):\r\n    try:\r\n        food_log.pop(entry_id)\r\n    except:\r\n        raise HTTPException(404, detail='Food entry not found')\r\n    return {'ok': True}\r\n\r\n\r\n    \r\n    ",
            "score": 3,
            "number_code_submits": 18,
            "tags": "FastAPI, freebie",
            "in_paths": "FastAPI"
        },
        {
            "bite": "Bite 347. Which words can you type with one hand?",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-22 18:50:11.672815+00:00",
            "passing_code": "from enum import Enum\r\n\r\n\r\nclass Hand(str, Enum):\r\n    RIGHT = \"right\"\r\n    LEFT = \"left\"\r\n    BOTH = \"both\"\r\n\r\n\r\nLEFT_HAND_CHARS = set(\"QWERTASDFGZXCVB\")\r\nRIGHT_HAND_CHARS = set(\"YUIOPHJKLNM\")\r\n\r\n\r\ndef get_hand_for_word(word: str) -> Hand:\r\n    \"\"\"\r\n    Use the LEFT_HAND_CHARS and RIGHT_HAND_CHARS sets to determine\r\n    if the passed in word can be written with only the left or right\r\n    hand, or if both hands are needed.\r\n    \"\"\"\r\n    \r\n    if all(letter.upper() in LEFT_HAND_CHARS for letter in word):\r\n        return Hand.LEFT\r\n    elif all(letter.upper() in RIGHT_HAND_CHARS for letter in word):\r\n        return Hand.RIGHT\r\n    else:\r\n        return Hand.BOTH\r\n",
            "score": 2,
            "number_code_submits": 3,
            "tags": "comparison, enum, set",
            "in_paths": ""
        },
        {
            "bite": "Bite 348. Citation indexes",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-07 17:13:16.124150+00:00",
            "passing_code": "from typing import Sequence\r\nfrom collections import Counter\r\n\r\nTYPE_ERROR_MSG = \"Unsupported input type: use either a list or a tuple\"\r\nVALUE_ERROR_MSG = \"Unsupported input value: citations cannot be neither empty nor None\"\r\n\r\ndef _check_valid_input(citations):\r\n    if citations is None:\r\n        raise ValueError(VALUE_ERROR_MSG)\r\n        \r\n    if not isinstance(citations, (list, tuple)):\r\n        raise TypeError(TYPE_ERROR_MSG)\r\n    \r\n    if not citations or any(not isinstance(item, int) or item<0 for item in citations):\r\n        raise ValueError(VALUE_ERROR_MSG)\r\n\r\n\r\ndef h_index(citations: Sequence[int]) -> int:\r\n    \"\"\"Return the highest number of papers h having at least h citations\"\"\"\r\n    _check_valid_input(citations)\r\n    \r\n    count = Counter(citations)\r\n\r\n    for i in range(len(citations),0,-1):\r\n        if sum(n_papers for n_citations, n_papers in count.items() if n_citations >=i) >= i:\r\n            return i\r\n    return 0\r\n\r\ndef i10_index(citations: Sequence[int]) -> int:\r\n    \"\"\"Return the number of papers having at least 10 citations\"\"\"\r\n    _check_valid_input(citations)\r\n\r\n    count = Counter(citations)\r\n    return sum(n_papers for n_citations, n_papers in count.items() if n_citations >=10)\r\n    \r\n\r\nprint(h_index([0, 0, 11, 1, 10, 5, 10, 5]))\r\n\r\nprint(i10_index([0, 0, 11, 1, 10, 5, 10, 3]))",
            "score": 3,
            "number_code_submits": 13,
            "tags": "builtins, exception handling, typing",
            "in_paths": ""
        },
        {
            "bite": "Bite 349. Writing better Spanish",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-10-04 19:12:10.466108+00:00",
            "passing_code": "import os\r\nfrom pathlib import Path\r\nfrom typing import List\r\nimport unicodedata\r\nfrom urllib.request import urlretrieve\r\nimport re\r\n\r\ndef _get_spanish_dictionary_words() -> List[str]:\r\n    filename = \"spanish.txt\"\r\n    # source of file\r\n    # https://raw.githubusercontent.com/bitcoin/bips\r\n    # /master/bip-0039/spanish.txt\r\n    url = f\"https://bites-data.s3.us-east-2.amazonaws.com/{filename}\"\r\n    tmp_folder = os.getenv(\"TMP\", \"/tmp\")\r\n    local_filepath = Path(tmp_folder) / filename\r\n    if not Path(local_filepath).exists():\r\n        urlretrieve(url, local_filepath)\r\n    return local_filepath.read_text().splitlines()\r\n\r\n\r\nSPANISH_WORDS = _get_spanish_dictionary_words()\r\n_accentuate = {unicodedata.normalize('NFKD', word).encode('ascii', 'ignore').decode('utf8'): word for word in SPANISH_WORDS}\r\n\r\ndef get_accentuated_sentence(\r\n    text: str, words: List[str] = SPANISH_WORDS\r\n) -> str:\r\n    replaced = []\r\n    for word_w_signs in text.split():\r\n        word = re.sub(r'[^a-zA-Z0-9]', '', word_w_signs)\r\n        replaced.append(word_w_signs.replace(word, _accentuate.get(word, word)))\r\n    return \" \".join(replaced)\r\n\r\nprint(get_accentuated_sentence(\"sesion de escribir, primera pagina de mi poesia hecha\"))",
            "score": 3,
            "number_code_submits": 3,
            "tags": "ascii, dict, unicode, unicodedata",
            "in_paths": ""
        },
        {
            "bite": "Bite 350. Learn to handle cron schedule expressions",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "crontab, dataclasses, datetime, exception handling, iteration",
            "in_paths": ""
        },
        {
            "bite": "Bite 351. Get spelling suggestions",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-12-06 19:10:55.272164+00:00",
            "passing_code": "from typing import List, NamedTuple\r\n\r\nfrom textblob import Word\r\n\r\nfrom collections import namedtuple\r\n\r\nMIN_CONFIDENCE = 0.5\r\n\r\n\r\n# define SuggestedWord NamedTuple with attributes\r\n# word (str) and confidence (float)\r\nSuggestedWord = namedtuple('SuggestedWord', ['word','confidence'])\r\n\r\n\r\ndef get_spelling_suggestions(\r\n    word: str, min_confidence: float = MIN_CONFIDENCE\r\n) -> List[SuggestedWord]:\r\n    \"\"\"\r\n    Find spelling suggestions with at least minimum confidence score\r\n    Use textblob.Word (check out the docs)\r\n    \"\"\"\r\n    w = Word(word)\r\n    return [SuggestedWord(word, confidence) for word, confidence in w.spellcheck() if confidence >= min_confidence]\r\n\r\n\r\n\"\"\"\r\nprint(get_spelling_suggestions('pron', min_confidence=0.1))\r\n\"\"\"",
            "score": 3,
            "number_code_submits": 3,
            "tags": "comparison, namedtuple, TextBlob, tuple unpacking, typing",
            "in_paths": ""
        },
        {
            "bite": "Bite 352. Hash SQL statements",
            "completed": false,
            "cheated": false,
            "date_first_completed": "None",
            "passing_code": null,
            "score": 0,
            "number_code_submits": 0,
            "tags": "hashlib, SQL",
            "in_paths": ""
        },
        {
            "bite": "Bite 353. Transform a Script Into a Command Line Interface (CLI)",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-05 11:56:36.394118+00:00",
            "passing_code": "import typer  # use typer.run and typer.Argument\r\n\r\n\r\ndef sum_numbers(a: int, b: int):\r\n    \"\"\"Sums two numbers\"\"\"\r\n    return a + b\r\n\r\n\r\ndef main(\r\n        a:int = typer.Argument(..., help=\"The value of the first summand\"),\r\n        b:int = typer.Argument(..., help=\"The value of the second summand\")\r\n        ):\r\n    \"\"\"\r\n    CLI that allows you to add two numbers\r\n    \"\"\"\r\n    print(sum_numbers(a,b))\r\n\r\nif __name__ == \"__main__\":\r\n    typer.run(main)",
            "score": 2,
            "number_code_submits": 3,
            "tags": "command line, Typer",
            "in_paths": "Typer"
        },
        {
            "bite": "Bite 354. When to Use Command Line Option (CLI) Options and When CLI Arguments?",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-07 16:36:09.200076+00:00",
            "passing_code": "import typer\r\n\r\n\r\ndef sum_numbers(a: int, b: int):\r\n    return a + b\r\n\r\n\r\ndef main(\r\n    a: int = typer.Argument(..., help=\"The value of the first summand\"),\r\n    b: int = typer.Argument(..., help=\"The value of the second summand\"),\r\n    c: int = typer.Option(None, help=\"The value to compare the sum.\"),\r\n):\r\n    \"\"\"CLI that allows you to add two numbers\"\"\"\r\n\r\n    if not c:\r\n        COMPARISON = None\r\n    elif c<sum_numbers(a, b):\r\n        COMPARISON = \"smaller\" \r\n    else:\r\n        COMPARISON = \"not smaller\"\r\n\r\n    print(f\"The sum is {sum_numbers(a, b)} and c is {COMPARISON}\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    typer.run(main)",
            "score": 3,
            "number_code_submits": 2,
            "tags": "command line, Typer",
            "in_paths": "Typer"
        },
        {
            "bite": "Bite 355. Create Your First Typer Command Line Interface (CLI) Application",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-06 13:34:30.304900+00:00",
            "passing_code": "import typer\r\n\r\n\r\ndef sum_numbers(a: int, b: int):\r\n    return a + b\r\n\r\n\r\napp = typer.Typer()\r\n\r\n\r\n@app.command()\r\ndef sum(\r\n    a:int = typer.Argument(..., help=\"The value of the first summand\"),\r\n    b:int = typer.Argument(..., help=\"The value of the second summand\"),\r\n):\r\n    \"\"\"Command that allows you to add two numbers.\"\"\"\r\n    sum_ab = sum_numbers(a, b)\r\n\r\n    print(f\"The sum is {sum_ab}\")\r\n\r\n\r\n@app.command()\r\ndef compare(\r\n    c:int = typer.Argument(..., help=\"First number to compare against.\"),\r\n    d:int = typer.Argument(..., help=\"Second number that is compared against first number.\"),\r\n):\r\n    \"\"\"Command that checks whether a number d is greater than a number c.\"\"\"\r\n\r\n    STRING_TRUE = \"greater\"\r\n    STRING_FALSE = \"not greater\"\r\n\r\n    c_evaluation = STRING_TRUE if d > c else STRING_FALSE\r\n\r\n    print(f\"{d=} is {c_evaluation} than {c=}\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app()\r\n\r\n\r\n\r\n\r\n\r\n",
            "score": 2,
            "number_code_submits": 2,
            "tags": "command line, Typer",
            "in_paths": "Typer"
        },
        {
            "bite": "Bite 356. Using Typer Callbacks to Create Command Line Interface (CLI) Parameters",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-08 18:26:44.130623+00:00",
            "passing_code": "import typer\r\n\r\n\r\ndef sum_numbers(a: int, b: int):\r\n    return a + b\r\n\r\n\r\napp = typer.Typer()\r\nstate = {\"verbose\": False} # MH\r\n\r\n\r\n@app.command()\r\ndef sum(\r\n    a: int = typer.Argument(..., help=\"The value of the first summand\"),\r\n    b: int = typer.Argument(..., help=\"The value of the second summand\"),\r\n):\r\n    \"\"\"Command that allows you to add two numbers.\"\"\"\r\n    sum_ab = sum_numbers(a, b)\r\n\r\n    # MH: add an if-else to write verbose output as a function of the callback setting\r\n    if state[\"verbose\"]:\r\n        print(f\"The sum is {sum_ab}\")\r\n    else:\r\n        print(f\"{sum_ab}\")\r\n\r\n\r\n@app.command()\r\ndef compare(\r\n    c: int = typer.Argument(..., help=\"First number to compare against.\"),\r\n    d: int = typer.Argument(\r\n        ..., help=\"Second number that is compared against first number.\"\r\n    ),\r\n):\r\n    \"\"\"Command that checks whether a number d is greater than a number c.\"\"\"\r\n\r\n    STRING_TRUE = \"greater\"\r\n    STRING_FALSE = \"not greater\"\r\n\r\n    d_greater_c = d > c\r\n\r\n    c_evaluation = STRING_TRUE if d_greater_c else STRING_FALSE\r\n\r\n    # MM: add an if-else to write verbose output as a function of the callback setting\r\n    if state[\"verbose\"]:\r\n        print(f\"{d=} is {c_evaluation} than {c=}\")\r\n    else:\r\n        print(f\"d > c: {d_greater_c}\")\r\n\r\n\r\n# MH: decorate this\r\n@app.callback()\r\ndef main(\r\n    verbose: bool = False\r\n):\r\n    \"\"\"\r\n    Have sum fun with numbers.\r\n    \"\"\"\r\n    # MH: inform user and set state according to user input about verbosity\r\n    if verbose:\r\n        print(\"Will write verbose output\")\r\n        state[\"verbose\"] = True\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app()",
            "score": 3,
            "number_code_submits": 3,
            "tags": "command line, Typer",
            "in_paths": "Typer"
        },
        {
            "bite": "Bite 357. Implement your First Subcommands and Command Groups",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-06 13:40:38.827787+00:00",
            "passing_code": "import os\r\nfrom pathlib import Path\r\nimport sys\r\nfrom urllib.request import urlretrieve\r\nfrom zipfile import ZipFile\r\n\r\nimport typer\r\n\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nS3 = \"https://bites-data.s3.us-east-2.amazonaws.com\"\r\n\r\n\r\ndef _setup():\r\n    data_zipfile = '357-data.zip'\r\n    urlretrieve(f'{S3}/{data_zipfile}', TMP / data_zipfile)\r\n    ZipFile(TMP / data_zipfile).extractall(TMP)\r\n    sys.path.append(TMP)\r\n\r\n\r\n_setup()\r\n\r\nimport algorithms  # noqa E402\r\nimport comparisons  # noqa E402\r\n\r\n\r\napp = typer.Typer()\r\napp.add_typer(algorithms.app, name=\"algorithms\")\r\napp.add_typer(comparisons.app, name=\"comparisons\")\r\n\r\nif __name__ == \"__main__\":\r\n    app()",
            "score": 2,
            "number_code_submits": 2,
            "tags": "command line, Typer",
            "in_paths": "Typer"
        },
        {
            "bite": "Bite 358. Implementation of a Simple Typer Test",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-08 18:36:06.675785+00:00",
            "passing_code": "import pytest\r\nfrom typer.testing import CliRunner\r\n\r\nfrom script import app\r\n\r\n\r\n@pytest.fixture()\r\ndef runner() -> CliRunner:\r\n    return CliRunner()\r\n\r\n    \r\ndef test_app(runner):\r\n    result = runner.invoke(app, [\"Manolo\"])\r\n    assert result.exit_code == 0\r\n    assert \"Hello Manolo!\" in result.stdout\r\n\r\n\r\ndef test_help_msg(runner):\r\n    result = runner.invoke(app, [\"--help\"])\r\n    assert result.exit_code == 0\r\n    assert \"CLI that allows you to greet a person.\" in result.stdout\r\n    assert \"The name of the person to greet.\" in result.stdout\r\n",
            "score": 3,
            "number_code_submits": 3,
            "tags": "command line, pytest, Typer",
            "in_paths": "Typer"
        },
        {
            "bite": "Bite 359. Implementation of a More Sophisticated Typer Tests",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-26 15:51:34.813413+00:00",
            "passing_code": "import pytest\r\nfrom typer.testing import CliRunner\r\n\r\nfrom script import app\r\n\r\n\r\n@pytest.fixture()\r\ndef runner() -> CliRunner:\r\n    return CliRunner()\r\n\r\n\r\n@pytest.mark.parametrize(\r\n    \"command, expected_result\",\r\n    [\r\n        (\"subtract 1 6\", \"The delta is -5\"),\r\n        (\"subtract 8 5\", \"The delta is 3\"),\r\n    ],\r\n)\r\ndef test_subtract(command:str, expected_result:str, runner:CliRunner):\r\n    result = runner.invoke(app, command)\r\n    assert result.exit_code == 0\r\n    assert expected_result in result.stdout\r\n\r\n\r\n@pytest.mark.parametrize(\r\n    \"command, expected_result\",\r\n    [\r\n        (\"compare 10 2\", \"d=2 is not greater than c=10\"),\r\n        (\"compare 0 5\", \"d=5 is greater than c=0\"),\r\n        (\"compare 3 3\", \"d=3 is not greater than c=3\"),\r\n    ],\r\n)\r\ndef test_compare(command:str, expected_result:str, runner:CliRunner):\r\n    result = runner.invoke(app, command)\r\n    assert result.exit_code == 0\r\n    assert expected_result in result.stdout\r\n\r\ndef test_help_msg(runner):\r\n    result = runner.invoke(app, [\"--help\"])\r\n    assert result.exit_code == 0\r\n    assert \"Command that allows you to add two numbers.\" in result.stdout\r\n    assert \"Command that checks whether a number d is greater than a number c.\" in result.stdout\r\n\r\ndef test_help_msg_subtract(runner):\r\n    result = runner.invoke(app, ['subtract', '--help'])\r\n    assert result.exit_code == 0    \r\n    assert \"The value of the first summand\" in result.stdout\r\n    assert \"The value of the second summand\" in result.stdout\r\n\r\ndef test_help_msg_compare(runner):\r\n    result = runner.invoke(app, ['compare', '--help'])\r\n    assert result.exit_code == 0    \r\n    assert \"First number to compare against.\" in result.stdout\r\n    assert \"Second number that is compared against first number.\" in result.stdout    \r\n\r\n\r\n",
            "score": 4,
            "number_code_submits": 13,
            "tags": "command line, Typer",
            "in_paths": "Typer"
        },
        {
            "bite": "Bite 360. Add a progress bar to Your Command Line Interface (CLI)",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-06 13:44:29.678002+00:00",
            "passing_code": "import time\r\n\r\nimport typer\r\nfrom rich.progress import track\r\n\r\n\r\napp = typer.Typer()\r\n\r\n\r\n@app.command()\r\ndef progress():\r\n    total = 0\r\n    for value in track(range(100), description=\"Processing...\"):\r\n        # Fake processing time\r\n        time.sleep(0.01)\r\n        total += 1\r\n    print(f\"Processed {total} things.\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app()",
            "score": 2,
            "number_code_submits": 2,
            "tags": "command line, rich, Typer",
            "in_paths": "Typer"
        },
        {
            "bite": "Bite 361. Rich Excursion - Create Beautiful Tables",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-25 21:34:20.938904+00:00",
            "passing_code": "import typer\r\nfrom rich.console import Console\r\nfrom rich.table import Table\r\n\r\napp = typer.Typer()\r\n\r\nconsole = Console()\r\n\r\n@app.command()\r\ndef table():\r\n    table = Table(\"Name\", \"Favorite Tool/Framework\")\r\n    table.add_row(\"Bob\", \"Vim\")\r\n    table.add_row(\"Julian\", \"Flask\")\r\n    table.add_row(\"Robin\", \"VS Code\")\r\n    console.print(table)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app()\r\n",
            "score": 3,
            "number_code_submits": 3,
            "tags": "command line, rich, Typer",
            "in_paths": "Typer"
        },
        {
            "bite": "Bite 362. Add a Password Prompt to Your Command Line Interface (CLI)",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-25 21:47:32.482162+00:00",
            "passing_code": "import typer\r\n\r\napp = typer.Typer()\r\n\r\n\r\n@app.command()\r\ndef main(\r\n    name: str = typer.Argument('Robin', help=\"Name\"),\r\n    password: str = typer.Option(\r\n        ..., prompt=True, confirmation_prompt=True, hide_input=True\r\n    ),\r\n):\r\n    print(f\"Hello {name}. Doing something very secure with password.\")\r\n    print(f\"...just kidding, here it is, very insecure: {password}\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app()\r\n    \r\n",
            "score": 3,
            "number_code_submits": 5,
            "tags": "command line, Typer",
            "in_paths": "Typer"
        },
        {
            "bite": "Bite 363. Movie Theater (Refactoring)",
            "completed": true,
            "cheated": false,
            "date_first_completed": "2022-11-16 22:34:40.981323+00:00",
            "passing_code": "\"\"\"\r\nRefactor the code below. Try go get the functions' bodies\r\nas close to the left side as possible (only one indentation deep).\r\n\"\"\"\r\navailable_movies = {\r\n    \"Tomorrow Never Dies\": {\r\n        \"id\": \"tomorrow_never_dies\",\r\n        \"quality\": \"IMAX\",\r\n        \"genre\": \"Action\",\r\n    },\r\n    \"Robin Hood\": {\"id\": \"robin_hood\", \"quality\": \"regular\", \"genre\": \"Adventure\"},\r\n    \"Pulp Fiction\": {\"id\": \"pulp_fiction\", \"quality\": \"regular\", \"genre\": \"Crime\"},\r\n}\r\n\r\n\r\ndef invoice_to_be_refactored(movie, tickets):\r\n    amount = 0\r\n    movie_in_available_movies = False\r\n    for title in available_movies:\r\n        if title == movie:\r\n            movie_in_available_movies = True\r\n            if tickets != 0:\r\n                if available_movies[movie][\"quality\"] == \"IMAX\":\r\n                    price = 12\r\n                    if tickets >= 5:\r\n                        discount = 10\r\n                    else:\r\n                        discount = 0\r\n                else:\r\n                    price = 10\r\n                    if tickets >= 5:\r\n                        discount = 10\r\n                    else:\r\n                        discount = 0\r\n            else:\r\n                raise ValueError(\"Cannot calculate price for 0 tickets\")\r\n    if movie_in_available_movies is False:\r\n        raise LookupError(\"Movie not available\")\r\n    else:\r\n        total_amount = amount + (tickets * price) - discount\r\n        return total_amount\r\n\r\ndef _price(movie):\r\n    if movie not in available_movies.keys():\r\n        raise LookupError(\"Movie not available\")\r\n    return 12 if available_movies[movie][\"quality\"] == \"IMAX\" else 10\r\n    \r\ndef _discount(tickets):\r\n    if tickets==0:\r\n        raise ValueError(\"Cannot calculate price for 0 tickets\")\r\n    return 10 if tickets >= 5 else 0\r\n    \r\ndef invoice_refactored(movie, tickets):\r\n    \"\"\"\"Refactor the above code getting rid of the arrow shape\"\"\"\r\n    return tickets * _price(movie) - _discount(tickets)\r\n",
            "score": 3,
            "number_code_submits": 5,
            "tags": "clean code, refactoring",
            "in_paths": ""
        }
    ],
    "commits": [
        {
            "bite": "Bite 87. Convert Decimal to Roman Numerals",
            "code": "def romanize(decimal_number):\r\n    \"\"\"Takes a decimal number int and converts its Roman Numeral str\"\"\"\r\n    UNITS = {0: '', 1:'I', 2: 'II', 3: 'III', 4: 'IV', 5: 'V', 6: 'VI', 7: 'VII', 8:'VIII', 9:'IX' }\r\n    TENS = {0: '', 1:'X', 2: 'XX', 3: 'XXX', 4: 'XL', 5: 'L', 6: 'LX', 7: 'LXX', 8:'LXXX', 9:'XC' }\r\n    HUNDREDS = {0: '', 1:'C', 2: 'CC', 3: 'CCC', 4: 'CD', 5: 'D', 6: 'DC', 7: 'DCC', 8:'DCCC', 9:'CM' }\r\n    \r\n    if not isinstance(decimal_number,int) or not 0<=decimal_number<=4000:\r\n        raise ValueError\r\n    \r\n    figures = [int(c) for c in str(decimal_number)[::-1]]\r\n    \r\n    result = ''\r\n    result+='M'*figures[3] if len(figures)>3 else '' \r\n    result+=HUNDREDS[figures[2]] if len(figures)>2 else ''\r\n    result+=TENS[figures[1]] if len(figures)>1 else ''\r\n    result+=UNITS[figures[0]] if len(figures)>0 else ''  \r\n    return result\r\n\r\n",
            "date": "2022-12-17 17:29:07.147968+00:00",
            "passed": true
        },
        {
            "bite": "Bite 87. Convert Decimal to Roman Numerals",
            "code": "def romanize(decimal_number):\r\n    \"\"\"Takes a decimal number int and converts its Roman Numeral str\"\"\"\r\n    UNITS = {0: '', 1:'I', 2: 'II', 3: 'III', 4: 'IV', 5: 'V', 6: 'VI', 7: 'VII', 8:'VIII', 9:'IX' }\r\n    TENS = {0: '', 1:'X', 2: 'XX', 3: 'XXX', 4: 'XL', 5: 'L', 6: 'LX', 7: 'LXX', 8:'LXXX', 9:'XC' }\r\n    HUNDREDS = {0: '', 1:'C', 2: 'CC', 3: 'CCC', 4: 'CD', 5: 'D', 6: 'DC', 7: 'DCC', 8:'DCCC', 9:'CM' }\r\n    \r\n    if not isinstance(decimal_number,int) or not 0<=decimal_number<=4000:\r\n        raise ValueError\r\n    \r\n    figures= [int(c) for c in str(decimal_number)[::-1]]\r\n    \r\n    result = ''\r\n    result+='M'*figures[3] if len(figures)>3 else '' \r\n    result+=HUNDREDS[figures[2]] if len(figures)>2 else ''\r\n    result+=TENS[figures[1]] if len(figures)>1 else ''\r\n    result+=UNITS[figures[0]] if len(figures)>0 else ''  \r\n    return result\r\n\r\n\r\n    \r\n\r\nprint(romanize(1234))",
            "date": "2022-12-17 17:28:39.278954+00:00",
            "passed": true
        },
        {
            "bite": "Bite 266. Composition, Inheritance, Abstract Base Class, what?",
            "code": "from abc import ABC, abstractmethod\r\nfrom collections import namedtuple\r\nfrom dataclasses import dataclass\r\nfrom datetime import date\r\nfrom os import getenv, path\r\nfrom pathlib import Path\r\nfrom typing import Any, List, Optional, NamedTuple\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup as Soup  # type: ignore\r\n\r\nTMP = getenv(\"TMP\", \"/tmp\")\r\nTODAY = date.today()\r\n\r\nCandidate = NamedTuple(\"Candidate\", [\r\n        ('name', str), \r\n        ('votes', int),\r\n    ]\r\n)\r\nLeaderBoard = NamedTuple(\r\n    \"LeaderBoard\", [\r\n        ('Candidate', str), \r\n        ('Average', str), \r\n        ('Delegates', str), \r\n        ('Contributions', str), \r\n        ('Coverage', str),\r\n    ]\r\n)\r\nPoll = NamedTuple(\r\n    \"Poll\",[\r\n        ('Poll', str),\r\n        ('Date', str),\r\n        ('Sample', int),\r\n        ('Sanders', float),\r\n        ('Biden', float),\r\n        ('Gabbard', float),\r\n        ('Spread', float),\r\n    ]\r\n)\r\n\r\n\r\ndef as_float(string):\r\n    try:\r\n        return float(string)\r\n    except ValueError:\r\n        return 0        \r\n\r\n@dataclass\r\nclass File:\r\n    \"\"\"File represents a filesystem path.\r\n\r\n    Variables:\r\n        name: str -- The filename that will be created on the filesystem.\r\n        path: Path -- Path object created from the name passed in.\r\n\r\n    Methods:\r\n        [property]\r\n        data: -> Optional[str] -- If the file exists, it returns its contents.\r\n            If it does not exist, it returns None.\r\n    \"\"\"\r\n    name: str\r\n    path: Path = ''\r\n    \r\n    def __post_init__(self):\r\n        if self.path:\r\n            self.path = Path(self_path , self.name)\r\n        else:\r\n            self.path = Path(TMP,f'{TODAY}_{self.name}')\r\n        \r\n    @property\r\n    def data(self) -> Optional[str]:\r\n        if path.isfile(self.path):\r\n            with open(self.path) as f:\r\n                return f.read()\r\n        else:\r\n            return None\r\n\r\n@dataclass\r\nclass Web:\r\n    \"\"\"Web object.\r\n\r\n    Web is an object that downloads the page from the url that is passed\r\n    to it and stores it in the File instance that is passed to it. If the\r\n    File already exists, it just reads the file, otherwise it downloads it\r\n    and stores it in File.\r\n\r\n    Variables:\r\n        url: str -- The url of the web page.\r\n        file: File -- The File object to store the page data into.\r\n\r\n    Methods:\r\n        [property]\r\n        data: -> Optional[str] -- Reads the text from File or retrieves it from the\r\n            web if it does not exists.\r\n\r\n        [property]\r\n        soup: -> Soup -- Parses the data from File and turns it into a BeautifulSoup\r\n            object.\r\n    \"\"\"\r\n    url: str\r\n    file: File\r\n\r\n    @property\r\n    def data(self) -> Optional[str]:\r\n        \"\"\"Reads the data from the File object.\r\n\r\n        First it checks if the File object has any data. If it doesn't, it retrieves\r\n        it and saves it to the File. It then reads it from the File and returns it.\r\n\r\n        Returns:\r\n            Optional[str] -- The string data from the File object.\r\n        \"\"\"\r\n        if not self.file.data:\r\n            urlretrieve(self.url, self.file.path)\r\n        return self.file.data\r\n\r\n    @property\r\n    def soup(self) -> Soup:\r\n        \"\"\"Converts string data from File into a BeautifulSoup object.\r\n\r\n        Returns:\r\n            Soup -- BeautifulSoup object created from the File.\r\n        \"\"\"\r\n        soup = Soup(self.data, 'html.parser')\r\n        return soup\r\n\r\n\r\nclass Site(ABC):\r\n    \"\"\"Site Abstract Base Class.\r\n\r\n    Defines the structure for the objects based on this class and defines the interfaces\r\n    that should be implemented in order to work properly.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        [abstractmethod]\r\n        parse_rows: -> Union[List[LeaderBoard], List[Poll]] -- Parses a BeautifulSoup\r\n            table element and returns the text found in the td elements as\r\n            namedtuples.\r\n\r\n        [abstractmethod]\r\n        polls: -> Union[List[LeaderBoard], List[Poll]] -- Does the parsing of the table\r\n            and rows for you. It takes the table index number if given, otherwise\r\n            parses table 0.\r\n\r\n        [abstractmethod]\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation.\r\n    \"\"\"\r\n    web: Web\r\n\r\n    def find_table(self, loc: int = 0) -> str:\r\n        \"\"\"Finds the table elements from the Soup object\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Parses the Web object for table elements and\r\n                returns the first one that it finds unless an integer representing\r\n                the required table is passed. (default: {0})\r\n\r\n        Returns:\r\n            str -- The html table\r\n        \"\"\"\r\n            \r\n        return self.web.soup.find_all('table')[loc or 0]\r\n\r\n    @abstractmethod\r\n    def parse_rows(self, table: Soup) -> List[Any]:\r\n        \"\"\"Abstract Method\r\n        \r\n        Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as NamedTuple.\r\n\r\n        Returns:\r\n            List[NamedTuple] -- List of NamedTuple that were created from the\r\n                table data.\r\n        \"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def polls(self, table: int = 0) -> List[Any]:\r\n        \"\"\"Abstract Method\r\n\r\n        Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[NamedTuple] -- List of NamedTuple that were created from the\r\n                table data.\r\n        \"\"\"\r\n        pass\r\n    \r\n    @abstractmethod\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Abstract Method\r\n        \r\n        Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n        \"\"\"\r\n        pass\r\n\r\n\r\n@dataclass\r\nclass RealClearPolitics(Site):\r\n    \"\"\"RealClearPolitics object.\r\n\r\n    RealClearPolitics is a custom class to parse a Web instance from the\r\n    realclearpolitics website.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        parse_rows: -> List[Poll] -- Parses a BeautifulSoup table element and\r\n            returns the text found in the td elements as Poll namedtuples.\r\n\r\n        polls: -> List[Poll] -- Does the parsing of the table and rows for you.\r\n            It takes the table index number if given, otherwise parses table 0.\r\n\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation:\r\n\r\n            Example:\r\n\r\n            RealClearPolitics\r\n            =================\r\n                Biden: 214.0\r\n              Sanders: 142.0\r\n              Gabbard: 6.0\r\n\r\n    \"\"\"\r\n\r\n    web:Web\r\n\r\n    def parse_rows(self, table: Soup) -> List[Poll]:\r\n        \"\"\"Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as Poll namedtuples.\r\n\r\n        Returns:\r\n            List[Poll] -- List of Poll namedtuples that were created from the\r\n                table data.\r\n        \"\"\"\r\n        lst=[]\r\n        for row in table.find_all('tr')[2:]:\r\n            tds=row.find_all('td')\r\n            poll=tds[0].text\r\n            date=tds[1].text\r\n            sample=as_float(tds[2].text)\r\n            biden=as_float(tds[3].text)\r\n            sanders=as_float(tds[4].text)\r\n            gabbard=as_float(tds[5].text)\r\n            spread=as_float(tds[5].text)\r\n            lst.append(Poll(poll, date, sample, sanders, biden, gabbard, spread))\r\n        # print(lst)\r\n        return lst\r\n\r\n    def polls(self, table: int = 0) -> List[Poll]:\r\n        \"\"\"Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[Poll] -- List of Poll namedtuples that were created from the\r\n                table data.\r\n        \"\"\"\r\n        return self.parse_rows(self.find_table(table))\r\n\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n\r\n        \"\"\"\r\n        output=\"\"\"\\nRealClearPolitics\\n=================\\n\"\"\"\r\n        for candidate in 'Biden', 'Sanders', 'Gabbard':\r\n            output+=f'{candidate:>9}: {sum(getattr(poll, candidate) for poll in self.polls(loc))}\\n'\r\n        print(output)\r\n\r\n\r\n@dataclass\r\nclass NYTimes(Site):\r\n    \"\"\"NYTimes object.\r\n\r\n    NYTimes is a custom class to parse a Web instance from the nytimes website.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        parse_rows: -> List[LeaderBoard] -- Parses a BeautifulSoup table element and\r\n            returns the text found in the td elements as LeaderBoard namedtuples.\r\n\r\n        polls: -> List[LeaderBoard] -- Does the parsing of the table and rows for you.\r\n            It takes the table index number if given, otherwise parses table 0.\r\n\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation:\r\n\r\n            Example:\r\n\r\n            NYTimes\r\n            =================================\r\n\r\n                               Pete Buttigieg\r\n            ---------------------------------\r\n            National Polling Average: 10%\r\n                   Pledged Delegates: 25\r\n            Individual Contributions: $76.2m\r\n                Weekly News Coverage: 3\r\n\r\n    \"\"\"\r\n\r\n    web: Web\r\n\r\n    def parse_rows(self, table: Soup) -> List[LeaderBoard]:\r\n        \"\"\"Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as LeaderBoard namedtuples.\r\n\r\n        Returns:\r\n            List[LeaderBoard] -- List of LeaderBoard namedtuples that were created from\r\n            the table data.\r\n        \"\"\"\r\n        lst=[]\r\n        for row in table.find_all('tr')[1:4]:\r\n            tds=row.find_all('td')\r\n            candidate=tds[0].text.strip()\r\n            average=tds[1].text.strip()\r\n            delegates=int(tds[2].text.strip())\r\n            contributions=tds[3].text.strip()\r\n            coverage=int(tds[4].text.strip('# '))\r\n            # print(\" # \".join([candidate, average, delegates, contributions, coverage]))\r\n            lst.append(LeaderBoard(candidate, average, delegates, contributions, coverage))\r\n        # print(lst)\r\n        return lst\r\n        \r\n\r\n    def polls(self, table: int = 0) -> List[LeaderBoard]:\r\n        \"\"\"Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[LeaderBoard] -- List of LeaderBoard namedtuples that were created from\r\n                the table data.\r\n        \"\"\"\r\n        return self.parse_rows(self.find_table(table))\r\n\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n        \"\"\"\r\n        output=f\"\\nNYTimes\\n{'='*33}\\n\\n\"\r\n        for item in self.polls(loc):\r\n            output+=f\"{item.Candidate:>33}\\n{'-'*33}\\n\"\r\n            output+=f'{\"National Polling Average\":>24}: {item.Average}\\n'\r\n            output+=f'{\"Pledged Delegates\":>24}: {item.Delegates}\\n'\r\n            output+=f'{\"Individual Contributions\":>24}: {item.Contributions}\\n'\r\n            output+=f'{\"Weekly News Coverage\":>24}: {item.Coverage}\\n\\n'            \r\n        print(output)\r\n\r\n\r\ndef gather_data():\r\n    rcp_file = File(\"realclearpolitics.html\")\r\n    rcp_url = (\r\n        \"https://bites-data.s3.us-east-2.amazonaws.com/2020-03-10_realclearpolitics.html\"\r\n    )\r\n    rcp_web = Web(rcp_url, rcp_file)\r\n    rcp = RealClearPolitics(rcp_web)\r\n    rcp.stats(3)\r\n\r\n    nyt_file = File(\"nytimes.html\")\r\n    nyt_url = (\r\n        \"https://bites-data.s3.us-east-2.amazonaws.com/2020-03-10_nytimes.html\"\r\n    )\r\n    nyt_web = Web(nyt_url, nyt_file)\r\n    nyt = NYTimes(nyt_web)\r\n    nyt.stats()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    gather_data()\r\n    \"\"\"url = \"https://bites-data.s3.us-east-2.amazonaws.com/pycon2019.html\"\r\n    test_file = 'test_file.html'\r\n    test_web = Web(url, File(test_file))\r\n    print(test_web.url)\r\n    print(test_web.file.name)\r\n    print(test_web.file.path)\r\n    print(test_web.file.data)\r\n    print(test_web.data)\r\n    print(test_web.soup)\r\n    \"\"\"\r\n    \r\n    \r\n\"\"\"\r\nassert \"National Polling Average: 29%\" in output\r\nassert \"       Pledged Delegates: 610\" in output\r\nassert \"Individual Contributions: $11.1m\" in output\r\nassert \"    Weekly News Coverage: 3\" in output\r\n\"\"\"    ",
            "date": "2022-12-16 21:09:51.450138+00:00",
            "passed": true
        },
        {
            "bite": "Bite 266. Composition, Inheritance, Abstract Base Class, what?",
            "code": "from abc import ABC, abstractmethod\r\nfrom collections import namedtuple\r\nfrom dataclasses import dataclass\r\nfrom datetime import date\r\nfrom os import getenv, path\r\nfrom pathlib import Path\r\nfrom typing import Any, List, Optional, NamedTuple\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup as Soup  # type: ignore\r\n\r\nTMP = getenv(\"TMP\", \"/tmp\")\r\nTODAY = date.today()\r\n\r\nCandidate = NamedTuple(\"Candidate\", [\r\n        ('name', str), \r\n        ('votes', int),\r\n    ]\r\n)\r\nLeaderBoard = NamedTuple(\r\n    \"LeaderBoard\", [\r\n        ('Candidate', str), \r\n        ('Average', str), \r\n        ('Delegates', str), \r\n        ('Contributions', str), \r\n        ('Coverage', str),\r\n    ]\r\n)\r\nPoll = NamedTuple(\r\n    \"Poll\",[\r\n        ('Poll', str),\r\n        ('Date', str),\r\n        ('Sample', int),\r\n        ('Sanders', float),\r\n        ('Biden', float),\r\n        ('Gabbard', float),\r\n        ('Spread', float),\r\n    ]\r\n)\r\n\r\n\r\ndef as_float(string):\r\n    try:\r\n        return float(string)\r\n    except ValueError:\r\n        return 0        \r\n\r\n@dataclass\r\nclass File:\r\n    \"\"\"File represents a filesystem path.\r\n\r\n    Variables:\r\n        name: str -- The filename that will be created on the filesystem.\r\n        path: Path -- Path object created from the name passed in.\r\n\r\n    Methods:\r\n        [property]\r\n        data: -> Optional[str] -- If the file exists, it returns its contents.\r\n            If it does not exist, it returns None.\r\n    \"\"\"\r\n    name: str\r\n    path: Path = ''\r\n    \r\n    def __post_init__(self):\r\n        if self.path:\r\n            self.path = Path(self_path , self.name)\r\n        else:\r\n            self.path = Path(TMP,f'{TODAY}_{self.name}')\r\n        \r\n    @property\r\n    def data(self) -> Optional[str]:\r\n        if path.isfile(self.path):\r\n            with open(self.path) as f:\r\n                return f.read()\r\n        else:\r\n            return None\r\n\r\n@dataclass\r\nclass Web:\r\n    \"\"\"Web object.\r\n\r\n    Web is an object that downloads the page from the url that is passed\r\n    to it and stores it in the File instance that is passed to it. If the\r\n    File already exists, it just reads the file, otherwise it downloads it\r\n    and stores it in File.\r\n\r\n    Variables:\r\n        url: str -- The url of the web page.\r\n        file: File -- The File object to store the page data into.\r\n\r\n    Methods:\r\n        [property]\r\n        data: -> Optional[str] -- Reads the text from File or retrieves it from the\r\n            web if it does not exists.\r\n\r\n        [property]\r\n        soup: -> Soup -- Parses the data from File and turns it into a BeautifulSoup\r\n            object.\r\n    \"\"\"\r\n    url: str\r\n    file: File\r\n\r\n    @property\r\n    def data(self) -> Optional[str]:\r\n        \"\"\"Reads the data from the File object.\r\n\r\n        First it checks if the File object has any data. If it doesn't, it retrieves\r\n        it and saves it to the File. It then reads it from the File and returns it.\r\n\r\n        Returns:\r\n            Optional[str] -- The string data from the File object.\r\n        \"\"\"\r\n        if not self.file.data:\r\n            urlretrieve(self.url, self.file.path)\r\n        return self.file.data\r\n\r\n    @property\r\n    def soup(self) -> Soup:\r\n        \"\"\"Converts string data from File into a BeautifulSoup object.\r\n\r\n        Returns:\r\n            Soup -- BeautifulSoup object created from the File.\r\n        \"\"\"\r\n        soup = Soup(self.data, 'html.parser')\r\n        return soup\r\n\r\n\r\nclass Site(ABC):\r\n    \"\"\"Site Abstract Base Class.\r\n\r\n    Defines the structure for the objects based on this class and defines the interfaces\r\n    that should be implemented in order to work properly.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        [abstractmethod]\r\n        parse_rows: -> Union[List[LeaderBoard], List[Poll]] -- Parses a BeautifulSoup\r\n            table element and returns the text found in the td elements as\r\n            namedtuples.\r\n\r\n        [abstractmethod]\r\n        polls: -> Union[List[LeaderBoard], List[Poll]] -- Does the parsing of the table\r\n            and rows for you. It takes the table index number if given, otherwise\r\n            parses table 0.\r\n\r\n        [abstractmethod]\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation.\r\n    \"\"\"\r\n    web: Web\r\n\r\n    def find_table(self, loc: int = 0) -> str:\r\n        \"\"\"Finds the table elements from the Soup object\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Parses the Web object for table elements and\r\n                returns the first one that it finds unless an integer representing\r\n                the required table is passed. (default: {0})\r\n\r\n        Returns:\r\n            str -- The html table\r\n        \"\"\"\r\n            \r\n        return self.web.soup.find_all('table')[loc or 0]\r\n\r\n    @abstractmethod\r\n    def parse_rows(self, table: Soup) -> List[Any]:\r\n        \"\"\"Abstract Method\r\n        \r\n        Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as NamedTuple.\r\n\r\n        Returns:\r\n            List[NamedTuple] -- List of NamedTuple that were created from the\r\n                table data.\r\n        \"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def polls(self, table: int = 0) -> List[Any]:\r\n        \"\"\"Abstract Method\r\n\r\n        Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[NamedTuple] -- List of NamedTuple that were created from the\r\n                table data.\r\n        \"\"\"\r\n        pass\r\n    \r\n    @abstractmethod\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Abstract Method\r\n        \r\n        Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n        \"\"\"\r\n        pass\r\n\r\n\r\n@dataclass\r\nclass RealClearPolitics(Site):\r\n    \"\"\"RealClearPolitics object.\r\n\r\n    RealClearPolitics is a custom class to parse a Web instance from the\r\n    realclearpolitics website.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        parse_rows: -> List[Poll] -- Parses a BeautifulSoup table element and\r\n            returns the text found in the td elements as Poll namedtuples.\r\n\r\n        polls: -> List[Poll] -- Does the parsing of the table and rows for you.\r\n            It takes the table index number if given, otherwise parses table 0.\r\n\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation:\r\n\r\n            Example:\r\n\r\n            RealClearPolitics\r\n            =================\r\n                Biden: 214.0\r\n              Sanders: 142.0\r\n              Gabbard: 6.0\r\n\r\n    \"\"\"\r\n\r\n    web:Web\r\n\r\n    def parse_rows(self, table: Soup) -> List[Poll]:\r\n        \"\"\"Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as Poll namedtuples.\r\n\r\n        Returns:\r\n            List[Poll] -- List of Poll namedtuples that were created from the\r\n                table data.\r\n        \"\"\"\r\n        lst=[]\r\n        for row in table.find_all('tr')[2:]:\r\n            tds=row.find_all('td')\r\n            poll=tds[0].text\r\n            date=tds[1].text\r\n            sample=as_float(tds[2].text)\r\n            biden=as_float(tds[3].text)\r\n            sanders=as_float(tds[4].text)\r\n            gabbard=as_float(tds[5].text)\r\n            spread=as_float(tds[5].text)\r\n            lst.append(Poll(poll, date, sample, sanders, biden, gabbard, spread))\r\n        # print(lst)\r\n        return lst\r\n\r\n    def polls(self, table: int = 0) -> List[Poll]:\r\n        \"\"\"Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[Poll] -- List of Poll namedtuples that were created from the\r\n                table data.\r\n        \"\"\"\r\n        return self.parse_rows(self.find_table(table))\r\n\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n\r\n        \"\"\"\r\n        output=\"\"\"\\nRealClearPolitics\\n=================\\n\"\"\"\r\n        for candidate in 'Biden', 'Sanders', 'Gabbard':\r\n            output+=f'{candidate:>9}: {sum(getattr(poll, candidate) for poll in self.polls(loc))}\\n'\r\n        print(output)\r\n\r\n\r\n@dataclass\r\nclass NYTimes(Site):\r\n    \"\"\"NYTimes object.\r\n\r\n    NYTimes is a custom class to parse a Web instance from the nytimes website.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        parse_rows: -> List[LeaderBoard] -- Parses a BeautifulSoup table element and\r\n            returns the text found in the td elements as LeaderBoard namedtuples.\r\n\r\n        polls: -> List[LeaderBoard] -- Does the parsing of the table and rows for you.\r\n            It takes the table index number if given, otherwise parses table 0.\r\n\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation:\r\n\r\n            Example:\r\n\r\n            NYTimes\r\n            =================================\r\n\r\n                               Pete Buttigieg\r\n            ---------------------------------\r\n            National Polling Average: 10%\r\n                   Pledged Delegates: 25\r\n            Individual Contributions: $76.2m\r\n                Weekly News Coverage: 3\r\n\r\n    \"\"\"\r\n\r\n    web: Web\r\n\r\n    def parse_rows(self, table: Soup) -> List[LeaderBoard]:\r\n        \"\"\"Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as LeaderBoard namedtuples.\r\n\r\n        Returns:\r\n            List[LeaderBoard] -- List of LeaderBoard namedtuples that were created from\r\n            the table data.\r\n        \"\"\"\r\n        lst=[]\r\n        for row in table.find_all('tr')[1:4]:\r\n            tds=row.find_all('td')\r\n            candidate=tds[0].text.strip()\r\n            average=tds[1].text.strip()\r\n            delegates=int(tds[2].text.strip())\r\n            contributions=tds[3].text.strip()\r\n            coverage=int(tds[4].text.strip('# '))\r\n            # print(\" # \".join([candidate, average, delegates, contributions, coverage]))\r\n            lst.append(LeaderBoard(candidate, average, delegates, contributions, coverage))\r\n        # print(lst)\r\n        return lst\r\n        \r\n\r\n    def polls(self, table: int = 0) -> List[LeaderBoard]:\r\n        \"\"\"Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[LeaderBoard] -- List of LeaderBoard namedtuples that were created from\r\n                the table data.\r\n        \"\"\"\r\n        return self.parse_rows(self.find_table(table))\r\n\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n        \"\"\"\r\n        output=f\"\\nNYTimes\\n{'='*33}\\n\\n\"\r\n        for item in self.polls(loc):\r\n            output+=f\"{item.Candidate:>33}\\n{'-'*33}\\n\"\r\n            output+=f'{\"National Polling Average\":>25}: {item.Average}\\n'\r\n            output+=f'{\"Pledged Delegates\":>25}: {item.Delegates}\\n'\r\n            output+=f'{\"Individual Contributions\":>25}: {item.Contributions}\\n'\r\n            output+=f'{\"Weekly News Coverage\":>25}: {item.Coverage}\\n\\n'            \r\n        print(output)\r\n\r\n\r\ndef gather_data():\r\n    rcp_file = File(\"realclearpolitics.html\")\r\n    rcp_url = (\r\n        \"https://bites-data.s3.us-east-2.amazonaws.com/2020-03-10_realclearpolitics.html\"\r\n    )\r\n    rcp_web = Web(rcp_url, rcp_file)\r\n    rcp = RealClearPolitics(rcp_web)\r\n    rcp.stats(3)\r\n\r\n    nyt_file = File(\"nytimes.html\")\r\n    nyt_url = (\r\n        \"https://bites-data.s3.us-east-2.amazonaws.com/2020-03-10_nytimes.html\"\r\n    )\r\n    nyt_web = Web(nyt_url, nyt_file)\r\n    nyt = NYTimes(nyt_web)\r\n    nyt.stats()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    gather_data()\r\n    \"\"\"url = \"https://bites-data.s3.us-east-2.amazonaws.com/pycon2019.html\"\r\n    test_file = 'test_file.html'\r\n    test_web = Web(url, File(test_file))\r\n    print(test_web.url)\r\n    print(test_web.file.name)\r\n    print(test_web.file.path)\r\n    print(test_web.file.data)\r\n    print(test_web.data)\r\n    print(test_web.soup)\r\n    \"\"\"",
            "date": "2022-12-16 21:05:01.733372+00:00",
            "passed": false
        },
        {
            "bite": "Bite 266. Composition, Inheritance, Abstract Base Class, what?",
            "code": "from abc import ABC, abstractmethod\r\nfrom collections import namedtuple\r\nfrom dataclasses import dataclass\r\nfrom datetime import date\r\nfrom os import getenv, path\r\nfrom pathlib import Path\r\nfrom typing import Any, List, Optional, NamedTuple\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup as Soup  # type: ignore\r\n\r\nTMP = getenv(\"TMP\", \"/tmp\")\r\nTODAY = date.today()\r\n\r\nCandidate = NamedTuple(\"Candidate\", [\r\n        ('name', str), \r\n        ('votes', int),\r\n    ]\r\n)\r\nLeaderBoard = NamedTuple(\r\n    \"LeaderBoard\", [\r\n        ('Candidate', str), \r\n        ('Average', str), \r\n        ('Delegates', str), \r\n        ('Contributions', str), \r\n        ('Coverage', str),\r\n    ]\r\n)\r\nPoll = NamedTuple(\r\n    \"Poll\",[\r\n        ('Poll', str),\r\n        ('Date', str),\r\n        ('Sample', int),\r\n        ('Sanders', float),\r\n        ('Biden', float),\r\n        ('Gabbard', float),\r\n        ('Spread', float),\r\n    ]\r\n)\r\n\r\n\r\ndef as_float(string):\r\n    try:\r\n        return float(string)\r\n    except ValueError:\r\n        return 0        \r\n\r\n@dataclass\r\nclass File:\r\n    \"\"\"File represents a filesystem path.\r\n\r\n    Variables:\r\n        name: str -- The filename that will be created on the filesystem.\r\n        path: Path -- Path object created from the name passed in.\r\n\r\n    Methods:\r\n        [property]\r\n        data: -> Optional[str] -- If the file exists, it returns its contents.\r\n            If it does not exist, it returns None.\r\n    \"\"\"\r\n    name: str\r\n    path: Path = ''\r\n    \r\n    def __post_init__(self):\r\n        if self.path:\r\n            self.path = Path(self_path , self.name)\r\n        else:\r\n            self.path = Path(TMP,f'{TODAY}_{self.name}')\r\n        \r\n    @property\r\n    def data(self) -> Optional[str]:\r\n        if path.isfile(self.path):\r\n            with open(self.path) as f:\r\n                return f.read()\r\n        else:\r\n            return None\r\n\r\n@dataclass\r\nclass Web:\r\n    \"\"\"Web object.\r\n\r\n    Web is an object that downloads the page from the url that is passed\r\n    to it and stores it in the File instance that is passed to it. If the\r\n    File already exists, it just reads the file, otherwise it downloads it\r\n    and stores it in File.\r\n\r\n    Variables:\r\n        url: str -- The url of the web page.\r\n        file: File -- The File object to store the page data into.\r\n\r\n    Methods:\r\n        [property]\r\n        data: -> Optional[str] -- Reads the text from File or retrieves it from the\r\n            web if it does not exists.\r\n\r\n        [property]\r\n        soup: -> Soup -- Parses the data from File and turns it into a BeautifulSoup\r\n            object.\r\n    \"\"\"\r\n    url: str\r\n    file: File\r\n\r\n    @property\r\n    def data(self) -> Optional[str]:\r\n        \"\"\"Reads the data from the File object.\r\n\r\n        First it checks if the File object has any data. If it doesn't, it retrieves\r\n        it and saves it to the File. It then reads it from the File and returns it.\r\n\r\n        Returns:\r\n            Optional[str] -- The string data from the File object.\r\n        \"\"\"\r\n        if not self.file.data:\r\n            urlretrieve(self.url, self.file.path)\r\n        return self.file.data\r\n\r\n    @property\r\n    def soup(self) -> Soup:\r\n        \"\"\"Converts string data from File into a BeautifulSoup object.\r\n\r\n        Returns:\r\n            Soup -- BeautifulSoup object created from the File.\r\n        \"\"\"\r\n        soup = Soup(self.data, 'html.parser')\r\n        return soup\r\n\r\n\r\nclass Site(ABC):\r\n    \"\"\"Site Abstract Base Class.\r\n\r\n    Defines the structure for the objects based on this class and defines the interfaces\r\n    that should be implemented in order to work properly.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        [abstractmethod]\r\n        parse_rows: -> Union[List[LeaderBoard], List[Poll]] -- Parses a BeautifulSoup\r\n            table element and returns the text found in the td elements as\r\n            namedtuples.\r\n\r\n        [abstractmethod]\r\n        polls: -> Union[List[LeaderBoard], List[Poll]] -- Does the parsing of the table\r\n            and rows for you. It takes the table index number if given, otherwise\r\n            parses table 0.\r\n\r\n        [abstractmethod]\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation.\r\n    \"\"\"\r\n    web: Web\r\n\r\n    def find_table(self, loc: int = 0) -> str:\r\n        \"\"\"Finds the table elements from the Soup object\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Parses the Web object for table elements and\r\n                returns the first one that it finds unless an integer representing\r\n                the required table is passed. (default: {0})\r\n\r\n        Returns:\r\n            str -- The html table\r\n        \"\"\"\r\n            \r\n        return self.web.soup.find_all('table')[loc or 0]\r\n\r\n    @abstractmethod\r\n    def parse_rows(self, table: Soup) -> List[Any]:\r\n        \"\"\"Abstract Method\r\n        \r\n        Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as NamedTuple.\r\n\r\n        Returns:\r\n            List[NamedTuple] -- List of NamedTuple that were created from the\r\n                table data.\r\n        \"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def polls(self, table: int = 0) -> List[Any]:\r\n        \"\"\"Abstract Method\r\n\r\n        Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[NamedTuple] -- List of NamedTuple that were created from the\r\n                table data.\r\n        \"\"\"\r\n        pass\r\n    \r\n    @abstractmethod\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Abstract Method\r\n        \r\n        Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n        \"\"\"\r\n        pass\r\n\r\n\r\n@dataclass\r\nclass RealClearPolitics(Site):\r\n    \"\"\"RealClearPolitics object.\r\n\r\n    RealClearPolitics is a custom class to parse a Web instance from the\r\n    realclearpolitics website.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        parse_rows: -> List[Poll] -- Parses a BeautifulSoup table element and\r\n            returns the text found in the td elements as Poll namedtuples.\r\n\r\n        polls: -> List[Poll] -- Does the parsing of the table and rows for you.\r\n            It takes the table index number if given, otherwise parses table 0.\r\n\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation:\r\n\r\n            Example:\r\n\r\n            RealClearPolitics\r\n            =================\r\n                Biden: 214.0\r\n              Sanders: 142.0\r\n              Gabbard: 6.0\r\n\r\n    \"\"\"\r\n\r\n    web:Web\r\n\r\n    def parse_rows(self, table: Soup) -> List[Poll]:\r\n        \"\"\"Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as Poll namedtuples.\r\n\r\n        Returns:\r\n            List[Poll] -- List of Poll namedtuples that were created from the\r\n                table data.\r\n        \"\"\"\r\n        lst=[]\r\n        for row in table.find_all('tr')[2:]:\r\n            tds=row.find_all('td')\r\n            poll=tds[0].text\r\n            date=tds[1].text\r\n            sample=as_float(tds[2].text)\r\n            biden=as_float(tds[3].text)\r\n            sanders=as_float(tds[4].text)\r\n            gabbard=as_float(tds[5].text)\r\n            spread=as_float(tds[5].text)\r\n            lst.append(Poll(poll, date, sample, sanders, biden, gabbard, spread))\r\n        # print(lst)\r\n        return lst\r\n\r\n    def polls(self, table: int = 0) -> List[Poll]:\r\n        \"\"\"Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[Poll] -- List of Poll namedtuples that were created from the\r\n                table data.\r\n        \"\"\"\r\n        return self.parse_rows(self.find_table(table))\r\n\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n\r\n        \"\"\"\r\n        output=\"\"\"\\nRealClearPolitics\\n=================\\n\"\"\"\r\n        for candidate in 'Biden', 'Sanders', 'Gabbard':\r\n            output+=f'{candidate:>9}: {sum(getattr(poll, candidate) for poll in self.polls(loc))}\\n'\r\n        print(output)\r\n\r\n\r\n@dataclass\r\nclass NYTimes(Site):\r\n    \"\"\"NYTimes object.\r\n\r\n    NYTimes is a custom class to parse a Web instance from the nytimes website.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        parse_rows: -> List[LeaderBoard] -- Parses a BeautifulSoup table element and\r\n            returns the text found in the td elements as LeaderBoard namedtuples.\r\n\r\n        polls: -> List[LeaderBoard] -- Does the parsing of the table and rows for you.\r\n            It takes the table index number if given, otherwise parses table 0.\r\n\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation:\r\n\r\n            Example:\r\n\r\n            NYTimes\r\n            =================================\r\n\r\n                               Pete Buttigieg\r\n            ---------------------------------\r\n            National Polling Average: 10%\r\n                   Pledged Delegates: 25\r\n            Individual Contributions: $76.2m\r\n                Weekly News Coverage: 3\r\n\r\n    \"\"\"\r\n\r\n    web: Web\r\n\r\n    def parse_rows(self, table: Soup) -> List[LeaderBoard]:\r\n        \"\"\"Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as LeaderBoard namedtuples.\r\n\r\n        Returns:\r\n            List[LeaderBoard] -- List of LeaderBoard namedtuples that were created from\r\n            the table data.\r\n        \"\"\"\r\n        lst=[]\r\n        for row in table.find_all('tr')[1:4]:\r\n            tds=row.find_all('td')\r\n            candidate=tds[0].text.strip()\r\n            average=tds[1].text.strip()\r\n            delegates=tds[2].text.strip()\r\n            contributions=tds[3].text.strip()\r\n            coverage=tds[4].text.strip()\r\n            # print(\" # \".join([candidate, average, delegates, contributions, coverage]))\r\n            lst.append(LeaderBoard(candidate, average, delegates, contributions, coverage))\r\n        # print(lst)\r\n        return lst\r\n        \r\n\r\n    def polls(self, table: int = 0) -> List[LeaderBoard]:\r\n        \"\"\"Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[LeaderBoard] -- List of LeaderBoard namedtuples that were created from\r\n                the table data.\r\n        \"\"\"\r\n        return self.parse_rows(self.find_table(table))\r\n\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n        \"\"\"\r\n        output=f\"\\nNYTimes\\n{'='*33}\\n\\n\"\r\n        for item in self.polls(loc):\r\n            output+=f\"{item.Candidate:>33}\\n{'-'*33}\\n\"\r\n            output+=f'{\"National Polling Average\":>25}: {item.Average}\\n'\r\n            output+=f'{\"Pledged Delegates\":>25}: {item.Delegates}\\n'\r\n            output+=f'{\"Individual Contributions\":>25}: {item.Contributions}\\n'\r\n            output+=f'{\"Weekly News Coverage\":>25}: {item.Coverage}\\n\\n'            \r\n        print(output)\r\n\r\n\r\ndef gather_data():\r\n    rcp_file = File(\"realclearpolitics.html\")\r\n    rcp_url = (\r\n        \"https://bites-data.s3.us-east-2.amazonaws.com/2020-03-10_realclearpolitics.html\"\r\n    )\r\n    rcp_web = Web(rcp_url, rcp_file)\r\n    rcp = RealClearPolitics(rcp_web)\r\n    rcp.stats(3)\r\n\r\n    nyt_file = File(\"nytimes.html\")\r\n    nyt_url = (\r\n        \"https://bites-data.s3.us-east-2.amazonaws.com/2020-03-10_nytimes.html\"\r\n    )\r\n    nyt_web = Web(nyt_url, nyt_file)\r\n    nyt = NYTimes(nyt_web)\r\n    nyt.stats()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    gather_data()\r\n    \"\"\"url = \"https://bites-data.s3.us-east-2.amazonaws.com/pycon2019.html\"\r\n    test_file = 'test_file.html'\r\n    test_web = Web(url, File(test_file))\r\n    print(test_web.url)\r\n    print(test_web.file.name)\r\n    print(test_web.file.path)\r\n    print(test_web.file.data)\r\n    print(test_web.data)\r\n    print(test_web.soup)\r\n    \"\"\"",
            "date": "2022-12-16 21:02:33.725562+00:00",
            "passed": false
        },
        {
            "bite": "Bite 266. Composition, Inheritance, Abstract Base Class, what?",
            "code": "from abc import ABC, abstractmethod\r\nfrom collections import namedtuple\r\nfrom dataclasses import dataclass\r\nfrom datetime import date\r\nfrom os import getenv, path\r\nfrom pathlib import Path\r\nfrom typing import Any, List, Optional, NamedTuple\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup as Soup  # type: ignore\r\n\r\nTMP = getenv(\"TMP\", \"/tmp\")\r\nTODAY = date.today()\r\n\r\nCandidate = NamedTuple(\"Candidate\", [\r\n        ('name', str), \r\n        ('votes', int),\r\n    ]\r\n)\r\nLeaderBoard = NamedTuple(\r\n    \"LeaderBoard\", [\r\n        ('Candidate', str), \r\n        ('Average', float), \r\n        ('Delegates', List), \r\n        ('Contributions', float), \r\n        ('Coverage', float),\r\n    ]\r\n)\r\nPoll = NamedTuple(\r\n    \"Poll\",[\r\n        ('Poll', str),\r\n        ('Date', str),\r\n        ('Sample', int),\r\n        ('Sanders', float),\r\n        ('Biden', float),\r\n        ('Gabbard', float),\r\n        ('Spread', float),\r\n    ]\r\n)\r\n\r\n\r\ndef as_float(string):\r\n    try:\r\n        return float(string)\r\n    except ValueError:\r\n        return 0        \r\n\r\n@dataclass\r\nclass File:\r\n    \"\"\"File represents a filesystem path.\r\n\r\n    Variables:\r\n        name: str -- The filename that will be created on the filesystem.\r\n        path: Path -- Path object created from the name passed in.\r\n\r\n    Methods:\r\n        [property]\r\n        data: -> Optional[str] -- If the file exists, it returns its contents.\r\n            If it does not exist, it returns None.\r\n    \"\"\"\r\n    name: str\r\n    path: Path = ''\r\n    \r\n    def __post_init__(self):\r\n        if self.path:\r\n            self.path = Path(self_path , self.name)\r\n        else:\r\n            self.path = Path(TMP,f'{TODAY}_{self.name}')\r\n        \r\n    @property\r\n    def data(self) -> Optional[str]:\r\n        if path.isfile(self.path):\r\n            with open(self.path) as f:\r\n                return f.read()\r\n        else:\r\n            return None\r\n\r\n@dataclass\r\nclass Web:\r\n    \"\"\"Web object.\r\n\r\n    Web is an object that downloads the page from the url that is passed\r\n    to it and stores it in the File instance that is passed to it. If the\r\n    File already exists, it just reads the file, otherwise it downloads it\r\n    and stores it in File.\r\n\r\n    Variables:\r\n        url: str -- The url of the web page.\r\n        file: File -- The File object to store the page data into.\r\n\r\n    Methods:\r\n        [property]\r\n        data: -> Optional[str] -- Reads the text from File or retrieves it from the\r\n            web if it does not exists.\r\n\r\n        [property]\r\n        soup: -> Soup -- Parses the data from File and turns it into a BeautifulSoup\r\n            object.\r\n    \"\"\"\r\n    url: str\r\n    file: File\r\n\r\n    @property\r\n    def data(self) -> Optional[str]:\r\n        \"\"\"Reads the data from the File object.\r\n\r\n        First it checks if the File object has any data. If it doesn't, it retrieves\r\n        it and saves it to the File. It then reads it from the File and returns it.\r\n\r\n        Returns:\r\n            Optional[str] -- The string data from the File object.\r\n        \"\"\"\r\n        if not self.file.data:\r\n            urlretrieve(self.url, self.file.path)\r\n        return self.file.data\r\n\r\n    @property\r\n    def soup(self) -> Soup:\r\n        \"\"\"Converts string data from File into a BeautifulSoup object.\r\n\r\n        Returns:\r\n            Soup -- BeautifulSoup object created from the File.\r\n        \"\"\"\r\n        soup = Soup(self.data, 'html.parser')\r\n        return soup\r\n\r\n\r\nclass Site(ABC):\r\n    \"\"\"Site Abstract Base Class.\r\n\r\n    Defines the structure for the objects based on this class and defines the interfaces\r\n    that should be implemented in order to work properly.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        [abstractmethod]\r\n        parse_rows: -> Union[List[LeaderBoard], List[Poll]] -- Parses a BeautifulSoup\r\n            table element and returns the text found in the td elements as\r\n            namedtuples.\r\n\r\n        [abstractmethod]\r\n        polls: -> Union[List[LeaderBoard], List[Poll]] -- Does the parsing of the table\r\n            and rows for you. It takes the table index number if given, otherwise\r\n            parses table 0.\r\n\r\n        [abstractmethod]\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation.\r\n    \"\"\"\r\n    web: Web\r\n\r\n    def find_table(self, loc: int = 0) -> str:\r\n        \"\"\"Finds the table elements from the Soup object\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Parses the Web object for table elements and\r\n                returns the first one that it finds unless an integer representing\r\n                the required table is passed. (default: {0})\r\n\r\n        Returns:\r\n            str -- The html table\r\n        \"\"\"\r\n            \r\n        return self.web.soup.find_all('table')[loc or 0]\r\n\r\n    @abstractmethod\r\n    def parse_rows(self, table: Soup) -> List[Any]:\r\n        \"\"\"Abstract Method\r\n        \r\n        Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as NamedTuple.\r\n\r\n        Returns:\r\n            List[NamedTuple] -- List of NamedTuple that were created from the\r\n                table data.\r\n        \"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def polls(self, table: int = 0) -> List[Any]:\r\n        \"\"\"Abstract Method\r\n\r\n        Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[NamedTuple] -- List of NamedTuple that were created from the\r\n                table data.\r\n        \"\"\"\r\n        pass\r\n    \r\n    @abstractmethod\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Abstract Method\r\n        \r\n        Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n        \"\"\"\r\n        pass\r\n\r\n\r\n@dataclass\r\nclass RealClearPolitics(Site):\r\n    \"\"\"RealClearPolitics object.\r\n\r\n    RealClearPolitics is a custom class to parse a Web instance from the\r\n    realclearpolitics website.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        parse_rows: -> List[Poll] -- Parses a BeautifulSoup table element and\r\n            returns the text found in the td elements as Poll namedtuples.\r\n\r\n        polls: -> List[Poll] -- Does the parsing of the table and rows for you.\r\n            It takes the table index number if given, otherwise parses table 0.\r\n\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation:\r\n\r\n            Example:\r\n\r\n            RealClearPolitics\r\n            =================\r\n                Biden: 214.0\r\n              Sanders: 142.0\r\n              Gabbard: 6.0\r\n\r\n    \"\"\"\r\n\r\n    web:Web\r\n\r\n    def parse_rows(self, table: Soup) -> List[Poll]:\r\n        \"\"\"Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as Poll namedtuples.\r\n\r\n        Returns:\r\n            List[Poll] -- List of Poll namedtuples that were created from the\r\n                table data.\r\n        \"\"\"\r\n        lst=[]\r\n        for row in table.find_all('tr')[2:]:\r\n            tds=row.find_all('td')\r\n            poll=tds[0].text\r\n            date=tds[1].text\r\n            sample=as_float(tds[2].text)\r\n            biden=as_float(tds[3].text)\r\n            sanders=as_float(tds[4].text)\r\n            gabbard=as_float(tds[5].text)\r\n            spread=as_float(tds[5].text)\r\n            lst.append(Poll(poll, date, sample, sanders, biden, gabbard, spread))\r\n        # print(lst)\r\n        return lst\r\n\r\n    def polls(self, table: int = 0) -> List[Poll]:\r\n        \"\"\"Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[Poll] -- List of Poll namedtuples that were created from the\r\n                table data.\r\n        \"\"\"\r\n        return self.parse_rows(self.find_table(table))\r\n\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n\r\n        \"\"\"\r\n        output=\"\"\"\\nRealClearPolitics\\n=================\\n\"\"\"\r\n        for candidate in 'Biden', 'Sanders', 'Gabbard':\r\n            output+=f'{candidate:>9}: {sum(getattr(poll, candidate) for poll in self.polls(loc))}\\n'\r\n        print(output)\r\n\r\n\r\n@dataclass\r\nclass NYTimes(Site):\r\n    \"\"\"NYTimes object.\r\n\r\n    NYTimes is a custom class to parse a Web instance from the nytimes website.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        parse_rows: -> List[LeaderBoard] -- Parses a BeautifulSoup table element and\r\n            returns the text found in the td elements as LeaderBoard namedtuples.\r\n\r\n        polls: -> List[LeaderBoard] -- Does the parsing of the table and rows for you.\r\n            It takes the table index number if given, otherwise parses table 0.\r\n\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation:\r\n\r\n            Example:\r\n\r\n            NYTimes\r\n            =================================\r\n\r\n                               Pete Buttigieg\r\n            ---------------------------------\r\n            National Polling Average: 10%\r\n                   Pledged Delegates: 25\r\n            Individual Contributions: $76.2m\r\n                Weekly News Coverage: 3\r\n\r\n    \"\"\"\r\n\r\n    web: Web\r\n\r\n    def parse_rows(self, table: Soup) -> List[LeaderBoard]:\r\n        \"\"\"Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as LeaderBoard namedtuples.\r\n\r\n        Returns:\r\n            List[LeaderBoard] -- List of LeaderBoard namedtuples that were created from\r\n            the table data.\r\n        \"\"\"\r\n        pass\r\n\r\n    def polls(self, table: int = 0) -> List[LeaderBoard]:\r\n        \"\"\"Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[LeaderBoard] -- List of LeaderBoard namedtuples that were created from\r\n                the table data.\r\n        \"\"\"\r\n        pass\r\n\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n        \"\"\"\r\n        pass\r\n\r\n\r\ndef gather_data():\r\n    rcp_file = File(\"realclearpolitics.html\")\r\n    rcp_url = (\r\n        \"https://bites-data.s3.us-east-2.amazonaws.com/2020-03-10_realclearpolitics.html\"\r\n    )\r\n    rcp_web = Web(rcp_url, rcp_file)\r\n    rcp = RealClearPolitics(rcp_web)\r\n    print(rcp.polls(3))\r\n    rcp.stats(3)\r\n\r\n    nyt_file = File(\"nytimes.html\")\r\n    nyt_url = (\r\n        \"https://bites-data.s3.us-east-2.amazonaws.com/2020-03-10_nytimes.html\"\r\n    )\r\n    nyt_web = Web(nyt_url, nyt_file)\r\n    nyt = NYTimes(nyt_web)\r\n    nyt.stats()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    gather_data()\r\n    \"\"\"url = \"https://bites-data.s3.us-east-2.amazonaws.com/pycon2019.html\"\r\n    test_file = 'test_file.html'\r\n    test_web = Web(url, File(test_file))\r\n    print(test_web.url)\r\n    print(test_web.file.name)\r\n    print(test_web.file.path)\r\n    print(test_web.file.data)\r\n    print(test_web.data)\r\n    print(test_web.soup)\r\n    \"\"\"",
            "date": "2022-12-16 20:28:30.347030+00:00",
            "passed": false
        },
        {
            "bite": "Bite 266. Composition, Inheritance, Abstract Base Class, what?",
            "code": "from abc import ABC, abstractmethod\r\nfrom collections import namedtuple\r\nfrom dataclasses import dataclass\r\nfrom datetime import date\r\nfrom os import getenv, path\r\nfrom pathlib import Path\r\nfrom typing import Any, List, Optional, NamedTuple\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup as Soup  # type: ignore\r\n\r\nTMP = getenv(\"TMP\", \"/tmp\")\r\nTODAY = date.today()\r\n\r\nCandidate = NamedTuple(\"Candidate\", [\r\n        ('name', str), \r\n        ('votes', int),\r\n    ]\r\n)\r\nLeaderBoard = NamedTuple(\r\n    \"LeaderBoard\", [\r\n        ('Candidate', str), \r\n        ('Average', float), \r\n        ('Delegates', List), \r\n        ('Contributions', float), \r\n        ('Coverage', float),\r\n    ]\r\n)\r\nPoll = NamedTuple(\r\n    \"Poll\",[\r\n        ('Poll', str),\r\n        ('Date', str),\r\n        ('Sample', int),\r\n        ('Sanders', float),\r\n        ('Biden', float),\r\n        ('Gabbard', float),\r\n        ('Spread', float),\r\n    ]\r\n)\r\n\r\n\r\ndef as_float(string):\r\n    try:\r\n        return float(string)\r\n    except ValueError:\r\n        return 0        \r\n\r\n@dataclass\r\nclass File:\r\n    \"\"\"File represents a filesystem path.\r\n\r\n    Variables:\r\n        name: str -- The filename that will be created on the filesystem.\r\n        path: Path -- Path object created from the name passed in.\r\n\r\n    Methods:\r\n        [property]\r\n        data: -> Optional[str] -- If the file exists, it returns its contents.\r\n            If it does not exist, it returns None.\r\n    \"\"\"\r\n    name: str\r\n    path: Path = ''\r\n    \r\n    def __post_init__(self):\r\n        if self.path:\r\n            self.path = Path(self_path , self.name)\r\n        else:\r\n            self.path = Path(TMP,f'{TODAY}_{self.name}')\r\n        \r\n    @property\r\n    def data(self) -> Optional[str]:\r\n        if path.isfile(self.path):\r\n            with open(self.path) as f:\r\n                return f.read()\r\n        else:\r\n            return None\r\n\r\n@dataclass\r\nclass Web:\r\n    \"\"\"Web object.\r\n\r\n    Web is an object that downloads the page from the url that is passed\r\n    to it and stores it in the File instance that is passed to it. If the\r\n    File already exists, it just reads the file, otherwise it downloads it\r\n    and stores it in File.\r\n\r\n    Variables:\r\n        url: str -- The url of the web page.\r\n        file: File -- The File object to store the page data into.\r\n\r\n    Methods:\r\n        [property]\r\n        data: -> Optional[str] -- Reads the text from File or retrieves it from the\r\n            web if it does not exists.\r\n\r\n        [property]\r\n        soup: -> Soup -- Parses the data from File and turns it into a BeautifulSoup\r\n            object.\r\n    \"\"\"\r\n    url: str\r\n    file: File\r\n\r\n    @property\r\n    def data(self) -> Optional[str]:\r\n        \"\"\"Reads the data from the File object.\r\n\r\n        First it checks if the File object has any data. If it doesn't, it retrieves\r\n        it and saves it to the File. It then reads it from the File and returns it.\r\n\r\n        Returns:\r\n            Optional[str] -- The string data from the File object.\r\n        \"\"\"\r\n        if not self.file.data:\r\n            urlretrieve(self.url, self.file.path)\r\n        return self.file.data\r\n\r\n    @property\r\n    def soup(self) -> Soup:\r\n        \"\"\"Converts string data from File into a BeautifulSoup object.\r\n\r\n        Returns:\r\n            Soup -- BeautifulSoup object created from the File.\r\n        \"\"\"\r\n        soup = Soup(self.data, 'html.parser')\r\n        return soup\r\n\r\n\r\nclass Site(ABC):\r\n    \"\"\"Site Abstract Base Class.\r\n\r\n    Defines the structure for the objects based on this class and defines the interfaces\r\n    that should be implemented in order to work properly.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        [abstractmethod]\r\n        parse_rows: -> Union[List[LeaderBoard], List[Poll]] -- Parses a BeautifulSoup\r\n            table element and returns the text found in the td elements as\r\n            namedtuples.\r\n\r\n        [abstractmethod]\r\n        polls: -> Union[List[LeaderBoard], List[Poll]] -- Does the parsing of the table\r\n            and rows for you. It takes the table index number if given, otherwise\r\n            parses table 0.\r\n\r\n        [abstractmethod]\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation.\r\n    \"\"\"\r\n    web: Web\r\n\r\n    def find_table(self, loc: int = 0) -> str:\r\n        \"\"\"Finds the table elements from the Soup object\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Parses the Web object for table elements and\r\n                returns the first one that it finds unless an integer representing\r\n                the required table is passed. (default: {0})\r\n\r\n        Returns:\r\n            str -- The html table\r\n        \"\"\"\r\n            \r\n        return self.web.soup.find_all('table')[loc or 0]\r\n\r\n    @abstractmethod\r\n    def parse_rows(self, table: Soup) -> List[Any]:\r\n        \"\"\"Abstract Method\r\n        \r\n        Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as NamedTuple.\r\n\r\n        Returns:\r\n            List[NamedTuple] -- List of NamedTuple that were created from the\r\n                table data.\r\n        \"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def polls(self, table: int = 0) -> List[Any]:\r\n        \"\"\"Abstract Method\r\n\r\n        Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[NamedTuple] -- List of NamedTuple that were created from the\r\n                table data.\r\n        \"\"\"\r\n        pass\r\n    \r\n    @abstractmethod\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Abstract Method\r\n        \r\n        Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n        \"\"\"\r\n        pass\r\n\r\n\r\n@dataclass\r\nclass RealClearPolitics(Site):\r\n    \"\"\"RealClearPolitics object.\r\n\r\n    RealClearPolitics is a custom class to parse a Web instance from the\r\n    realclearpolitics website.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        parse_rows: -> List[Poll] -- Parses a BeautifulSoup table element and\r\n            returns the text found in the td elements as Poll namedtuples.\r\n\r\n        polls: -> List[Poll] -- Does the parsing of the table and rows for you.\r\n            It takes the table index number if given, otherwise parses table 0.\r\n\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation:\r\n\r\n            Example:\r\n\r\n            RealClearPolitics\r\n            =================\r\n                Biden: 214.0\r\n              Sanders: 142.0\r\n              Gabbard: 6.0\r\n\r\n    \"\"\"\r\n\r\n    web:Web\r\n\r\n    def parse_rows(self, table: Soup) -> List[Poll]:\r\n        \"\"\"Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as Poll namedtuples.\r\n\r\n        Returns:\r\n            List[Poll] -- List of Poll namedtuples that were created from the\r\n                table data.\r\n        \"\"\"\r\n        lst=[]\r\n        for row in table.find_all('tr')[2:]:\r\n            tds=row.find_all('td')\r\n            poll=tds[0].text\r\n            date=tds[1].text\r\n            sample=as_float(tds[2].text)\r\n            sanders=as_float(tds[3].text)\r\n            biden=as_float(tds[4].text)\r\n            gabbard=as_float(tds[5].text)\r\n            spread=as_float(tds[5].text)\r\n            lst.append(Poll(poll, date, sample, sanders, biden, gabbard, spread))\r\n        # print(lst)\r\n        return lst\r\n\r\n    def polls(self, table: int = 0) -> List[Poll]:\r\n        \"\"\"Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[Poll] -- List of Poll namedtuples that were created from the\r\n                table data.\r\n        \"\"\"\r\n        return self.parse_rows(self.find_table(table))\r\n\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n\r\n        \"\"\"\r\n        output=\"\"\"\\nRealClearPolitics\\n=================\\n\"\"\"\r\n        for candidate in 'Biden', 'Sanders', 'Gabbard':\r\n            output+=f'{candidate:>9}: {sum(getattr(poll, candidate) for poll in self.polls(loc))}\\n'\r\n        print(output)\r\n\r\n\r\n@dataclass\r\nclass NYTimes(Site):\r\n    \"\"\"NYTimes object.\r\n\r\n    NYTimes is a custom class to parse a Web instance from the nytimes website.\r\n\r\n    Variables:\r\n        web: Web -- The web object stores the information needed to process\r\n            the data.\r\n\r\n    Methods:\r\n        find_table: -> str -- Parses the Web object for table elements and\r\n            returns the first one that it finds unless an integer representing\r\n            the required table is passed.\r\n\r\n        parse_rows: -> List[LeaderBoard] -- Parses a BeautifulSoup table element and\r\n            returns the text found in the td elements as LeaderBoard namedtuples.\r\n\r\n        polls: -> List[LeaderBoard] -- Does the parsing of the table and rows for you.\r\n            It takes the table index number if given, otherwise parses table 0.\r\n\r\n        stats: -- Formats the results from polls into a more user friendly\r\n            representation:\r\n\r\n            Example:\r\n\r\n            NYTimes\r\n            =================================\r\n\r\n                               Pete Buttigieg\r\n            ---------------------------------\r\n            National Polling Average: 10%\r\n                   Pledged Delegates: 25\r\n            Individual Contributions: $76.2m\r\n                Weekly News Coverage: 3\r\n\r\n    \"\"\"\r\n\r\n    web: Web\r\n\r\n    def parse_rows(self, table: Soup) -> List[LeaderBoard]:\r\n        \"\"\"Parses the row data from the html table.\r\n\r\n        Arguments:\r\n            table {Soup} -- Parses a BeautifulSoup table element and\r\n                returns the text found in the td elements as LeaderBoard namedtuples.\r\n\r\n        Returns:\r\n            List[LeaderBoard] -- List of LeaderBoard namedtuples that were created from\r\n            the table data.\r\n        \"\"\"\r\n        pass\r\n\r\n    def polls(self, table: int = 0) -> List[LeaderBoard]:\r\n        \"\"\"Parses the data\r\n\r\n        The find_table and parse_rows methods are called for you and the table index\r\n        that is passed to it is used to get the correct table from the soup object.\r\n\r\n        Keyword Arguments:\r\n            table {int} -- Does the parsing of the table and rows for you.\r\n                It takes the table index number if given, otherwise parses table 0.\r\n                (default: {0})\r\n\r\n        Returns:\r\n            List[LeaderBoard] -- List of LeaderBoard namedtuples that were created from\r\n                the table data.\r\n        \"\"\"\r\n        pass\r\n\r\n    def stats(self, loc: int = 0):\r\n        \"\"\"Produces the stats from the polls.\r\n\r\n        Keyword Arguments:\r\n            loc {int} -- Formats the results from polls into a more user friendly\r\n            representation.\r\n        \"\"\"\r\n        pass\r\n\r\n\r\ndef gather_data():\r\n    rcp_file = File(\"realclearpolitics.html\")\r\n    rcp_url = (\r\n        \"https://bites-data.s3.us-east-2.amazonaws.com/2020-03-10_realclearpolitics.html\"\r\n    )\r\n    rcp_web = Web(rcp_url, rcp_file)\r\n    rcp = RealClearPolitics(rcp_web)\r\n    print(rcp.polls(3))\r\n    rcp.stats(3)\r\n\r\n    nyt_file = File(\"nytimes.html\")\r\n    nyt_url = (\r\n        \"https://bites-data.s3.us-east-2.amazonaws.com/2020-03-10_nytimes.html\"\r\n    )\r\n    nyt_web = Web(nyt_url, nyt_file)\r\n    nyt = NYTimes(nyt_web)\r\n    nyt.stats()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    gather_data()\r\n    \"\"\"url = \"https://bites-data.s3.us-east-2.amazonaws.com/pycon2019.html\"\r\n    test_file = 'test_file.html'\r\n    test_web = Web(url, File(test_file))\r\n    print(test_web.url)\r\n    print(test_web.file.name)\r\n    print(test_web.file.path)\r\n    print(test_web.file.data)\r\n    print(test_web.data)\r\n    print(test_web.soup)\r\n    \"\"\"",
            "date": "2022-12-16 20:27:24.821471+00:00",
            "passed": false
        },
        {
            "bite": "Bite 206. Calculate and evenly split the bill",
            "code": "import decimal\r\n\r\ndef check_split(item_total, tax_rate, tip, people):\r\n    \"\"\"Calculate check value and evenly split.\r\n\r\n       :param item_total: str (e.g. '$8.68')\r\n       :param tax_rate: str (e.g. '4.75%)\r\n       :param tip: str (e.g. '10%')\r\n       :param people: int (e.g. 3)\r\n\r\n       :return: tuple of (grand_total: str, splits: list)\r\n                e.g. ('$10.00', [3.34, 3.33, 3.33])\r\n    \"\"\"\r\n    \r\n    \r\n    \"\"\"ctx = decimal.getcontext()\r\n    ctx.rounding = decimal.ROUND_HALF_EVEN\r\n    \"\"\"\r\n    \r\n    item_total = decimal.Decimal(item_total.lstrip('$'))\r\n    tax = item_total * decimal.Decimal(tax_rate.rstrip('%'))/decimal.Decimal('100')\r\n    tax = tax.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_HALF_EVEN)\r\n\r\n    after_tax= item_total + tax\r\n    \r\n    tip = after_tax * decimal.Decimal(tip.rstrip('%'))/decimal.Decimal('100')\r\n    tip = tip.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_HALF_EVEN)\r\n\r\n    grand_total= after_tax + tip\r\n    grand_total = grand_total.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_HALF_EVEN)\r\n    \r\n    per_person= grand_total / people\r\n    per_person = per_person.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_HALF_EVEN)\r\n    \r\n    split=[per_person for _ in range(people)]\r\n    split[0]+=grand_total-sum(split)\r\n    \r\n    grand_total=f'${grand_total}'\r\n    \r\n    return (grand_total, split)\r\n    \r\n    \r\nprint(check_split('$9.99', '3.25%', '10%', 2))  # ('$9.99', '3.25%', '10%', 2), expected = '$11.34' vs '$11.35'\r\nprint(check_split('$186.70', '6.75%', '18%', 6))  # ('$186.70', '6.75%', '18%', 6), expected = '$235.17' vs '$235.18'\r\nprint(check_split('$141.86', '2%', '18%', 9))  # ('$141.86', '2%', '18%', 9), expected = '$170.75' vs '$170.74'\r\n\r\n\r\n",
            "date": "2022-12-16 19:23:06.614536+00:00",
            "passed": true
        },
        {
            "bite": "Bite 206. Calculate and evenly split the bill",
            "code": "import decimal\r\n\r\ndef check_split(item_total, tax_rate, tip, people):\r\n    \"\"\"Calculate check value and evenly split.\r\n\r\n       :param item_total: str (e.g. '$8.68')\r\n       :param tax_rate: str (e.g. '4.75%)\r\n       :param tip: str (e.g. '10%')\r\n       :param people: int (e.g. 3)\r\n\r\n       :return: tuple of (grand_total: str, splits: list)\r\n                e.g. ('$10.00', [3.34, 3.33, 3.33])\r\n    \"\"\"\r\n    \r\n    \r\n    ctx = decimal.getcontext()\r\n    ctx.rounding = decimal.ROUND_HALF_EVEN\r\n    \r\n    \r\n    item_total = decimal.Decimal(item_total.lstrip('$'))\r\n    tax = item_total * decimal.Decimal(tax_rate.rstrip('%'))/decimal.Decimal('100')\r\n    tax = tax.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_HALF_EVEN)\r\n    print(tax)\r\n    after_tax= item_total + tax \r\n    tip = after_tax * decimal.Decimal(tip.rstrip('%'))/decimal.Decimal('100')\r\n    tip = tip.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_HALF_EVEN)\r\n    print(tip)\r\n    grand_total= after_tax + tip\r\n    grand_total = grand_total.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_HALF_EVEN)\r\n    per_person= grand_total / people\r\n    per_person = per_person.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_HALF_EVEN)\r\n    split=[per_person for _ in range(people)]\r\n    split[0]+=grand_total-sum(split)\r\n    grand_total=f'${grand_total}'\r\n    \r\n    return (grand_total, split)\r\n    \r\n    \r\nprint(check_split('$9.99', '3.25%', '10%', 2))  # ('$9.99', '3.25%', '10%', 2), expected = '$11.34' vs '$11.35'\r\nprint(check_split('$186.70', '6.75%', '18%', 6))  # ('$186.70', '6.75%', '18%', 6), expected = '$235.17' vs '$235.18'\r\nprint(check_split('$141.86', '2%', '18%', 9))  # ('$141.86', '2%', '18%', 9), expected = '$170.75' vs '$170.74'\r\n\r\n\r\n",
            "date": "2022-12-16 19:21:18.893398+00:00",
            "passed": true
        },
        {
            "bite": "Bite 206. Calculate and evenly split the bill",
            "code": "import decimal\r\n\r\ndef check_split(item_total, tax_rate, tip, people):\r\n    \"\"\"Calculate check value and evenly split.\r\n\r\n       :param item_total: str (e.g. '$8.68')\r\n       :param tax_rate: str (e.g. '4.75%)\r\n       :param tip: str (e.g. '10%')\r\n       :param people: int (e.g. 3)\r\n\r\n       :return: tuple of (grand_total: str, splits: list)\r\n                e.g. ('$10.00', [3.34, 3.33, 3.33])\r\n    \"\"\"\r\n    \r\n    \r\n    ctx = decimal.getcontext()\r\n    ctx.rounding = decimal.ROUND_HALF_EVEN\r\n    \r\n    \r\n    item_total = decimal.Decimal(item_total.lstrip('$'))\r\n    tax = item_total * decimal.Decimal(tax_rate.rstrip('%'))/decimal.Decimal('100')\r\n    after_tax= item_total + tax \r\n    tip = after_tax * decimal.Decimal(tip.rstrip('%'))/decimal.Decimal('100')\r\n    grand_total= after_tax + tip\r\n    grand_total = grand_total.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_HALF_EVEN)\r\n    per_person= grand_total / people\r\n    per_person = per_person.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_HALF_EVEN)\r\n    split=[per_person for _ in range(people)]\r\n    split[0]+=grand_total-sum(split)\r\n    grand_total=f'${grand_total}'\r\n    \r\n    return (grand_total, split)\r\n    \r\n    \r\nprint(check_split('$9.99', '3.25%', '10%', 2))  # ('$9.99', '3.25%', '10%', 2), expected = '$11.34' vs '$11.35'\r\nprint(check_split('$186.70', '6.75%', '18%', 6))  # ('$186.70', '6.75%', '18%', 6), expected = '$235.17' vs '$235.17'\r\nprint(check_split('$141.86', '2%', '18%', 9))  # ('$141.86', '2%', '18%', 9), expected = '$170.75' vs '$170.74'\r\n\r\n\r\n",
            "date": "2022-12-16 19:17:01.489501+00:00",
            "passed": false
        },
        {
            "bite": "Bite 206. Calculate and evenly split the bill",
            "code": "import decimal\r\n\r\ndef check_split(item_total, tax_rate, tip, people):\r\n    \"\"\"Calculate check value and evenly split.\r\n\r\n       :param item_total: str (e.g. '$8.68')\r\n       :param tax_rate: str (e.g. '4.75%)\r\n       :param tip: str (e.g. '10%')\r\n       :param people: int (e.g. 3)\r\n\r\n       :return: tuple of (grand_total: str, splits: list)\r\n                e.g. ('$10.00', [3.34, 3.33, 3.33])\r\n    \"\"\"\r\n    \r\n    \r\n    ctx = decimal.getcontext()\r\n    ctx.rounding = decimal.ROUND_HALF_EVEN\r\n    \r\n    \r\n    item_total = decimal.Decimal(item_total.lstrip('$'))\r\n    tax = item_total * decimal.Decimal(tax_rate.rstrip('%'))/decimal.Decimal('100')\r\n    after_tax= item_total + tax \r\n    tip = after_tax * decimal.Decimal(tip.rstrip('%'))/decimal.Decimal('100')\r\n    grand_total= after_tax + tip\r\n    grand_total = grand_total.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_DOWN)\r\n    per_person= grand_total / people\r\n    per_person = per_person.quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_DOWN)\r\n    split=[per_person for _ in range(people)]\r\n    split[0]+=grand_total-sum(split)\r\n    grand_total=f'${grand_total}'\r\n    \r\n    return (grand_total, split)\r\n    \r\n    \r\nprint(check_split('$9.99', '3.25%', '10%', 2))  # ('$9.99', '3.25%', '10%', 2), expected = '$11.34' vs '$11.35'\r\nprint(check_split('$186.70', '6.75%', '18%', 6))  # ('$186.70', '6.75%', '18%', 6), expected = '$235.17' vs '$235.17'\r\nprint(check_split('$141.86', '2%', '18%', 9))  # ('$141.86', '2%', '18%', 9), expected = '$170.75' vs '$170.74'\r\n\r\n\r\n",
            "date": "2022-12-16 19:16:27.981112+00:00",
            "passed": false
        },
        {
            "bite": "Bite 206. Calculate and evenly split the bill",
            "code": "import decimal\r\n\r\ndef check_split(item_total, tax_rate, tip, people):\r\n    \"\"\"Calculate check value and evenly split.\r\n\r\n       :param item_total: str (e.g. '$8.68')\r\n       :param tax_rate: str (e.g. '4.75%)\r\n       :param tip: str (e.g. '10%')\r\n       :param people: int (e.g. 3)\r\n\r\n       :return: tuple of (grand_total: str, splits: list)\r\n                e.g. ('$10.00', [3.34, 3.33, 3.33])\r\n    \"\"\"\r\n    \"\"\"\r\n    ctx = decimal.getcontext()\r\n    ctx.rounding = decimal.ROUND_HALF_EVEN\r\n    \"\"\"\r\n    \r\n    item_total = decimal.Decimal(item_total.lstrip('$'))\r\n    tax = item_total * decimal.Decimal(tax_rate.rstrip('%'))/100\r\n    after_tax= item_total + tax \r\n    tip = after_tax * decimal.Decimal(tip.rstrip('%'))/100\r\n    grand_total= round(after_tax + tip,2)\r\n    \r\n    per_person= round(grand_total / people,2)\r\n    split=[per_person for _ in range(people)]\r\n    split[0]+=grand_total-sum(split)\r\n    grand_total=f'${grand_total}'\r\n    \r\n    return (grand_total, split)\r\n    \r\n    \r\nprint(check_split('$9.99', '3.25%', '10%', 2))  # ('$9.99', '3.25%', '10%', 2), expected = '$11.34'\r\nprint(check_split('$186.70', '6.75%', '18%', 6))  # ('$186.70', '6.75%', '18%', 6), expected = '$235.17'\r\nprint(check_split('$141.86', '2%', '18%', 9))  # ('$141.86', '2%', '18%', 9), expected = '$170.75'\r\n\r\n\r\n",
            "date": "2022-12-16 19:00:43.405968+00:00",
            "passed": false
        },
        {
            "bite": "Bite 132. Find the word with the most vowels",
            "code": "VOWELS = list(\"aeiou\")\r\n\r\n\r\ndef get_word_max_vowels(text):\r\n    \"\"\"Get the case insensitive word in text that has most vowels.\r\n       Return a tuple of the matching word and the vowel count, e.g.\r\n       ('object-oriented', 6)\"\"\"\r\n\r\n    tuples = [\r\n        (word, sum(c in VOWELS for c in word)) for word in text.casefold().split()\r\n    ]\r\n\r\n    return max(tuples, key=lambda x: x[1])\r\n\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    test_text = \"\"\"\r\n    Python is an easy to learn, powerful programming language. It has efficient high-level data structures\r\n    and a simple but effective approach to object-oriented programming. Python\u2019s elegant syntax and dynamic \r\n    typing, together with its interpreted nature, make it an ideal language for scripting and rapid \r\n    application development in many areas on most platforms.\r\n    \"\"\"\r\n\r\n    print(get_word_max_vowels(test_text))",
            "date": "2022-12-15 23:29:06.270993+00:00",
            "passed": true
        },
        {
            "bite": "Bite 132. Find the word with the most vowels",
            "code": "VOWELS = list('aeiou')\r\n\r\n\r\ndef get_word_max_vowels(text):\r\n    \"\"\"Get the case insensitive word in text that has most vowels.\r\n       Return a tuple of the matching word and the vowel count, e.g.\r\n       ('object-oriented', 6)\"\"\"\r\n       \r\n    return max( \r\n        [\r\n            (\r\n                word, \r\n                sum(c in VOWELS for c in word)\r\n            ) for word in text.casefold().split()\r\n        ], key = lambda x: x[1]\r\n    )\r\n    \r\nif __name__ == '__main__':\r\n\r\n    test_text = \"\"\"\r\n    Python is an easy to learn, powerful programming language. It has efficient high-level data structures\r\n    and a simple but effective approach to object-oriented programming. Python\u2019s elegant syntax and dynamic \r\n    typing, together with its interpreted nature, make it an ideal language for scripting and rapid \r\n    application development in many areas on most platforms.\r\n    \"\"\"\r\n    \r\n    print(get_word_max_vowels(test_text))",
            "date": "2022-12-15 23:26:30.266359+00:00",
            "passed": true
        },
        {
            "bite": "Bite 132. Find the word with the most vowels",
            "code": "VOWELS = list('aeiou')\r\n\r\n\r\ndef get_word_max_vowels(text):\r\n    \"\"\"Get the case insensitive word in text that has most vowels.\r\n       Return a tuple of the matching word and the vowel count, e.g.\r\n       ('object-oriented', 6)\"\"\"\r\n       \r\n    tuples = [(word, sum(1 for c in word if c in VOWELS)) for word in text.casefold().split()]\r\n    \r\n    return max(tuples, key = lambda x: x[1])\r\n\r\nif __name__ == '__main__':\r\n\r\n    test_text = \"\"\"\r\n    Python is an easy to learn, powerful programming language. It has efficient high-level data structures\r\n    and a simple but effective approach to object-oriented programming. Python\u2019s elegant syntax and dynamic \r\n    typing, together with its interpreted nature, make it an ideal language for scripting and rapid \r\n    application development in many areas on most platforms.\r\n    \"\"\"\r\n    \r\n    print(get_word_max_vowels(test_text))",
            "date": "2022-12-15 23:23:12.768144+00:00",
            "passed": true
        },
        {
            "bite": "Bite 296. Jagged list",
            "code": "from typing import List\r\nfrom itertools import zip_longest\r\n\r\ndef jagged_list(lst_of_lst: List[List[int]], fillvalue: int = 0) -> List[List[int]]:\r\n    zipped = zip_longest(*lst_of_lst, fillvalue = fillvalue)\r\n    return [list(item) for item in zip(*zipped)]\r\n\r\nprint(jagged_list([[1, 1, 1, 1], [0, 0, 0, 0], [1]], fillvalue=1))",
            "date": "2022-12-15 23:09:02.111656+00:00",
            "passed": true
        },
        {
            "bite": "Bite 308. Calculate the median from a dictionary",
            "code": "def calc_median_from_dict(d: dict) -> float:\r\n    \"\"\"\r\n    :param d: dict of numbers and their occurrences\r\n    :return: float: median\r\n    Example:\r\n    {1: 2, 3: 1, 4: 2} -> [1, 1, 3, 4, 4] --> 3 is median\r\n    \"\"\"\r\n\r\n    # TODO: Your code\r\n    lst = [number for number, frequency in sorted(d.items()) for _ in range(frequency) ]\r\n    mid_pt= len(lst)//2\r\n    if len(lst)%2!=0:\r\n        return lst[mid_pt]\r\n    else:\r\n        return (lst[mid_pt-1] + lst[mid_pt])/2\r\n        \r\nprint(calc_median_from_dict({1: 2, 3: 1, 4: 2}))",
            "date": "2022-12-15 06:11:21.864816+00:00",
            "passed": false
        },
        {
            "bite": "Bite 304. Most identical letters in a word",
            "code": "from typing import Tuple\r\nimport string\r\nfrom collections import Counter\r\nNOT_LETTER = string.punctuation + string.digits\r\nimport unicodedata\r\n\r\n\r\ndef _strip_non_letters(word):\r\n    chars=[c for c in word]\r\n    for i,c in enumerate(chars):\r\n        if unicodedata.category(c) in ['Ll', 'Lu']:\r\n            start=i\r\n            break\r\n\r\n    for i,c in enumerate(chars[::-1]):\r\n        if unicodedata.category(c) in ['Ll', 'Lu']:\r\n            end=len(chars)-i\r\n            break\r\n    return word[start:end]\r\n\r\n    \r\n    \r\n    \r\ndef max_letter_word(text: str) -> Tuple[str, str, int]:\r\n    \"\"\"\r\n    Find the word in text with the most repeated letters. If more than one word\r\n    has the highest number of repeated letters choose the first one. Return a\r\n    tuple of the word, the (first) repeated letter and the count of that letter\r\n    in the word.\r\n    >>> max_letter_word('I have just returned from a visit...')\r\n    ('returned', 'r', 2)\r\n    >>> max_letter_word('$5000 !!')\r\n    ('', '', 0)\r\n    \"\"\"\r\n    if not isinstance(text, str):\r\n        raise ValueError\r\n        \r\n    lst=[]\r\n    for word in text.split():\r\n        if word: \r\n            word_stripped_as_lst=[c for c in word.casefold() if unicodedata.category(c) in ['Ll', 'Lu']]\r\n            if word_stripped_as_lst:\r\n                top_letter, count = Counter(word_stripped_as_lst).most_common()[0]\r\n                lst.append((_strip_non_letters(word), top_letter, count))\r\n    if lst:\r\n        return max(lst,key= lambda x:x[2])\r\n    else:\r\n        return ('', '', 0)\r\n\r\nif __name__== '__main__':\r\n    \r\n    \r\n    print(_strip_non_letters('\u00ab\u00bfTiene'))\r\n    \r\n    \"\"\"\r\n    test = ['emoji like \ud83d\ude03\ud83d\ude03\ud83d\ude03\ud83d\ude03 are not letters',\r\n    'Soci\u00e9t\u00e9 G\u00e9n\u00e9rale est une des principales banques fran\u00e7aises',\r\n    'Short Plays By Lady Gregory The Knickerbocker Press 1916',\r\n    'six-feet-two in height',\r\n    'der Schlo\u00df is riesig',\r\n    'the quick brown fox jumped over the lazy dog',\r\n    '\u00ab\u00bfTiene sentido la TV p\u00fablica?\u00bb',\r\n    \"but we've been there already!!!\",\r\n    '\"____\".isalpha() is True, thus this test text',\r\n    '99abc99 __abc__ --abc-- digits _ and - are not letters',\r\n    'test test test test test correct-answer.',\r\n    'They shouted \"Oh no she didn\\'t\"',\r\n    \"The brothers' feet were muddy.\",\r\n    '1, 2, 3',\r\n    '',\r\n    ]\r\n    \r\n    for item in test: \r\n        print(max_letter_word(item))\r\n        \r\n    \"\"\"",
            "date": "2022-12-15 01:15:06.491505+00:00",
            "passed": true
        },
        {
            "bite": "Bite 304. Most identical letters in a word",
            "code": "from typing import Tuple\r\nimport string\r\nfrom collections import Counter\r\nNOT_LETTER = string.punctuation + string.digits\r\nimport unicodedata\r\n\r\n\r\ndef _strip_non_letters(word):\r\n    chars=[c for c in word]\r\n    for i,c in enumerate(chars):\r\n        if unicodedata.category(c) in ['Ll', 'Lu']:\r\n            start=i\r\n            break\r\n\r\n    for i,c in enumerate(chars[::-1]):\r\n        if unicodedata.category(c) in ['Ll', 'Lu']:\r\n            end=len(chars)-i\r\n            break\r\n    print(start,end)\r\n    return word[start:end]\r\n\r\n    \r\n    \r\n    \r\ndef max_letter_word(text: str) -> Tuple[str, str, int]:\r\n    \"\"\"\r\n    Find the word in text with the most repeated letters. If more than one word\r\n    has the highest number of repeated letters choose the first one. Return a\r\n    tuple of the word, the (first) repeated letter and the count of that letter\r\n    in the word.\r\n    >>> max_letter_word('I have just returned from a visit...')\r\n    ('returned', 'r', 2)\r\n    >>> max_letter_word('$5000 !!')\r\n    ('', '', 0)\r\n    \"\"\"\r\n    if not isinstance(text, str):\r\n        raise ValueError\r\n        \r\n    lst=[]\r\n    for word in text.split():\r\n        if word: \r\n            word_stripped_as_lst=[c for c in word.casefold() if unicodedata.category(c) in ['Ll', 'Lu']]\r\n            if word_stripped_as_lst:\r\n                top_letter, count = Counter(word_stripped_as_lst).most_common()[0]\r\n                lst.append((_strip_non_letters(word), top_letter, count))\r\n    if lst:\r\n        return max(lst,key= lambda x:x[2])\r\n    else:\r\n        return ('', '', 0)\r\n\r\nif __name__== '__main__':\r\n    \r\n    \r\n    print(_strip_non_letters('\u00ab\u00bfTiene'))\r\n    \r\n    \"\"\"\r\n    test = ['emoji like \ud83d\ude03\ud83d\ude03\ud83d\ude03\ud83d\ude03 are not letters',\r\n    'Soci\u00e9t\u00e9 G\u00e9n\u00e9rale est une des principales banques fran\u00e7aises',\r\n    'Short Plays By Lady Gregory The Knickerbocker Press 1916',\r\n    'six-feet-two in height',\r\n    'der Schlo\u00df is riesig',\r\n    'the quick brown fox jumped over the lazy dog',\r\n    '\u00ab\u00bfTiene sentido la TV p\u00fablica?\u00bb',\r\n    \"but we've been there already!!!\",\r\n    '\"____\".isalpha() is True, thus this test text',\r\n    '99abc99 __abc__ --abc-- digits _ and - are not letters',\r\n    'test test test test test correct-answer.',\r\n    'They shouted \"Oh no she didn\\'t\"',\r\n    \"The brothers' feet were muddy.\",\r\n    '1, 2, 3',\r\n    '',\r\n    ]\r\n    \r\n    for item in test: \r\n        print(max_letter_word(item))\r\n        \r\n    \"\"\"",
            "date": "2022-12-15 01:14:11.182409+00:00",
            "passed": true
        },
        {
            "bite": "Bite 304. Most identical letters in a word",
            "code": "from typing import Tuple\r\nimport string\r\nfrom collections import Counter\r\nNOT_LETTER = string.punctuation + string.digits\r\nimport unicodedata\r\n\r\n\r\ndef _strip_non_letters(word):\r\n    return \"\".join([c for c in word if unicodedata.category(c) in ['Ll', 'Lu']])\r\n    \r\n    \r\n    \r\ndef max_letter_word(text: str) -> Tuple[str, str, int]:\r\n    \"\"\"\r\n    Find the word in text with the most repeated letters. If more than one word\r\n    has the highest number of repeated letters choose the first one. Return a\r\n    tuple of the word, the (first) repeated letter and the count of that letter\r\n    in the word.\r\n    >>> max_letter_word('I have just returned from a visit...')\r\n    ('returned', 'r', 2)\r\n    >>> max_letter_word('$5000 !!')\r\n    ('', '', 0)\r\n    \"\"\"\r\n    if not isinstance(text, str):\r\n        raise ValueError\r\n        \r\n    lst=[]\r\n    for word in text.split():\r\n        if word: \r\n            word_stripped_as_lst=[c for c in word.casefold() if unicodedata.category(c) in ['Ll', 'Lu']]\r\n            if word_stripped_as_lst:\r\n                top_letter, count = Counter(word_stripped_as_lst).most_common()[0]\r\n                lst.append((_strip_non_letters(word), top_letter, count))\r\n    if lst:\r\n        return max(lst,key= lambda x:x[2])\r\n    else:\r\n        return ('', '', 0)\r\n\r\nif __name__== '__main__':\r\n    \r\n    test = ['emoji like \ud83d\ude03\ud83d\ude03\ud83d\ude03\ud83d\ude03 are not letters',\r\n    'Soci\u00e9t\u00e9 G\u00e9n\u00e9rale est une des principales banques fran\u00e7aises',\r\n    'Short Plays By Lady Gregory The Knickerbocker Press 1916',\r\n    'six-feet-two in height',\r\n    'der Schlo\u00df is riesig',\r\n    'the quick brown fox jumped over the lazy dog',\r\n    '\u00ab\u00bfTiene sentido la TV p\u00fablica?\u00bb',\r\n    \"but we've been there already!!!\",\r\n    '\"____\".isalpha() is True, thus this test text',\r\n    '99abc99 __abc__ --abc-- digits _ and - are not letters',\r\n    'test test test test test correct-answer.',\r\n    'They shouted \"Oh no she didn\\'t\"',\r\n    \"The brothers' feet were muddy.\",\r\n    '1, 2, 3',\r\n    '',\r\n    ]\r\n    \r\n    for item in test: \r\n        print(max_letter_word(item))",
            "date": "2022-12-15 01:05:34.098023+00:00",
            "passed": false
        },
        {
            "bite": "Bite 304. Most identical letters in a word",
            "code": "from typing import Tuple\r\nimport string\r\nfrom collections import Counter\r\nNOT_LETTER = string.punctuation + string.digits\r\nimport unicodedata\r\n\r\n\r\n\r\ndef max_letter_word(text: str) -> Tuple[str, str, int]:\r\n    \"\"\"\r\n    Find the word in text with the most repeated letters. If more than one word\r\n    has the highest number of repeated letters choose the first one. Return a\r\n    tuple of the word, the (first) repeated letter and the count of that letter\r\n    in the word.\r\n    >>> max_letter_word('I have just returned from a visit...')\r\n    ('returned', 'r', 2)\r\n    >>> max_letter_word('$5000 !!')\r\n    ('', '', 0)\r\n    \"\"\"\r\n    if not isinstance(text, str):\r\n        raise ValueError\r\n        \r\n    lst=[]\r\n    for word in text.split():\r\n        if word: \r\n            word_stripped_as_lst=[c for c in word.casefold() if unicodedata.category(c) in ['Ll', 'Lu']]\r\n            if word_stripped_as_lst:\r\n                top_letter, count = Counter(word_stripped_as_lst).most_common()[0]\r\n                lst.append((word.strip(NOT_LETTER), top_letter, count))\r\n    if lst:\r\n        return max(lst,key= lambda x:x[2])\r\n    else:\r\n        return ('', '', 0)\r\n\r\nif __name__== '__main__':\r\n    \r\n    test = ['emoji like \ud83d\ude03\ud83d\ude03\ud83d\ude03\ud83d\ude03 are not letters',\r\n    'Soci\u00e9t\u00e9 G\u00e9n\u00e9rale est une des principales banques fran\u00e7aises',\r\n    'Short Plays By Lady Gregory The Knickerbocker Press 1916',\r\n    'six-feet-two in height',\r\n    'der Schlo\u00df is riesig',\r\n    'the quick brown fox jumped over the lazy dog',\r\n    '\u00ab\u00bfTiene sentido la TV p\u00fablica?\u00bb',\r\n    \"but we've been there already!!!\",\r\n    '\"____\".isalpha() is True, thus this test text',\r\n    '99abc99 __abc__ --abc-- digits _ and - are not letters',\r\n    'test test test test test correct-answer.',\r\n    'They shouted \"Oh no she didn\\'t\"',\r\n    \"The brothers' feet were muddy.\",\r\n    '1, 2, 3',\r\n    '',\r\n    ]\r\n    \r\n    for item in test: \r\n        print(max_letter_word(item))",
            "date": "2022-12-15 01:01:26.979038+00:00",
            "passed": false
        },
        {
            "bite": "Bite 304. Most identical letters in a word",
            "code": "from typing import Tuple\r\nimport string\r\nfrom collections import Counter\r\nNOT_LETTER = string.punctuation + string.digits\r\nimport unicodedata\r\n\r\n\r\n\r\ndef max_letter_word(text: str) -> Tuple[str, str, int]:\r\n    \"\"\"\r\n    Find the word in text with the most repeated letters. If more than one word\r\n    has the highest number of repeated letters choose the first one. Return a\r\n    tuple of the word, the (first) repeated letter and the count of that letter\r\n    in the word.\r\n    >>> max_letter_word('I have just returned from a visit...')\r\n    ('returned', 'r', 2)\r\n    >>> max_letter_word('$5000 !!')\r\n    ('', '', 0)\r\n    \"\"\"\r\n    if not isinstance(text, str):\r\n        raise ValueError\r\n        \r\n    lst=[]\r\n    for word in text.split():\r\n        if word: \r\n            word_stripped_as_lst=[c for c in word.casefold() if unicodedata.category(c) not in ['Po', 'Pd', 'Nd']]\r\n            if word_stripped_as_lst:\r\n                top_letter, count = Counter(word_stripped_as_lst).most_common()[0]\r\n                lst.append((word.strip(NOT_LETTER), top_letter, count))\r\n    if lst:\r\n        return max(lst,key= lambda x:x[2])\r\n    else:\r\n        return ('', '', 0)\r\n\r\nif __name__== '__main__':\r\n    \r\n    test = ['emoji like \ud83d\ude03\ud83d\ude03\ud83d\ude03\ud83d\ude03 are not letters',\r\n    'Soci\u00e9t\u00e9 G\u00e9n\u00e9rale est une des principales banques fran\u00e7aises',\r\n    'Short Plays By Lady Gregory The Knickerbocker Press 1916',\r\n    'six-feet-two in height',\r\n    'der Schlo\u00df is riesig',\r\n    'the quick brown fox jumped over the lazy dog',\r\n    '\u00ab\u00bfTiene sentido la TV p\u00fablica?\u00bb',\r\n    \"but we've been there already!!!\",\r\n    '\"____\".isalpha() is True, thus this test text',\r\n    '99abc99 __abc__ --abc-- digits _ and - are not letters',\r\n    'test test test test test correct-answer.',\r\n    'They shouted \"Oh no she didn\\'t\"',\r\n    \"The brothers' feet were muddy.\",\r\n    '1, 2, 3',\r\n    '',\r\n    ]\r\n    \r\n    for item in test: \r\n        print(max_letter_word(item))",
            "date": "2022-12-15 00:56:00.522731+00:00",
            "passed": false
        },
        {
            "bite": "Bite 325. Floating point arithmetic",
            "code": "from typing import Generator\r\n\r\nimport json\r\nimport decimal\r\n\r\nVALUES = \"[0.1, 0.2, 0.3, 0.005, 0.005, 2.67]\"\r\n\r\n\r\ndef calc_sums(values: str = VALUES) -> Generator[str, None, None]:\r\n    \"\"\"\r\n    Process the above JSON-encoded string of values and calculate the sum of each adjacent pair.\r\n\r\n    The output should be a generator that produces a string that recites the calculation for each pair, for example:\r\n\r\n        'The sum of 0.1 and 0.2, rounded to two decimal places, is 0.3.'\r\n    \"\"\"\r\n    \r\n    ctx = decimal.getcontext()\r\n    ctx.rounding = decimal.ROUND_HALF_UP\r\n\r\n    decimal_values = [decimal.Decimal(str(value)) for value in json.loads(values)]\r\n    for a,b in zip(decimal_values, decimal_values[1:]):\r\n        c = a + b\r\n        yield f\"The sum of {a} and {b}, rounded to two decimal places, is {c:.2f}.\"\r\n",
            "date": "2022-12-13 21:04:45.163047+00:00",
            "passed": true
        },
        {
            "bite": "Bite 325. Floating point arithmetic",
            "code": "from typing import Generator\r\n\r\nimport json\r\nimport decimal\r\n\r\nVALUES = \"[0.1, 0.2, 0.3, 0.005, 0.005, 2.67]\"\r\n\r\n\r\ndef calc_sums(values: str = VALUES) -> Generator[str, None, None]:\r\n    \"\"\"\r\n    Process the above JSON-encoded string of values and calculate the sum of each adjacent pair.\r\n\r\n    The output should be a generator that produces a string that recites the calculation for each pair, for example:\r\n\r\n        'The sum of 0.1 and 0.2, rounded to two decimal places, is 0.3.'\r\n    \"\"\"\r\n    \r\n    ctx = decimal.getcontext()\r\n    ctx.rounding = decimal.ROUND_HALF_UP\r\n\r\n    values = json.loads(values)\r\n    values = [decimal.Decimal(str(value)) for value in values]\r\n    for a,b in zip(values, values[1:]):\r\n        c = a + b\r\n        yield f\"The sum of {a} and {b}, rounded to two decimal places, is {c:.2f}.\"\r\n        \r\n\r\ncalc_sums()",
            "date": "2022-12-13 21:03:20.675600+00:00",
            "passed": true
        },
        {
            "bite": "Bite 325. Floating point arithmetic",
            "code": "from typing import Generator\r\n\r\nimport json\r\nimport decimal\r\n\r\nVALUES = \"[0.1, 0.2, 0.3, 0.005, 0.005, 2.67]\"\r\n\r\n\r\ndef calc_sums(values: str = VALUES) -> Generator[str, None, None]:\r\n    \"\"\"\r\n    Process the above JSON-encoded string of values and calculate the sum of each adjacent pair.\r\n\r\n    The output should be a generator that produces a string that recites the calculation for each pair, for example:\r\n\r\n        'The sum of 0.1 and 0.2, rounded to two decimal places, is 0.3.'\r\n    \"\"\"\r\n    \r\n    ctx = decimal.getcontext()\r\n    ctx.rounding = decimal.ROUND_HALF_UP\r\n\r\n    values = json.loads(values)\r\n    values = [decimal.Decimal(str(value)) for value in values]\r\n    for a,b in zip(values, values[1:]):\r\n        c = a + b\r\n        print(f\"The sum of {a} and {b}, rounded to two decimal places, is {c:.2f}.\")\r\n        \r\n\r\ncalc_sums()",
            "date": "2022-12-13 21:02:49.075869+00:00",
            "passed": false
        },
        {
            "bite": "Bite 325. Floating point arithmetic",
            "code": "from typing import Generator\r\n\r\nimport json\r\nfrom decimal import Decimal\r\n\r\nVALUES = \"[0.1, 0.2, 0.3, 0.005, 0.005, 2.67]\"\r\n\r\n\r\ndef calc_sums(values: str = VALUES) -> Generator[str, None, None]:\r\n    \"\"\"\r\n    Process the above JSON-encoded string of values and calculate the sum of each adjacent pair.\r\n\r\n    The output should be a generator that produces a string that recites the calculation for each pair, for example:\r\n\r\n        'The sum of 0.1 and 0.2, rounded to two decimal places, is 0.3.'\r\n    \"\"\"\r\n    values = json.loads(values)\r\n    values = [Decimal(str(value)) for value in values]\r\n    for a,b in zip(values, values[1:]):\r\n        c = a + b\r\n        yield f\"The sum of {a} and {b}, rounded to two decimal places, is {c:.2f}.\"\r\n        \r\n# calc_sums()",
            "date": "2022-12-13 20:46:47.049511+00:00",
            "passed": false
        },
        {
            "bite": "Bite 325. Floating point arithmetic",
            "code": "from typing import Generator\r\n\r\nimport json\r\nfrom decimal import Decimal\r\n\r\nVALUES = \"[0.1, 0.2, 0.3, 0.005, 0.005, 2.67]\"\r\n\r\n\r\ndef calc_sums(values: str = VALUES) -> Generator[str, None, None]:\r\n    \"\"\"\r\n    Process the above JSON-encoded string of values and calculate the sum of each adjacent pair.\r\n\r\n    The output should be a generator that produces a string that recites the calculation for each pair, for example:\r\n\r\n        'The sum of 0.1 and 0.2, rounded to two decimal places, is 0.3.'\r\n    \"\"\"\r\n    values = json.loads(values)\r\n    values = [Decimal(str(value)) for value in values]\r\n    for a,b in zip(values, values[1:]):\r\n        c = round(a + b,2)\r\n        yield f\"The sum of {a} and {b}, rounded to two decimal places, is {c}.\"\r\n        \r\n# calc_sums()",
            "date": "2022-12-13 20:45:45.513413+00:00",
            "passed": false
        },
        {
            "bite": "Bite 94. Parse PyCon talk data from YouTube",
            "code": "from collections import namedtuple\r\nimport os\r\nimport pickle\r\nimport urllib.request\r\nimport re\r\nfrom datetime import timedelta\r\n\r\n\r\n# prework\r\n# download pickle file and store it in a tmp file\r\npkl_file = 'pycon_videos.pkl'\r\ndata = f'https://bites-data.s3.us-east-2.amazonaws.com/{pkl_file}'\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\npycon_videos = os.path.join(tmp, pkl_file)\r\nurllib.request.urlretrieve(data, pycon_videos)\r\n\r\nfrom pprint import pprint\r\n\r\n# the pkl contains a list of Video namedtuples\r\nVideo = namedtuple('Video', 'id title duration metrics')\r\n\r\n\r\ndef load_pycon_data(pycon_videos=pycon_videos):\r\n    \"\"\"Load the pickle file (pycon_videos) and return the data structure\r\n       it holds\"\"\"\r\n    with open(pycon_videos, 'rb') as f:\r\n        return pickle.load(f)\r\n\r\n\r\ndef get_most_popular_talks_by_views(videos):\r\n    \"\"\"Return the pycon video list sorted by viewCount\"\"\"\r\n    return sorted(videos, key=lambda x:int(x.metrics['viewCount']),reverse=True)    \r\n\r\n\r\ndef get_most_popular_talks_by_like_ratio(videos):\r\n    \"\"\"Return the pycon video list sorted by most likes relative to\r\n       number of views, so 10 likes on 175 views ranks higher than\r\n       12 likes on 300 views. Discount the dislikeCount from the likeCount.\r\n       Return the filtered list\"\"\"\r\n       \r\n    fun = lambda x: (int(x.metrics['likeCount']) - int(x.metrics['dislikeCount']))/ int(x.metrics['viewCount'])\r\n    return sorted(videos, key=fun,reverse=True)    \r\n\r\n\r\ndef _video_duration(duration_str):\r\n    \r\n    hours=int(re.search('[0-9]+(?=H)', duration_str).group(0)) if 'H' in duration_str else 0\r\n    minutes=int(re.search('[0-9]+(?=M)', duration_str).group(0)) if 'M' in duration_str else 0\r\n    seconds=int(re.search('[0-9]+(?=S)', duration_str).group(0)) if 'S' in duration_str else 0\r\n    return timedelta(hours=hours, minutes=minutes, seconds=seconds)\r\n\r\ndef get_talks_gt_one_hour(videos):\r\n    \"\"\"Filter the videos list down to videos of > 1 hour\"\"\"\r\n    return [video for video in videos if _video_duration(video.duration) > timedelta(hours=1)] \r\n\r\n\r\ndef get_talks_lt_twentyfour_min(videos):\r\n    \"\"\"Filter videos list down to videos that have a duration of less than\r\n       24 minutes\"\"\"\r\n    return [video for video in videos if _video_duration(video.duration) < timedelta(minutes=24)] \r\n\r\n\r\nif __name__ =='__main__':\r\n    top=10\r\n    videos = load_pycon_data()\r\n    print(\" \".join([item.metrics['viewCount'] for item in videos[0:top] ]))\r\n    popular_videos = get_most_popular_talks_by_views(videos)\r\n    print(\" \".join([item.metrics['viewCount'] for item in popular_videos[0:top]]))\r\n    \r\n    liked_videos = get_most_popular_talks_by_like_ratio(videos)\r\n    print(\" \".join([\r\n                    str(\r\n                        100*((int(item.metrics['likeCount'])-int(item.metrics['dislikeCount'])) / \r\n                        int(item.metrics['viewCount']))) for item in liked_videos[0:top]]\r\n                )\r\n        )\r\n\r\n    print(_video_duration('PT3H17M9S'))",
            "date": "2022-12-12 18:27:31.824286+00:00",
            "passed": true
        },
        {
            "bite": "Bite 94. Parse PyCon talk data from YouTube",
            "code": "from collections import namedtuple\r\nimport os\r\nimport pickle\r\nimport urllib.request\r\nimport re\r\nfrom datetime import timedelta\r\n\r\n\r\n# prework\r\n# download pickle file and store it in a tmp file\r\npkl_file = 'pycon_videos.pkl'\r\ndata = f'https://bites-data.s3.us-east-2.amazonaws.com/{pkl_file}'\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\npycon_videos = os.path.join(tmp, pkl_file)\r\nurllib.request.urlretrieve(data, pycon_videos)\r\n\r\nfrom pprint import pprint\r\n\r\n# the pkl contains a list of Video namedtuples\r\nVideo = namedtuple('Video', 'id title duration metrics')\r\n\r\n\r\ndef load_pycon_data(pycon_videos=pycon_videos):\r\n    \"\"\"Load the pickle file (pycon_videos) and return the data structure\r\n       it holds\"\"\"\r\n    with open(pycon_videos, 'rb') as f:\r\n        return pickle.load(f)\r\n\r\n\r\ndef get_most_popular_talks_by_views(videos):\r\n    \"\"\"Return the pycon video list sorted by viewCount\"\"\"\r\n    return sorted(videos, key=lambda x:int(x.metrics['viewCount']),reverse=True)    \r\n\r\n\r\ndef get_most_popular_talks_by_like_ratio(videos):\r\n    \"\"\"Return the pycon video list sorted by most likes relative to\r\n       number of views, so 10 likes on 175 views ranks higher than\r\n       12 likes on 300 views. Discount the dislikeCount from the likeCount.\r\n       Return the filtered list\"\"\"\r\n       \r\n    fun = lambda x: (int(x.metrics['likeCount']) - int(x.metrics['dislikeCount']))/ int(x.metrics['viewCount'])\r\n    return sorted(videos, key=fun,reverse=True)    \r\n\r\n\r\ndef _video_duration(duration_str):\r\n    \r\n    hours=int(re.search('[0-9]+(?=H)', duration_str).group(0)) if 'H' in duration_str else 0\r\n    minutes=int(re.search('[0-9]+(?=M)', duration_str).group(0)) if 'M' in duration_str else 0\r\n    seconds=int(re.search('[0-9]+(?=S)', duration_str).group(0)) if 'S' in duration_str else 0\r\n    return timedelta(hours=hours, minutes=minutes, seconds=seconds)\r\n\r\ndef get_talks_gt_one_hour(videos):\r\n    \"\"\"Filter the videos list down to videos of > 1 hour\"\"\"\r\n    return [video for video in videos if _video_duration(video.duration) > timedelta(hours=1)] \r\n\r\n\r\ndef get_talks_lt_twentyfour_min(videos):\r\n    \"\"\"Filter videos list down to videos that have a duration of less than\r\n       24 minutes\"\"\"\r\n    return [video for video in videos if _video_duration(video) < timedelta(minutes=24)] \r\n\r\n\r\nif __name__ =='__main__':\r\n    top=10\r\n    videos = load_pycon_data()\r\n    print(\" \".join([item.metrics['viewCount'] for item in videos[0:top] ]))\r\n    popular_videos = get_most_popular_talks_by_views(videos)\r\n    print(\" \".join([item.metrics['viewCount'] for item in popular_videos[0:top]]))\r\n    \r\n    liked_videos = get_most_popular_talks_by_like_ratio(videos)\r\n    print(\" \".join([\r\n                    str(\r\n                        100*((int(item.metrics['likeCount'])-int(item.metrics['dislikeCount'])) / \r\n                        int(item.metrics['viewCount']))) for item in liked_videos[0:top]]\r\n                )\r\n        )\r\n\r\n    print(_video_duration('PT3H17M9S'))",
            "date": "2022-12-12 18:26:29.610703+00:00",
            "passed": false
        },
        {
            "bite": "Bite 94. Parse PyCon talk data from YouTube",
            "code": "from collections import namedtuple\r\nimport os\r\nimport pickle\r\nimport urllib.request\r\n\r\n# prework\r\n# download pickle file and store it in a tmp file\r\npkl_file = 'pycon_videos.pkl'\r\ndata = f'https://bites-data.s3.us-east-2.amazonaws.com/{pkl_file}'\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\npycon_videos = os.path.join(tmp, pkl_file)\r\nurllib.request.urlretrieve(data, pycon_videos)\r\n\r\nfrom pprint import pprint\r\n\r\n# the pkl contains a list of Video namedtuples\r\nVideo = namedtuple('Video', 'id title duration metrics')\r\n\r\n\r\ndef load_pycon_data(pycon_videos=pycon_videos):\r\n    \"\"\"Load the pickle file (pycon_videos) and return the data structure\r\n       it holds\"\"\"\r\n    with open(pycon_videos, 'rb') as f:\r\n        return pickle.load(f)\r\n\r\n\r\ndef get_most_popular_talks_by_views(videos):\r\n    \"\"\"Return the pycon video list sorted by viewCount\"\"\"\r\n    return sorted(videos, key=lambda x:int(x.metrics['viewCount']),reverse=True)    \r\n\r\n\r\ndef get_most_popular_talks_by_like_ratio(videos):\r\n    \"\"\"Return the pycon video list sorted by most likes relative to\r\n       number of views, so 10 likes on 175 views ranks higher than\r\n       12 likes on 300 views. Discount the dislikeCount from the likeCount.\r\n       Return the filtered list\"\"\"\r\n       \r\n    fun = lambda x: (int(x.metrics['likeCount']) - int(x.metrics['dislikeCount']))/ int(x.metrics['viewCount'])\r\n    return sorted(videos, key=fun,reverse=True)    \r\n\r\n\r\n\r\ndef get_talks_gt_one_hour(videos):\r\n    \"\"\"Filter the videos list down to videos of > 1 hour\"\"\"\r\n    pass\r\n\r\n\r\ndef get_talks_lt_twentyfour_min(videos):\r\n    \"\"\"Filter videos list down to videos that have a duration of less than\r\n       24 minutes\"\"\"\r\n    pass\r\n\r\n\r\nif __name__ =='__main__':\r\n    top=10\r\n    videos = load_pycon_data()\r\n    print(\" \".join([item.metrics['viewCount'] for item in videos[0:top] ]))\r\n    popular_videos = get_most_popular_talks_by_views(videos)\r\n    print(\" \".join([item.metrics['viewCount'] for item in popular_videos[0:top]]))\r\n    \r\n    liked_videos = get_most_popular_talks_by_like_ratio(videos)\r\n    print(\" \".join([\r\n                    str(\r\n                        100*((int(item.metrics['likeCount'])-int(item.metrics['dislikeCount'])) / \r\n                        int(item.metrics['viewCount']))) for item in liked_videos[0:top]]\r\n                )\r\n        )\r\n    ",
            "date": "2022-12-12 18:13:32.131577+00:00",
            "passed": false
        },
        {
            "bite": "Bite 94. Parse PyCon talk data from YouTube",
            "code": "from collections import namedtuple\r\nimport os\r\nimport pickle\r\nimport urllib.request\r\n\r\n# prework\r\n# download pickle file and store it in a tmp file\r\npkl_file = 'pycon_videos.pkl'\r\ndata = f'https://bites-data.s3.us-east-2.amazonaws.com/{pkl_file}'\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\npycon_videos = os.path.join(tmp, pkl_file)\r\nurllib.request.urlretrieve(data, pycon_videos)\r\n\r\nfrom pprint import pprint\r\n\r\n# the pkl contains a list of Video namedtuples\r\nVideo = namedtuple('Video', 'id title duration metrics')\r\n\r\n\r\ndef load_pycon_data(pycon_videos=pycon_videos):\r\n    \"\"\"Load the pickle file (pycon_videos) and return the data structure\r\n       it holds\"\"\"\r\n    with open(pycon_videos, 'rb') as f:\r\n        return pickle.load(f)\r\n\r\n\r\ndef get_most_popular_talks_by_views(videos):\r\n    \"\"\"Return the pycon video list sorted by viewCount\"\"\"\r\n    return sorted(videos, key=lambda x:int(x.metrics['viewCount']),reverse=True)    \r\n\r\n\r\ndef get_most_popular_talks_by_like_ratio(videos):\r\n    \"\"\"Return the pycon video list sorted by most likes relative to\r\n       number of views, so 10 likes on 175 views ranks higher than\r\n       12 likes on 300 views. Discount the dislikeCount from the likeCount.\r\n       Return the filtered list\"\"\"\r\n    pass\r\n\r\n\r\ndef get_talks_gt_one_hour(videos):\r\n    \"\"\"Filter the videos list down to videos of > 1 hour\"\"\"\r\n    pass\r\n\r\n\r\ndef get_talks_lt_twentyfour_min(videos):\r\n    \"\"\"Filter videos list down to videos that have a duration of less than\r\n       24 minutes\"\"\"\r\n    pass\r\n\r\n\r\nif __name__ =='__main__':\r\n    top=10\r\n    videos = load_pycon_data()\r\n    print(\" \".join([item.metrics['viewCount'] for item in videos[0:top] ]))\r\n    popular_videos = get_most_popular_talks_by_views(videos)\r\n    print(\" \".join([item.metrics['viewCount'] for item in popular_videos[0:top]]))",
            "date": "2022-12-12 18:02:36.312769+00:00",
            "passed": false
        },
        {
            "bite": "Bite 50. Make a little PyBites search engine (feedparser)",
            "code": "from collections import namedtuple\r\nfrom datetime import date\r\n\r\nimport feedparser\r\nimport re\r\nfrom pprint import pprint\r\n\r\nFEED = 'https://bites-data.s3.us-east-2.amazonaws.com/all.rss.xml'\r\n\r\nEntry = namedtuple('Entry', 'date title link tags')\r\n\r\n\r\ndef _convert_struct_time_to_dt(stime):\r\n    \"\"\"Convert a time.struct_time as returned by feedparser into a\r\n    datetime.date object, so:\r\n    time.struct_time(tm_year=2016, tm_mon=12, tm_mday=28, ...)\r\n    -> date(2016, 12, 28)\r\n    \"\"\"\r\n    year, month, day, *_ = stime\r\n    return date(year=year,month=month,day=day)\r\n\r\n\r\ndef get_feed_entries(feed=FEED):\r\n    \"\"\"Use feedparser to parse PyBites RSS feed.\r\n       Return a list of Entry namedtuples (date = date, drop time part)\r\n    \"\"\"\r\n    feed = feedparser.parse(feed)\r\n    lst = []\r\n    for entry in feed.entries:\r\n        \r\n        entry_tags = [tag['term'].lower() for tag in entry.tags]\r\n        # print(entry_date, entry.title, entry.link, entry_tags)\r\n        lst.append(Entry(_convert_struct_time_to_dt(entry.published_parsed), entry.title, entry.link, entry_tags))\r\n    return lst\r\n\r\ndef filter_entries_by_tag(search, entry):\r\n    \"\"\"Check if search matches any tags as stored in the Entry namedtuple\r\n       (case insensitive, only whole, not partial string matches).\r\n       Returns bool: True if match, False if not.\r\n       Supported searches:\r\n       1. If & in search do AND match,\r\n          e.g. flask&api should match entries with both tags\r\n       2. Elif | in search do an OR match,\r\n          e.g. flask|django should match entries with either tag\r\n       3. Else: match if search is in tags\r\n    \"\"\"\r\n    if '&' in search:\r\n        words = search.split('&')\r\n        return all(filter_entries_by_tag(word,entry) for word in words)\r\n    elif '|' in search:\r\n        words = search.split('|')\r\n        return any(filter_entries_by_tag(word,entry) for word in words)\r\n    else:\r\n        return any(search.lower() == tag.lower() for tag in entry.tags)\r\n        \r\n\r\ndef main():\r\n    \"\"\"Entry point to the program\r\n       1. Call get_feed_entries and store them in entries\r\n       2. Initiate an infinite loop\r\n       3. Ask user for a search term:\r\n          - if enter was hit (empty string), print 'Please provide a search term'\r\n          - if 'q' was entered, print 'Bye' and exit/break the infinite loop\r\n       4. Filter/match the entries (see filter_entries_by_tag docstring)\r\n       5. Print the title of each match ordered by date ascending\r\n       6. Secondly, print the number of matches: 'n entries matched'\r\n          (use entry if only 1 match)\r\n    \"\"\"\r\n    \r\n    entries  = get_feed_entries()\r\n    \r\n    while True:\r\n    \r\n        usr_input = input('Search for (q for exit):')\r\n    \r\n        if not usr_input:\r\n            print('Please provide a search term')\r\n            continue\r\n\r\n        if usr_input.lower() =='q':\r\n            print('Bye')\r\n            break\r\n        else:\r\n            filtered_entries = [entry for entry in entries if filter_entries_by_tag(usr_input, entry)]\r\n            if filtered_entries:\r\n                for entry in  sorted(filtered_entries, key=lambda x:x.date):\r\n                    print(f'{entry.date} | {entry.title:<42} | {entry.link}')\r\n\r\n            entrx = 'entry' if len(filtered_entries)==1 else 'entries'\r\n\r\n            print(f'\\n\\t{len(filtered_entries)} {entrx} matched \"{usr_input}\"\\n')\r\n                \r\n\r\nif __name__ == '__main__':\r\n    main()",
            "date": "2022-12-12 17:32:44.028260+00:00",
            "passed": true
        },
        {
            "bite": "Bite 50. Make a little PyBites search engine (feedparser)",
            "code": "from collections import namedtuple\r\nfrom datetime import date\r\n\r\nimport feedparser\r\nimport re\r\nfrom pprint import pprint\r\n\r\nFEED = 'https://bites-data.s3.us-east-2.amazonaws.com/all.rss.xml'\r\n\r\nEntry = namedtuple('Entry', 'date title link tags')\r\n\r\n\r\ndef _convert_struct_time_to_dt(stime):\r\n    \"\"\"Convert a time.struct_time as returned by feedparser into a\r\n    datetime.date object, so:\r\n    time.struct_time(tm_year=2016, tm_mon=12, tm_mday=28, ...)\r\n    -> date(2016, 12, 28)\r\n    \"\"\"\r\n    year, month, day, *_ = stime\r\n    return date(year=year,month=month,day=day)\r\n\r\n\r\ndef get_feed_entries(feed=FEED):\r\n    \"\"\"Use feedparser to parse PyBites RSS feed.\r\n       Return a list of Entry namedtuples (date = date, drop time part)\r\n    \"\"\"\r\n    feed = feedparser.parse(feed)\r\n    lst = []\r\n    for entry in feed.entries:\r\n        \r\n        entry_tags = [tag['term'].lower() for tag in entry.tags]\r\n        # print(entry_date, entry.title, entry.link, entry_tags)\r\n        lst.append(Entry(_convert_struct_time_to_dt(entry.published_parsed), entry.title, entry.link, entry_tags))\r\n    return lst\r\n\r\ndef filter_entries_by_tag(search, entry):\r\n    \"\"\"Check if search matches any tags as stored in the Entry namedtuple\r\n       (case insensitive, only whole, not partial string matches).\r\n       Returns bool: True if match, False if not.\r\n       Supported searches:\r\n       1. If & in search do AND match,\r\n          e.g. flask&api should match entries with both tags\r\n       2. Elif | in search do an OR match,\r\n          e.g. flask|django should match entries with either tag\r\n       3. Else: match if search is in tags\r\n    \"\"\"\r\n    if '&' in search:\r\n        words = search.split('&')\r\n        return all(filter_entries_by_tag(word,entry) for word in words)\r\n    elif '|' in search:\r\n        words = search.split('|')\r\n        return any(filter_entries_by_tag(word,entry) for word in words)\r\n    else:\r\n        return any(search.lower() == tag.lower() for tag in entry.tags)\r\n        \r\n\r\ndef main():\r\n    \"\"\"Entry point to the program\r\n       1. Call get_feed_entries and store them in entries\r\n       2. Initiate an infinite loop\r\n       3. Ask user for a search term:\r\n          - if enter was hit (empty string), print 'Please provide a search term'\r\n          - if 'q' was entered, print 'Bye' and exit/break the infinite loop\r\n       4. Filter/match the entries (see filter_entries_by_tag docstring)\r\n       5. Print the title of each match ordered by date ascending\r\n       6. Secondly, print the number of matches: 'n entries matched'\r\n          (use entry if only 1 match)\r\n    \"\"\"\r\n    \r\n    entries  = get_feed_entries()\r\n    \r\n    while True:\r\n    \r\n        usr_input = input('Search for (q for exit):')\r\n    \r\n        if not usr_input:\r\n            print('Please provide a search term')\r\n            continue\r\n\r\n        if usr_input.lower() =='q':\r\n            print('Bye')\r\n            break\r\n        else:\r\n            filtered_entries = [entry for entry in entries if filter_entries_by_tag(usr_input, entry)]\r\n            if filtered_entries:\r\n                for entry in  sorted(filtered_entries, key=lambda x:x.date):\r\n                    print(f'{entry.date} | {entry.title:<42} | {entry.link}')\r\n\r\n            entrx = 'entry' if len(entries)==1 else 'entries'\r\n\r\n            print(f'\\n\\t{len(filtered_entries)} {entrx} matched \"{usr_input}\"\\n')\r\n                \r\n\r\nif __name__ == '__main__':\r\n    main()",
            "date": "2022-12-12 15:15:40.629641+00:00",
            "passed": false
        },
        {
            "bite": "Bite 50. Make a little PyBites search engine (feedparser)",
            "code": "from collections import namedtuple\r\nfrom datetime import date\r\n\r\nimport feedparser\r\nimport re\r\nfrom pprint import pprint\r\n\r\nFEED = 'https://bites-data.s3.us-east-2.amazonaws.com/all.rss.xml'\r\n\r\nEntry = namedtuple('Entry', 'date title link tags')\r\n\r\n\r\ndef _convert_struct_time_to_dt(stime):\r\n    \"\"\"Convert a time.struct_time as returned by feedparser into a\r\n    datetime.date object, so:\r\n    time.struct_time(tm_year=2016, tm_mon=12, tm_mday=28, ...)\r\n    -> date(2016, 12, 28)\r\n    \"\"\"\r\n    year, month, day, *_ = stime\r\n    return date(year=year,month=month,day=day)\r\n\r\n\r\ndef get_feed_entries(feed=FEED):\r\n    \"\"\"Use feedparser to parse PyBites RSS feed.\r\n       Return a list of Entry namedtuples (date = date, drop time part)\r\n    \"\"\"\r\n    feed = feedparser.parse(feed)\r\n    lst = []\r\n    for entry in feed.entries:\r\n        \r\n        entry_tags = [tag['term'].lower() for tag in entry.tags]\r\n        # print(entry_date, entry.title, entry.link, entry_tags)\r\n        lst.append(Entry(_convert_struct_time_to_dt(entry.published_parsed), entry.title, entry.link, entry_tags))\r\n    return lst\r\n\r\ndef filter_entries_by_tag(search, entry):\r\n    \"\"\"Check if search matches any tags as stored in the Entry namedtuple\r\n       (case insensitive, only whole, not partial string matches).\r\n       Returns bool: True if match, False if not.\r\n       Supported searches:\r\n       1. If & in search do AND match,\r\n          e.g. flask&api should match entries with both tags\r\n       2. Elif | in search do an OR match,\r\n          e.g. flask|django should match entries with either tag\r\n       3. Else: match if search is in tags\r\n    \"\"\"\r\n    if '&' in search:\r\n        words = search.split('&')\r\n        return all(filter_entries_by_tag(word,entry) for word in words)\r\n    elif '|' in search:\r\n        words = search.split('|')\r\n        return any(filter_entries_by_tag(word,entry) for word in words)\r\n    else:\r\n        return any(search.lower() == tag.lower() for tag in entry.tags)\r\n        \r\n\r\ndef main():\r\n    \"\"\"Entry point to the program\r\n       1. Call get_feed_entries and store them in entries\r\n       2. Initiate an infinite loop\r\n       3. Ask user for a search term:\r\n          - if enter was hit (empty string), print 'Please provide a search term'\r\n          - if 'q' was entered, print 'Bye' and exit/break the infinite loop\r\n       4. Filter/match the entries (see filter_entries_by_tag docstring)\r\n       5. Print the title of each match ordered by date ascending\r\n       6. Secondly, print the number of matches: 'n entries matched'\r\n          (use entry if only 1 match)\r\n    \"\"\"\r\n    \r\n    entries  = get_feed_entries()\r\n    \r\n    while True:\r\n    \r\n        usr_input = input('Search for (q for exit):')\r\n    \r\n        if not usr_input:\r\n            print('Please provide a search term')\r\n            continue\r\n\r\n        if usr_input.lower() =='q':\r\n            print('Bye')\r\n            break\r\n        else:\r\n            filtered_entries = [entry for entry in entries if filter_entries_by_tag(usr_input, entry)]\r\n            if filtered_entries:\r\n                for entry in  sorted(filtered_entries, key=lamdba x:x.date):\r\n                    print(f'{entry.date} | {entry.title:<42} | {entry.link}')\r\n\r\n            entrx = 'entry' if len(entries)==1 else 'entries'\r\n\r\n            print(f'\\n\\t{len(filtered_entries)} {entrx} matched \"{usr_input}\"\\n')\r\n                \r\n\r\nif __name__ == '__main__':\r\n    main()",
            "date": "2022-12-12 15:15:01.765324+00:00",
            "passed": false
        },
        {
            "bite": "Bite 50. Make a little PyBites search engine (feedparser)",
            "code": "from collections import namedtuple\r\nfrom datetime import date\r\n\r\nimport feedparser\r\nimport re\r\nfrom pprint import pprint\r\n\r\nFEED = 'https://bites-data.s3.us-east-2.amazonaws.com/all.rss.xml'\r\n\r\nEntry = namedtuple('Entry', 'date title link tags')\r\n\r\n\r\ndef _convert_struct_time_to_dt(stime):\r\n    \"\"\"Convert a time.struct_time as returned by feedparser into a\r\n    datetime.date object, so:\r\n    time.struct_time(tm_year=2016, tm_mon=12, tm_mday=28, ...)\r\n    -> date(2016, 12, 28)\r\n    \"\"\"\r\n    year, month, day, *_ = stime\r\n    return date(year=year,month=month,day=day)\r\n\r\n\r\ndef get_feed_entries(feed=FEED):\r\n    \"\"\"Use feedparser to parse PyBites RSS feed.\r\n       Return a list of Entry namedtuples (date = date, drop time part)\r\n    \"\"\"\r\n    feed = feedparser.parse(feed)\r\n    lst = []\r\n    for entry in feed.entries:\r\n        \r\n        entry_tags = [tag['term'].lower() for tag in entry.tags]\r\n        # print(entry_date, entry.title, entry.link, entry_tags)\r\n        lst.append(Entry(_convert_struct_time_to_dt(entry.published_parsed), entry.title, entry.link, entry_tags))\r\n    return lst\r\n\r\ndef filter_entries_by_tag(search, entry):\r\n    \"\"\"Check if search matches any tags as stored in the Entry namedtuple\r\n       (case insensitive, only whole, not partial string matches).\r\n       Returns bool: True if match, False if not.\r\n       Supported searches:\r\n       1. If & in search do AND match,\r\n          e.g. flask&api should match entries with both tags\r\n       2. Elif | in search do an OR match,\r\n          e.g. flask|django should match entries with either tag\r\n       3. Else: match if search is in tags\r\n    \"\"\"\r\n    if '&' in search:\r\n        words = search.split('&')\r\n        return all(filter_entries_by_tag(word,entry) for word in words)\r\n    elif '|' in search:\r\n        words = search.split('|')\r\n        return any(filter_entries_by_tag(word,entry) for word in words)\r\n    else:\r\n        return any(search.lower() == tag.lower() for tag in entry.tags)\r\n        \r\n\r\ndef main():\r\n    \"\"\"Entry point to the program\r\n       1. Call get_feed_entries and store them in entries\r\n       2. Initiate an infinite loop\r\n       3. Ask user for a search term:\r\n          - if enter was hit (empty string), print 'Please provide a search term'\r\n          - if 'q' was entered, print 'Bye' and exit/break the infinite loop\r\n       4. Filter/match the entries (see filter_entries_by_tag docstring)\r\n       5. Print the title of each match ordered by date ascending\r\n       6. Secondly, print the number of matches: 'n entries matched'\r\n          (use entry if only 1 match)\r\n    \"\"\"\r\n    pass\r\n\r\n# pprint(get_feed_entries())\r\n    \r\nif __name__ == '__main__':\r\n    main()",
            "date": "2022-12-12 14:58:12.280605+00:00",
            "passed": false
        },
        {
            "bite": "Bite 50. Make a little PyBites search engine (feedparser)",
            "code": "from collections import namedtuple\r\nfrom datetime import date\r\n\r\nimport feedparser\r\nimport re\r\nfrom pprint import pprint\r\n\r\nFEED = 'https://bites-data.s3.us-east-2.amazonaws.com/all.rss.xml'\r\n\r\nEntry = namedtuple('Entry', 'date title link tags')\r\n\r\n\r\ndef _convert_struct_time_to_dt(stime):\r\n    \"\"\"Convert a time.struct_time as returned by feedparser into a\r\n    datetime.date object, so:\r\n    time.struct_time(tm_year=2016, tm_mon=12, tm_mday=28, ...)\r\n    -> date(2016, 12, 28)\r\n    \"\"\"\r\n    year, month, day, *_ = stime\r\n    return date(year=year,month=month,day=day)\r\n\r\n\r\ndef get_feed_entries(feed=FEED):\r\n    \"\"\"Use feedparser to parse PyBites RSS feed.\r\n       Return a list of Entry namedtuples (date = date, drop time part)\r\n    \"\"\"\r\n    feed = feedparser.parse(feed)\r\n    lst = []\r\n    for entry in feed.entries:\r\n        \r\n        entry_tags = [tag['term'].lower() for tag in entry.tags]\r\n        # print(entry_date, entry.title, entry.link, entry_tags)\r\n        lst.append(Entry(_convert_struct_time_to_dt(entry.published_parsed), entry.title, entry.link, entry_tags))\r\n    return lst\r\n\r\ndef filter_entries_by_tag(search, entry):\r\n    \"\"\"Check if search matches any tags as stored in the Entry namedtuple\r\n       (case insensitive, only whole, not partial string matches).\r\n       Returns bool: True if match, False if not.\r\n       Supported searches:\r\n       1. If & in search do AND match,\r\n          e.g. flask&api should match entries with both tags\r\n       2. Elif | in search do an OR match,\r\n          e.g. flask|django should match entries with either tag\r\n       3. Else: match if search is in tags\r\n    \"\"\"\r\n    if '&' in search:\r\n        words = search.split('&')\r\n        return all(filter_entries_by_tag(word,entry) for word in words)\r\n    elif '|' in search:\r\n        words = search.split('|')\r\n        return any(filter_entries_by_tag(word,entry) for word in words)\r\n    else:\r\n        return any(search == tag for tag in entry.tags)\r\n        \r\n\r\ndef main():\r\n    \"\"\"Entry point to the program\r\n       1. Call get_feed_entries and store them in entries\r\n       2. Initiate an infinite loop\r\n       3. Ask user for a search term:\r\n          - if enter was hit (empty string), print 'Please provide a search term'\r\n          - if 'q' was entered, print 'Bye' and exit/break the infinite loop\r\n       4. Filter/match the entries (see filter_entries_by_tag docstring)\r\n       5. Print the title of each match ordered by date ascending\r\n       6. Secondly, print the number of matches: 'n entries matched'\r\n          (use entry if only 1 match)\r\n    \"\"\"\r\n    pass\r\n\r\n# pprint(get_feed_entries())\r\n    \r\nif __name__ == '__main__':\r\n    main()",
            "date": "2022-12-12 14:57:04.344673+00:00",
            "passed": false
        },
        {
            "bite": "Bite 200. \ud83e\udd73 Minecraft Enchantable Items",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup as Soup\r\nimport re\r\nfrom pprint import pprint\r\n\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nHTML_FILE = TMP / \"enchantment_list_pc.html\"\r\n\r\n# source:\r\n# https://www.digminecraft.com/lists/enchantment_list_pc.php\r\nURL = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n       \"minecraft-enchantment.html\")\r\n\r\n\r\nclass Enchantment:\r\n    \"\"\"Minecraft enchantment class\r\n    \r\n    Implements the following: \r\n        id_name, name, max_level, description, items\r\n    \"\"\"\r\n    \r\n    LEVEL={'I':1, 'II':2, 'III':3, 'IV':4 , 'V':5}\r\n    \r\n    def __init__(self, id_name, name, max_level, description, items = None):\r\n        \r\n        self.id_name = id_name  # Internal name of the enchantment\r\n        self.name = name  # User friendly name of the enchantment\r\n        self.max_level = max_level  # Enchantment level. Original is in Roman numerals; they need to be converted to integers\r\n        self.description = description  # Summary of what the enchantment does\r\n        self.items = items or [] # List of item names that are typically enchanted with this enchantment.\r\n\r\n    def __repr__(self):\r\n        return f'{self.name.title()} ({self.max_level}): {self.description}'\r\n\r\nclass Item:\r\n    \"\"\"Minecraft enchantable item class\r\n    \r\n    Implements the following: \r\n        name, enchantments\r\n    \"\"\"\r\n\r\n    def __init__(self, name, enchantments = None):\r\n        \r\n        self.name = name\r\n        self.enchantments = enchantments or []\r\n        \r\n    def __repr__(self):\r\n        result= f'{self.name.title()}: \\n'\r\n        for enchantment in sorted(self.enchantments,key=lambda x:x.id_name):\r\n            result+=f'  [{enchantment.max_level}] {enchantment.id_name}\\n'\r\n        return result\r\n\r\n\r\ndef _get_items(string):\r\n    \r\n    filename=string.split('/')[-1].split('.')[0]\r\n    # replace fishing_rod fishing-rod\r\n    filename=filename.replace('fishing_rod', 'fishing-rod')\r\n    items_raw=filename.split('_')\r\n    items = [item for item in items_raw if item.lower() not in ['enchanted','iron', 'sm']]\r\n    return list(map(lambda x: x.replace('fishing-rod','fishing_rod'),items))\r\n\r\ndef generate_enchantments(soup):\r\n    \"\"\"Generates a dictionary of Enchantment objects\r\n    \r\n    With the key being the id_name of the enchantment.\r\n    \"\"\"\r\n    table = soup.find('table',{'id':'minecraft_items'})\r\n    rows = table.find_all('tr')\r\n    enchantments={}\r\n    for row in rows[1:]:\r\n        # print(row)\r\n        cols = row.find_all('td')\r\n        id_name = cols[0].em.text\r\n        # id_name = re.search('(?<=/enchantments/)[A-Za-z_]+(?=\\.php)',id_name_raw).group(0)\r\n        # print(id_name_raw, id_name)\r\n        name = cols[0].a.text\r\n        max_level = Enchantment.LEVEL[cols[1].text.upper()] \r\n        description = cols[2].text\r\n        items = _get_items(cols[4].find('img',{'class':'img-rounded'})['data-src'])\r\n        enchantments[id_name]=Enchantment(id_name, name, max_level, description,items)\r\n    return enchantments\r\n\r\n\r\ndef _get_item_name(item_id):\r\n    return \" \".join(item_id.split('_')).title()\r\n\r\n\r\ndef generate_items(data):\r\n    \"\"\"Generates a dictionary of Item objects\r\n    \r\n    With the key being the item name.\r\n    \"\"\"\r\n    items_dict= {}\r\n    \r\n    for enchantment in data.values():\r\n        for item_id in enchantment.items:\r\n            #create Item object with this enchantment or append enchantment if Item exists\r\n            if item_id in items_dict:\r\n                items_dict[item_id].enchantments.append(enchantment)\r\n            else:\r\n                items_dict[item_id] = Item(_get_item_name(item_id),[enchantment])\r\n    return items_dict\r\n    \r\n\r\n\r\ndef get_soup(file=HTML_FILE):\r\n    \"\"\"Retrieves/takes source HTML and returns a BeautifulSoup object\"\"\"\r\n    if isinstance(file, Path):\r\n        if not file.is_file():\r\n            urlretrieve(URL, file)\r\n\r\n        with file.open() as html_source:\r\n            soup = Soup(html_source, \"html.parser\")\r\n    else:\r\n        soup = Soup(file, \"html.parser\")\r\n\r\n    return soup\r\n\r\n\r\ndef main():\r\n    \"\"\"This function is here to help you test your final code.\r\n    \r\n    Once complete, the print out should match what's at the bottom of this file\"\"\"\r\n    soup = get_soup()\r\n    enchantment_data = generate_enchantments(soup)\r\n    print(enchantment_data)\r\n    minecraft_items = generate_items(enchantment_data)\r\n    for item in minecraft_items:\r\n        print(minecraft_items[item], \"\\n\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n    \r\n    mock_html = \"\"\"\r\n<table id=\"minecraft_items\" class=\"std_table\">\r\n<tr>\r\n<th data-search=\"1\" width=\"175\">Enchantment<br>(<em>Minecraft ID Name</em>)</th>\r\n<th data-search=\"1\">Max Level</th>\r\n<th class=\"hidden-xs\">Description</th>\r\n<th data-search=\"1\"><span class=\"hidden-xs\">Minecraft </span>ID</th>\r\n<th class=\"hidden-xs\">Items</th>\r\n<th>Version</th>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/aqua_affinity.php\">Aqua Affinity</a><br>(<em>aqua_<wbr>affinity</em>)</td>\r\n<td>I</td>\r\n<td class=\"hidden-xs\">Speeds up how fast you can mine blocks underwater</td>\r\n<td>6</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/armor_recipes/images/enchanted_iron_helmet.png\" alt=\"aqua affinity\" width=\"40\" height=\"40\"></td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/bane_of_arthropods.php\">Bane of Arthropods</a><br>(<em>bane_<wbr>of_<wbr>arthropods</em>)</td>\r\n<td>V</td>\r\n<td class=\"hidden-xs\">Increases attack damage against arthropods</td>\r\n<td>18</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/enchantments/images/sword_axe_sm.png\" alt=\"bane of arthropods\" width=\"40\" height=\"40\"></td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/blast_protection.php\">Blast Protection</a><br>(<em>blast_<wbr>protection</em>)</td>\r\n<td>IV</td>\r\n<td class=\"hidden-xs\">Reduces blast and explosion damage</td>\r\n<td>3</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/enchantments/images/armor_sm.png\" alt=\"blast protection\" width=\"40\" height=\"40\"></td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/channeling.php\">Channeling</a><br>(<em>channeling</em>)</td>\r\n<td>I</td>\r\n<td class=\"hidden-xs\">Summons a lightning bolt at a targeted mob when enchanted item is thrown (targeted mob must be standing in raining)</td>\r\n<td>68</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/weapon_recipes/images/enchanted_trident.png\" alt=\"channeling\" width=\"40\" height=\"40\"></td>\r\n<td>1.13</td>\r\n</tr>\r\n</table>\r\n\"\"\"\r\n    pprint(generate_enchantments(get_soup(mock_html)))\r\n    \r\n    \r\n\"\"\"\r\nArmor: \r\n  [1] binding_curse\r\n  [4] blast_protection\r\n  [4] fire_protection\r\n  [4] projectile_protection\r\n  [4] protection\r\n  [3] thorns \r\n\r\nAxe: \r\n  [5] bane_of_arthropods\r\n  [5] efficiency\r\n  [3] fortune\r\n  [5] sharpness\r\n  [1] silk_touch\r\n  [5] smite \r\n\r\nBoots: \r\n  [3] depth_strider\r\n  [4] feather_falling\r\n  [2] frost_walker \r\n\r\nBow: \r\n  [1] flame\r\n  [1] infinity\r\n  [5] power\r\n  [2] punch \r\n\r\nChestplate: \r\n  [1] mending\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nCrossbow: \r\n  [1] multishot\r\n  [4] piercing\r\n  [3] quick_charge \r\n\r\nFishing Rod: \r\n  [3] luck_of_the_sea\r\n  [3] lure\r\n  [1] mending\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nHelmet: \r\n  [1] aqua_affinity\r\n  [3] respiration \r\n\r\nPickaxe: \r\n  [5] efficiency\r\n  [3] fortune\r\n  [1] mending\r\n  [1] silk_touch\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nShovel: \r\n  [5] efficiency\r\n  [3] fortune\r\n  [1] silk_touch \r\n\r\nSword: \r\n  [5] bane_of_arthropods\r\n  [2] fire_aspect\r\n  [2] knockback\r\n  [3] looting\r\n  [1] mending\r\n  [5] sharpness\r\n  [5] smite\r\n  [3] sweeping\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nTrident: \r\n  [1] channeling\r\n  [5] impaling\r\n  [3] loyalty\r\n  [3] riptide\r\n\"\"\"\r\n\r\n\r\n",
            "date": "2022-12-11 22:54:08.114418+00:00",
            "passed": true
        },
        {
            "bite": "Bite 200. \ud83e\udd73 Minecraft Enchantable Items",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup as Soup\r\nimport re\r\nfrom pprint import pprint\r\n\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nHTML_FILE = TMP / \"enchantment_list_pc.html\"\r\n\r\n# source:\r\n# https://www.digminecraft.com/lists/enchantment_list_pc.php\r\nURL = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n       \"minecraft-enchantment.html\")\r\n\r\n\r\nclass Enchantment:\r\n    \"\"\"Minecraft enchantment class\r\n    \r\n    Implements the following: \r\n        id_name, name, max_level, description, items\r\n    \"\"\"\r\n    \r\n    LEVEL={'I':1, 'II':2, 'III':3, 'IV':4 , 'V':5}\r\n    \r\n    def __init__(self, id_name, name, max_level, description, items = None):\r\n        \r\n        self.id_name = id_name  # Internal name of the enchantment\r\n        self.name = name  # User friendly name of the enchantment\r\n        self.max_level = max_level  # Enchantment level. Original is in Roman numerals; they need to be converted to integers\r\n        self.description = description  # Summary of what the enchantment does\r\n        self.items = items or [] # List of item names that are typically enchanted with this enchantment.\r\n\r\n    def __repr__(self):\r\n        return f'{self.name.title()} ({self.max_level}): {self.description}'\r\n\r\nclass Item:\r\n    \"\"\"Minecraft enchantable item class\r\n    \r\n    Implements the following: \r\n        name, enchantments\r\n    \"\"\"\r\n\r\n    def __init__(self, name, enchantments = None):\r\n        \r\n        self.name = name\r\n        self.enchantments = enchantments or []\r\n        \r\n    def __repr__(self):\r\n        result= f'{self.name.title()}: \\n'\r\n        for enchantment in self.enchantments:\r\n            result+=f'  [{enchantment.max_level}] {enchantment.id_name}\\n'\r\n        return result\r\n\r\n\r\ndef _get_items(string):\r\n    \r\n    filename=string.split('/')[-1].split('.')[0]\r\n    # replace fishing_rod fishing-rod\r\n    filename=filename.replace('fishing_rod', 'fishing-rod')\r\n    items_raw=filename.split('_')\r\n    items = [item for item in items_raw if item.lower() not in ['enchanted','iron', 'sm']]\r\n    return list(map(lambda x: x.replace('fishing-rod','fishing_rod'),items))\r\n\r\ndef generate_enchantments(soup):\r\n    \"\"\"Generates a dictionary of Enchantment objects\r\n    \r\n    With the key being the id_name of the enchantment.\r\n    \"\"\"\r\n    table = soup.find('table',{'id':'minecraft_items'})\r\n    rows = table.find_all('tr')\r\n    enchantments={}\r\n    for row in rows[1:]:\r\n        # print(row)\r\n        cols = row.find_all('td')\r\n        id_name = cols[0].em.text\r\n        # id_name = re.search('(?<=/enchantments/)[A-Za-z_]+(?=\\.php)',id_name_raw).group(0)\r\n        # print(id_name_raw, id_name)\r\n        name = cols[0].a.text\r\n        max_level = Enchantment.LEVEL[cols[1].text.upper()] \r\n        description = cols[2].text\r\n        items = _get_items(cols[4].find('img',{'class':'img-rounded'})['data-src'])\r\n        enchantments[id_name]=Enchantment(id_name, name, max_level, description,items)\r\n    return enchantments\r\n\r\n\r\ndef _get_item_name(item_id):\r\n    return \" \".join(item_id.split('_')).title()\r\n\r\n\r\ndef generate_items(data):\r\n    \"\"\"Generates a dictionary of Item objects\r\n    \r\n    With the key being the item name.\r\n    \"\"\"\r\n    items_dict= {}\r\n    \r\n    for enchantment in data.values():\r\n        for item_id in enchantment.items:\r\n            #create Item object with this enchantment or append enchantment if Item exists\r\n            if item_id in items_dict:\r\n                items_dict[item_id].enchantments.append(enchantment)\r\n            else:\r\n                items_dict[item_id] = Item(_get_item_name(item_id),[enchantment])\r\n    return items_dict\r\n    \r\n\r\n\r\ndef get_soup(file=HTML_FILE):\r\n    \"\"\"Retrieves/takes source HTML and returns a BeautifulSoup object\"\"\"\r\n    if isinstance(file, Path):\r\n        if not file.is_file():\r\n            urlretrieve(URL, file)\r\n\r\n        with file.open() as html_source:\r\n            soup = Soup(html_source, \"html.parser\")\r\n    else:\r\n        soup = Soup(file, \"html.parser\")\r\n\r\n    return soup\r\n\r\n\r\ndef main():\r\n    \"\"\"This function is here to help you test your final code.\r\n    \r\n    Once complete, the print out should match what's at the bottom of this file\"\"\"\r\n    soup = get_soup()\r\n    enchantment_data = generate_enchantments(soup)\r\n    print(enchantment_data)\r\n    minecraft_items = generate_items(enchantment_data)\r\n    for item in minecraft_items:\r\n        print(minecraft_items[item], \"\\n\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n    \r\n    mock_html = \"\"\"\r\n<table id=\"minecraft_items\" class=\"std_table\">\r\n<tr>\r\n<th data-search=\"1\" width=\"175\">Enchantment<br>(<em>Minecraft ID Name</em>)</th>\r\n<th data-search=\"1\">Max Level</th>\r\n<th class=\"hidden-xs\">Description</th>\r\n<th data-search=\"1\"><span class=\"hidden-xs\">Minecraft </span>ID</th>\r\n<th class=\"hidden-xs\">Items</th>\r\n<th>Version</th>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/aqua_affinity.php\">Aqua Affinity</a><br>(<em>aqua_<wbr>affinity</em>)</td>\r\n<td>I</td>\r\n<td class=\"hidden-xs\">Speeds up how fast you can mine blocks underwater</td>\r\n<td>6</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/armor_recipes/images/enchanted_iron_helmet.png\" alt=\"aqua affinity\" width=\"40\" height=\"40\"></td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/bane_of_arthropods.php\">Bane of Arthropods</a><br>(<em>bane_<wbr>of_<wbr>arthropods</em>)</td>\r\n<td>V</td>\r\n<td class=\"hidden-xs\">Increases attack damage against arthropods</td>\r\n<td>18</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/enchantments/images/sword_axe_sm.png\" alt=\"bane of arthropods\" width=\"40\" height=\"40\"></td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/blast_protection.php\">Blast Protection</a><br>(<em>blast_<wbr>protection</em>)</td>\r\n<td>IV</td>\r\n<td class=\"hidden-xs\">Reduces blast and explosion damage</td>\r\n<td>3</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/enchantments/images/armor_sm.png\" alt=\"blast protection\" width=\"40\" height=\"40\"></td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/channeling.php\">Channeling</a><br>(<em>channeling</em>)</td>\r\n<td>I</td>\r\n<td class=\"hidden-xs\">Summons a lightning bolt at a targeted mob when enchanted item is thrown (targeted mob must be standing in raining)</td>\r\n<td>68</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/weapon_recipes/images/enchanted_trident.png\" alt=\"channeling\" width=\"40\" height=\"40\"></td>\r\n<td>1.13</td>\r\n</tr>\r\n</table>\r\n\"\"\"\r\n    pprint(generate_enchantments(get_soup(mock_html)))\r\n    \r\n    \r\n\"\"\"\r\nArmor: \r\n  [1] binding_curse\r\n  [4] blast_protection\r\n  [4] fire_protection\r\n  [4] projectile_protection\r\n  [4] protection\r\n  [3] thorns \r\n\r\nAxe: \r\n  [5] bane_of_arthropods\r\n  [5] efficiency\r\n  [3] fortune\r\n  [5] sharpness\r\n  [1] silk_touch\r\n  [5] smite \r\n\r\nBoots: \r\n  [3] depth_strider\r\n  [4] feather_falling\r\n  [2] frost_walker \r\n\r\nBow: \r\n  [1] flame\r\n  [1] infinity\r\n  [5] power\r\n  [2] punch \r\n\r\nChestplate: \r\n  [1] mending\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nCrossbow: \r\n  [1] multishot\r\n  [4] piercing\r\n  [3] quick_charge \r\n\r\nFishing Rod: \r\n  [3] luck_of_the_sea\r\n  [3] lure\r\n  [1] mending\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nHelmet: \r\n  [1] aqua_affinity\r\n  [3] respiration \r\n\r\nPickaxe: \r\n  [5] efficiency\r\n  [3] fortune\r\n  [1] mending\r\n  [1] silk_touch\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nShovel: \r\n  [5] efficiency\r\n  [3] fortune\r\n  [1] silk_touch \r\n\r\nSword: \r\n  [5] bane_of_arthropods\r\n  [2] fire_aspect\r\n  [2] knockback\r\n  [3] looting\r\n  [1] mending\r\n  [5] sharpness\r\n  [5] smite\r\n  [3] sweeping\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nTrident: \r\n  [1] channeling\r\n  [5] impaling\r\n  [3] loyalty\r\n  [3] riptide\r\n\"\"\"\r\n\r\n\r\n",
            "date": "2022-12-11 22:52:24.054647+00:00",
            "passed": false
        },
        {
            "bite": "Bite 200. \ud83e\udd73 Minecraft Enchantable Items",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup as Soup\r\nimport re\r\nfrom pprint import pprint\r\n\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nHTML_FILE = TMP / \"enchantment_list_pc.html\"\r\n\r\n# source:\r\n# https://www.digminecraft.com/lists/enchantment_list_pc.php\r\nURL = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n       \"minecraft-enchantment.html\")\r\n\r\n\r\nclass Enchantment:\r\n    \"\"\"Minecraft enchantment class\r\n    \r\n    Implements the following: \r\n        id_name, name, max_level, description, items\r\n    \"\"\"\r\n    \r\n    LEVEL={'I':1, 'II':2, 'III':3, 'IV':4 , 'V':5}\r\n    \r\n    def __init__(self, id_name, name, max_level, description, items = None):\r\n        \r\n        self.id_name = id_name  # Internal name of the enchantment\r\n        self.name = name  # User friendly name of the enchantment\r\n        self.max_level = max_level  # Enchantment level. Original is in Roman numerals; they need to be converted to integers\r\n        self.description = description  # Summary of what the enchantment does\r\n        self.items = items or [] # List of item names that are typically enchanted with this enchantment.\r\n\r\n    def __repr__(self):\r\n        return f'{self.name.title()} ({self.max_level}): {self.description}'\r\n\r\nclass Item:\r\n    \"\"\"Minecraft enchantable item class\r\n    \r\n    Implements the following: \r\n        name, enchantments\r\n    \"\"\"\r\n\r\n    def __init__(self, name, enchantments = None):\r\n        \r\n        self.name = name\r\n        self.enchantments = enchantments or []\r\n        \r\n    def __repr__(self):\r\n        result= f'{self.name.title()}: \\n'\r\n        for enchantment in self.enchantments:\r\n            result+=f'  [{enchantment.max_level}] {enchantment.id_name}\\n'\r\n        return result\r\n\r\n\r\ndef _get_items(string):\r\n    \r\n    filename=string.split('/')[-1].split('.')[0]\r\n    # replace fishing_rod fishing-rod\r\n    filename=filename.replace('fishing_rod', 'fishing-rod')\r\n    items_raw=filename.split('_')\r\n    items = [item for item in items_raw if item.lower() not in ['enchanted','iron', 'sm']]\r\n    return list(map(lambda x: x.replace('fishing-rod','fishing_rod'),items))\r\n\r\ndef generate_enchantments(soup):\r\n    \"\"\"Generates a dictionary of Enchantment objects\r\n    \r\n    With the key being the id_name of the enchantment.\r\n    \"\"\"\r\n    table = soup.find('table',{'id':'minecraft_items'})\r\n    rows = table.find_all('tr')\r\n    enchantments={}\r\n    for row in rows[1:]:\r\n        # print(row)\r\n        cols = row.find_all('td')\r\n        id_name_raw = cols[0].a['href']\r\n        id_name = re.search('(?<=/enchantments/)[A-Za-z_]+(?=\\.php)',id_name_raw).group(0)\r\n        # print(id_name_raw, id_name)\r\n        name = cols[0].a.text\r\n        max_level = Enchantment.LEVEL[cols[1].text.upper()] \r\n        description = cols[2].text\r\n        items = _get_items(cols[4].find('img',{'class':'img-rounded'})['data-src'])\r\n        enchantments[id_name]=Enchantment(id_name, name, max_level, description,items)\r\n    return enchantments\r\n\r\n\r\ndef _get_item_name(item_id):\r\n    return \" \".join(item_id.split('_')).title()\r\n\r\n\r\ndef generate_items(data):\r\n    \"\"\"Generates a dictionary of Item objects\r\n    \r\n    With the key being the item name.\r\n    \"\"\"\r\n    items_dict= {}\r\n    \r\n    for enchantment in data.values():\r\n        for item_id in enchantment.items:\r\n            #create Item object with this enchantment or append enchantment if Item exists\r\n            if item_id in items_dict:\r\n                items_dict[item_id].enchantments.append(enchantment)\r\n            else:\r\n                items_dict[item_id] = Item(_get_item_name(item_id),[enchantment])\r\n    return items_dict\r\n    \r\n\r\n\r\ndef get_soup(file=HTML_FILE):\r\n    \"\"\"Retrieves/takes source HTML and returns a BeautifulSoup object\"\"\"\r\n    if isinstance(file, Path):\r\n        if not file.is_file():\r\n            urlretrieve(URL, file)\r\n\r\n        with file.open() as html_source:\r\n            soup = Soup(html_source, \"html.parser\")\r\n    else:\r\n        soup = Soup(file, \"html.parser\")\r\n\r\n    return soup\r\n\r\n\r\ndef main():\r\n    \"\"\"This function is here to help you test your final code.\r\n    \r\n    Once complete, the print out should match what's at the bottom of this file\"\"\"\r\n    soup = get_soup()\r\n    enchantment_data = generate_enchantments(soup)\r\n    print(enchantment_data)\r\n    minecraft_items = generate_items(enchantment_data)\r\n    for item in minecraft_items:\r\n        print(minecraft_items[item], \"\\n\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n    \r\n    mock_html = \"\"\"\r\n<table id=\"minecraft_items\" class=\"std_table\">\r\n<tr>\r\n<th data-search=\"1\" width=\"175\">Enchantment<br>(<em>Minecraft ID Name</em>)</th>\r\n<th data-search=\"1\">Max Level</th>\r\n<th class=\"hidden-xs\">Description</th>\r\n<th data-search=\"1\"><span class=\"hidden-xs\">Minecraft </span>ID</th>\r\n<th class=\"hidden-xs\">Items</th>\r\n<th>Version</th>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/aqua_affinity.php\">Aqua Affinity</a><br>(<em>aqua_<wbr>affinity</em>)</td>\r\n<td>I</td>\r\n<td class=\"hidden-xs\">Speeds up how fast you can mine blocks underwater</td>\r\n<td>6</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/armor_recipes/images/enchanted_iron_helmet.png\" alt=\"aqua affinity\" width=\"40\" height=\"40\"></td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/bane_of_arthropods.php\">Bane of Arthropods</a><br>(<em>bane_<wbr>of_<wbr>arthropods</em>)</td>\r\n<td>V</td>\r\n<td class=\"hidden-xs\">Increases attack damage against arthropods</td>\r\n<td>18</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/enchantments/images/sword_axe_sm.png\" alt=\"bane of arthropods\" width=\"40\" height=\"40\"></td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/blast_protection.php\">Blast Protection</a><br>(<em>blast_<wbr>protection</em>)</td>\r\n<td>IV</td>\r\n<td class=\"hidden-xs\">Reduces blast and explosion damage</td>\r\n<td>3</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/enchantments/images/armor_sm.png\" alt=\"blast protection\" width=\"40\" height=\"40\"></td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/channeling.php\">Channeling</a><br>(<em>channeling</em>)</td>\r\n<td>I</td>\r\n<td class=\"hidden-xs\">Summons a lightning bolt at a targeted mob when enchanted item is thrown (targeted mob must be standing in raining)</td>\r\n<td>68</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/weapon_recipes/images/enchanted_trident.png\" alt=\"channeling\" width=\"40\" height=\"40\"></td>\r\n<td>1.13</td>\r\n</tr>\r\n</table>\r\n\"\"\"\r\n    pprint(generate_enchantments(get_soup(mock_html)))\r\n    \r\n    \r\n\"\"\"\r\nArmor: \r\n  [1] binding_curse\r\n  [4] blast_protection\r\n  [4] fire_protection\r\n  [4] projectile_protection\r\n  [4] protection\r\n  [3] thorns \r\n\r\nAxe: \r\n  [5] bane_of_arthropods\r\n  [5] efficiency\r\n  [3] fortune\r\n  [5] sharpness\r\n  [1] silk_touch\r\n  [5] smite \r\n\r\nBoots: \r\n  [3] depth_strider\r\n  [4] feather_falling\r\n  [2] frost_walker \r\n\r\nBow: \r\n  [1] flame\r\n  [1] infinity\r\n  [5] power\r\n  [2] punch \r\n\r\nChestplate: \r\n  [1] mending\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nCrossbow: \r\n  [1] multishot\r\n  [4] piercing\r\n  [3] quick_charge \r\n\r\nFishing Rod: \r\n  [3] luck_of_the_sea\r\n  [3] lure\r\n  [1] mending\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nHelmet: \r\n  [1] aqua_affinity\r\n  [3] respiration \r\n\r\nPickaxe: \r\n  [5] efficiency\r\n  [3] fortune\r\n  [1] mending\r\n  [1] silk_touch\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nShovel: \r\n  [5] efficiency\r\n  [3] fortune\r\n  [1] silk_touch \r\n\r\nSword: \r\n  [5] bane_of_arthropods\r\n  [2] fire_aspect\r\n  [2] knockback\r\n  [3] looting\r\n  [1] mending\r\n  [5] sharpness\r\n  [5] smite\r\n  [3] sweeping\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nTrident: \r\n  [1] channeling\r\n  [5] impaling\r\n  [3] loyalty\r\n  [3] riptide\r\n\"\"\"\r\n\r\n\r\n",
            "date": "2022-12-11 22:41:12.209049+00:00",
            "passed": false
        },
        {
            "bite": "Bite 200. \ud83e\udd73 Minecraft Enchantable Items",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup as Soup\r\nimport re\r\nfrom pprint import pprint\r\n\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nHTML_FILE = TMP / \"enchantment_list_pc.html\"\r\n\r\n# source:\r\n# https://www.digminecraft.com/lists/enchantment_list_pc.php\r\nURL = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n       \"minecraft-enchantment.html\")\r\n\r\n\r\nclass Enchantment:\r\n    \"\"\"Minecraft enchantment class\r\n    \r\n    Implements the following: \r\n        id_name, name, max_level, description, items\r\n    \"\"\"\r\n    \r\n    LEVEL={'I':1, 'II':2, 'III':3, 'IV':4 , 'V':5}\r\n    \r\n    def __init__(self, id_name, name, max_level, description, items = None):\r\n        \r\n        self.id_name = id_name  # Internal name of the enchantment\r\n        self.name = name  # User friendly name of the enchantment\r\n        self.max_level = max_level  # Enchantment level. Original is in Roman numerals; they need to be converted to integers\r\n        self.description = description  # Summary of what the enchantment does\r\n        self.items = items or [] # List of item names that are typically enchanted with this enchantment.\r\n\r\n    def __repr__(self):\r\n        return f'{self.name.title()} ({self.max_level}): {self.description}'\r\n\r\nclass Item:\r\n    \"\"\"Minecraft enchantable item class\r\n    \r\n    Implements the following: \r\n        name, enchantments\r\n    \"\"\"\r\n\r\n    def __init__(self, name, enchantments = None):\r\n        \r\n        self.name = name\r\n        self.enchantments = enchantments or []\r\n        \r\n    def __repr__(self):\r\n        result= f'{self.name.title()}: \\n'\r\n        for enchantment in self.enchantments:\r\n            result+=f'  [{enchantment.max_level}] {enchantment.id_name}\\n'\r\n        return result\r\n\r\n\r\ndef _get_items(string):\r\n    \r\n    filename=string.split('/')[-1].split('.')[0]\r\n    # replace fishing_rod fishing-rod\r\n    filename=filename.replace('fishing_rod', 'fishing-rod')\r\n    items_raw=filename.split('_')\r\n    items = [item for item in items_raw if item.lower() not in ['enchanted','iron', 'sm']]\r\n    return list(map(lambda x: x.replace('fishing-rod','fishing_rod'),items))\r\n\r\ndef generate_enchantments(soup):\r\n    \"\"\"Generates a dictionary of Enchantment objects\r\n    \r\n    With the key being the id_name of the enchantment.\r\n    \"\"\"\r\n    table = soup.find('table',{'id':'minecraft_items'})\r\n    rows = table.find_all('tr')\r\n    enchantments={}\r\n    for row in rows[1:]:\r\n        # print(row)\r\n        cols = row.find_all('td')\r\n        id_name_raw = cols[0].a['href']\r\n        id_name = re.search('(?<=/enchantments/)[A-Za-z_]+(?=\\.php)',id_name_raw).group(0)\r\n        # print(id_name_raw, id_name)\r\n        name = cols[0].a.text\r\n        max_level = Enchantment.LEVEL[cols[1].text.upper()] \r\n        description = cols[2].text\r\n        items = _get_items(cols[4].find('img',{'class':'img-rounded'})['data-src'])\r\n        enchantments[id_name]=Enchantment(id_name, name, max_level, description,items)\r\n    return enchantments\r\n\r\n\r\ndef _get_item_name(item_id):\r\n    return \" \".join(item_id.split('_')).title()\r\n\r\n\r\ndef generate_items(data):\r\n    \"\"\"Generates a dictionary of Item objects\r\n    \r\n    With the key being the item name.\r\n    \"\"\"\r\n    items_dict= {}\r\n    \r\n    for enchantment in data.values():\r\n        for item_id in enchantment.items:\r\n            #create Item object with this enchantment or append enchantment if Item exists\r\n            if item_id in items_dict:\r\n                items_dict[item_id].enchantments.append(enchantment)\r\n            else:\r\n                items_dict[item_id] = Item(_get_item_name(item_id),[enchantment])\r\n    \r\n    \r\n\r\n\r\ndef get_soup(file=HTML_FILE):\r\n    \"\"\"Retrieves/takes source HTML and returns a BeautifulSoup object\"\"\"\r\n    if isinstance(file, Path):\r\n        if not file.is_file():\r\n            urlretrieve(URL, file)\r\n\r\n        with file.open() as html_source:\r\n            soup = Soup(html_source, \"html.parser\")\r\n    else:\r\n        soup = Soup(file, \"html.parser\")\r\n\r\n    return soup\r\n\r\n\r\ndef main():\r\n    \"\"\"This function is here to help you test your final code.\r\n    \r\n    Once complete, the print out should match what's at the bottom of this file\"\"\"\r\n    soup = get_soup()\r\n    enchantment_data = generate_enchantments(soup)\r\n    print(enchantment_data)\r\n    minecraft_items = generate_items(enchantment_data)\r\n    for item in minecraft_items:\r\n        print(minecraft_items[item], \"\\n\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n    \r\n    mock_html = \"\"\"\r\n<table id=\"minecraft_items\" class=\"std_table\">\r\n<tr>\r\n<th data-search=\"1\" width=\"175\">Enchantment<br>(<em>Minecraft ID Name</em>)</th>\r\n<th data-search=\"1\">Max Level</th>\r\n<th class=\"hidden-xs\">Description</th>\r\n<th data-search=\"1\"><span class=\"hidden-xs\">Minecraft </span>ID</th>\r\n<th class=\"hidden-xs\">Items</th>\r\n<th>Version</th>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/aqua_affinity.php\">Aqua Affinity</a><br>(<em>aqua_<wbr>affinity</em>)</td>\r\n<td>I</td>\r\n<td class=\"hidden-xs\">Speeds up how fast you can mine blocks underwater</td>\r\n<td>6</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/armor_recipes/images/enchanted_iron_helmet.png\" alt=\"aqua affinity\" width=\"40\" height=\"40\"></td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/bane_of_arthropods.php\">Bane of Arthropods</a><br>(<em>bane_<wbr>of_<wbr>arthropods</em>)</td>\r\n<td>V</td>\r\n<td class=\"hidden-xs\">Increases attack damage against arthropods</td>\r\n<td>18</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/enchantments/images/sword_axe_sm.png\" alt=\"bane of arthropods\" width=\"40\" height=\"40\"></td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/blast_protection.php\">Blast Protection</a><br>(<em>blast_<wbr>protection</em>)</td>\r\n<td>IV</td>\r\n<td class=\"hidden-xs\">Reduces blast and explosion damage</td>\r\n<td>3</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/enchantments/images/armor_sm.png\" alt=\"blast protection\" width=\"40\" height=\"40\"></td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"/enchantments/channeling.php\">Channeling</a><br>(<em>channeling</em>)</td>\r\n<td>I</td>\r\n<td class=\"hidden-xs\">Summons a lightning bolt at a targeted mob when enchanted item is thrown (targeted mob must be standing in raining)</td>\r\n<td>68</td>\r\n<td class=\"hidden-xs\"><img class=\"img-rounded b-lazy\" src=\"/images/thumbnail_loading.gif\" data-src=\"/weapon_recipes/images/enchanted_trident.png\" alt=\"channeling\" width=\"40\" height=\"40\"></td>\r\n<td>1.13</td>\r\n</tr>\r\n</table>\r\n\"\"\"\r\n    pprint(generate_enchantments(get_soup(mock_html)))\r\n    \r\n    \r\n\"\"\"\r\nArmor: \r\n  [1] binding_curse\r\n  [4] blast_protection\r\n  [4] fire_protection\r\n  [4] projectile_protection\r\n  [4] protection\r\n  [3] thorns \r\n\r\nAxe: \r\n  [5] bane_of_arthropods\r\n  [5] efficiency\r\n  [3] fortune\r\n  [5] sharpness\r\n  [1] silk_touch\r\n  [5] smite \r\n\r\nBoots: \r\n  [3] depth_strider\r\n  [4] feather_falling\r\n  [2] frost_walker \r\n\r\nBow: \r\n  [1] flame\r\n  [1] infinity\r\n  [5] power\r\n  [2] punch \r\n\r\nChestplate: \r\n  [1] mending\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nCrossbow: \r\n  [1] multishot\r\n  [4] piercing\r\n  [3] quick_charge \r\n\r\nFishing Rod: \r\n  [3] luck_of_the_sea\r\n  [3] lure\r\n  [1] mending\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nHelmet: \r\n  [1] aqua_affinity\r\n  [3] respiration \r\n\r\nPickaxe: \r\n  [5] efficiency\r\n  [3] fortune\r\n  [1] mending\r\n  [1] silk_touch\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nShovel: \r\n  [5] efficiency\r\n  [3] fortune\r\n  [1] silk_touch \r\n\r\nSword: \r\n  [5] bane_of_arthropods\r\n  [2] fire_aspect\r\n  [2] knockback\r\n  [3] looting\r\n  [1] mending\r\n  [5] sharpness\r\n  [5] smite\r\n  [3] sweeping\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nTrident: \r\n  [1] channeling\r\n  [5] impaling\r\n  [3] loyalty\r\n  [3] riptide\r\n\"\"\"\r\n\r\n\r\n",
            "date": "2022-12-11 22:39:21.046858+00:00",
            "passed": false
        },
        {
            "bite": "Bite 200. \ud83e\udd73 Minecraft Enchantable Items",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup as Soup\r\nimport re\r\n\r\n\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nHTML_FILE = TMP / \"enchantment_list_pc.html\"\r\n\r\n# source:\r\n# https://www.digminecraft.com/lists/enchantment_list_pc.php\r\nURL = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n       \"minecraft-enchantment.html\")\r\n\r\n\r\nclass Enchantment:\r\n    \"\"\"Minecraft enchantment class\r\n    \r\n    Implements the following: \r\n        id_name, name, max_level, description, items\r\n    \"\"\"\r\n    \r\n    LEVEL={'I':1, 'II':2, 'III':3, 'IV':4 , 'V':5}\r\n    \r\n    def __init__(self, id_name, name, max_level, description, items = None):\r\n        \r\n        self.id_name = id_name  # Internal name of the enchantment\r\n        self.name = name  # User friendly name of the enchantment\r\n        self.max_level = max_level  # Enchantment level. Original is in Roman numerals; they need to be converted to integers\r\n        self.description = description  # Summary of what the enchantment does\r\n        self.items = items or [] # List of item names that are typically enchanted with this enchantment.\r\n\r\n    def __repr__(self):\r\n        return f'{self.name.title()} ({self.max_level}): {self.description}'\r\n\r\nclass Item:\r\n    \"\"\"Minecraft enchantable item class\r\n    \r\n    Implements the following: \r\n        name, enchantments\r\n    \"\"\"\r\n\r\n    def __init__(self, name, enchantments = None):\r\n        \r\n        self.name = name\r\n        self.enchantments = enchantments or []\r\n        \r\n    def __repr__(self):\r\n        result= f'{self.name.title()}: \\n'\r\n        for enchantment in self.enchantments:\r\n            result+=f'  [{enchantment.max_level}] {enchantment.id_name}\\n'\r\n        return result\r\n\r\n\r\ndef _get_items(string):\r\n    \r\n    filename=string.split('/')[-1].split('.')[0]\r\n    # replace fishing_rod fishing-rod\r\n    filename=filename.replace('fishing_rod', 'fishing-rod')\r\n    items_raw=filename.split('_')\r\n    items = [item for item in items_raw if item.lower() not in ['enchanted','iron', 'sm']]\r\n    return list(map(lambda x: x.replace('fishing-rod','fishing_rod'),items))\r\n\r\ndef generate_enchantments(soup):\r\n    \"\"\"Generates a dictionary of Enchantment objects\r\n    \r\n    With the key being the id_name of the enchantment.\r\n    \"\"\"\r\n    table = soup.find('table',{'id':'minecraft_items'})\r\n    rows = table.find_all('tr')\r\n    enchantments={}\r\n    for row in rows[1:]:\r\n        # print(row)\r\n        cols = row.find_all('td')\r\n        id_name_raw = cols[0].a['href']\r\n        id_name = re.search('(?<=/enchantments/)[A-Za-z_]+(?=\\.php)',id_name_raw).group(0)\r\n        # print(id_name_raw, id_name)\r\n        name = cols[0].a.text\r\n        max_level = Enchantment.LEVEL[cols[1].text.upper()] \r\n        description = cols[2].text\r\n        items = _get_items(cols[4].find('img',{'class':'img-rounded'})['data-src'])\r\n        enchantments[id_name]=Enchantment(id_name, name, max_level, description,items)\r\n    return enchantments\r\n\r\n\r\ndef _get_item_name(item_id):\r\n    return \" \".join(item_id.split('_')).title()\r\n\r\n\r\ndef generate_items(data):\r\n    \"\"\"Generates a dictionary of Item objects\r\n    \r\n    With the key being the item name.\r\n    \"\"\"\r\n    items_dict= {}\r\n    \r\n    for enchantment in data.values():\r\n        for item_id in enchantment.items:\r\n            #create Item object with this enchantment or append enchantment if Item exists\r\n            if item_id in items_dict:\r\n                items_dict[item_id].enchantments.append(enchantment)\r\n            else:\r\n                items_dict[item_id] = Item(_get_item_name(item_id),[enchantment])\r\n    \r\n    \r\n\r\n\r\ndef get_soup(file=HTML_FILE):\r\n    \"\"\"Retrieves/takes source HTML and returns a BeautifulSoup object\"\"\"\r\n    if isinstance(file, Path):\r\n        if not file.is_file():\r\n            urlretrieve(URL, file)\r\n\r\n        with file.open() as html_source:\r\n            soup = Soup(html_source, \"html.parser\")\r\n    else:\r\n        soup = Soup(file, \"html.parser\")\r\n\r\n    return soup\r\n\r\n\r\ndef main():\r\n    \"\"\"This function is here to help you test your final code.\r\n    \r\n    Once complete, the print out should match what's at the bottom of this file\"\"\"\r\n    soup = get_soup()\r\n    enchantment_data = generate_enchantments(soup)\r\n    print(enchantment_data)\r\n    minecraft_items = generate_items(enchantment_data)\r\n    for item in minecraft_items:\r\n        print(minecraft_items[item], \"\\n\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n\"\"\"\r\nArmor: \r\n  [1] binding_curse\r\n  [4] blast_protection\r\n  [4] fire_protection\r\n  [4] projectile_protection\r\n  [4] protection\r\n  [3] thorns \r\n\r\nAxe: \r\n  [5] bane_of_arthropods\r\n  [5] efficiency\r\n  [3] fortune\r\n  [5] sharpness\r\n  [1] silk_touch\r\n  [5] smite \r\n\r\nBoots: \r\n  [3] depth_strider\r\n  [4] feather_falling\r\n  [2] frost_walker \r\n\r\nBow: \r\n  [1] flame\r\n  [1] infinity\r\n  [5] power\r\n  [2] punch \r\n\r\nChestplate: \r\n  [1] mending\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nCrossbow: \r\n  [1] multishot\r\n  [4] piercing\r\n  [3] quick_charge \r\n\r\nFishing Rod: \r\n  [3] luck_of_the_sea\r\n  [3] lure\r\n  [1] mending\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nHelmet: \r\n  [1] aqua_affinity\r\n  [3] respiration \r\n\r\nPickaxe: \r\n  [5] efficiency\r\n  [3] fortune\r\n  [1] mending\r\n  [1] silk_touch\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nShovel: \r\n  [5] efficiency\r\n  [3] fortune\r\n  [1] silk_touch \r\n\r\nSword: \r\n  [5] bane_of_arthropods\r\n  [2] fire_aspect\r\n  [2] knockback\r\n  [3] looting\r\n  [1] mending\r\n  [5] sharpness\r\n  [5] smite\r\n  [3] sweeping\r\n  [3] unbreaking\r\n  [1] vanishing_curse \r\n\r\nTrident: \r\n  [1] channeling\r\n  [5] impaling\r\n  [3] loyalty\r\n  [3] riptide\r\n\"\"\"",
            "date": "2022-12-11 22:27:34.379878+00:00",
            "passed": false
        },
        {
            "bite": "Bite 226. Get top titles from news.python.sc",
            "code": "from collections import namedtuple\r\n\r\nfrom bs4 import BeautifulSoup\r\nimport requests\r\nimport re\r\n\r\n# feed = https://news.python.sc/, to get predictable results we cached\r\n# first two pages - use these:\r\n# https://bites-data.s3.us-east-2.amazonaws.com/news.python.sc/index.html\r\n# https://bites-data.s3.us-east-2.amazonaws.com/news.python.sc/index2.html\r\n\r\nEntry = namedtuple('Entry', 'title points comments')\r\n\r\n\r\ndef _create_soup_obj(url):\r\n    \"\"\"Need utf-8 to properly parse emojis\"\"\"\r\n    resp = requests.get(url)\r\n    resp.encoding = \"utf-8\"\r\n    return BeautifulSoup(resp.text, \"html.parser\")\r\n\r\n\r\ndef get_top_titles(url, top=5):\r\n    \"\"\"Parse the titles (class 'title') using the soup object.\r\n       Return a list of top (default = 5) titles ordered descending\r\n       by number of points and comments.\r\n    \"\"\"\r\n    soup = _create_soup_obj(url)\r\n\r\n    # your code ...\r\n    lst=[]\r\n    \r\n    titles_spans=soup.find_all('span',{'class':'title'})\r\n    points_spans=soup.find_all('span',{'class':'controls'})\r\n    comments_spans=soup.find_all('span',{'class':'naturaltime'})\r\n\r\n    for title,points,comments in zip(titles_spans,points_spans,comments_spans):\r\n        title=f\"{title.text.strip()}\"\r\n        points=int(re.search('[0-9]+',points.span.text)[0])\r\n        comments=int(re.search('[0-9]+',comments.span.a.text)[0])\r\n        entry=Entry(title,points,comments)\r\n        lst.append(entry)\r\n        \r\n    return sorted(lst,key=lambda x:x.points+x.comments, reverse=True)[:top]\r\n    \r\n    \r\nurl = 'https://bites-data.s3.us-east-2.amazonaws.com/news.python.sc/index.html'\r\nprint(get_top_titles(url))",
            "date": "2022-12-11 14:15:26.705322+00:00",
            "passed": true
        },
        {
            "bite": "Bite 226. Get top titles from news.python.sc",
            "code": "from collections import namedtuple\r\n\r\nfrom bs4 import BeautifulSoup\r\nimport requests\r\nimport re\r\n\r\n# feed = https://news.python.sc/, to get predictable results we cached\r\n# first two pages - use these:\r\n# https://bites-data.s3.us-east-2.amazonaws.com/news.python.sc/index.html\r\n# https://bites-data.s3.us-east-2.amazonaws.com/news.python.sc/index2.html\r\n\r\nEntry = namedtuple('Entry', 'title points comments')\r\n\r\n\r\ndef _create_soup_obj(url):\r\n    \"\"\"Need utf-8 to properly parse emojis\"\"\"\r\n    resp = requests.get(url)\r\n    resp.encoding = \"utf-8\"\r\n    return BeautifulSoup(resp.text, \"html.parser\")\r\n\r\n\r\ndef get_top_titles(url, top=5):\r\n    \"\"\"Parse the titles (class 'title') using the soup object.\r\n       Return a list of top (default = 5) titles ordered descending\r\n       by number of points and comments.\r\n    \"\"\"\r\n    soup = _create_soup_obj(url)\r\n\r\n    # your code ...\r\n    lst=[]\r\n    \r\n    titles_spans=soup.find_all('span',{'class':'title'})\r\n    points_spans=soup.find_all('span',{'class':'controls'})\r\n    comments_spans=soup.find_all('span',{'class':'naturaltime'})\r\n    # print(titles_spans,websites_spans,points_spans,comments_spans)\r\n\r\n    for title,points,comments in zip(titles_spans,points_spans,comments_spans):\r\n        title=f\"{title.text.strip()}\"\r\n        points=int(re.search('[0-9]+',points.span.text)[0])\r\n        comments=int(re.search('[0-9]+',comments.span.a.text)[0])\r\n        entry=Entry(title,points,comments)\r\n        print(entry)\r\n        lst.append(entry)\r\n        \r\n    return sorted(lst,key=lambda x:x.points+x.comments, reverse=True)[:top]\r\n    \r\n    \r\nurl = 'https://bites-data.s3.us-east-2.amazonaws.com/news.python.sc/index.html'\r\nprint(get_top_titles(url))",
            "date": "2022-12-11 14:14:46.370420+00:00",
            "passed": true
        },
        {
            "bite": "Bite 226. Get top titles from news.python.sc",
            "code": "from collections import namedtuple\r\n\r\nfrom bs4 import BeautifulSoup\r\nimport requests\r\nimport re\r\n\r\n# feed = https://news.python.sc/, to get predictable results we cached\r\n# first two pages - use these:\r\n# https://bites-data.s3.us-east-2.amazonaws.com/news.python.sc/index.html\r\n# https://bites-data.s3.us-east-2.amazonaws.com/news.python.sc/index2.html\r\n\r\nEntry = namedtuple('Entry', 'title points comments')\r\n\r\n\r\ndef _create_soup_obj(url):\r\n    \"\"\"Need utf-8 to properly parse emojis\"\"\"\r\n    resp = requests.get(url)\r\n    resp.encoding = \"utf-8\"\r\n    return BeautifulSoup(resp.text, \"html.parser\")\r\n\r\n\r\ndef get_top_titles(url, top=5):\r\n    \"\"\"Parse the titles (class 'title') using the soup object.\r\n       Return a list of top (default = 5) titles ordered descending\r\n       by number of points and comments.\r\n    \"\"\"\r\n    soup = _create_soup_obj(url)\r\n\r\n    # your code ...\r\n    lst=[]\r\n    \r\n    titles_spans=soup.find_all('span',{'class':'title'})\r\n    websites_spans=soup.find_all('span',{'class':'smaller'})\r\n    points_spans=soup.find_all('span',{'class':'controls'})\r\n    comments_spans=soup.find_all('span',{'class':'naturaltime'})\r\n    # print(titles_spans,websites_spans,points_spans,comments_spans)\r\n\r\n    for title,website,points,comments in zip(titles_spans,websites_spans,points_spans,comments_spans):\r\n        title=f\"{title.a.text} ({website.a.text})\"\r\n        points=int(re.search('[0-9]+',points.span.text)[0])\r\n        comments=int(re.search('[0-9]+',comments.span.a.text)[0])\r\n        entry=Entry(title,points,comments)\r\n        # print(entry)\r\n        lst.append(entry)\r\n        \r\n    return sorted(lst,key=lambda x:x.points+x.comments, reverse=True)[:top]\r\n    \r\n    \r\nurl = 'https://bites-data.s3.us-east-2.amazonaws.com/news.python.sc/index.html'\r\nprint(get_top_titles(url))",
            "date": "2022-12-11 14:05:22.175949+00:00",
            "passed": false
        },
        {
            "bite": "Bite 226. Get top titles from news.python.sc",
            "code": "from collections import namedtuple\r\n\r\nfrom bs4 import BeautifulSoup\r\nimport requests\r\nimport re\r\n\r\n# feed = https://news.python.sc/, to get predictable results we cached\r\n# first two pages - use these:\r\n# https://bites-data.s3.us-east-2.amazonaws.com/news.python.sc/index.html\r\n# https://bites-data.s3.us-east-2.amazonaws.com/news.python.sc/index2.html\r\n\r\nEntry = namedtuple('Entry', 'title points comments')\r\n\r\n\r\ndef _create_soup_obj(url):\r\n    \"\"\"Need utf-8 to properly parse emojis\"\"\"\r\n    resp = requests.get(url)\r\n    resp.encoding = \"utf-8\"\r\n    return BeautifulSoup(resp.text, \"html.parser\")\r\n\r\n\r\ndef get_top_titles(url, top=5):\r\n    \"\"\"Parse the titles (class 'title') using the soup object.\r\n       Return a list of top (default = 5) titles ordered descending\r\n       by number of points and comments.\r\n    \"\"\"\r\n    soup = _create_soup_obj(url)\r\n\r\n    # your code ...\r\n    lst=[]\r\n    \r\n    titles_spans=soup.find_all('span',{'class':'title'})\r\n    websites_spans=soup.find_all('span',{'class':'smaller'})\r\n    points_spans=soup.find_all('span',{'class':'controls'})\r\n    comments_spans=soup.find_all('span',{'class':'naturaltime'})\r\n    # print(titles_spans,websites_spans,points_spans,comments_spans)\r\n\r\n    for title,website,points,comments in zip(titles_spans,websites_spans,points_spans,comments_spans):\r\n        title=f\"{title.a.text} ({website.a.text})\"\r\n        points=int(re.search('[0-9]+',points.span.text)[0])\r\n        comments=int(re.search('[0-9]+',comments.span.a.text)[0])\r\n        entry=Entry(title,points,comments)\r\n        # print(entry)\r\n        lst.append(entry)\r\n        \r\n    return sorted(lst,key=lambda x:x.points+x.comments)[:top]\r\n    \r\n    \r\nurl = 'https://bites-data.s3.us-east-2.amazonaws.com/news.python.sc/index.html'\r\nprint(get_top_titles(url))",
            "date": "2022-12-11 14:03:44.274398+00:00",
            "passed": false
        },
        {
            "bite": "Bite 198. Calculate my Mac's longest uptime",
            "code": "from datetime import date, datetime\r\n\r\n\r\nMAC1 = \"\"\"\r\nreboot    ~                         Wed Apr 10 22:39\r\nreboot    ~                         Wed Mar 27 16:24\r\nreboot    ~                         Wed Mar 27 15:01\r\nreboot    ~                         Sun Mar  3 14:51\r\nreboot    ~                         Sun Feb 17 11:36\r\nreboot    ~                         Thu Jan 17 21:54\r\nreboot    ~                         Mon Jan 14 09:25\r\n\"\"\"\r\n\r\nYEAR=date.today().year\r\n\r\ndef calc_max_uptime(reboots):\r\n    \"\"\"Parse the passed in reboots output,\r\n       extracting the datetimes.\r\n\r\n       Calculate the highest uptime between reboots =\r\n       highest diff between extracted reboot datetimes.\r\n\r\n       Return a tuple of this max uptime in days (int) and the\r\n       date (str) this record was hit.\r\n\r\n       For the output above it would be (30, '2019-02-17'),\r\n       but we use different outputs in the tests as well ...\r\n    \"\"\"\r\n    time_objects=[]\r\n    for line in reboots.strip().splitlines():\r\n        _, timestamp_raw =line.split('~')\r\n        timestamp=f'{YEAR} {timestamp_raw.strip()[4:]}'\r\n        time_objects.append(datetime.strptime(timestamp,'%Y %b %d %H:%M'))\r\n        # print(timestamp, str(time_object))\r\n    \r\n    durations = [(\r\n                    (time_objects[i]-time_objects[i+1]).days, \r\n                    datetime.strftime(time_objects[i],'%Y-%m-%d')\r\n                    ) for i in range(len(time_objects)-1)\r\n                ]\r\n    return max(durations, key=lambda x:x[0])\r\n        \r\n        \r\nprint(calc_max_uptime(MAC1))",
            "date": "2022-12-11 00:20:42.568539+00:00",
            "passed": true
        },
        {
            "bite": "Bite 198. Calculate my Mac's longest uptime",
            "code": "from datetime import date, datetime\r\n\r\n\r\nMAC1 = \"\"\"\r\nreboot    ~                         Wed Apr 10 22:39\r\nreboot    ~                         Wed Mar 27 16:24\r\nreboot    ~                         Wed Mar 27 15:01\r\nreboot    ~                         Sun Mar  3 14:51\r\nreboot    ~                         Sun Feb 17 11:36\r\nreboot    ~                         Thu Jan 17 21:54\r\nreboot    ~                         Mon Jan 14 09:25\r\n\"\"\"\r\n\r\nYEAR=date.today().year\r\n\r\ndef calc_max_uptime(reboots):\r\n    \"\"\"Parse the passed in reboots output,\r\n       extracting the datetimes.\r\n\r\n       Calculate the highest uptime between reboots =\r\n       highest diff between extracted reboot datetimes.\r\n\r\n       Return a tuple of this max uptime in days (int) and the\r\n       date (str) this record was hit.\r\n\r\n       For the output above it would be (30, '2019-02-17'),\r\n       but we use different outputs in the tests as well ...\r\n    \"\"\"\r\n    time_objects=[]\r\n    for line in reboots.strip().splitlines():\r\n        _, timestamp_raw =line.split('~')\r\n        timestamp=f'{YEAR} {timestamp_raw.strip()[4:]}'\r\n        time_objects.append(datetime.strptime(timestamp,'%Y %b %d %H:%M'))\r\n        # print(timestamp, str(time_object))\r\n    \r\n    durations = [((time_objects[i]-time_objects[i+1]).days, datetime.strftime(time_objects[i],'%Y-%m-%d')) for i in range(len(time_objects)-1)]\r\n    return max(durations, key=lambda x:x[0])\r\n        \r\n        \r\nprint(calc_max_uptime(MAC1))",
            "date": "2022-12-11 00:19:36.670094+00:00",
            "passed": true
        },
        {
            "bite": "Bite 291. Find the fastest speech",
            "code": "from datetime import timedelta, datetime\r\nfrom typing import List\r\n\r\n\r\ndef get_srt_section_ids(text: str) -> List[int]:\r\n    \"\"\"Parse a caption (srt) text passed in and return a\r\n       list of section numbers ordered descending by\r\n       highest speech speed\r\n       (= ratio of \"time past:characters spoken\")\r\n\r\n       e.g. this section:\r\n\r\n       1\r\n       00:00:00,000 --> 00:00:01,000\r\n       let's code\r\n\r\n       (10 chars in 1 second)\r\n\r\n       has a higher ratio then:\r\n\r\n       2\r\n       00:00:00,000 --> 00:00:03,000\r\n       code\r\n\r\n       (4 chars in 3 seconds)\r\n\r\n       You can ignore milliseconds for this exercise.\r\n    \"\"\"\r\n    lines=iter(text.lstrip().splitlines())\r\n    sections_speed=[]\r\n    for line in lines:\r\n        section=int(line)\r\n        timing=next(lines)\r\n        start,stop=timing.split(' --> ')\r\n        start=datetime.strptime(start.split(',')[0], '%H:%M:%S')\r\n        stop=datetime.strptime(stop.split(',')[0], '%H:%M:%S')\r\n        duration=stop-start\r\n        speech_lines=[]\r\n        speech_line=next(lines)\r\n        while speech_line:\r\n            speech_lines.append(speech_line)\r\n            try:\r\n                speech_line=next(lines)\r\n            except StopIteration:\r\n                speech_line =''\r\n        \r\n        speech='\\n'.join(speech_lines)\r\n        chars_per_second = len(speech)/duration.total_seconds()\r\n        sections_speed.append((section,chars_per_second))\r\n        # print('##'.join([str(section),str(duration),speech,str(chars_per_second)]))\r\n    # print(sections_speed)\r\n    return [item[0] for item in sorted(sections_speed, key=lambda x:x[1], reverse=True)]\r\n    \r\n    \r\n    \r\n    \r\ntext = \"\"\"\r\n1\r\n00:00:00,498 --> 00:00:02,827\r\nBeautiful is better than ugly.\r\n\r\n2\r\n00:00:02,827 --> 00:00:06,383\r\nExplicit is better than implicit.\r\n\r\n3\r\n00:00:06,383 --> 00:00:09,427\r\nSimple is better than complex.\r\n\"\"\"\r\n\r\nprint(get_srt_section_ids(text))",
            "date": "2022-12-10 23:42:16.111745+00:00",
            "passed": true
        },
        {
            "bite": "Bite 291. Find the fastest speech",
            "code": "from datetime import timedelta, datetime\r\nfrom typing import List\r\n\r\n\r\ndef get_srt_section_ids(text: str) -> List[int]:\r\n    \"\"\"Parse a caption (srt) text passed in and return a\r\n       list of section numbers ordered descending by\r\n       highest speech speed\r\n       (= ratio of \"time past:characters spoken\")\r\n\r\n       e.g. this section:\r\n\r\n       1\r\n       00:00:00,000 --> 00:00:01,000\r\n       let's code\r\n\r\n       (10 chars in 1 second)\r\n\r\n       has a higher ratio then:\r\n\r\n       2\r\n       00:00:00,000 --> 00:00:03,000\r\n       code\r\n\r\n       (4 chars in 3 seconds)\r\n\r\n       You can ignore milliseconds for this exercise.\r\n    \"\"\"\r\n    lines=iter(text.lstrip().splitlines())\r\n    for line in lines:\r\n        section=int(line)\r\n        timing=next(lines)\r\n        start,stop=timing.split(' --> ')\r\n        start=datetime.strptime(start.split(',')[0], '%H:%M:%S')\r\n        stop=datetime.strptime(stop.split(',')[0], '%H:%M:%S')\r\n        speech_lines=[]\r\n        speech_line=next(lines)\r\n        while speech_line:\r\n            speech_lines.append(speech_line)\r\n            try:\r\n                speech_line=next(lines)\r\n            except StopIteration:\r\n                speech_line =''\r\n        \r\n        speech='\\n'.join(speech_lines)\r\n        print('##'.join([str(section),str(start),str(stop),speech]))\r\n    \r\n    \r\n    \r\n    \r\ntext = \"\"\"\r\n1\r\n00:00:00,498 --> 00:00:02,827\r\nBeautiful is better than ugly.\r\n\r\n2\r\n00:00:02,827 --> 00:00:06,383\r\nExplicit is better than implicit.\r\nSecond line for the laughs.\r\n\r\n3\r\n00:00:06,383 --> 00:00:09,427\r\nSimple is better than complex.\r\n\"\"\"\r\n\r\nprint(get_srt_section_ids(text))",
            "date": "2022-12-10 23:28:43.957176+00:00",
            "passed": false
        },
        {
            "bite": "Bite 291. Find the fastest speech",
            "code": "from datetime import timedelta\r\nfrom typing import List\r\n\r\n\r\ndef get_srt_section_ids(text: str) -> List[int]:\r\n    \"\"\"Parse a caption (srt) text passed in and return a\r\n       list of section numbers ordered descending by\r\n       highest speech speed\r\n       (= ratio of \"time past:characters spoken\")\r\n\r\n       e.g. this section:\r\n\r\n       1\r\n       00:00:00,000 --> 00:00:01,000\r\n       let's code\r\n\r\n       (10 chars in 1 second)\r\n\r\n       has a higher ratio then:\r\n\r\n       2\r\n       00:00:00,000 --> 00:00:03,000\r\n       code\r\n\r\n       (4 chars in 3 seconds)\r\n\r\n       You can ignore milliseconds for this exercise.\r\n    \"\"\"\r\n    pass",
            "date": "2022-12-10 23:16:24.365910+00:00",
            "passed": false
        },
        {
            "bite": "Bite 197. What date is Mother's Day celebrated?",
            "code": "from datetime import date\r\nimport dateutil.relativedelta as rd\r\n\r\n\r\ndef get_mothers_day_date(year):\r\n    \"\"\"Given the passed in year int, return the date Mother's Day\r\n       is celebrated assuming it's the 2nd Sunday of May.\"\"\"\r\n    start=date(year=year, month=4, day=30)\r\n    return start+rd.relativedelta(days=+1, weekday=rd.SU(+2))\r\n    \r\nfor year in range(2018,2028,1):\r\n    print(get_mothers_day_date(year))\r\n",
            "date": "2022-12-10 20:32:59.747044+00:00",
            "passed": true
        },
        {
            "bite": "Bite 187. Actor/actress age at movie release",
            "code": "from dataclasses import dataclass\r\n\r\nfrom dateutil.relativedelta import relativedelta\r\nfrom dateutil.parser import parse\r\n\r\n@dataclass\r\nclass Actor:\r\n    name: str\r\n    born: str\r\n\r\n\r\n@dataclass\r\nclass Movie:\r\n    title: str\r\n    release_date: str\r\n\r\n\r\ndef get_age(actor: Actor, movie: Movie) -> str:\r\n    \"\"\"Calculates age of actor / actress when movie was released,\r\n       return a string like this:\r\n\r\n       {name} was {age} years old when {movie} came out.\r\n       e.g.\r\n       Wesley Snipes was 28 years old when New Jack City came out.\r\n    \"\"\"\r\n    actor_born=parse(actor.born, fuzzy=True)\r\n    movie_released=parse(movie.release_date, fuzzy=True)\r\n    \r\n    age=relativedelta(movie_released,actor_born).years\r\n    return f\"{actor.name} was {age} years old when {movie.title} came out.\"\r\n    \r\n    \r\n\"\"\"\r\nactor=Actor('Michelle Pfeiffer', 'April 29, 1958')\r\nmovie=Movie('New Jack City', 'January 17, 1991')\r\nprint(get_age(actor, movie) )\r\n\"\"\"",
            "date": "2022-12-09 20:58:03.502767+00:00",
            "passed": true
        },
        {
            "bite": "Bite 187. Actor/actress age at movie release",
            "code": "from dataclasses import dataclass\r\n\r\nimport dateutil\r\n\r\n\r\n@dataclass\r\nclass Actor:\r\n    name: str\r\n    born: str\r\n\r\n\r\n@dataclass\r\nclass Movie:\r\n    title: str\r\n    release_date: str\r\n\r\n\r\ndef get_age(actor: Actor, movie: Movie) -> str:\r\n    \"\"\"Calculates age of actor / actress when movie was released,\r\n       return a string like this:\r\n\r\n       {name} was {age} years old when {movie} came out.\r\n       e.g.\r\n       Wesley Snipes was 28 years old when New Jack City came out.\r\n    \"\"\"\r\n    actor_born=dateutil.parser.parse(actor.born, fuzzy=True)\r\n    movie_released=dateutil.parser.parse(movie.release_date, fuzzy=True)\r\n    age=dateutil.relativedelta.relativedelta(movie_released-actor_born).years\r\n    return f\"{actor.name} was {age} years old when {movie.title} came out.\"",
            "date": "2022-12-09 20:50:49.435191+00:00",
            "passed": false
        },
        {
            "bite": "Bite 187. Actor/actress age at movie release",
            "code": "from dataclasses import dataclass\r\n\r\nfrom dateutil.parser import parse\r\n\r\n\r\n@dataclass\r\nclass Actor:\r\n    name: str\r\n    born: str\r\n\r\n\r\n@dataclass\r\nclass Movie:\r\n    title: str\r\n    release_date: str\r\n\r\n\r\ndef get_age(actor: Actor, movie: Movie) -> str:\r\n    \"\"\"Calculates age of actor / actress when movie was released,\r\n       return a string like this:\r\n\r\n       {name} was {age} years old when {movie} came out.\r\n       e.g.\r\n       Wesley Snipes was 28 years old when New Jack City came out.\r\n    \"\"\"\r\n    actor_born=parse(actor.born, fuzzy=True)\r\n    movie_released=parse(movie.release_date, fuzzy=True)\r\n    age=(movie_released-actor_born).years\r\n    return f\"{actor.name} was {age} years old when {movie.title} came out.\"",
            "date": "2022-12-09 20:39:37.837559+00:00",
            "passed": false
        },
        {
            "bite": "Bite 187. Actor/actress age at movie release",
            "code": "from dataclasses import dataclass\r\n\r\nfrom import dateutil.parser import parse\r\n\r\n\r\n@dataclass\r\nclass Actor:\r\n    name: str\r\n    born: str\r\n\r\n\r\n@dataclass\r\nclass Movie:\r\n    title: str\r\n    release_date: str\r\n\r\n\r\ndef get_age(actor: Actor, movie: Movie) -> str:\r\n    \"\"\"Calculates age of actor / actress when movie was released,\r\n       return a string like this:\r\n\r\n       {name} was {age} years old when {movie} came out.\r\n       e.g.\r\n       Wesley Snipes was 28 years old when New Jack City came out.\r\n    \"\"\"\r\n    actor_born=parse(actor.born, fuzzy=True)\r\n    movie_released=parse(movie.release_date, fuzzy=True)\r\n    age=(movie_released-actor_born).years\r\n    return f\"{actor.name} was {age} years old when {movie.title} came out.\"",
            "date": "2022-12-09 20:39:21.071946+00:00",
            "passed": false
        },
        {
            "bite": "Bite 187. Actor/actress age at movie release",
            "code": "from dataclasses import dataclass\r\n\r\nimport dateutil\r\n\r\n\r\n@dataclass\r\nclass Actor:\r\n    name: str\r\n    born: str\r\n\r\n\r\n@dataclass\r\nclass Movie:\r\n    title: str\r\n    release_date: str\r\n\r\n\r\ndef get_age(actor: Actor, movie: Movie) -> str:\r\n    \"\"\"Calculates age of actor / actress when movie was released,\r\n       return a string like this:\r\n\r\n       {name} was {age} years old when {movie} came out.\r\n       e.g.\r\n       Wesley Snipes was 28 years old when New Jack City came out.\r\n    \"\"\"\r\n    actor_born=parse(actor.born, fuzzy=True)\r\n    movie_released=parse(movie.release_date, fuzzy=True)\r\n    age=(movie_released-actor_born).years\r\n    return f\"{actor.name} was {age} years old when {movie.title} came out.\"",
            "date": "2022-12-09 20:38:25.979876+00:00",
            "passed": false
        },
        {
            "bite": "Bite 186. Calculate number of books to have read at date ...",
            "code": "from datetime import datetime\r\n\r\nfrom dateutil.parser import parse\r\n\r\n# work with a static date for tests, real use = datetime.now()\r\nNOW = datetime(2019, 3, 17, 16, 28, 42, 966663)\r\nWEEKS_PER_YEAR = 52\r\n\r\n\r\ndef get_number_books_read(books_per_year_goal: int,\r\n                          at_date: str = None) -> int:\r\n    \"\"\"Based on books_per_year_goal and at_date, return the\r\n       number of books that should have been read.\r\n       If books_per_year_goal negative or 0, or at_date is in the\r\n       past, raise a ValueError.\"\"\"\r\n    at_date = at_date or str(NOW)\r\n    # TODOs\r\n\r\n    # 1. use dateutil's parse to convert at_date into a\r\n    # datetime object\r\n\r\n    # 2. check books_per_year_goal and at_date and raise\r\n    # a ValueError if goal <= 0 or at_date in the past (< NOW)\r\n\r\n    # 3. check the offset of at_date in the year (\"week of the\r\n    # year\" - e.g. whatweekisit.com) and based on the books_per_year_goal,\r\n    # calculate the number of books that should have been read / completed\r\n    \r\n    if isinstance(at_date, str):\r\n        at_date = parse(at_date, fuzzy=True)\r\n    \r\n    if books_per_year_goal<=0 or at_date < NOW:\r\n        raise ValueError('Should have positive goal and future date')\r\n        \r\n    at_week= at_date.isocalendar()[1]\r\n    return int(at_week/WEEKS_PER_YEAR *books_per_year_goal)\r\n   \r\n\"\"\" \r\nprint(get_number_books_read(100, 'Sunday, March 25th, 2019'))\r\nprint(get_number_books_read(52, 'Sunday, March 18th, 2019'))\r\nprint(get_number_books_read(52, '5-20-2018'))\r\n\"\"\"",
            "date": "2022-12-09 20:31:09.541774+00:00",
            "passed": true
        },
        {
            "bite": "Bite 186. Calculate number of books to have read at date ...",
            "code": "from datetime import datetime\r\n\r\nfrom dateutil.parser import parse\r\n\r\n# work with a static date for tests, real use = datetime.now()\r\nNOW = datetime(2019, 3, 17, 16, 28, 42, 966663)\r\nWEEKS_PER_YEAR = 52\r\n\r\n\r\ndef get_number_books_read(books_per_year_goal: int,\r\n                          at_date: str = None) -> int:\r\n    \"\"\"Based on books_per_year_goal and at_date, return the\r\n       number of books that should have been read.\r\n       If books_per_year_goal negative or 0, or at_date is in the\r\n       past, raise a ValueError.\"\"\"\r\n    at_date = at_date or str(NOW)\r\n    # TODOs\r\n\r\n    # 1. use dateutil's parse to convert at_date into a\r\n    # datetime object\r\n\r\n    # 2. check books_per_year_goal and at_date and raise\r\n    # a ValueError if goal <= 0 or at_date in the past (< NOW)\r\n\r\n    # 3. check the offset of at_date in the year (\"week of the\r\n    # year\" - e.g. whatweekisit.com) and based on the books_per_year_goal,\r\n    # calculate the number of books that should have been read / completed\r\n    \r\n    if isinstance(at_date, str):\r\n        at_date = parse(at_date, fuzzy=True)\r\n    \r\n    if books_per_year_goal <0 or at_date < NOW:\r\n        raise ValueError('Should have positive goal and future date')\r\n        \r\n    at_week= at_date.isocalendar()[1]\r\n    return int(at_week/WEEKS_PER_YEAR *books_per_year_goal)\r\n   \r\n\"\"\" \r\nprint(get_number_books_read(100, 'Sunday, March 25th, 2019'))\r\nprint(get_number_books_read(52, 'Sunday, March 18th, 2019'))\r\nprint(get_number_books_read(52, '5-20-2018'))\r\n\"\"\"",
            "date": "2022-12-09 20:29:59.579506+00:00",
            "passed": false
        },
        {
            "bite": "Bite 186. Calculate number of books to have read at date ...",
            "code": "from datetime import datetime\r\n\r\nfrom dateutil.parser import parse\r\n\r\n# work with a static date for tests, real use = datetime.now()\r\nNOW = datetime(2019, 3, 17, 16, 28, 42, 966663)\r\nWEEKS_PER_YEAR = 52\r\n\r\n\r\ndef get_number_books_read(books_per_year_goal: int,\r\n                          at_date: str = None) -> int:\r\n    \"\"\"Based on books_per_year_goal and at_date, return the\r\n       number of books that should have been read.\r\n       If books_per_year_goal negative or 0, or at_date is in the\r\n       past, raise a ValueError.\"\"\"\r\n    at_date = at_date or str(NOW)\r\n    # TODOs\r\n\r\n    # 1. use dateutil's parse to convert at_date into a\r\n    # datetime object\r\n\r\n    # 2. check books_per_year_goal and at_date and raise\r\n    # a ValueError if goal <= 0 or at_date in the past (< NOW)\r\n\r\n    # 3. check the offset of at_date in the year (\"week of the\r\n    # year\" - e.g. whatweekisit.com) and based on the books_per_year_goal,\r\n    # calculate the number of books that should have been read / completed\r\n    \r\n    if isinstance(at_date, str):\r\n        at_date = parse(at_date, fuzzy=True)\r\n    \r\n    if books_per_year_goal <0 or at_date < NOW:\r\n        raise ValueError('Should have positive goal and future date')\r\n        \r\n    at_week= at_date.isocalendar()[1]\r\n    return int(at_week/WEEKS_PER_YEAR *books_per_year_goal)\r\n    \r\nprint(get_number_books_read(100, 'Sunday, March 25th, 2019'))\r\nprint(get_number_books_read(52, 'Sunday, March 18th, 2019'))\r\nprint(get_number_books_read(52, '5-20-2018'))",
            "date": "2022-12-09 20:29:34.335061+00:00",
            "passed": false
        },
        {
            "bite": "Bite 173. Set up future notifications",
            "code": "from datetime import datetime, timedelta\r\nimport re\r\n\r\nNOW = datetime(year=2019, month=2, day=6,\r\n               hour=22, minute=0, second=0)\r\n\r\n\r\ndef add_todo(delay_time: str, task: str,\r\n             start_time: datetime = NOW) -> str:\r\n    \"\"\"\r\n    Add a todo list item in the future with a delay time.\r\n\r\n    Parse out the time unit from the passed in delay_time str:\r\n    - 30d = 30 days\r\n    - 1h 10m = 1 hour and 10 min\r\n    - 5m 3s = 5 min and 3 seconds\r\n    - 45 or 45s = 45 seconds\r\n\r\n    Return the task and planned time which is calculated from\r\n    provided start_time (here default = NOW):\r\n    >>> add_todo(\"1h 10m\", \"Wash my car\")\r\n    >>> \"Wash my car @ 2019-02-06 23:10:00\"\r\n    \"\"\"\r\n    dt = timedelta()\r\n    for item in delay_time.split():\r\n        if 'd' in item:\r\n            dt+=timedelta(days=int(item.strip('d')))\r\n        elif 'h' in item:\r\n            dt+=timedelta(hours=int(item.strip('h')))\r\n        elif 'm' in item:\r\n            dt+=timedelta(minutes=int(item.strip('m')))\r\n        elif 's' in item:            \r\n            dt+=timedelta(seconds=int(item.strip('s')))\r\n        else:\r\n            dt+=timedelta(seconds=int(item))\r\n        \r\n    return f\"{task} @ {datetime.strftime(start_time+dt, '%Y-%m-%d %H:%M:%S')}\"       \r\n\r\n\r\nprint(add_todo(\"11h 10m\", \"Wash my car\"))\r\nprint(add_todo(\"30d\", \"Code a Bite\"))\r\nprint(add_todo(\"5m 3s\", \"Go to Bed\"))",
            "date": "2022-12-09 20:08:41.284472+00:00",
            "passed": true
        },
        {
            "bite": "Bite 229. Scrape best programming books",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup\r\nfrom pprint import pprint \r\n\r\nurl = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n       \"best-programming-books.html\")\r\ntmp = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nhtml_file = tmp / \"books.html\"\r\n\r\n\r\nif not html_file.exists():\r\n    urlretrieve(url, html_file)\r\n\r\n\r\nclass Book:\r\n    \"\"\"Book class should instantiate the following variables:\r\n\r\n    title - as it appears on the page\r\n    author - should be entered as lastname, firstname\r\n    year - four digit integer year that the book was published\r\n    rank - integer rank to be updated once the books have been sorted\r\n    rating - float as indicated on the page\r\n    \"\"\"\r\n    def __init__(self, title:str, author:str, year:int, rank: int, rating:float):\r\n        self.title = title # as it appears on the page\r\n        self.author = author # should be entered as lastname, firstname\r\n        self.year = year # four digit integer year that the book was published\r\n        self.rank = rank # integer rank to be updated once the books have been sorted\r\n        self.rating = float(rating) # float as indicated on the page\r\n\r\n\r\n    def __repr__(self):\r\n        return f'[{self.rank:03d}] {self.title} ({self.year})\\n      {self.author} {self.rating}'\r\n\r\ndef _get_soup(file):\r\n    return BeautifulSoup(file.read_text(), \"html.parser\")\r\n\r\n\r\ndef display_books(books, limit=10, year=None):\r\n    \"\"\"Prints the specified books to the console\r\n\r\n    :param books: list of all the books\r\n    :param limit: integer that indicates how many books to return\r\n    :param year: integer indicating the oldest year to include\r\n    :return: None\r\n    \"\"\"\r\n    books_until_year = [book for book in books if year is None or book.year >= year]\r\n    for book in books_until_year[:limit]:\r\n        print(book)\r\n\r\n\r\ndef load_data():\r\n    \"\"\"Loads the data from the html file\r\n\r\n    Creates the soup object and processes it to extract the information\r\n    required to create the Book class objects and returns a sorted list\r\n    of Book objects.\r\n\r\n    Books should be sorted by rating, year, title, and then by author's\r\n    last name. After the books have been sorted, the rank of each book\r\n    should be updated to indicate this new sorting order.The Book object\r\n    with the highest rating should be first and go down from there.\r\n    \"\"\"\r\n    soup = _get_soup(html_file)\r\n    books = soup.find_all('div', {'class': 'book accepted normal'})\r\n    result = []\r\n    for book in books:\r\n        try:\r\n            rank = book.find('div', {'class': 'rank'}).span.get_text()\r\n            title = book.find('h2', {'class':  'main'}).get_text()\r\n            authors = book.find('h3', {'class':  'authors'}).a.get_text()\r\n            year = book.find('span', {'class': 'date'}).get_text().strip('| ')\r\n            rating = book.find('span', {'class':  'our-rating'}).get_text()\r\n        except AttributeError:\r\n            continue\r\n        # format\r\n        rank = int(rank)\r\n        # assumes one author only and surname is last word only\r\n        names = authors.split()\r\n        name= \" \".join(names[:-1]) \r\n        surname = names[-1]\r\n        author = f'{surname}, {name}'\r\n        year = int(year) # why insists in 4 digits?\r\n        rating = float(rating)\r\n        if 'python' in title.lower():\r\n            result.append(Book(title, author, year, rank, rating))\r\n    # sort descending by rating \r\n    # ascending by year, \r\n    # by title case insensitive but don't change the original\r\n    # and then by author's last name\r\n    # in that order\r\n    result.sort(key=lambda x:x.author.split(',')[0])\r\n    result.sort(key=lambda x:x.title.lower())\r\n    result.sort(key=lambda x:x.year)\r\n    result.sort(key=lambda x:x.rating, reverse = True)\r\n    # update ranks\r\n    for i, book in enumerate(result):\r\n        book.rank = i+1\r\n    return result\r\n        \r\n\r\n\r\ndef main():\r\n    books = load_data()\r\n    display_books(books, limit=5, year=2017)\r\n    \"\"\"If done correctly, the previous function call should display the\r\n    output below.\r\n    \"\"\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n\"\"\"\r\n[001] Python Tricks (2017)\r\n      Bader, Dan 4.74\r\n[002] Mastering Deep Learning Fundamentals with Python (2019)\r\n      Wilson, Richard 4.7\r\n[006] Python Programming (2019)\r\n      Fedden, Antony Mc 4.68\r\n[007] Python Programming (2019)\r\n      Mining, Joseph 4.68\r\n[009] A Smarter Way to Learn Python (2017)\r\n      Myers, Mark 4.66\r\n\"\"\"",
            "date": "2022-12-08 11:03:28.505010+00:00",
            "passed": true
        },
        {
            "bite": "Bite 229. Scrape best programming books",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup\r\nfrom pprint import pprint \r\n\r\nurl = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n       \"best-programming-books.html\")\r\ntmp = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nhtml_file = tmp / \"books.html\"\r\n\r\n\r\nif not html_file.exists():\r\n    urlretrieve(url, html_file)\r\n\r\n\r\nclass Book:\r\n    \"\"\"Book class should instantiate the following variables:\r\n\r\n    title - as it appears on the page\r\n    author - should be entered as lastname, firstname\r\n    year - four digit integer year that the book was published\r\n    rank - integer rank to be updated once the books have been sorted\r\n    rating - float as indicated on the page\r\n    \"\"\"\r\n    def __init__(self, title:str, author:str, year:int, rank: int, rating:float):\r\n        self.title = title # as it appears on the page\r\n        self.author = author # should be entered as lastname, firstname\r\n        self.year = year # four digit integer year that the book was published\r\n        self.rank = rank # integer rank to be updated once the books have been sorted\r\n        self.rating = float(rating) # float as indicated on the page\r\n\r\n\r\n    def __repr__(self):\r\n        return f'[{self.rank:03d}] {self.title} ({self.year})\\n      {self.author} {self.rating}'\r\n\r\ndef _get_soup(file):\r\n    return BeautifulSoup(file.read_text(), \"html.parser\")\r\n\r\n\r\ndef display_books(books, limit=10, year=None):\r\n    \"\"\"Prints the specified books to the console\r\n\r\n    :param books: list of all the books\r\n    :param limit: integer that indicates how many books to return\r\n    :param year: integer indicating the oldest year to include\r\n    :return: None\r\n    \"\"\"\r\n    books_until_year = [book for book in books if not year is None and book.year >= year]\r\n    for book in books_until_year[:limit]:\r\n        print(book)\r\n\r\n\r\ndef load_data():\r\n    \"\"\"Loads the data from the html file\r\n\r\n    Creates the soup object and processes it to extract the information\r\n    required to create the Book class objects and returns a sorted list\r\n    of Book objects.\r\n\r\n    Books should be sorted by rating, year, title, and then by author's\r\n    last name. After the books have been sorted, the rank of each book\r\n    should be updated to indicate this new sorting order.The Book object\r\n    with the highest rating should be first and go down from there.\r\n    \"\"\"\r\n    soup = _get_soup(html_file)\r\n    books = soup.find_all('div', {'class': 'book accepted normal'})\r\n    result = []\r\n    for book in books:\r\n        try:\r\n            rank = book.find('div', {'class': 'rank'}).span.get_text()\r\n            title = book.find('h2', {'class':  'main'}).get_text()\r\n            authors = book.find('h3', {'class':  'authors'}).a.get_text()\r\n            year = book.find('span', {'class': 'date'}).get_text().strip('| ')\r\n            rating = book.find('span', {'class':  'our-rating'}).get_text()\r\n        except AttributeError:\r\n            continue\r\n        # format\r\n        rank = int(rank)\r\n        # assumes one author only and surname is last word only\r\n        names = authors.split()\r\n        name= \" \".join(names[:-1]) \r\n        surname = names[-1]\r\n        author = f'{surname}, {name}'\r\n        year = int(year) # why insists in 4 digits?\r\n        rating = float(rating)\r\n        if 'python' in title.lower():\r\n            result.append(Book(title, author, year, rank, rating))\r\n    # sort descending by rating \r\n    # ascending by year, \r\n    # by title case insensitive but don't change the original\r\n    # and then by author's last name\r\n    # in that order\r\n    result.sort(key=lambda x:x.author.split(',')[0])\r\n    result.sort(key=lambda x:x.title.lower())\r\n    result.sort(key=lambda x:x.year)\r\n    result.sort(key=lambda x:x.rating, reverse = True)\r\n    # update ranks\r\n    for i, book in enumerate(result):\r\n        book.rank = i+1\r\n    return result\r\n        \r\n\r\n\r\ndef main():\r\n    books = load_data()\r\n    display_books(books, limit=5, year=2017)\r\n    \"\"\"If done correctly, the previous function call should display the\r\n    output below.\r\n    \"\"\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n\"\"\"\r\n[001] Python Tricks (2017)\r\n      Bader, Dan 4.74\r\n[002] Mastering Deep Learning Fundamentals with Python (2019)\r\n      Wilson, Richard 4.7\r\n[006] Python Programming (2019)\r\n      Fedden, Antony Mc 4.68\r\n[007] Python Programming (2019)\r\n      Mining, Joseph 4.68\r\n[009] A Smarter Way to Learn Python (2017)\r\n      Myers, Mark 4.66\r\n\"\"\"",
            "date": "2022-12-08 11:03:01.595806+00:00",
            "passed": false
        },
        {
            "bite": "Bite 229. Scrape best programming books",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup\r\nfrom pprint import pprint \r\n\r\nurl = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n       \"best-programming-books.html\")\r\ntmp = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nhtml_file = tmp / \"books.html\"\r\n\r\n\r\nif not html_file.exists():\r\n    urlretrieve(url, html_file)\r\n\r\n\r\nclass Book:\r\n    \"\"\"Book class should instantiate the following variables:\r\n\r\n    title - as it appears on the page\r\n    author - should be entered as lastname, firstname\r\n    year - four digit integer year that the book was published\r\n    rank - integer rank to be updated once the books have been sorted\r\n    rating - float as indicated on the page\r\n    \"\"\"\r\n    def __init__(self, title:str, author:str, year:int, rank: int, rating:float):\r\n        self.title = title # as it appears on the page\r\n        self.author = author # should be entered as lastname, firstname\r\n        self.year = year # four digit integer year that the book was published\r\n        self.rank = rank # integer rank to be updated once the books have been sorted\r\n        self.rating = float(rating) # float as indicated on the page\r\n\r\n\r\n    def __repr__(self):\r\n        return f'[{self.rank:03d}] {self.title} ({self.year})\\n      {self.author} {self.rating}'\r\n\r\ndef _get_soup(file):\r\n    return BeautifulSoup(file.read_text(), \"html.parser\")\r\n\r\n\r\ndef display_books(books, limit=10, year=None):\r\n    \"\"\"Prints the specified books to the console\r\n\r\n    :param books: list of all the books\r\n    :param limit: integer that indicates how many books to return\r\n    :param year: integer indicating the oldest year to include\r\n    :return: None\r\n    \"\"\"\r\n    books_until_year = [book for book in books if year and book.year >= year]\r\n    for book in books_until_year[:limit]:\r\n        print(book)\r\n\r\n\r\ndef load_data():\r\n    \"\"\"Loads the data from the html file\r\n\r\n    Creates the soup object and processes it to extract the information\r\n    required to create the Book class objects and returns a sorted list\r\n    of Book objects.\r\n\r\n    Books should be sorted by rating, year, title, and then by author's\r\n    last name. After the books have been sorted, the rank of each book\r\n    should be updated to indicate this new sorting order.The Book object\r\n    with the highest rating should be first and go down from there.\r\n    \"\"\"\r\n    soup = _get_soup(html_file)\r\n    books = soup.find_all('div', {'class': 'book accepted normal'})\r\n    result = []\r\n    for book in books:\r\n        try:\r\n            rank = book.find('div', {'class': 'rank'}).span.get_text()\r\n            title = book.find('h2', {'class':  'main'}).get_text()\r\n            authors = book.find('h3', {'class':  'authors'}).a.get_text()\r\n            year = book.find('span', {'class': 'date'}).get_text().strip('| ')\r\n            rating = book.find('span', {'class':  'our-rating'}).get_text()\r\n        except AttributeError:\r\n            continue\r\n        # format\r\n        rank = int(rank)\r\n        # assumes one author only and surname is last word only\r\n        names = authors.split()\r\n        name= \" \".join(names[:-1]) \r\n        surname = names[-1]\r\n        author = f'{surname}, {name}'\r\n        year = int(year) # why insists in 4 digits?\r\n        rating = float(rating)\r\n        if 'python' in title.lower():\r\n            result.append(Book(title, author, year, rank, rating))\r\n    # sort descending by rating \r\n    # ascending by year, \r\n    # by title case insensitive but don't change the original\r\n    # and then by author's last name\r\n    # in that order\r\n    result.sort(key=lambda x:x.author.split(',')[0])\r\n    result.sort(key=lambda x:x.title.lower())\r\n    result.sort(key=lambda x:x.year)\r\n    result.sort(key=lambda x:x.rating, reverse = True)\r\n    # update ranks\r\n    for i, book in enumerate(result):\r\n        book.rank = i+1\r\n    return result\r\n        \r\n\r\n\r\ndef main():\r\n    books = load_data()\r\n    display_books(books, limit=5, year=2017)\r\n    \"\"\"If done correctly, the previous function call should display the\r\n    output below.\r\n    \"\"\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n\"\"\"\r\n[001] Python Tricks (2017)\r\n      Bader, Dan 4.74\r\n[002] Mastering Deep Learning Fundamentals with Python (2019)\r\n      Wilson, Richard 4.7\r\n[006] Python Programming (2019)\r\n      Fedden, Antony Mc 4.68\r\n[007] Python Programming (2019)\r\n      Mining, Joseph 4.68\r\n[009] A Smarter Way to Learn Python (2017)\r\n      Myers, Mark 4.66\r\n\"\"\"",
            "date": "2022-12-08 11:01:14.703467+00:00",
            "passed": false
        },
        {
            "bite": "Bite 229. Scrape best programming books",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup\r\nfrom pprint import pprint \r\n\r\nurl = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n       \"best-programming-books.html\")\r\ntmp = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nhtml_file = tmp / \"books.html\"\r\n\r\n\r\nif not html_file.exists():\r\n    urlretrieve(url, html_file)\r\n\r\n\r\nclass Book:\r\n    \"\"\"Book class should instantiate the following variables:\r\n\r\n    title - as it appears on the page\r\n    author - should be entered as lastname, firstname\r\n    year - four digit integer year that the book was published\r\n    rank - integer rank to be updated once the books have been sorted\r\n    rating - float as indicated on the page\r\n    \"\"\"\r\n    def __init__(self, title:str, author:str, year:int, rank: int, rating:float):\r\n        self.title = title # as it appears on the page\r\n        self.author = author # should be entered as lastname, firstname\r\n        self.year = year # four digit integer year that the book was published\r\n        self.rank = rank # integer rank to be updated once the books have been sorted\r\n        self.rating = float(rating) # float as indicated on the page\r\n\r\n\r\n    def __repr__(self):\r\n        return f'[{self.rank:03d}] {self.title} ({self.year})\\n      {self.author} {self.rating}'\r\n\r\ndef _get_soup(file):\r\n    return BeautifulSoup(file.read_text(), \"html.parser\")\r\n\r\n\r\ndef display_books(books, limit=10, year=None):\r\n    \"\"\"Prints the specified books to the console\r\n\r\n    :param books: list of all the books\r\n    :param limit: integer that indicates how many books to return\r\n    :param year: integer indicating the oldest year to include\r\n    :return: None\r\n    \"\"\"\r\n    books_until_year = [book for book in books if book.year >= year]\r\n    for book in books_until_year[:limit]:\r\n        print(book)\r\n\r\n\r\ndef load_data():\r\n    \"\"\"Loads the data from the html file\r\n\r\n    Creates the soup object and processes it to extract the information\r\n    required to create the Book class objects and returns a sorted list\r\n    of Book objects.\r\n\r\n    Books should be sorted by rating, year, title, and then by author's\r\n    last name. After the books have been sorted, the rank of each book\r\n    should be updated to indicate this new sorting order.The Book object\r\n    with the highest rating should be first and go down from there.\r\n    \"\"\"\r\n    soup = _get_soup(html_file)\r\n    books = soup.find_all('div', {'class': 'book accepted normal'})\r\n    result = []\r\n    for book in books:\r\n        try:\r\n            rank = book.find('div', {'class': 'rank'}).span.get_text()\r\n            title = book.find('h2', {'class':  'main'}).get_text()\r\n            authors = book.find('h3', {'class':  'authors'}).a.get_text()\r\n            year = book.find('span', {'class': 'date'}).get_text().strip('| ')\r\n            rating = book.find('span', {'class':  'our-rating'}).get_text()\r\n        except AttributeError:\r\n            continue\r\n        # format\r\n        rank = int(rank)\r\n        # assumes one author only and surname is last word only\r\n        names = authors.split()\r\n        name= \" \".join(names[:-1]) \r\n        surname = names[-1]\r\n        author = f'{surname}, {name}'\r\n        year = int(year) # why insists in 4 digits?\r\n        rating = float(rating)\r\n        if 'python' in title.lower():\r\n            result.append(Book(title, author, year, rank, rating))\r\n    # sort descending by rating \r\n    # ascending by year, \r\n    # by title case insensitive but don't change the original\r\n    # and then by author's last name\r\n    # in that order\r\n    result.sort(key=lambda x:x.author.split(',')[0])\r\n    result.sort(key=lambda x:x.title.lower())\r\n    result.sort(key=lambda x:x.year)\r\n    result.sort(key=lambda x:x.rating, reverse = True)\r\n    # update ranks\r\n    for i, book in enumerate(result):\r\n        book.rank = i+1\r\n    return result\r\n        \r\n\r\n\r\ndef main():\r\n    books = load_data()\r\n    display_books(books, limit=5, year=2017)\r\n    \"\"\"If done correctly, the previous function call should display the\r\n    output below.\r\n    \"\"\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n\"\"\"\r\n[001] Python Tricks (2017)\r\n      Bader, Dan 4.74\r\n[002] Mastering Deep Learning Fundamentals with Python (2019)\r\n      Wilson, Richard 4.7\r\n[006] Python Programming (2019)\r\n      Fedden, Antony Mc 4.68\r\n[007] Python Programming (2019)\r\n      Mining, Joseph 4.68\r\n[009] A Smarter Way to Learn Python (2017)\r\n      Myers, Mark 4.66\r\n\"\"\"",
            "date": "2022-12-08 10:52:47.482629+00:00",
            "passed": false
        },
        {
            "bite": "Bite 229. Scrape best programming books",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup\r\nfrom pprint import pprint \r\n\r\nurl = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n       \"best-programming-books.html\")\r\ntmp = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nhtml_file = tmp / \"books.html\"\r\n\r\n\r\nif not html_file.exists():\r\n    urlretrieve(url, html_file)\r\n\r\n\r\nclass Book:\r\n    \"\"\"Book class should instantiate the following variables:\r\n\r\n    title - as it appears on the page\r\n    author - should be entered as lastname, firstname\r\n    year - four digit integer year that the book was published\r\n    rank - integer rank to be updated once the books have been sorted\r\n    rating - float as indicated on the page\r\n    \"\"\"\r\n    def __init__(self, title:str, author:str, year:int, rank: int, rating:float):\r\n        self.title = title # as it appears on the page\r\n        self.author = author # should be entered as lastname, firstname\r\n        self.year = year # four digit integer year that the book was published\r\n        self.rank = rank # integer rank to be updated once the books have been sorted\r\n        self.rating = float(rating) # float as indicated on the page\r\n\r\n\r\n    def __repr__(self):\r\n        return f'[{self.rank:03d}] {self.title} ({self.year})\\n      {self.author} {self.rating}'\r\n\r\ndef _get_soup(file):\r\n    return BeautifulSoup(file.read_text(), \"html.parser\")\r\n\r\n\r\ndef display_books(books, limit=10, year=None):\r\n    \"\"\"Prints the specified books to the console\r\n\r\n    :param books: list of all the books\r\n    :param limit: integer that indicates how many books to return\r\n    :param year: integer indicating the oldest year to include\r\n    :return: None\r\n    \"\"\"\r\n    books_until_year = [book for book in books if book.year >= year]\r\n    for book in books_until_year[:limit]:\r\n        print(book)\r\n\r\n\r\ndef load_data():\r\n    \"\"\"Loads the data from the html file\r\n\r\n    Creates the soup object and processes it to extract the information\r\n    required to create the Book class objects and returns a sorted list\r\n    of Book objects.\r\n\r\n    Books should be sorted by rating, year, title, and then by author's\r\n    last name. After the books have been sorted, the rank of each book\r\n    should be updated to indicate this new sorting order.The Book object\r\n    with the highest rating should be first and go down from there.\r\n    \"\"\"\r\n    soup = _get_soup(html_file)\r\n    books = soup.find_all('div', {'class': 'book accepted normal'})\r\n    result = []\r\n    for book in books:\r\n        try:\r\n            rank = book.find('div', {'class': 'rank'}).span.get_text()\r\n            title = book.find('h2', {'class':  'main'}).get_text()\r\n            authors = book.find('h3', {'class':  'authors'}).a.get_text()\r\n            year = book.find('span', {'class': 'date'}).get_text().strip('| ')\r\n            rating = book.find('span', {'class':  'our-rating'}).get_text()\r\n        except AttributeError:\r\n            continue\r\n        # format\r\n        rank = int(rank)\r\n        # assumes one author only and surname is last word only\r\n        names = authors.split()\r\n        name= \" \".join(names[:-1]) \r\n        surname = names[-1]\r\n        author = f'{surname}, {name}'\r\n        year = int(year) # why insists in 4 digits?\r\n        rating = float(rating)\r\n        if 'python' in title.lower():\r\n            result.append(Book(title, author, year, rank, rating))\r\n    # sort descending by rating \r\n    # ascending by year, \r\n    # by title case insensitive but don't change the original\r\n    # and then by author's last name\r\n    # in that order\r\n    sorted(result, key=lambda x:x.author.split(',')[0])\r\n    sorted(result, key=lambda x:x.title.lower())\r\n    sorted(result, key=lambda x:x.year)\r\n    sorted(result, key=lambda x:x.rating, reverse = True)\r\n    # update ranks\r\n    for i, book in enumerate(result):\r\n        book.rank = i+1\r\n    return result\r\n        \r\n\r\n\r\ndef main():\r\n    books = load_data()\r\n    display_books(books, limit=5, year=2017)\r\n    \"\"\"If done correctly, the previous function call should display the\r\n    output below.\r\n    \"\"\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n\"\"\"\r\n[001] Python Tricks (2017)\r\n      Bader, Dan 4.74\r\n[002] Mastering Deep Learning Fundamentals with Python (2019)\r\n      Wilson, Richard 4.7\r\n[006] Python Programming (2019)\r\n      Fedden, Antony Mc 4.68\r\n[007] Python Programming (2019)\r\n      Mining, Joseph 4.68\r\n[009] A Smarter Way to Learn Python (2017)\r\n      Myers, Mark 4.66\r\n\"\"\"",
            "date": "2022-12-08 10:49:29.525336+00:00",
            "passed": false
        },
        {
            "bite": "Bite 275. Get the most common email domains",
            "code": "from collections import Counter\r\n\r\nimport bs4\r\nimport requests\r\n\r\n\r\nCOMMON_DOMAINS = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n                  \"common-domains.html\")\r\nTARGET_DIV = {\"class\": \"middle_info_noborder\"}\r\n\r\ndef get_common_domains(url=COMMON_DOMAINS):\r\n    \"\"\"Scrape the url return the 100 most common domain names\"\"\"\r\n\r\n    content = requests.get(url).text\r\n\r\n    soup = bs4.BeautifulSoup(content, \"html.parser\")\r\n    target_div=soup.find('div', TARGET_DIV)\r\n    row_domains=target_div.find_all('tr')\r\n    return [row.td.next_sibling.next_sibling.get_text() for row in row_domains ]\r\n\r\ndef get_most_common_domains(emails, common_domains=None):\r\n    \"\"\"Given a list of emails return the most common domain names,\r\n       ignoring the list (or set) of common_domains\"\"\"\r\n    if common_domains is None:\r\n        common_domains = get_common_domains()\r\n\r\n    # your code\r\n    domains = [email.split('@')[1] for email in emails]\r\n    domains_filtered= [domain for domain in domains if domain not in common_domains]\r\n\r\n    return Counter(domains_filtered).most_common()\r\n\r\n\r\nlst= get_common_domains()\r\nprint(len(lst))\r\nprint(lst)\r\n\r\n# sample email list from mockaroo, edited manually\r\ntest_emails='''\r\nsally.sainsberry@bbb.org\r\ndcrauford1@gmail.com\r\nnmaccawley2@zdnet.com\r\ngsteinor3@vkontakte.ru\r\nn.mayer4@zdnet.com\r\nlaurent.lohrensen5@bbb.org\r\ntrich6@jigsy.com\r\nmbiggs7@linkedin.com\r\nraymond.jaquest@gmail.com\r\nedimitresco9@zdnet.com\r\nrvaraha@yahoo.com\r\n'''.strip().split()\r\nprint(get_most_common_domains(test_emails))\r\n",
            "date": "2022-12-08 07:55:13.504588+00:00",
            "passed": true
        },
        {
            "bite": "Bite 275. Get the most common email domains",
            "code": "from collections import Counter\r\n\r\nimport bs4\r\nimport requests\r\nimport re\r\n\r\n\r\nCOMMON_DOMAINS = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n                  \"common-domains.html\")\r\nTARGET_DIV = {\"class\": \"middle_info_noborder\"}\r\n\r\ndef get_common_domains(url=COMMON_DOMAINS):\r\n    \"\"\"Scrape the url return the 100 most common domain names\"\"\"\r\n\r\n    CONTENT = requests.get(COMMON_DOMAINS).text\r\n\r\n    soup = bs4.BeautifulSoup(CONTENT, \"html.parser\")\r\n    target_div=soup.find(attrs=TARGET_DIV)\r\n    row_domains=target_div.find_all('tr')\r\n    return [row.td.next_sibling.next_sibling.get_text() for row in row_domains ]\r\n\r\ndef get_most_common_domains(emails, common_domains=None):\r\n    \"\"\"Given a list of emails return the most common domain names,\r\n       ignoring the list (or set) of common_domains\"\"\"\r\n    if common_domains is None:\r\n        common_domains = get_common_domains()\r\n\r\n    # your code\r\n    domains = [re.split('@',email)[1] for email in emails]\r\n    domains_filtered= [domain for domain in domains if domain not in common_domains]\r\n\r\n    return Counter(domains_filtered).most_common()\r\n\r\n\"\"\"\r\nlst= get_common_domains()\r\nprint(len(lst))\r\nprint(lst)\r\n\r\n# sample email list from mockaroo, edited manually\r\ntest_emails='''\r\nsally.sainsberry@bbb.org\r\ndcrauford1@gmail.com\r\nnmaccawley2@zdnet.com\r\ngsteinor3@vkontakte.ru\r\nn.mayer4@zdnet.com\r\nlaurent.lohrensen5@bbb.org\r\ntrich6@jigsy.com\r\nmbiggs7@linkedin.com\r\nraymond.jaquest@gmail.com\r\nedimitresco9@zdnet.com\r\nrvaraha@yahoo.com\r\n'''.strip().split()\r\nprint(get_most_common_domains(test_emails))\r\n\"\"\"",
            "date": "2022-12-08 07:50:25.848639+00:00",
            "passed": true
        },
        {
            "bite": "Bite 275. Get the most common email domains",
            "code": "from collections import Counter\r\n\r\nimport bs4\r\nimport requests\r\nimport re\r\n\r\n\r\nCOMMON_DOMAINS = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n                  \"common-domains.html\")\r\nTARGET_DIV = {\"class\": \"middle_info_noborder\"}\r\n\r\ndef get_common_domains(url=COMMON_DOMAINS):\r\n    \"\"\"Scrape the url return the 100 most common domain names\"\"\"\r\n\r\n    CONTENT = requests.get(COMMON_DOMAINS).text\r\n\r\n    soup = bs4.BeautifulSoup(CONTENT, \"html.parser\")\r\n    target_div=soup.find(attrs=TARGET_DIV)\r\n    row_domains=target_div.find_all('tr')\r\n    return [row.td.next_sibling.next_sibling.get_text() for row in row_domains ]\r\n\r\ndef get_most_common_domains(emails, common_domains=None):\r\n    \"\"\"Given a list of emails return the most common domain names,\r\n       ignoring the list (or set) of common_domains\"\"\"\r\n    if common_domains is None:\r\n        common_domains = get_common_domains()\r\n\r\n    # your code\r\n    domains = []\r\n    for email in emails:\r\n        domain = re.split('@',email)[1]\r\n        if domain not in common_domains:\r\n            domains.append(domain) \r\n    return Counter(domains).most_common()\r\n\r\n'''\r\nlst= get_common_domains()\r\nprint(len(lst))\r\nprint(lst)\r\n\r\n# sample email list from mockaroo, edited manually\r\ntest_emails=\"\"\"\r\nsally.sainsberry@bbb.org\r\ndcrauford1@gmail.com\r\nnmaccawley2@zdnet.com\r\ngsteinor3@vkontakte.ru\r\nn.mayer4@zdnet.com\r\nlaurent.lohrensen5@bbb.org\r\ntrich6@jigsy.com\r\nmbiggs7@linkedin.com\r\nraymond.jaquest@gmail.com\r\nedimitresco9@zdnet.com\r\nrvaraha@yahoo.com\r\n\"\"\".strip().split()\r\nprint(get_most_common_domains(test_emails))\r\n'''",
            "date": "2022-12-08 07:47:05.772269+00:00",
            "passed": true
        },
        {
            "bite": "Bite 275. Get the most common email domains",
            "code": "from collections import Counter\r\n\r\nimport bs4\r\nimport requests\r\nimport re\r\n\r\n\r\nCOMMON_DOMAINS = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n                  \"common-domains.html\")\r\nTARGET_DIV = {\"class\": \"middle_info_noborder\"}\r\n\r\ndef get_common_domains(url=COMMON_DOMAINS):\r\n    \"\"\"Scrape the url return the 100 most common domain names\"\"\"\r\n\r\n    CONTENT = requests.get(COMMON_DOMAINS).text\r\n\r\n    soup = bs4.BeautifulSoup(CONTENT, \"html.parser\")\r\n    target_div=soup.find(attrs=TARGET_DIV)\r\n    row_domains=target_div.find_all('tr')\r\n    return [row.td.next_sibling.next_sibling.get_text() for row in row_domains ]\r\n\r\ndef get_most_common_domains(emails, common_domains=None):\r\n    \"\"\"Given a list of emails return the most common domain names,\r\n       ignoring the list (or set) of common_domains\"\"\"\r\n    if common_domains is None:\r\n        common_domains = get_common_domains()\r\n\r\n    # your code\r\n    domains = []\r\n    for email in emails:\r\n        domain = re.split('@',email)[1]\r\n        if domain not in common_domains:\r\n            domains.append(domain) \r\n    return Counter(domains).most_common()\r\n\r\n    \r\nlst= get_common_domains()\r\nprint(len(lst))\r\nprint(lst)\r\n\r\ntest_emails=\"\"\"\r\nssainsberry0@bbb.org\r\nd.crauford1@gmail.com\r\nnmaccawley2@zdnet.com\r\ngsteinor3@vkontakte.ru\r\nnmayer4@zdnet.com\r\nllohrensen5@bbb.org\r\ntrich6@jigsy.com\r\nmbiggs7@linkedin.com\r\nrjaquest8@gmail.com\r\nedimitresco9@zdnet.com\r\nrvaraha@yahoo.com\r\n\"\"\".strip().split()\r\nprint(get_most_common_domains(test_emails))\r\n",
            "date": "2022-12-08 07:43:36.940872+00:00",
            "passed": true
        },
        {
            "bite": "Bite 275. Get the most common email domains",
            "code": "from collections import Counter\r\n\r\nimport bs4\r\nimport requests\r\nimport re\r\n\r\n\r\nCOMMON_DOMAINS = (\"https://bites-data.s3.us-east-2.amazonaws.com/\"\r\n                  \"common-domains.html\")\r\nTARGET_DIV = {\"class\": \"middle_info_noborder\"}\r\n\r\ndef get_common_domains(url=COMMON_DOMAINS):\r\n    \"\"\"Scrape the url return the 100 most common domain names\"\"\"\r\n\r\n    CONTENT = requests.get(COMMON_DOMAINS).text\r\n\r\n    soup = bs4.BeautifulSoup(CONTENT, \"html.parser\")\r\n    target_div=soup.find(attrs=TARGET_DIV)\r\n    row_domains=target_div.find_all('tr')\r\n    return [row.td.next_sibling.next_sibling.get_text() for row in row_domains ]\r\n\r\ndef get_most_common_domains(emails, common_domains=None):\r\n    \"\"\"Given a list of emails return the most common domain names,\r\n       ignoring the list (or set) of common_domains\"\"\"\r\n    if common_domains is None:\r\n        common_domains = get_common_domains()\r\n\r\n    # your code\r\n    domains = []\r\n    for email in emails:\r\n        domain = re.split('@',email)[1]\r\n        if domain not in common_domains:\r\n            domains.append(domain) \r\n   return Counter(domains).most_common()\r\n\r\n    \r\n    \r\nlst= get_common_domains()\r\nprint(len(lst))\r\nprint(lst)\r\n\r\ntest_emails=\"\"\"\r\nssainsberry0@bbb.org\r\nd.crauford1@gmail.com\r\nnmaccawley2@zdnet.com\r\ngsteinor3@vkontakte.ru\r\nnmayer4@zdnet.com\r\nllohrensen5@bbb.org\r\ntrich6@jigsy.com\r\nmbiggs7@linkedin.com\r\nrjaquest8@gmail.com\r\nedimitresco9@zdnet.com\r\nrvaraha@yahoo.com\r\n\"\"\".strip().split()\r\nget_most_common_domains(test_emails)\r\n",
            "date": "2022-12-08 07:42:58.798102+00:00",
            "passed": false
        },
        {
            "bite": "Bite 348. Citation indexes",
            "code": "from typing import Sequence\r\nfrom collections import Counter\r\n\r\nTYPE_ERROR_MSG = \"Unsupported input type: use either a list or a tuple\"\r\nVALUE_ERROR_MSG = \"Unsupported input value: citations cannot be neither empty nor None\"\r\n\r\ndef _check_valid_input(citations):\r\n    if citations is None:\r\n        raise ValueError(VALUE_ERROR_MSG)\r\n        \r\n    if not isinstance(citations, (list, tuple)):\r\n        raise TypeError(TYPE_ERROR_MSG)\r\n    \r\n    if not citations or any(not isinstance(item, int) or item<0 for item in citations):\r\n        raise ValueError(VALUE_ERROR_MSG)\r\n\r\n\r\ndef h_index(citations: Sequence[int]) -> int:\r\n    \"\"\"Return the highest number of papers h having at least h citations\"\"\"\r\n    _check_valid_input(citations)\r\n    \r\n    count = Counter(citations)\r\n\r\n    for i in range(len(citations),0,-1):\r\n        if sum(n_papers for n_citations, n_papers in count.items() if n_citations >=i) >= i:\r\n            return i\r\n    return 0\r\n\r\ndef i10_index(citations: Sequence[int]) -> int:\r\n    \"\"\"Return the number of papers having at least 10 citations\"\"\"\r\n    _check_valid_input(citations)\r\n\r\n    count = Counter(citations)\r\n    return sum(n_papers for n_citations, n_papers in count.items() if n_citations >=10)\r\n    \r\n\r\nprint(h_index([0, 0, 11, 1, 10, 5, 10, 5]))\r\n\r\nprint(i10_index([0, 0, 11, 1, 10, 5, 10, 3]))",
            "date": "2022-12-07 17:13:08.649111+00:00",
            "passed": true
        },
        {
            "bite": "Bite 348. Citation indexes",
            "code": "from typing import Sequence\r\nfrom collections import Counter\r\n\r\nTYPE_ERROR_MSG = \"Unsupported input type: use either a list or a tuple\"\r\nVALUE_ERROR_MSG = \"Unsupported input value: citations cannot be neither empty nor None\"\r\n\r\ndef _check_valid_input(citations):\r\n    if citations is None:\r\n        raise ValueError(VALUE_ERROR_MSG)\r\n        \r\n    if not isinstance(citations, (list, tuple)):\r\n        raise TypeError(TYPE_ERROR_MSG)\r\n    \r\n    if not citations or any(not isinstance(item, int) or item<0 for item in citations):\r\n        raise ValueError(VALUE_ERROR_MSG)\r\n\r\n\r\ndef h_index(citations: Sequence[int]) -> int:\r\n    \"\"\"Return the highest number of papers h having at least h citations\"\"\"\r\n    _check_valid_input(citations)\r\n    \r\n    count = Counter(citations)\r\n\r\n    for i in range(len(citations),0,-1):\r\n        if sum(n_papers for n_citations, n_papers in count.items() if n_citations >=i) >= i:\r\n            return i\r\n\r\n\r\ndef i10_index(citations: Sequence[int]) -> int:\r\n    \"\"\"Return the number of papers having at least 10 citations\"\"\"\r\n    _check_valid_input(citations)\r\n\r\n    count = Counter(citations)\r\n    return sum(n_papers for n_citations, n_papers in count.items() if n_citations >=10)\r\n    \r\n\r\nprint(h_index([0, 0, 11, 1, 10, 5, 10, 5]))\r\n\r\nprint(i10_index([0, 0, 11, 1, 10, 5, 10, 3]))",
            "date": "2022-12-07 17:11:59.805176+00:00",
            "passed": false
        },
        {
            "bite": "Bite 348. Citation indexes",
            "code": "from typing import Sequence\r\nfrom collections import Counter\r\n\r\nTYPE_ERROR_MSG = \"Unsupported input type: use either a list or a tuple\"\r\nVALUE_ERROR_MSG = \"Unsupported input value: citations cannot be neither empty nor None\"\r\n\r\ndef _check_valid_input(citations):\r\n    if citations is None:\r\n        raise ValueError(VALUE_ERROR_MSG)\r\n        \r\n    if not isinstance(citations, (list, tuple)):\r\n        raise TypeError(TYPE_ERROR_MSG)\r\n    \r\n    if not citaions or any(not isinstance(item, int) or item<0 for item in citations):\r\n        raise ValueError(VALUE_ERROR_MSG)\r\n\r\n\r\ndef h_index(citations: Sequence[int]) -> int:\r\n    \"\"\"Return the highest number of papers h having at least h citations\"\"\"\r\n    _check_valid_input(citations)\r\n    \r\n    count = Counter(citations)\r\n\r\n    for i in range(len(citations),0,-1):\r\n        if sum(n_papers for n_citations, n_papers in count.items() if n_citations >=i) >= i:\r\n            return i\r\n\r\n\r\ndef i10_index(citations: Sequence[int]) -> int:\r\n    \"\"\"Return the number of papers having at least 10 citations\"\"\"\r\n    _check_valid_input(citations)\r\n\r\n    count = Counter(citations)\r\n    return sum(n_papers for n_citations, n_papers in count.items() if n_citations >=10)\r\n    \r\n\r\nprint(h_index([0, 0, 11, 1, 10, 5, 10, 5]))\r\n\r\nprint(i10_index([0, 0, 11, 1, 10, 5, 10, 3]))",
            "date": "2022-12-07 17:11:41.799394+00:00",
            "passed": false
        },
        {
            "bite": "Bite 348. Citation indexes",
            "code": "from typing import Sequence\r\nfrom collections import Counter\r\n\r\nTYPE_ERROR_MSG = \"Unsupported input type: use either a list or a tuple\"\r\nVALUE_ERROR_MSG = \"Unsupported input value: citations cannot be neither empty nor None\"\r\n\r\ndef _check_valid_input(citations):\r\n    if citations is None:\r\n        raise ValueError(VALUE_ERROR_MSG)\r\n        \r\n    if not isinstance(citations, (list, tuple)):\r\n        raise TypeError(TYPE_ERROR_MSG)\r\n    \r\n    if any(not isinstance(item, int) or item<0 for item in citations):\r\n        raise ValueError(VALUE_ERROR_MSG)\r\n\r\n\r\ndef h_index(citations: Sequence[int]) -> int:\r\n    \"\"\"Return the highest number of papers h having at least h citations\"\"\"\r\n    _check_valid_input(citations)\r\n    \r\n    count = Counter(citations)\r\n\r\n    for i in range(len(citations),0,-1):\r\n        if sum(n_papers for n_citations, n_papers in count.items() if n_citations >=i) >= i:\r\n            return i\r\n\r\n\r\ndef i10_index(citations: Sequence[int]) -> int:\r\n    \"\"\"Return the number of papers having at least 10 citations\"\"\"\r\n    _check_valid_input(citations)\r\n\r\n    count = Counter(citations)\r\n    return sum(n_papers for n_citations, n_papers in count.items() if n_citations >=10)\r\n    \r\n\r\nprint(h_index([0, 0, 11, 1, 10, 5, 10, 5]))\r\n\r\nprint(i10_index([0, 0, 11, 1, 10, 5, 10, 3]))",
            "date": "2022-12-07 17:11:21.404145+00:00",
            "passed": false
        },
        {
            "bite": "Bite 348. Citation indexes",
            "code": "from typing import Sequence\r\nfrom collections import Counter\r\n\r\nTYPE_ERROR_MSG = \"Unsupported input type: use either a list or a tuple\"\r\nVALUE_ERROR_MSG = \"Unsupported input value: citations cannot be neither empty nor None\"\r\n\r\ndef _check_valid_input(citations):\r\n    if citations is None:\r\n        raise ValueError(VALUE_ERROR_MSG)\r\n        \r\n    if not isinstance(citations, (list, tuple)):\r\n        raise TypeError(TYPE_ERROR_MSG)\r\n    \r\n    if not citations or any(not isinstance(item, int) or item<0 for item in citations):\r\n        raise ValueError(VALUE_ERROR_MSG)\r\n\r\n\r\ndef h_index(citations: Sequence[int]) -> int:\r\n    \"\"\"Return the highest number of papers h having at least h citations\"\"\"\r\n    _check_valid_input(citations)\r\n    \r\n    count = Counter(citations)\r\n\r\n    for i in range(len(citations),0,-1):\r\n        if sum(n_papers for n_citations, n_papers in count.items() if n_citations >=i) >= i:\r\n            return i\r\n\r\n\r\ndef i10_index(citations: Sequence[int]) -> int:\r\n    \"\"\"Return the number of papers having at least 10 citations\"\"\"\r\n    _check_valid_input(citations)\r\n\r\n    count = Counter(citations)\r\n    return sum(n_papers for n_citations, n_papers in count.items() if n_citations >=10)\r\n    \r\n\r\nprint(h_index([0, 0, 11, 1, 10, 5, 10, 5]))\r\n\r\nprint(i10_index([0, 0, 11, 1, 10, 5, 10, 3]))",
            "date": "2022-12-07 17:11:02.989133+00:00",
            "passed": false
        },
        {
            "bite": "Bite 351. Get spelling suggestions",
            "code": "from typing import List, NamedTuple\r\n\r\nfrom textblob import Word\r\n\r\nfrom collections import namedtuple\r\n\r\nMIN_CONFIDENCE = 0.5\r\n\r\n\r\n# define SuggestedWord NamedTuple with attributes\r\n# word (str) and confidence (float)\r\nSuggestedWord = namedtuple('SuggestedWord', ['word','confidence'])\r\n\r\n\r\ndef get_spelling_suggestions(\r\n    word: str, min_confidence: float = MIN_CONFIDENCE\r\n) -> List[SuggestedWord]:\r\n    \"\"\"\r\n    Find spelling suggestions with at least minimum confidence score\r\n    Use textblob.Word (check out the docs)\r\n    \"\"\"\r\n    w = Word(word)\r\n    return [SuggestedWord(word, confidence) for word, confidence in w.spellcheck() if confidence >= min_confidence]\r\n\r\n\r\n\"\"\"\r\nprint(get_spelling_suggestions('pron', min_confidence=0.1))\r\n\"\"\"",
            "date": "2022-12-06 19:10:11.006853+00:00",
            "passed": true
        },
        {
            "bite": "Bite 351. Get spelling suggestions",
            "code": "from typing import List, NamedTuple\r\n\r\nfrom textblob import Word\r\n\r\nfrom collections import namedtuple\r\n\r\nMIN_CONFIDENCE = 0.5\r\n\r\n\r\n# define SuggestedWord NamedTuple with attributes\r\n# word (str) and confidence (float)\r\nSuggestedWord = namedtuple('SuggestedWord', ['word','confidence'])\r\n\r\n\r\ndef get_spelling_suggestions(\r\n    word: str, min_confidence: float = MIN_CONFIDENCE\r\n) -> List[SuggestedWord]:\r\n    \"\"\"\r\n    Find spelling suggestions with at least minimum confidence score\r\n    Use textblob.Word (check out the docs)\r\n    \"\"\"\r\n    w = Word(word)\r\n    return [SuggestedWord(word, confidence) for word, confidence in w.spellcheck() if confidence >= min_confidence]\r\n",
            "date": "2022-12-06 19:06:44.793512+00:00",
            "passed": true
        },
        {
            "bite": "Bite 243. Test code that parses JSON and IP ranges",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom ipaddress import IPv4Network\r\nfrom urllib.request import urlretrieve\r\n\r\nimport pytest\r\n\r\nfrom ips import (ServiceIPRange, parse_ipv4_service_ranges,\r\n                 get_aws_service_range)\r\n\r\nURL = \"https://bites-data.s3.us-east-2.amazonaws.com/ip-ranges.json\"\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nPATH = Path(TMP, \"ip-ranges.json\")\r\nIP = IPv4Network('192.0.2.8/29')\r\n\r\n\r\n@pytest.fixture(scope='module')\r\ndef json_file():\r\n    \"\"\"Import data into tmp folder\"\"\"\r\n    urlretrieve(URL, PATH)\r\n    return PATH\r\n\r\n\r\n# write your pytest code ...\r\n\r\n@pytest.mark.parametrize(\"service, region, cidr\", [\r\n    ('AMAZON', 'af-south-1', '3.2.34.0/26' ),\r\n])\r\ndef test_ServiceIPRange(service, region, cidr):\r\n    ip_range= ServiceIPRange(\r\n                service=service,\r\n                region=region,\r\n                cidr=IPv4Network(cidr))\r\n\r\n    expected_str = f\"{cidr} is allocated to the {service} service in the {region} region\"\r\n\r\n    assert str(ip_range) == expected_str\r\n\r\n\r\ndef test_ServiceIPRange_invalid_ip():\r\n    with pytest.raises(ValueError):\r\n        ip_range= ServiceIPRange(\r\n                service='foo',\r\n                region='bar',\r\n                cidr=IPv4Network('invalid'))\r\n\r\n\r\ndef test_parse_ipv4_service_ranges(json_file):\r\n    ip_ranges = parse_ipv4_service_ranges(json_file)\r\n    assert len(ip_ranges) == 1886\r\n    assert ip_ranges[0].cidr == IPv4Network(\"13.248.118.0/24\")\r\n    assert ip_ranges[0].region == \"eu-west-1\"\r\n    assert ip_ranges[0].service == \"AMAZON\"\r\n    assert ip_ranges[-1].cidr == IPv4Network(\"54.250.251.0/24\")\r\n    assert ip_ranges[-1].region == \"ap-northeast-1\"\r\n    assert ip_ranges[-1].service == \"WORKSPACES_GATEWAYS\"\r\n\r\n\r\n@pytest.mark.parametrize(\"address, expected\", [\r\n            ('0.0.0.0', []),\r\n            ('255.255.255.255', []),\r\n            ('54.153.254.10', [\r\n                            ServiceIPRange(\r\n                            service='AMAZON', \r\n                            region='ap-southeast-2', \r\n                            cidr=IPv4Network('54.153.128.0/17')), \r\n                        ServiceIPRange(\r\n                            service='EC2', \r\n                            region='ap-southeast-2', \r\n                            cidr=IPv4Network('54.153.128.0/17')), \r\n                        ServiceIPRange(\r\n                            service='WORKSPACES_GATEWAYS', \r\n                            region='ap-southeast-2', \r\n                            cidr=IPv4Network('54.153.254.0/24'))\r\n                        ]),\r\n    ])\r\ndef test_get_aws_service_range(address, expected, json_file):\r\n    service_range = get_aws_service_range(address, parse_ipv4_service_ranges(json_file))\r\n    assert service_range == expected\r\n    \r\n\r\ndef test_get_aws_service_range_invalid_ip(json_file):\r\n    with pytest.raises(ValueError,match=r\"Address must be a valid IPv4 address\"):\r\n        service_range = get_aws_service_range(\r\n            'invalid',\r\n            parse_ipv4_service_ranges(json_file))\r\n\r\n\r\n\"\"\"\r\nurlretrieve(URL, PATH)\r\nprint(get_aws_service_range('54.153.254.10', parse_ipv4_service_ranges(PATH)))\r\n\"\"\"\r\n",
            "date": "2022-12-06 18:49:15.960137+00:00",
            "passed": true
        },
        {
            "bite": "Bite 243. Test code that parses JSON and IP ranges",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom ipaddress import IPv4Network\r\nfrom urllib.request import urlretrieve\r\n\r\nimport pytest\r\n\r\nfrom ips import (ServiceIPRange, parse_ipv4_service_ranges,\r\n                 get_aws_service_range)\r\n\r\nURL = \"https://bites-data.s3.us-east-2.amazonaws.com/ip-ranges.json\"\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nPATH = Path(TMP, \"ip-ranges.json\")\r\nIP = IPv4Network('192.0.2.8/29')\r\n\r\n\r\n@pytest.fixture(scope='module')\r\ndef json_file():\r\n    \"\"\"Import data into tmp folder\"\"\"\r\n    urlretrieve(URL, PATH)\r\n    return PATH\r\n\r\n\r\n# write your pytest code ...\r\n\r\n@pytest.mark.parametrize(\"service, region, cidr\", [\r\n    ('AMAZON', 'af-south-1', '3.2.34.0/26' ),\r\n])\r\ndef test_ServiceIPRange(service, region, cidr):\r\n    ip_range= ServiceIPRange(\r\n                service=service,\r\n                region=region,\r\n                cidr=IPv4Network(cidr))\r\n\r\n    expected_str = f\"{cidr} is allocated to the {service} service in the {region} region\"\r\n\r\n    assert str(ip_range) == expected_str\r\n\r\n\r\ndef test_ServiceIPRange_invalid_ip():\r\n    with pytest.raises(ValueError):\r\n        ip_range= ServiceIPRange(\r\n                service='foo',\r\n                region='bar',\r\n                cidr=IPv4Network('invalid'))\r\n\r\n\r\ndef test_parse_ipv4_service_ranges(json_file):\r\n    ip_ranges = parse_ipv4_service_ranges(json_file)\r\n    assert len(ip_ranges) == 1886\r\n    assert ip_ranges[0].cidr == IPv4Network(\"13.248.118.0/24\")\r\n    assert ip_ranges[0].region == \"eu-west-1\"\r\n    assert ip_ranges[0].service == \"AMAZON\"\r\n    assert ip_ranges[-1].cidr == IPv4Network(\"54.250.251.0/24\")\r\n    assert ip_ranges[-1].region == \"ap-northeast-1\"\r\n    assert ip_ranges[-1].service == \"WORKSPACES_GATEWAYS\"\r\n\r\n\r\n@pytest.mark.parametrize(\"address, expected\", [\r\n            ('0.0.0.0', []),\r\n            ('255.255.255.255', []),\r\n            ('54.153.254.10', [\r\n                            ServiceIPRange(\r\n                            service='AMAZON', \r\n                            region='ap-southeast-2', \r\n                            cidr=IPv4Network('54.153.128.0/17')), \r\n                        ServiceIPRange(\r\n                            service='EC2', \r\n                            region='ap-southeast-2', \r\n                            cidr=IPv4Network('54.153.128.0/17')), \r\n                        ServiceIPRange(\r\n                            service='WORKSPACES_GATEWAYS', \r\n                            region='ap-southeast-2', \r\n                            cidr=IPv4Network('54.153.254.0/24'))\r\n                        ]),\r\n    ])\r\ndef test_get_aws_service_range(address, expected, json_file):\r\n    service_range = get_aws_service_range(address, parse_ipv4_service_ranges(json_file))\r\n    assert service_range == expected\r\n    \r\n\r\ndef test_get_aws_service_range_invalid_ip(json_file):\r\n    with pytest.raises(ValueError,match=r\"Address must be a valid IPv4 address\"):\r\n        service_range = get_aws_service_range(\r\n            'invalid',\r\n            parse_ipv4_service_ranges(json_file))\r\n\r\n\r\nurlretrieve(URL, PATH)\r\nprint(get_aws_service_range('54.153.254.10', parse_ipv4_service_ranges(PATH)))\r\n\r\n",
            "date": "2022-12-06 18:48:57.480764+00:00",
            "passed": false
        },
        {
            "bite": "Bite 243. Test code that parses JSON and IP ranges",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom ipaddress import IPv4Network\r\nfrom urllib.request import urlretrieve\r\n\r\nimport pytest\r\n\r\nfrom ips import (ServiceIPRange, parse_ipv4_service_ranges,\r\n                 get_aws_service_range)\r\n\r\nURL = \"https://bites-data.s3.us-east-2.amazonaws.com/ip-ranges.json\"\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nPATH = Path(TMP, \"ip-ranges.json\")\r\nIP = IPv4Network('192.0.2.8/29')\r\n\r\n\r\n@pytest.fixture(scope='module')\r\ndef json_file():\r\n    \"\"\"Import data into tmp folder\"\"\"\r\n    urlretrieve(URL, PATH)\r\n    return PATH\r\n\r\n\r\n# write your pytest code ...\r\n\r\n@pytest.mark.parametrize(\"service, region, cidr\", [\r\n    ('AMAZON', 'af-south-1', '3.2.34.0/26' ),\r\n])\r\ndef test_ServiceIPRange(service, region, cidr):\r\n    ip_range= ServiceIPRange(\r\n                service=service,\r\n                region=region,\r\n                cidr=IPv4Network(cidr))\r\n\r\n    expected_str = f\"{cidr} is allocated to the {service} service in the {region} region\"\r\n\r\n    assert str(ip_range) == expected_str\r\n\r\n\r\ndef test_ServiceIPRange_invalid_ip():\r\n    with pytest.raises(ValueError):\r\n        ip_range= ServiceIPRange(\r\n                service='foo',\r\n                region='bar',\r\n                cidr=IPv4Network('invalid'))\r\n\r\n\r\ndef test_parse_ipv4_service_ranges(json_file):\r\n    ip_ranges = parse_ipv4_service_ranges(json_file)\r\n    assert len(ip_ranges) == 1886\r\n    assert ip_ranges[0].cidr == IPv4Network(\"13.248.118.0/24\")\r\n    assert ip_ranges[0].region == \"eu-west-1\"\r\n    assert ip_ranges[0].service == \"AMAZON\"\r\n    assert ip_ranges[-1].cidr == IPv4Network(\"54.250.251.0/24\")\r\n    assert ip_ranges[-1].region == \"ap-northeast-1\"\r\n    assert ip_ranges[-1].service == \"WORKSPACES_GATEWAYS\"\r\n\r\n\r\n@pytest.mark.parametrize(\"address, expected\", [\r\n    ('0.0.0.0', []),\r\n    ('255.255.255.255', []),\r\n    ('54.153.254.10', [\r\n        ServiceIPRange(service='AMAZON', region='ap-southeast-2', cidr=IPv4Network('54.153.128.0/17')), \r\n        ServiceIPRange(service='EC2', region='ap-southeast-2', cidr=IPv4Network('54.153.128.0/17')), \r\n        ServiceIPRange(service='WORKSPACES_GATEWAYS', region='ap-southeast-2', cidr=IPv4Network('54.153.254.0/24'))\r\n        ]),\r\ndef test_get_aws_service_range(address, expected, json_file):\r\n    service_range = get_aws_service_range(address, parse_ipv4_service_ranges(json_file))\r\n    assert service_range == expected\r\n    \r\n\r\ndef test_get_aws_service_range_invalid_ip(json_file):\r\n    with pytest.raises(ValueError,match=r\"Address must be a valid IPv4 address\"):\r\n        service_range = get_aws_service_range(\r\n            'invalid',\r\n            parse_ipv4_service_ranges(json_file))\r\n\r\n\r\nurlretrieve(URL, PATH)\r\nprint(get_aws_service_range('54.153.254.10', parse_ipv4_service_ranges(PATH)))\r\n\r\n",
            "date": "2022-12-06 18:46:28.040770+00:00",
            "passed": false
        },
        {
            "bite": "Bite 243. Test code that parses JSON and IP ranges",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom ipaddress import IPv4Network\r\nfrom urllib.request import urlretrieve\r\n\r\nimport pytest\r\n\r\nfrom ips import (ServiceIPRange, parse_ipv4_service_ranges,\r\n                 get_aws_service_range)\r\n\r\nURL = \"https://bites-data.s3.us-east-2.amazonaws.com/ip-ranges.json\"\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nPATH = Path(TMP, \"ip-ranges.json\")\r\nIP = IPv4Network('192.0.2.8/29')\r\n\r\n\r\n@pytest.fixture(scope='module')\r\ndef json_file():\r\n    \"\"\"Import data into tmp folder\"\"\"\r\n    urlretrieve(URL, PATH)\r\n    return PATH\r\n\r\n\r\n# write your pytest code ...\r\n\r\n@pytest.mark.parametrize(\"service, region, cidr\", [\r\n    ('AMAZON', 'af-south-1', '3.2.34.0/26' ),\r\n])\r\ndef test_ServiceIPRange(service, region, cidr):\r\n    ip_range= ServiceIPRange(\r\n                service=service,\r\n                region=region,\r\n                cidr=IPv4Network(cidr))\r\n\r\n    expected_str = f\"{cidr} is allocated to the {service} service in the {region} region\"\r\n\r\n    assert str(ip_range) == expected_str\r\n\r\n\r\ndef test_ServiceIPRange_invalid_ip():\r\n    with pytest.raises(ValueError):\r\n        ip_range= ServiceIPRange(\r\n                service='foo',\r\n                region='bar',\r\n                cidr=IPv4Network('invalid'))\r\n\r\n\r\ndef test_parse_ipv4_service_ranges(json_file):\r\n    ip_ranges = parse_ipv4_service_ranges(json_file)\r\n    assert len(ip_ranges) == 1886\r\n    assert ip_ranges[0].cidr == IPv4Network(\"13.248.118.0/24\")\r\n    assert ip_ranges[0].region == \"eu-west-1\"\r\n    assert ip_ranges[0].service == \"AMAZON\"\r\n    assert ip_ranges[-1].cidr == IPv4Network(\"54.250.251.0/24\")\r\n    assert ip_ranges[-1].region == \"ap-northeast-1\"\r\n    assert ip_ranges[-1].service == \"WORKSPACES_GATEWAYS\"\r\n\r\n\r\n@pytest.mark.parametrize(\"address, expected\", [\r\n    ('0.0.0.0', []),\r\n    ('255.255.255.255', []),\r\n    ('54.153.254.10', []),\r\n])\r\ndef test_get_aws_service_range(address, expected, json_file):\r\n    service_range = get_aws_service_range(address, parse_ipv4_service_ranges(json_file))\r\n    assert service_range == expected\r\n    \r\n\r\ndef test_get_aws_service_range_invalid_ip(json_file):\r\n    with pytest.raises(ValueError,match=r\"Address must be a valid IPv4 address\"):\r\n        service_range = get_aws_service_range(\r\n            'invalid',\r\n            parse_ipv4_service_ranges(json_file))\r\n\r\n\r\nurlretrieve(URL, PATH)\r\nprint(get_aws_service_range('54.153.254.10', parse_ipv4_service_ranges(PATH)))\r\n\r\n",
            "date": "2022-12-06 18:44:57.354810+00:00",
            "passed": false
        },
        {
            "bite": "Bite 243. Test code that parses JSON and IP ranges",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom ipaddress import IPv4Network\r\nfrom urllib.request import urlretrieve\r\n\r\nimport pytest\r\n\r\nfrom ips import (ServiceIPRange, parse_ipv4_service_ranges,\r\n                 get_aws_service_range)\r\n\r\nURL = \"https://bites-data.s3.us-east-2.amazonaws.com/ip-ranges.json\"\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nPATH = Path(TMP, \"ip-ranges.json\")\r\nIP = IPv4Network('192.0.2.8/29')\r\n\r\n\r\n@pytest.fixture(scope='module')\r\ndef json_file():\r\n    \"\"\"Import data into tmp folder\"\"\"\r\n    urlretrieve(URL, PATH)\r\n    return PATH\r\n\r\n\r\n# write your pytest code ...\r\n\r\n@pytest.mark.parametrize(\"service, region, cidr\", [\r\n    ('AMAZON', 'af-south-1', '3.2.34.0/26' ),\r\n])\r\ndef test_ServiceIPRange(service, region, cidr):\r\n    ip_range= ServiceIPRange(\r\n                service=service,\r\n                region=region,\r\n                cidr=IPv4Network(cidr))\r\n\r\n    expected_str = f\"{cidr} is allocated to the {service} service in the {region} region\"\r\n\r\n    assert str(ip_range) == expected_str\r\n\r\n\r\ndef test_ServiceIPRange_invalid_ip():\r\n    with pytest.raises(ValueError):\r\n        ip_range= ServiceIPRange(\r\n                service='foo',\r\n                region='bar',\r\n                cidr=IPv4Network('invalid'))\r\n\r\n\r\ndef test_parse_ipv4_service_ranges(json_file):\r\n    ip_ranges = parse_ipv4_service_ranges(json_file)\r\n    assert len(ip_ranges) == 1886\r\n    assert ip_ranges[0].cidr == IPv4Network(\"13.248.118.0/24\")\r\n    assert ip_ranges[0].region == \"eu-west-1\"\r\n    assert ip_ranges[0].service == \"AMAZON\"\r\n    assert ip_ranges[-1].cidr == IPv4Network(\"54.250.251.0/24\")\r\n    assert ip_ranges[-1].region == \"ap-northeast-1\"\r\n    assert ip_ranges[-1].service == \"WORKSPACES_GATEWAYS\"\r\n\r\n\r\n@pytest.mark.parametrize(\"address, expected\", [\r\n    ('0.0.0.0', []),\r\n    ('255.255.255.255', []),\r\n    ('54.153.254.10', []),\r\n])\r\ndef test_get_aws_service_range(address, expected, json_file):\r\n    service_range = get_aws_service_range(address, parse_ipv4_service_ranges(json_file))\r\n    assert service_range == expected\r\n    \r\n\r\ndef test_get_aws_service_range_invalid_ip(json_file):\r\n    with pytest.raises(ValueError,match=r\"Address must be a valid IPv4 address\"):\r\n        service_range = get_aws_service_range(\r\n            'invalid',\r\n            parse_ipv4_service_ranges(json_file))\r\n\r\n\r\nprint(get_aws_service_range('54.153.254.10', parse_ipv4_service_ranges(json_file())))\r\n\r\n",
            "date": "2022-12-06 18:43:41.363081+00:00",
            "passed": false
        },
        {
            "bite": "Bite 256. Scrape PyCon events",
            "code": "import json\r\nfrom collections import namedtuple\r\nfrom typing import List\r\n\r\nimport requests\r\nfrom bs4 import BeautifulSoup as Soup\r\nfrom dateutil.parser import parse\r\n\r\nfrom datetime import datetime\r\nfrom pprint import pprint\r\n\r\nPYCON_DATA = \"https://bites-data.s3.us-east-2.amazonaws.com/pycons.html\"\r\n\r\nPyCon = namedtuple(\"PyCon\", \"name city country start_date end_date url\")\r\n\r\ncountry_lookup = {\r\n    \"Africa\": [\r\n        \"Algeria\", \"Angola\", \"Benin\", \"Botswana\",\r\n        \"Burkina Faso\", \"Burundi\", \"Cameroon\", \"Cape Verde\",\r\n        \"Central African Republic\", \"Chad\", \"Comoros\",\r\n        \"Democratic Republic of the Congo\",\r\n        \"Djibouti\", \"Egypt\", \"Equatorial Guinea\", \"Eritrea\",\r\n        \"Ethiopia\", \"Gabon\", \"Ghana\", \"Guinea\", \"Guinea-Bissau\",\r\n        \"Ivory Coast\", \"Kenya\", \"Lesotho\", \"Liberia\",\r\n        \"Libya\", \"Madagascar\", \"Malawi\", \"Mali\",\r\n        \"Mauritania\", \"Mauritius\", \"Morocco\", \"Mozambique\",\r\n        \"Namibia\", \"Niger\", \"Nigeria\", \"Republic of the Congo\",\r\n        \"Rwanda\", \"S\u00e3o Tome and Principe\", \"Senegal\", \"Seychelles\",\r\n        \"Sierra Leone\", \"Somalia\", \"South Africa\", \"South Sudan\",\r\n        \"Sudan\", \"Swaziland\", \"Tanzania\", \"The Gambia\",\r\n        \"Togo\", \"Tunisia\", \"Uganda\", \"Zambia\", \"Zimbabwe\",\r\n    ],\r\n    \"Asia\": [\r\n        \"Afghanistan\", \"Armenia\", \"Azerbaijan\", \"Bahrain\",\r\n        \"Bangladesh\", \"Bhutan\", \"Brunei\", \"Cambodia\",\r\n        \"China\", \"East Timor\", \"Georgia\", \"India\",\r\n        \"Indonesia\", \"Iran\", \"Iraq\", \"Israel\",\r\n        \"Japan\", \"Jordan\", \"Kazakhstan\", \"Kuwait\",\r\n        \"Kyrgyzstan\", \"Laos\", \"Lebanon\", \"Malaysia\",\r\n        \"Maldives\", \"Mongolia\", \"Myanmar\", \"Nepal\",\r\n        \"North Korea\", \"Oman\", \"Pakistan\", \"Palestinian territories\",\r\n        \"Philippines\", \"Qatar\", \"Saudi Arabia\", \"Singapore\",\r\n        \"South Korea\", \"Sri Lanka\", \"Syria\", \"Taiwan\",\r\n        \"Tajikistan\", \"Thailand\", \"Turkey\", \"Turkmenistan\",\r\n        \"United Arab Emirates\", \"Uzbekistan\", \"Vietnam\",\r\n        \"Yemen\",\r\n    ],\r\n    \"Australia and Oceania\": [\r\n        \"Australia\", \"Federated States of Micronesia\", \"Fiji\",\r\n        \"Kiribati\", \"Marshall Islands\", \"Nauru\", \"New Zealand\",\r\n        \"Palau\", \"Papua New Guinea\", \"Samoa\", \"Solomon Islands\",\r\n        \"Tonga\", \"Tuvalu\", \"Vanuatu\",\r\n    ],\r\n    \"Europe\": [\r\n        \"Albania\", \"Andorra\", \"Austria\", \"Belarus\", \"Belgium\",\r\n        \"Bosnia and Herzegovina\", \"Bulgaria\", \"Croatia\", \"Cyprus\",\r\n        \"Czech Republic\", \"Denmark\", \"Estonia\", \"Finland\",\r\n        \"France\", \"Germany\", \"Greece\", \"Hungary\", \"Iceland\",\r\n        \"Italy\", \"Latvia\", \"Liechtenstein\", \"Lithuania\",\r\n        \"Luxembourg\", \"Malta\", \"Moldova\", \"Monaco\",\r\n        \"Montenegro\", \"Netherlands\", \"Norway\", \"Poland\",\r\n        \"Portugal\", \"Republic of Ireland\", \"Republic of Macedonia\",\r\n        \"Romania\", \"Russia\", \"San Marino\", \"Serbia\", \"Slovakia\",\r\n        \"Slovenia\", \"Spain\", \"Sweden\", \"Switzerland\",\r\n        \"Ukraine\", \"United Kingdom\", \"U.K.\", \"Vatican City\",\r\n    ],\r\n    \"North America\": [\r\n        \"Antigua and Barbuda\", \"Barbados\", \"Belize\",\r\n        \"Canada\", \"Costa Rica\", \"Cuba\", \"Dominica\",\r\n        \"Dominican Republic\", \"El Salvador\", \"Grenada\",\r\n        \"Guatemala\", \"Haiti\", \"Honduras\", \"Jamaica\",\r\n        \"Mexico\", \"Nicaragua\", \"Panama\", \"Saint Kitts and Nevis\",\r\n        \"Saint Lucia\", \"Saint Vincent and the Grenadines\",\r\n        \"The Bahamas\", \"Trinidad and Tobago\",\r\n        \"United States of America\", \"U.S.A.\",\r\n    ],\r\n    \"South America\": [\r\n        \"Argentina\", \"Bolivia\", \"Brazil\", \"Chile\",\r\n        \"Colombia\", \"Ecuador\", \"Guyana\", \"Paraguay\",\r\n        \"Peru\", \"Suriname\", \"Uruguay\", \"Venezuela\",\r\n    ],\r\n}\r\n\r\n\r\ndef get_continent(country: str) -> str:\r\n    \"\"\"\r\n    Given a country name returns the associated continent of the country.\r\n\r\n    :param country: The name of the country\r\n    :type country: str\r\n    :returns: The continent of the country\r\n    :rtype: str\r\n    \"\"\"\r\n    for continent, countries in country_lookup.items():\r\n        for c in countries:\r\n            if country.lower() in c.lower():\r\n                return continent\r\n\r\n\r\ndef _get_pycon_data():\r\n    \"\"\"Helper function that retrieves the required PyCon data\"\"\"\r\n    with requests.Session() as session:\r\n        return session.get(PYCON_DATA).content.decode(\"utf-8\")\r\n\r\n\r\ndef get_pycon_events(data=_get_pycon_data()) -> List[PyCon]:\r\n    \"\"\"\r\n    Scrape the PyCon events from the given website data and\r\n    return a list of PyCon namedtuples. Pay attention to the\r\n    application/ld+json data structure website data.\r\n    \"\"\"\r\n    result = []\r\n    soup = Soup(data, \"html.parser\")\r\n    scripts = soup.find_all(\"script\", {\"type\": \"application/ld+json\"})\r\n    for item in scripts:\r\n        script=json.loads(item.text)\r\n        name=script['name']\r\n        city=script['location']['address']['addressLocality']\r\n        country=script['location']['address']['addressCountry']\r\n        start_date=datetime.strptime(script['startDate'],'%Y-%m-%d')\r\n        end_date=datetime.strptime(script['endDate'],'%Y-%m-%d')\r\n        url=script['url']\r\n        conference=PyCon(name,city,country,start_date, end_date,url)\r\n\r\n        if 'pycon' in name.lower():\r\n            result.append(conference)\r\n    return result\r\n\r\n\r\ndef filter_pycons(pycons: List[PyCon],\r\n                  year: int = 2019,\r\n                  continent: str = \"Europe\") -> List[PyCon]:\r\n    \"\"\"\r\n    Given a list of PyCons a year and a continent return\r\n    a list of PyCons that take place in that year and on\r\n    that continent.\r\n    \"\"\"\r\n    return list(pycon for pycon in pycons if pycon.start_date.year == year and get_continent(pycon.country) == continent)\r\n        \r\n\r\npycons = get_pycon_events()\r\npprint(filter_pycons(pycons, 2019, \"Europe\"))",
            "date": "2022-12-05 18:13:01.725889+00:00",
            "passed": true
        },
        {
            "bite": "Bite 256. Scrape PyCon events",
            "code": "import json\r\nfrom collections import namedtuple\r\nfrom typing import List\r\n\r\nimport requests\r\nfrom bs4 import BeautifulSoup as Soup\r\nfrom dateutil.parser import parse\r\n\r\nfrom datetime import datetime\r\nfrom pprint import pprint\r\n\r\nPYCON_DATA = \"https://bites-data.s3.us-east-2.amazonaws.com/pycons.html\"\r\n\r\nPyCon = namedtuple(\"PyCon\", \"name city country start_date end_date url\")\r\n\r\ncountry_lookup = {\r\n    \"Africa\": [\r\n        \"Algeria\", \"Angola\", \"Benin\", \"Botswana\",\r\n        \"Burkina Faso\", \"Burundi\", \"Cameroon\", \"Cape Verde\",\r\n        \"Central African Republic\", \"Chad\", \"Comoros\",\r\n        \"Democratic Republic of the Congo\",\r\n        \"Djibouti\", \"Egypt\", \"Equatorial Guinea\", \"Eritrea\",\r\n        \"Ethiopia\", \"Gabon\", \"Ghana\", \"Guinea\", \"Guinea-Bissau\",\r\n        \"Ivory Coast\", \"Kenya\", \"Lesotho\", \"Liberia\",\r\n        \"Libya\", \"Madagascar\", \"Malawi\", \"Mali\",\r\n        \"Mauritania\", \"Mauritius\", \"Morocco\", \"Mozambique\",\r\n        \"Namibia\", \"Niger\", \"Nigeria\", \"Republic of the Congo\",\r\n        \"Rwanda\", \"S\u00e3o Tome and Principe\", \"Senegal\", \"Seychelles\",\r\n        \"Sierra Leone\", \"Somalia\", \"South Africa\", \"South Sudan\",\r\n        \"Sudan\", \"Swaziland\", \"Tanzania\", \"The Gambia\",\r\n        \"Togo\", \"Tunisia\", \"Uganda\", \"Zambia\", \"Zimbabwe\",\r\n    ],\r\n    \"Asia\": [\r\n        \"Afghanistan\", \"Armenia\", \"Azerbaijan\", \"Bahrain\",\r\n        \"Bangladesh\", \"Bhutan\", \"Brunei\", \"Cambodia\",\r\n        \"China\", \"East Timor\", \"Georgia\", \"India\",\r\n        \"Indonesia\", \"Iran\", \"Iraq\", \"Israel\",\r\n        \"Japan\", \"Jordan\", \"Kazakhstan\", \"Kuwait\",\r\n        \"Kyrgyzstan\", \"Laos\", \"Lebanon\", \"Malaysia\",\r\n        \"Maldives\", \"Mongolia\", \"Myanmar\", \"Nepal\",\r\n        \"North Korea\", \"Oman\", \"Pakistan\", \"Palestinian territories\",\r\n        \"Philippines\", \"Qatar\", \"Saudi Arabia\", \"Singapore\",\r\n        \"South Korea\", \"Sri Lanka\", \"Syria\", \"Taiwan\",\r\n        \"Tajikistan\", \"Thailand\", \"Turkey\", \"Turkmenistan\",\r\n        \"United Arab Emirates\", \"Uzbekistan\", \"Vietnam\",\r\n        \"Yemen\",\r\n    ],\r\n    \"Australia and Oceania\": [\r\n        \"Australia\", \"Federated States of Micronesia\", \"Fiji\",\r\n        \"Kiribati\", \"Marshall Islands\", \"Nauru\", \"New Zealand\",\r\n        \"Palau\", \"Papua New Guinea\", \"Samoa\", \"Solomon Islands\",\r\n        \"Tonga\", \"Tuvalu\", \"Vanuatu\",\r\n    ],\r\n    \"Europe\": [\r\n        \"Albania\", \"Andorra\", \"Austria\", \"Belarus\", \"Belgium\",\r\n        \"Bosnia and Herzegovina\", \"Bulgaria\", \"Croatia\", \"Cyprus\",\r\n        \"Czech Republic\", \"Denmark\", \"Estonia\", \"Finland\",\r\n        \"France\", \"Germany\", \"Greece\", \"Hungary\", \"Iceland\",\r\n        \"Italy\", \"Latvia\", \"Liechtenstein\", \"Lithuania\",\r\n        \"Luxembourg\", \"Malta\", \"Moldova\", \"Monaco\",\r\n        \"Montenegro\", \"Netherlands\", \"Norway\", \"Poland\",\r\n        \"Portugal\", \"Republic of Ireland\", \"Republic of Macedonia\",\r\n        \"Romania\", \"Russia\", \"San Marino\", \"Serbia\", \"Slovakia\",\r\n        \"Slovenia\", \"Spain\", \"Sweden\", \"Switzerland\",\r\n        \"Ukraine\", \"United Kingdom\", \"U.K.\", \"Vatican City\",\r\n    ],\r\n    \"North America\": [\r\n        \"Antigua and Barbuda\", \"Barbados\", \"Belize\",\r\n        \"Canada\", \"Costa Rica\", \"Cuba\", \"Dominica\",\r\n        \"Dominican Republic\", \"El Salvador\", \"Grenada\",\r\n        \"Guatemala\", \"Haiti\", \"Honduras\", \"Jamaica\",\r\n        \"Mexico\", \"Nicaragua\", \"Panama\", \"Saint Kitts and Nevis\",\r\n        \"Saint Lucia\", \"Saint Vincent and the Grenadines\",\r\n        \"The Bahamas\", \"Trinidad and Tobago\",\r\n        \"United States of America\", \"U.S.A.\",\r\n    ],\r\n    \"South America\": [\r\n        \"Argentina\", \"Bolivia\", \"Brazil\", \"Chile\",\r\n        \"Colombia\", \"Ecuador\", \"Guyana\", \"Paraguay\",\r\n        \"Peru\", \"Suriname\", \"Uruguay\", \"Venezuela\",\r\n    ],\r\n}\r\n\r\n\r\ndef get_continent(country: str) -> str:\r\n    \"\"\"\r\n    Given a country name returns the associated continent of the country.\r\n\r\n    :param country: The name of the country\r\n    :type country: str\r\n    :returns: The continent of the country\r\n    :rtype: str\r\n    \"\"\"\r\n    for continent, countries in country_lookup.items():\r\n        for c in countries:\r\n            if country.lower() in c.lower():\r\n                return continent\r\n\r\n\r\ndef _get_pycon_data():\r\n    \"\"\"Helper function that retrieves the required PyCon data\"\"\"\r\n    with requests.Session() as session:\r\n        return session.get(PYCON_DATA).content.decode(\"utf-8\")\r\n\r\n\r\ndef get_pycon_events(data=_get_pycon_data()) -> List[PyCon]:\r\n    \"\"\"\r\n    Scrape the PyCon events from the given website data and\r\n    return a list of PyCon namedtuples. Pay attention to the\r\n    application/ld+json data structure website data.\r\n    \"\"\"\r\n    result = []\r\n    soup = Soup(data, \"html.parser\")\r\n    scripts = soup.find_all(\"script\", {\"type\": \"application/ld+json\"})\r\n    for item in scripts:\r\n        script=json.loads(item.text)\r\n        name=script['name']\r\n        city=script['location']['address']['addressLocality']\r\n        country=script['location']['address']['addressCountry']\r\n        start_date=datetime.strptime(script['startDate'],'%Y-%m-%d')\r\n        end_date=datetime.strptime(script['endDate'],'%Y-%m-%d')\r\n        url=script['url']\r\n        conference=PyCon(name,city,country,start_date, end_date,url)\r\n        # print(conference)\r\n        if 'pycon' in name.lower():\r\n            result.append(conference)\r\n    return result\r\n\r\n\r\ndef filter_pycons(pycons: List[PyCon],\r\n                  year: int = 2019,\r\n                  continent: str = \"Europe\") -> List[PyCon]:\r\n    \"\"\"\r\n    Given a list of PyCons a year and a continent return\r\n    a list of PyCons that take place in that year and on\r\n    that continent.\r\n    \"\"\"\r\n    return list(pycon for pycon in pycons if pycon.start_date.year == year and get_continent(pycon.country) == continent)\r\n        \r\n\r\npycons = get_pycon_events()\r\npprint(filter_pycons(pycons, 2019, \"Europe\"))",
            "date": "2022-12-05 18:12:25.393586+00:00",
            "passed": true
        },
        {
            "bite": "Bite 256. Scrape PyCon events",
            "code": "import json\r\nfrom collections import namedtuple\r\nfrom typing import List\r\n\r\nimport requests\r\nfrom bs4 import BeautifulSoup as Soup\r\nfrom dateutil.parser import parse\r\n\r\nfrom datetime import datetime\r\nfrom pprint import pprint\r\n\r\nPYCON_DATA = \"https://bites-data.s3.us-east-2.amazonaws.com/pycons.html\"\r\n\r\nPyCon = namedtuple(\"PyCon\", \"name city country start_date end_date url\")\r\n\r\ncountry_lookup = {\r\n    \"Africa\": [\r\n        \"Algeria\", \"Angola\", \"Benin\", \"Botswana\",\r\n        \"Burkina Faso\", \"Burundi\", \"Cameroon\", \"Cape Verde\",\r\n        \"Central African Republic\", \"Chad\", \"Comoros\",\r\n        \"Democratic Republic of the Congo\",\r\n        \"Djibouti\", \"Egypt\", \"Equatorial Guinea\", \"Eritrea\",\r\n        \"Ethiopia\", \"Gabon\", \"Ghana\", \"Guinea\", \"Guinea-Bissau\",\r\n        \"Ivory Coast\", \"Kenya\", \"Lesotho\", \"Liberia\",\r\n        \"Libya\", \"Madagascar\", \"Malawi\", \"Mali\",\r\n        \"Mauritania\", \"Mauritius\", \"Morocco\", \"Mozambique\",\r\n        \"Namibia\", \"Niger\", \"Nigeria\", \"Republic of the Congo\",\r\n        \"Rwanda\", \"S\u00e3o Tome and Principe\", \"Senegal\", \"Seychelles\",\r\n        \"Sierra Leone\", \"Somalia\", \"South Africa\", \"South Sudan\",\r\n        \"Sudan\", \"Swaziland\", \"Tanzania\", \"The Gambia\",\r\n        \"Togo\", \"Tunisia\", \"Uganda\", \"Zambia\", \"Zimbabwe\",\r\n    ],\r\n    \"Asia\": [\r\n        \"Afghanistan\", \"Armenia\", \"Azerbaijan\", \"Bahrain\",\r\n        \"Bangladesh\", \"Bhutan\", \"Brunei\", \"Cambodia\",\r\n        \"China\", \"East Timor\", \"Georgia\", \"India\",\r\n        \"Indonesia\", \"Iran\", \"Iraq\", \"Israel\",\r\n        \"Japan\", \"Jordan\", \"Kazakhstan\", \"Kuwait\",\r\n        \"Kyrgyzstan\", \"Laos\", \"Lebanon\", \"Malaysia\",\r\n        \"Maldives\", \"Mongolia\", \"Myanmar\", \"Nepal\",\r\n        \"North Korea\", \"Oman\", \"Pakistan\", \"Palestinian territories\",\r\n        \"Philippines\", \"Qatar\", \"Saudi Arabia\", \"Singapore\",\r\n        \"South Korea\", \"Sri Lanka\", \"Syria\", \"Taiwan\",\r\n        \"Tajikistan\", \"Thailand\", \"Turkey\", \"Turkmenistan\",\r\n        \"United Arab Emirates\", \"Uzbekistan\", \"Vietnam\",\r\n        \"Yemen\",\r\n    ],\r\n    \"Australia and Oceania\": [\r\n        \"Australia\", \"Federated States of Micronesia\", \"Fiji\",\r\n        \"Kiribati\", \"Marshall Islands\", \"Nauru\", \"New Zealand\",\r\n        \"Palau\", \"Papua New Guinea\", \"Samoa\", \"Solomon Islands\",\r\n        \"Tonga\", \"Tuvalu\", \"Vanuatu\",\r\n    ],\r\n    \"Europe\": [\r\n        \"Albania\", \"Andorra\", \"Austria\", \"Belarus\", \"Belgium\",\r\n        \"Bosnia and Herzegovina\", \"Bulgaria\", \"Croatia\", \"Cyprus\",\r\n        \"Czech Republic\", \"Denmark\", \"Estonia\", \"Finland\",\r\n        \"France\", \"Germany\", \"Greece\", \"Hungary\", \"Iceland\",\r\n        \"Italy\", \"Latvia\", \"Liechtenstein\", \"Lithuania\",\r\n        \"Luxembourg\", \"Malta\", \"Moldova\", \"Monaco\",\r\n        \"Montenegro\", \"Netherlands\", \"Norway\", \"Poland\",\r\n        \"Portugal\", \"Republic of Ireland\", \"Republic of Macedonia\",\r\n        \"Romania\", \"Russia\", \"San Marino\", \"Serbia\", \"Slovakia\",\r\n        \"Slovenia\", \"Spain\", \"Sweden\", \"Switzerland\",\r\n        \"Ukraine\", \"United Kingdom\", \"U.K.\", \"Vatican City\",\r\n    ],\r\n    \"North America\": [\r\n        \"Antigua and Barbuda\", \"Barbados\", \"Belize\",\r\n        \"Canada\", \"Costa Rica\", \"Cuba\", \"Dominica\",\r\n        \"Dominican Republic\", \"El Salvador\", \"Grenada\",\r\n        \"Guatemala\", \"Haiti\", \"Honduras\", \"Jamaica\",\r\n        \"Mexico\", \"Nicaragua\", \"Panama\", \"Saint Kitts and Nevis\",\r\n        \"Saint Lucia\", \"Saint Vincent and the Grenadines\",\r\n        \"The Bahamas\", \"Trinidad and Tobago\",\r\n        \"United States of America\", \"U.S.A.\",\r\n    ],\r\n    \"South America\": [\r\n        \"Argentina\", \"Bolivia\", \"Brazil\", \"Chile\",\r\n        \"Colombia\", \"Ecuador\", \"Guyana\", \"Paraguay\",\r\n        \"Peru\", \"Suriname\", \"Uruguay\", \"Venezuela\",\r\n    ],\r\n}\r\n\r\n\r\ndef get_continent(country: str) -> str:\r\n    \"\"\"\r\n    Given a country name returns the associated continent of the country.\r\n\r\n    :param country: The name of the country\r\n    :type country: str\r\n    :returns: The continent of the country\r\n    :rtype: str\r\n    \"\"\"\r\n    for continent, countries in country_lookup.items():\r\n        for c in countries:\r\n            if country.lower() in c.lower():\r\n                return continent\r\n\r\n\r\ndef _get_pycon_data():\r\n    \"\"\"Helper function that retrieves the required PyCon data\"\"\"\r\n    with requests.Session() as session:\r\n        return session.get(PYCON_DATA).content.decode(\"utf-8\")\r\n\r\n\r\ndef get_pycon_events(data=_get_pycon_data()) -> List[PyCon]:\r\n    \"\"\"\r\n    Scrape the PyCon events from the given website data and\r\n    return a list of PyCon namedtuples. Pay attention to the\r\n    application/ld+json data structure website data.\r\n    \"\"\"\r\n    result = []\r\n    soup = Soup(data, \"html.parser\")\r\n    scripts = soup.find_all(\"script\", {\"type\": \"application/ld+json\"})\r\n    for item in scripts:\r\n        script=json.loads(item.text)\r\n        name=script['name']\r\n        city=script['location']['address']['addressLocality']\r\n        country=script['location']['address']['addressCountry']\r\n        start_date=datetime.strptime(script['startDate'],'%Y-%m-%d')\r\n        end_date=datetime.strptime(script['endDate'],'%Y-%m-%d')\r\n        url=script['url']\r\n        conference=PyCon(name,city,country,start_date, end_date,url)\r\n        # print(conference)\r\n        if 'pycon' in name.lower():\r\n            result.append(conference)\r\n    return result\r\n\r\n\r\ndef filter_pycons(pycons: List[PyCon],\r\n                  year: int = 2019,\r\n                  continent: str = \"Europe\") -> List[PyCon]:\r\n    \"\"\"\r\n    Given a list of PyCons a year and a continent return\r\n    a list of PyCons that take place in that year and on\r\n    that continent.\r\n    \"\"\"\r\n    pass\r\n\r\npprint(get_pycon_events())",
            "date": "2022-12-05 18:08:18.198435+00:00",
            "passed": false
        },
        {
            "bite": "Bite 111. Use the ipinfo API to lookup IP country",
            "code": "import requests\r\n\r\nIPINFO_URL = 'http://ipinfo.io/{ip}/json'\r\n\r\n\r\ndef get_ip_country(ip_address):\r\n    \"\"\"Receives ip address string, use IPINFO_URL to get geo data,\r\n       parse the json response returning the country code of the IP\"\"\"\r\n    pass\r\n    # send get request and save the response as response object\r\n    response = requests.get(url = IPINFO_URL.format(ip=ip_address))\r\n\r\n    # extract data in json format\r\n    data = response.json()\r\n    \r\n    return data['country']\r\n    \r\n\r\nprint(get_ip_country('8.8.8.8'))\r\n\r\n",
            "date": "2022-12-05 17:16:08.675712+00:00",
            "passed": true
        },
        {
            "bite": "Bite 111. Use the ipinfo API to lookup IP country",
            "code": "import requests\r\n\r\nIPINFO_URL = 'http://ipinfo.io/{ip}/json'\r\n\r\n\r\ndef get_ip_country(ip_address):\r\n    \"\"\"Receives ip address string, use IPINFO_URL to get geo data,\r\n       parse the json response returning the country code of the IP\"\"\"\r\n    pass\r\n    # sending get request and saving the response as response object\r\n    response = requests.get(url = IPINFO_URL.format(ip=ip_address))\r\n\r\n    # extracting data in json format\r\n    data = response.json()\r\n    \r\n    return data['country']\r\n    \r\n\r\nprint(get_ip_country('8.8.8.8'))\r\n\r\n",
            "date": "2022-12-05 17:15:32.652130+00:00",
            "passed": true
        },
        {
            "bite": "Bite 160. 15-way Rock Paper Scissors",
            "code": "import csv\r\nimport os\r\nfrom urllib.request import urlretrieve\r\n\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nDATA = 'battle-table.csv'\r\nBATTLE_DATA = os.path.join(TMP, DATA)\r\nif not os.path.isfile(BATTLE_DATA):\r\n    urlretrieve(\r\n        f'https://bites-data.s3.us-east-2.amazonaws.com/{DATA}',\r\n        BATTLE_DATA\r\n    )\r\n\r\n\r\n\r\ndef _create_defeat_mapping():\r\n    \"\"\"Parse battle-table.csv building up a defeat_mapping dict\r\n       with keys = attackers / values = who they defeat.\r\n    \"\"\"\r\n    with open(BATTLE_DATA) as f:\r\n        reader = csv.DictReader(f)\r\n        headers = reader.fieldnames\r\n        defeat_mapping = {}\r\n        for i,row in enumerate(reader):\r\n            gesture = row['Attacker']\r\n            defeats_lst = [key for key,val in row.items() if val =='win']\r\n            defeat_mapping[gesture]=defeats_lst\r\n        return defeat_mapping\r\n\r\n\r\ndef get_winner(player1, player2, defeat_mapping=None):\r\n    \"\"\"Given player1 and player2 determine game output returning the\r\n       appropriate string:\r\n       Tie\r\n       Player1\r\n       Player2\r\n       (where Player1 and Player2 are the names passed in)\r\n\r\n       Raise a ValueError if invalid player strings are passed in.\r\n    \"\"\"\r\n    defeat_mapping = defeat_mapping or _create_defeat_mapping()\r\n    # ...\r\n    if player1 not in defeat_mapping or player2 not in defeat_mapping:\r\n        raise ValueError('Invalid gesture')\r\n    if player1 ==player2:\r\n        return 'Tie'\r\n    if player2 in defeat_mapping[player1]:\r\n        return player1\r\n    if player1 in defeat_mapping[player2]:\r\n        return player2\r\n",
            "date": "2022-12-04 20:52:36.180950+00:00",
            "passed": true
        },
        {
            "bite": "Bite 160. 15-way Rock Paper Scissors",
            "code": "import csv\r\nimport os\r\nfrom urllib.request import urlretrieve\r\n\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nDATA = 'battle-table.csv'\r\nBATTLE_DATA = os.path.join(TMP, DATA)\r\nif not os.path.isfile(BATTLE_DATA):\r\n    urlretrieve(\r\n        f'https://bites-data.s3.us-east-2.amazonaws.com/{DATA}',\r\n        BATTLE_DATA\r\n    )\r\n\r\n\r\n\r\ndef _create_defeat_mapping():\r\n    \"\"\"Parse battle-table.csv building up a defeat_mapping dict\r\n       with keys = attackers / values = who they defeat.\r\n    \"\"\"\r\n    with open(BATTLE_DATA) as f:\r\n        reader = csv.DictReader(f)\r\n        headers = reader.fieldnames\r\n        defeat_mapping = {}\r\n        for i,row in enumerate(reader):\r\n            gesture = row['Attacker']\r\n            defeats_lst = [key for key,val in row.items() if val =='win']\r\n            defeat_mapping[gesture]=defeats_lst\r\n        return defeat_mapping\r\n\r\n\r\ndef get_winner(player1, player2, defeat_mapping=None):\r\n    \"\"\"Given player1 and player2 determine game output returning the\r\n       appropriate string:\r\n       Tie\r\n       Player1\r\n       Player2\r\n       (where Player1 and Player2 are the names passed in)\r\n\r\n       Raise a ValueError if invalid player strings are passed in.\r\n    \"\"\"\r\n    defeat_mapping = defeat_mapping or _create_defeat_mapping()\r\n    # ...\r\n    if player1 not in defeat_mapping or player2 not in defeat_mapping:\r\n        raise ValueError('Invalid gesture')\r\n    if player1 ==player2:\r\n        return 'Tie'\r\n    if player2 in defeat_mapping[player1]:\r\n        return player1\r\n    if player1 in defeat_mapping[player2]:\r\n        return player2\r\n\r\nprint(_create_defeat_mapping())",
            "date": "2022-12-04 20:51:34.606575+00:00",
            "passed": true
        },
        {
            "bite": "Bite 195. Analyze NBA Data with sqlite3",
            "code": "from collections import namedtuple\r\nimport csv\r\nimport os\r\nfrom pathlib import Path\r\nimport sqlite3\r\nimport random\r\nimport string\r\n\r\nimport requests\r\n\r\nDATA_URL = 'https://query.data.world/s/ezwk64ej624qyverrw6x7od7co7ftm'\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\n\r\nsalt = ''.join(\r\n    random.choice(string.ascii_lowercase) for i in range(20)\r\n)\r\nDB = TMP / f'nba_{salt}.db'\r\n\r\nPlayer = namedtuple('Player', ('name year first_year team college active '\r\n                               'games avg_min avg_points'))\r\n\r\nconn = sqlite3.connect(DB)\r\ncur = conn.cursor()\r\n\r\n\r\ndef import_data():\r\n    with requests.Session() as session:\r\n        content = session.get(DATA_URL).content.decode('utf-8')\r\n\r\n    reader = csv.DictReader(content.splitlines(), delimiter=',')\r\n\r\n    players = []\r\n    for row in reader:\r\n        players.append(Player(name=row['Player'],\r\n                              year=row['Draft_Yr'],\r\n                              first_year=row['first_year'],\r\n                              team=row['Team'],\r\n                              college=row['College'],\r\n                              active=row['Yrs'],\r\n                              games=row['Games'],\r\n                              avg_min=row['Minutes.per.Game'],\r\n                              avg_points=row['Points.per.Game']))\r\n\r\n    cur.execute('''CREATE TABLE IF NOT EXISTS players\r\n                  (name, year, first_year, team, college, active,\r\n                  games, avg_min, avg_points)''')\r\n    cur.executemany('INSERT INTO players VALUES (?,?,?,?,?,?,?,?,?)', players)\r\n    conn.commit()\r\n\r\n\r\nimport_data()\r\n\r\n\r\n# you code:\r\n\r\ndef player_with_max_points_per_game():\r\n    \"\"\"The player with highest average points per game (don't forget to CAST to\r\n       numeric in your SQL query)\"\"\"\r\n       \r\n    rows = cur.execute(\"SELECT name FROM players ORDER BY CAST(avg_points AS FLOAT) DESC\").fetchone()\r\n    return rows[0]\r\n\r\n\r\n\r\ndef number_of_players_from_duke():\r\n    \"\"\"Return the number of players with college == Duke University\"\"\"\r\n    target_college = \"Duke University\"\r\n    count = cur.execute(\"SELECT COUNT(name) FROM players WHERE college = ? \",(target_college,)).fetchone()\r\n    return count[0]\r\n\r\n\r\ndef avg_years_active_players_stanford():\r\n    \"\"\"Return the average years that players from \"Stanford University\r\n       are active (\"active\" column)\"\"\"\r\n    target_college = \"Stanford University\"\r\n    rows = cur.execute(\"SELECT CAST(active AS FLOAT) FROM players WHERE college = ? \",(target_college,)).fetchall()\r\n    return round(sum(row[0] for row in rows)/len(rows),2)\r\n\r\n\r\ndef year_with_most_new_players():\r\n    \"\"\"Return the year with the most new players.\r\n       Hint: you can use GROUP BY on the year column.\r\n    \"\"\"\r\n    \r\n    \"\"\"this works\r\n    rows = cur.execute(\"SELECT year, COUNT(name) FROM players GROUP BY CAST(year AS INT)\").fetchall()\r\n    return max(rows, key=lambda x: x[1])[0]\r\n    \"\"\"\r\n    \r\n    rows = cur.execute(\"SELECT CAST(year AS INT) FROM players GROUP BY CAST(year AS INT) ORDER BY COUNT(name) DESC\").fetchone()\r\n    return rows[0]\r\n    \r\n\r\nprint(player_with_max_points_per_game())\r\nprint(number_of_players_from_duke())\r\nprint(avg_years_active_players_stanford())\r\nprint(year_with_most_new_players())",
            "date": "2022-12-04 10:17:36.155967+00:00",
            "passed": true
        },
        {
            "bite": "Bite 195. Analyze NBA Data with sqlite3",
            "code": "from collections import namedtuple\r\nimport csv\r\nimport os\r\nfrom pathlib import Path\r\nimport sqlite3\r\nimport random\r\nimport string\r\n\r\nimport requests\r\n\r\nDATA_URL = 'https://query.data.world/s/ezwk64ej624qyverrw6x7od7co7ftm'\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\n\r\nsalt = ''.join(\r\n    random.choice(string.ascii_lowercase) for i in range(20)\r\n)\r\nDB = TMP / f'nba_{salt}.db'\r\n\r\nPlayer = namedtuple('Player', ('name year first_year team college active '\r\n                               'games avg_min avg_points'))\r\n\r\nconn = sqlite3.connect(DB)\r\ncur = conn.cursor()\r\n\r\n\r\ndef import_data():\r\n    with requests.Session() as session:\r\n        content = session.get(DATA_URL).content.decode('utf-8')\r\n\r\n    reader = csv.DictReader(content.splitlines(), delimiter=',')\r\n\r\n    players = []\r\n    for row in reader:\r\n        players.append(Player(name=row['Player'],\r\n                              year=row['Draft_Yr'],\r\n                              first_year=row['first_year'],\r\n                              team=row['Team'],\r\n                              college=row['College'],\r\n                              active=row['Yrs'],\r\n                              games=row['Games'],\r\n                              avg_min=row['Minutes.per.Game'],\r\n                              avg_points=row['Points.per.Game']))\r\n\r\n    cur.execute('''CREATE TABLE IF NOT EXISTS players\r\n                  (name, year, first_year, team, college, active,\r\n                  games, avg_min, avg_points)''')\r\n    cur.executemany('INSERT INTO players VALUES (?,?,?,?,?,?,?,?,?)', players)\r\n    conn.commit()\r\n\r\n\r\nimport_data()\r\n\r\n\r\n# you code:\r\n\r\ndef player_with_max_points_per_game():\r\n    \"\"\"The player with highest average points per game (don't forget to CAST to\r\n       numeric in your SQL query)\"\"\"\r\n       \r\n    rows = cur.execute(\"SELECT name, CAST(avg_points AS FLOAT) FROM players ORDER BY CAST(avg_points AS FLOAT) DESC\").fetchone()\r\n    return rows[0]\r\n\r\n\r\n\r\ndef number_of_players_from_duke():\r\n    \"\"\"Return the number of players with college == Duke University\"\"\"\r\n    target_college = \"Duke University\"\r\n    rows = cur.execute(\"SELECT name, college FROM players WHERE college = ? \",(target_college,)).fetchall()\r\n    return len(rows)\r\n\r\n\r\ndef avg_years_active_players_stanford():\r\n    \"\"\"Return the average years that players from \"Stanford University\r\n       are active (\"active\" column)\"\"\"\r\n    target_college = \"Stanford University\"\r\n    rows = cur.execute(\"SELECT CAST(active AS FLOAT) FROM players WHERE college = ? \",(target_college,)).fetchall()\r\n    return sum(row[0] for row in rows)/len(rows)\r\n\r\n\r\ndef year_with_most_new_players():\r\n    \"\"\"Return the year with the most new players.\r\n       Hint: you can use GROUP BY on the year column.\r\n    \"\"\"\r\n    pass\r\n\r\n\r\nprint(player_with_max_points_per_game())\r\nprint(number_of_players_from_duke())\r\nprint(avg_years_active_players_stanford())",
            "date": "2022-12-04 09:01:30.107015+00:00",
            "passed": false
        },
        {
            "bite": "Bite 78. Find programmers with common languages",
            "code": "def common_languages(programmers):\r\n    \"\"\"Receive a dict of keys -> names and values -> a sequence of\r\n       of programming languages, return the common languages\"\"\"\r\n    languages = list(programmers.values())\r\n    return list(set(languages[0]).intersection(*languages))\r\n\r\n",
            "date": "2022-12-03 18:38:02.388114+00:00",
            "passed": true
        },
        {
            "bite": "Bite 78. Find programmers with common languages",
            "code": "def common_languages(programmers):\r\n    \"\"\"Receive a dict of keys -> names and values -> a sequence of\r\n       of programming languages, return the common languages\"\"\"\r\n    result = set(programmers[0]).intersection(*programmers)",
            "date": "2022-12-03 18:32:31.806418+00:00",
            "passed": false
        },
        {
            "bite": "Bite 124. Marvel data analysis",
            "code": "from collections import Counter, namedtuple, defaultdict\r\nimport csv\r\nimport re\r\n\r\nimport requests\r\n\r\nfrom pprint import pprint\r\n\r\nMARVEL_CSV = 'https://raw.githubusercontent.com/pybites/marvel_challenge/master/marvel-wikia-data.csv'  # noqa E501\r\n\r\nCharacter = namedtuple('Character', 'pid name sid align sex appearances year')\r\n\r\nMALE, FEMALE, AGENDER, GENDERFLUID = 'male characters', 'female characters', 'agender characters', 'genderfluid characters'\r\nVALID_GENDERS = [MALE, FEMALE, AGENDER, GENDERFLUID ]\r\n\r\n# csv parsing code provided so this Bite can focus on the parsing\r\n\r\ndef _get_csv_data():\r\n    \"\"\"Download the marvel csv data and return its decoded content\"\"\"\r\n    with requests.Session() as session:\r\n        return session.get(MARVEL_CSV).content.decode('utf-8')\r\n\r\n\r\ndef load_data():\r\n    \"\"\"Converts marvel.csv into a sequence of Character namedtuples\r\n       as defined above\"\"\"\r\n    content = _get_csv_data()\r\n    reader = csv.DictReader(content.splitlines(), delimiter=',')\r\n    for row in reader:\r\n        name = re.sub(r'(.*?)\\(.*', r'\\1', row['name']).strip()\r\n        yield Character(pid=row['page_id'],\r\n                        name=name,\r\n                        sid=row['ID'],\r\n                        align=row['ALIGN'],\r\n                        sex=row['SEX'],\r\n                        appearances=row['APPEARANCES'],\r\n                        year=row['Year'])\r\n\r\n\r\ncharacters = list(load_data())\r\n\r\n\r\n# start coding\r\n\r\ndef most_popular_characters(characters=characters, top=5):\r\n    \"\"\"Get the most popular character by number of appearances,\r\n       return top n characters (default 5)\r\n    \"\"\"\r\n    \r\n    \"\"\"\r\n    # this works but results differ. Note e.g. Benjamin Grimm appears \r\n    # several times with the same name, this code adds them all together\r\n    \r\n    char_appears = defaultdict(int)\r\n    for character in characters:\r\n         if character.appearances:\r\n            char_appears[character.name]+= int(character.appearances)\r\n\r\n    count = Counter(char_appears).most_common(top)\r\n    return [name for name, appears in count]\r\n    \"\"\"\r\n    \r\n    # wrote this to mimic results in the tests. Now every line of 'Benjamin Grimm'\r\n    # is considered separately\r\n    \r\n    char_appears= {c.pid: int(c.appearances) for c in characters if c.appearances}\r\n    top_chars_by_pid = Counter(char_appears).most_common(top)\r\n    return [c.name for pid,appears in top_chars_by_pid for c in characters if c.pid ==pid]\r\n        \r\n\r\n\r\n\r\ndef max_and_min_years_new_characters(characters=characters):\r\n    \"\"\"Get the year with most and least new characters introduced respectively,\r\n       use either the 'FIRST APPEARANCE' or 'Year' column in the csv\r\n       characters, or the 'year' attribute of the namedtuple, return a tuple\r\n       of (max_year, min_year)\r\n    \"\"\"\r\n    new_chars_per_year = defaultdict(int)\r\n    for character in characters:\r\n        if character.year:\r\n            new_chars_per_year[character.year]+=1\r\n    count = Counter(new_chars_per_year).most_common()\r\n    return count[0][0],count[-1][0]\r\n\r\n\r\n\r\ndef get_percentage_female_characters(characters=characters):\r\n    \"\"\"Get the percentage of female characters as percentage of all genders\r\n       over all appearances.\r\n       Ignore characters that don't have gender ('sex' attribue) set\r\n       (in your characters data set you should only have Male, Female,\r\n       Agender and Genderfluid Characters.\r\n       Return the result rounded to 2 digits\r\n    \"\"\"\r\n\r\n    \"\"\"\r\n    appearances_by_gender = defaultdict(int)\r\n    for character in characters:\r\n        if character.sex.lower() in VALID_GENDERS:\r\n            appearances_by_gender[character.sex.lower()]+=int(character.appearances or 0)\r\n        \r\n        else:\r\n            print(character.sex +\" : \"+ character.appearances)\r\n        \r\n    total = sum(value for value in appearances_by_gender.values())\r\n    return round(100*appearances_by_gender[FEMALE]/total,2)\r\n    \"\"\"\r\n    \r\n    chars_by_gender = defaultdict(int)\r\n    for character in characters:\r\n        if character.sex.lower():\r\n            chars_by_gender[character.sex.lower()]+=1\r\n\r\n    total = sum(value for key, value in chars_by_gender.items() if key.lower() in VALID_GENDERS)\r\n    return round(100*chars_by_gender[FEMALE]/total,2)\r\n    \r\n\r\n\r\nprint(most_popular_characters(top=10))\r\nprint(max_and_min_years_new_characters())\r\nprint(get_percentage_female_characters())\r\n",
            "date": "2022-12-03 16:37:18.069662+00:00",
            "passed": true
        },
        {
            "bite": "Bite 124. Marvel data analysis",
            "code": "from collections import Counter, namedtuple, defaultdict\r\nimport csv\r\nimport re\r\n\r\nimport requests\r\n\r\nfrom pprint import pprint\r\n\r\nMARVEL_CSV = 'https://raw.githubusercontent.com/pybites/marvel_challenge/master/marvel-wikia-data.csv'  # noqa E501\r\n\r\nCharacter = namedtuple('Character', 'pid name sid align sex appearances year')\r\n\r\nMALE, FEMALE, AGENDER, GENDERFLUID = 'male characters', 'female characters', 'agender characters', 'genderfluid characters'\r\nVALID_GENDERS = [MALE, FEMALE, AGENDER, GENDERFLUID ]\r\n\r\n# csv parsing code provided so this Bite can focus on the parsing\r\n\r\ndef _get_csv_data():\r\n    \"\"\"Download the marvel csv data and return its decoded content\"\"\"\r\n    with requests.Session() as session:\r\n        return session.get(MARVEL_CSV).content.decode('utf-8')\r\n\r\n\r\ndef load_data():\r\n    \"\"\"Converts marvel.csv into a sequence of Character namedtuples\r\n       as defined above\"\"\"\r\n    content = _get_csv_data()\r\n    reader = csv.DictReader(content.splitlines(), delimiter=',')\r\n    for row in reader:\r\n        name = re.sub(r'(.*?)\\(.*', r'\\1', row['name']).strip()\r\n        yield Character(pid=row['page_id'],\r\n                        name=name,\r\n                        sid=row['ID'],\r\n                        align=row['ALIGN'],\r\n                        sex=row['SEX'],\r\n                        appearances=row['APPEARANCES'],\r\n                        year=row['Year'])\r\n\r\n\r\ncharacters = list(load_data())\r\n\r\n\r\n# start coding\r\n\r\ndef most_popular_characters(characters=characters, top=5):\r\n    \"\"\"Get the most popular character by number of appearances,\r\n       return top n characters (default 5)\r\n    \"\"\"\r\n    \r\n    \"\"\"\r\n    # this works but results differ. Note e.g. Benjamin Grimm appears \r\n    # several times with the same name, this code adds them all together\r\n    \r\n    char_appears = defaultdict(int)\r\n    for character in characters:\r\n         if character.appearances:\r\n            char_appears[character.name]+= int(character.appearances)\r\n\r\n    count = Counter(char_appears).most_common(top)\r\n    return [name for name, appears in count]\r\n    \"\"\"\r\n    \r\n    # wrote this to mimic results in the tests. Now every line of 'Benjamin Grimm'\r\n    # is considered separately\r\n    \r\n    char_appears= {c.pid: int(c.appearances) for c in characters if c.appearances}\r\n\r\n    top_chars_by_pid = Counter(char_appears).most_common(top)\r\n\r\n    return [character.name for pid,appears in top_chars_by_pid for character in characters if character.pid ==pid]\r\n        \r\n\r\n\r\n\r\ndef max_and_min_years_new_characters(characters=characters):\r\n    \"\"\"Get the year with most and least new characters introduced respectively,\r\n       use either the 'FIRST APPEARANCE' or 'Year' column in the csv\r\n       characters, or the 'year' attribute of the namedtuple, return a tuple\r\n       of (max_year, min_year)\r\n    \"\"\"\r\n    new_chars_per_year = defaultdict(int)\r\n    for character in characters:\r\n        if character.year:\r\n            new_chars_per_year[character.year]+=1\r\n    count = Counter(new_chars_per_year).most_common()\r\n    return count[0][0],count[-1][0]\r\n\r\n\r\n\r\ndef get_percentage_female_characters(characters=characters):\r\n    \"\"\"Get the percentage of female characters as percentage of all genders\r\n       over all appearances.\r\n       Ignore characters that don't have gender ('sex' attribue) set\r\n       (in your characters data set you should only have Male, Female,\r\n       Agender and Genderfluid Characters.\r\n       Return the result rounded to 2 digits\r\n    \"\"\"\r\n\r\n    appearances_by_gender = defaultdict(int)\r\n    for character in characters:\r\n        if character.sex.lower() in VALID_GENDERS:\r\n            appearances_by_gender[character.sex.lower()]+=int(character.appearances or 1)\r\n        \"\"\"\r\n        else:\r\n            print(character.sex +\" : \"+ character.appearances)\r\n        \"\"\"\r\n    total = sum(value for value in appearances_by_gender.values())\r\n    return round(100*appearances_by_gender[FEMALE]/total,2)\r\n\r\n\r\n\r\nprint(most_popular_characters(top=10))\r\nprint(max_and_min_years_new_characters())\r\nprint(get_percentage_female_characters())\r\n",
            "date": "2022-12-03 16:19:25.060471+00:00",
            "passed": false
        },
        {
            "bite": "Bite 124. Marvel data analysis",
            "code": "from collections import Counter, namedtuple, defaultdict\r\nimport csv\r\nimport re\r\n\r\nimport requests\r\n\r\nfrom pprint import pprint\r\n\r\nMARVEL_CSV = 'https://raw.githubusercontent.com/pybites/marvel_challenge/master/marvel-wikia-data.csv'  # noqa E501\r\n\r\nCharacter = namedtuple('Character', 'pid name sid align sex appearances year')\r\n\r\nMALE, FEMALE, AGENDER, GENDERFLUID = 'male characters', 'female characters', 'agender characters', 'genderfluid characters'\r\nVALID_GENDERS = [MALE, FEMALE, AGENDER, GENDERFLUID ]\r\n\r\n# csv parsing code provided so this Bite can focus on the parsing\r\n\r\ndef _get_csv_data():\r\n    \"\"\"Download the marvel csv data and return its decoded content\"\"\"\r\n    with requests.Session() as session:\r\n        return session.get(MARVEL_CSV).content.decode('utf-8')\r\n\r\n\r\ndef load_data():\r\n    \"\"\"Converts marvel.csv into a sequence of Character namedtuples\r\n       as defined above\"\"\"\r\n    content = _get_csv_data()\r\n    reader = csv.DictReader(content.splitlines(), delimiter=',')\r\n    for row in reader:\r\n        name = re.sub(r'(.*?)\\(.*', r'\\1', row['name']).strip()\r\n        yield Character(pid=row['page_id'],\r\n                        name=name,\r\n                        sid=row['ID'],\r\n                        align=row['ALIGN'],\r\n                        sex=row['SEX'],\r\n                        appearances=row['APPEARANCES'],\r\n                        year=row['Year'])\r\n\r\n\r\ncharacters = list(load_data())\r\n\r\n\r\n# start coding\r\n\r\ndef most_popular_characters(characters=characters, top=5):\r\n    \"\"\"Get the most popular character by number of appearances,\r\n       return top n characters (default 5)\r\n    \"\"\"\r\n    \r\n    \"\"\"\r\n    # this works but results differ. Note e.g. Benjamin Grimm appears \r\n    # several times with the same name, this code adds them all together\r\n    \r\n    char_appears = defaultdict(int)\r\n    for character in characters:\r\n         if character.appearances:\r\n            char_appears[character.name]+= int(character.appearances)\r\n\r\n    count = Counter(char_appears).most_common(top)\r\n    return [name for name, appears in count]\r\n    \"\"\"\r\n    \r\n    # wrote this to mimic results in the tests. Now every line of 'Benjamin Grimm'\r\n    # is considered separately\r\n    \r\n    char_appears= {c.pid: int(c.appearances) for c in characters if c.appearances}\r\n\r\n    top_chars_by_pid = Counter(char_appears).most_common(top)\r\n\r\n    return [character.name for pid,appears in top_chars_by_pid for character in characters if character.pid ==pid]\r\n        \r\n\r\n\r\n\r\ndef max_and_min_years_new_characters(characters=characters):\r\n    \"\"\"Get the year with most and least new characters introduced respectively,\r\n       use either the 'FIRST APPEARANCE' or 'Year' column in the csv\r\n       characters, or the 'year' attribute of the namedtuple, return a tuple\r\n       of (max_year, min_year)\r\n    \"\"\"\r\n    new_chars_per_year = defaultdict(int)\r\n    for character in characters:\r\n        if character.year:\r\n            new_chars_per_year[character.year]+=1\r\n    count = Counter(new_chars_per_year).most_common()\r\n    return count[0][0],count[-1][0]\r\n\r\n\r\n\r\ndef get_percentage_female_characters(characters=characters):\r\n    \"\"\"Get the percentage of female characters as percentage of all genders\r\n       over all appearances.\r\n       Ignore characters that don't have gender ('sex' attribue) set\r\n       (in your characters data set you should only have Male, Female,\r\n       Agender and Genderfluid Characters.\r\n       Return the result rounded to 2 digits\r\n    \"\"\"\r\n\r\n    appearances_by_gender = defaultdict(int)\r\n    for character in characters:\r\n        if character.sex.lower() in VALID_GENDERS:\r\n            appearances_by_gender[character.sex.lower()]+=int(character.appearances or 0)\r\n        \"\"\"\r\n        else:\r\n            print(character.sex +\" : \"+ character.appearances)\r\n        \"\"\"\r\n    total = sum(value for value in appearances_by_gender.values())\r\n    return round(100*appearances_by_gender[FEMALE]/total,2)\r\n\r\n\r\n\r\nprint(most_popular_characters(top=10))\r\nprint(max_and_min_years_new_characters())\r\nprint(get_percentage_female_characters())\r\n",
            "date": "2022-12-03 16:19:04.019980+00:00",
            "passed": false
        },
        {
            "bite": "Bite 124. Marvel data analysis",
            "code": "from collections import Counter, namedtuple, defaultdict\r\nimport csv\r\nimport re\r\n\r\nimport requests\r\n\r\nfrom pprint import pprint\r\n\r\nMARVEL_CSV = 'https://raw.githubusercontent.com/pybites/marvel_challenge/master/marvel-wikia-data.csv'  # noqa E501\r\n\r\nCharacter = namedtuple('Character', 'pid name sid align sex appearances year')\r\n\r\nMALE, FEMALE, AGENDER, GENDERFLUID = 'male characters', 'female characters', 'agender characters', 'genderfluid characters'\r\nVALID_GENDERS = [MALE, FEMALE, AGENDER, GENDERFLUID ]\r\n\r\n# csv parsing code provided so this Bite can focus on the parsing\r\n\r\ndef _get_csv_data():\r\n    \"\"\"Download the marvel csv data and return its decoded content\"\"\"\r\n    with requests.Session() as session:\r\n        return session.get(MARVEL_CSV).content.decode('utf-8')\r\n\r\n\r\ndef load_data():\r\n    \"\"\"Converts marvel.csv into a sequence of Character namedtuples\r\n       as defined above\"\"\"\r\n    content = _get_csv_data()\r\n    reader = csv.DictReader(content.splitlines(), delimiter=',')\r\n    for row in reader:\r\n        name = re.sub(r'(.*?)\\(.*', r'\\1', row['name']).strip()\r\n        yield Character(pid=row['page_id'],\r\n                        name=name,\r\n                        sid=row['ID'],\r\n                        align=row['ALIGN'],\r\n                        sex=row['SEX'],\r\n                        appearances=row['APPEARANCES'],\r\n                        year=row['Year'])\r\n\r\n\r\ncharacters = list(load_data())\r\n\r\n\r\n# start coding\r\n\r\ndef most_popular_characters(characters=characters, top=5):\r\n    \"\"\"Get the most popular character by number of appearances,\r\n       return top n characters (default 5)\r\n    \"\"\"\r\n    \r\n    \"\"\"this works but numbers are different\r\n    char_appears = defaultdict(int)\r\n    for character in characters:\r\n         if character.appearances:\r\n            char_appears[character.name]+= int(character.appearances)\r\n\r\n    count = Counter(char_appears).most_common(top)\r\n    return [name for name, appears in count]\r\n    \"\"\"\r\n    char_appears = defaultdict(int)\r\n    for character in characters:\r\n         if character.appearances:\r\n            char_appears[character.pid]= int(character.appearances)\r\n\r\n    top_chars_by_pid = Counter(char_appears).most_common(top)\r\n\r\n    return [character.name for pid,appears in top_chars_by_pid for character in characters if character.pid ==pid]\r\n        \r\n\r\n\r\n\r\ndef max_and_min_years_new_characters(characters=characters):\r\n    \"\"\"Get the year with most and least new characters introduced respectively,\r\n       use either the 'FIRST APPEARANCE' or 'Year' column in the csv\r\n       characters, or the 'year' attribute of the namedtuple, return a tuple\r\n       of (max_year, min_year)\r\n    \"\"\"\r\n    new_chars_per_year = defaultdict(int)\r\n    for character in characters:\r\n        if character.year:\r\n            new_chars_per_year[character.year]+=1\r\n    count = Counter(new_chars_per_year).most_common()\r\n    return count[0][0],count[-1][0]\r\n\r\n\r\n\r\ndef get_percentage_female_characters(characters=characters):\r\n    \"\"\"Get the percentage of female characters as percentage of all genders\r\n       over all appearances.\r\n       Ignore characters that don't have gender ('sex' attribue) set\r\n       (in your characters data set you should only have Male, Female,\r\n       Agender and Genderfluid Characters.\r\n       Return the result rounded to 2 digits\r\n    \"\"\"\r\n    # pprint(characters)\r\n    appearances_by_gender = defaultdict(int)\r\n    for character in characters:\r\n        if character.sex.lower() in VALID_GENDERS and character.appearances:\r\n            appearances_by_gender[character.sex.lower()]+=int(character.appearances)\r\n        \"\"\"\r\n        else:\r\n            print(character.sex +\" : \"+ character.appearances)\r\n        \"\"\"\r\n    total = sum(value for value in appearances_by_gender.values())\r\n    return round(100*appearances_by_gender[FEMALE]/total,2)\r\n\r\n\r\n\r\nprint(most_popular_characters(top=10))\r\nprint(max_and_min_years_new_characters())\r\nprint(get_percentage_female_characters())\r\n",
            "date": "2022-12-03 16:12:09.978455+00:00",
            "passed": false
        },
        {
            "bite": "Bite 124. Marvel data analysis",
            "code": "from collections import Counter, namedtuple, defaultdict\r\nimport csv\r\nimport re\r\n\r\nimport requests\r\n\r\nfrom pprint import pprint\r\n\r\nMARVEL_CSV = 'https://raw.githubusercontent.com/pybites/marvel_challenge/master/marvel-wikia-data.csv'  # noqa E501\r\n\r\nCharacter = namedtuple('Character', 'pid name sid align sex appearances year')\r\n\r\nMALE, FEMALE, AGENDER, GENDERFLUID = 'male characters', 'female characters', 'agender characters', 'genderfluid characters'\r\nVALID_GENDERS = [MALE, FEMALE, AGENDER, GENDERFLUID ]\r\n\r\n# csv parsing code provided so this Bite can focus on the parsing\r\n\r\ndef _get_csv_data():\r\n    \"\"\"Download the marvel csv data and return its decoded content\"\"\"\r\n    with requests.Session() as session:\r\n        return session.get(MARVEL_CSV).content.decode('utf-8')\r\n\r\n\r\ndef load_data():\r\n    \"\"\"Converts marvel.csv into a sequence of Character namedtuples\r\n       as defined above\"\"\"\r\n    content = _get_csv_data()\r\n    reader = csv.DictReader(content.splitlines(), delimiter=',')\r\n    for row in reader:\r\n        name = re.sub(r'(.*?)\\(.*', r'\\1', row['name']).strip()\r\n        yield Character(pid=row['page_id'],\r\n                        name=name,\r\n                        sid=row['ID'],\r\n                        align=row['ALIGN'],\r\n                        sex=row['SEX'],\r\n                        appearances=row['APPEARANCES'],\r\n                        year=row['Year'])\r\n\r\n\r\ncharacters = list(load_data())\r\n\r\n\r\n# start coding\r\n\r\ndef most_popular_characters(characters=characters, top=5):\r\n    \"\"\"Get the most popular character by number of appearances,\r\n       return top n characters (default 5)\r\n    \"\"\"\r\n    char_appears = defaultdict(int)\r\n    for character in characters:\r\n            increment = int(character.appearances) if character.appearances else 1\r\n            char_appears[character.name]+= increment\r\n\r\n    count = Counter(char_appears).most_common(top)\r\n    return [name for name, appears in count]\r\n\r\n\r\n\r\ndef max_and_min_years_new_characters(characters=characters):\r\n    \"\"\"Get the year with most and least new characters introduced respectively,\r\n       use either the 'FIRST APPEARANCE' or 'Year' column in the csv\r\n       characters, or the 'year' attribute of the namedtuple, return a tuple\r\n       of (max_year, min_year)\r\n    \"\"\"\r\n    new_chars_per_year = defaultdict(int)\r\n    for character in characters:\r\n        if character.year:\r\n            new_chars_per_year[character.year]+=1\r\n    count = Counter(new_chars_per_year).most_common()\r\n    return count[0][0],count[-1][0]\r\n\r\n\r\n\r\ndef get_percentage_female_characters(characters=characters):\r\n    \"\"\"Get the percentage of female characters as percentage of all genders\r\n       over all appearances.\r\n       Ignore characters that don't have gender ('sex' attribue) set\r\n       (in your characters data set you should only have Male, Female,\r\n       Agender and Genderfluid Characters.\r\n       Return the result rounded to 2 digits\r\n    \"\"\"\r\n    # pprint(characters)\r\n    appearances_by_gender = defaultdict(int)\r\n    for character in characters:\r\n        if character.sex.lower() in VALID_GENDERS and character.appearances:\r\n            appearances_by_gender[character.sex.lower()]+=int(character.appearances)\r\n        \"\"\"\r\n        else:\r\n            print(character.sex +\" : \"+ character.appearances)\r\n        \"\"\"\r\n    total = sum(value for value in appearances_by_gender.values())\r\n    return round(100*appearances_by_gender[FEMALE]/total,2)\r\n\r\n\r\n\r\nprint(most_popular_characters(top=10))\r\nprint(max_and_min_years_new_characters())\r\nprint(get_percentage_female_characters())\r\n",
            "date": "2022-12-03 15:55:22.908332+00:00",
            "passed": false
        },
        {
            "bite": "Bite 151. Contemporary Composers",
            "code": "from collections import namedtuple\r\nfrom datetime import datetime\r\n\r\nComposer = namedtuple('Composer', 'name born died')\r\nOpera = namedtuple('Opera', 'author play date')\r\n\r\ncomposers = {\r\n    \"beethoven\": Composer(\"Ludwig van Beethoven\",\r\n                          \"17 December 1770\", \"26 March 1827\"),\r\n    \"wagner\": Composer(\"Richard Wagner\",\r\n                       \"22 May 1813\", \"13 February 1883\"),\r\n    \"verdi\": Composer(\"Giuseppe Verdi\",\r\n                      \"9 October 1813\", \"27 January 1901\"),\r\n    \"mozart\": Composer(\"Wolfgang Amadeus Mozart\",\r\n                       \"27 January 1756\", \"5 December 1791\"),\r\n}\r\n\r\noperas = [\r\n    Opera(\"mozart\", \"Apollo and Hyacinth\", \"13 May 1767\"),\r\n    Opera(\"mozart\", \"Marriage of Figaro\", \"1 May 1786\"),\r\n    Opera(\"mozart\", \"Don Giovanni\", \"29 October 1787\"),\r\n    Opera(\"mozart\", \"Cos\u00ec fan tutte\", \"6 January 1790\"),\r\n    Opera(\"mozart\", \"The Clemency of Titus\", \"6 September 1791\"),\r\n    Opera(\"mozart\", \"The Magic Flute\", \"30 September 1791\"),\r\n    Opera(\"wagner\", \"The Fairies\", \"29 June 1888\"),\r\n    Opera(\"wagner\", \"Rienzi\", \"20 October 1842\"),\r\n    Opera(\"wagner\", \"The Flying Dutchman\", \"2 January 1843\"),\r\n    Opera(\"wagner\", \"Tannh\u00e4user\", \"19 October 1845\"),\r\n    Opera(\"wagner\", \"Lohengrin\", \"28 August 1850\"),\r\n    Opera(\"wagner\", \"The Rhinegold\", \"22 September 1869\"),\r\n    Opera(\"wagner\", \"The Valkyrie\", \"26 June 1870\"),\r\n    Opera(\"wagner\", \"Siegfried\", \"16 August 1876\"),\r\n    Opera(\"wagner\", \"Twilight of the Gods\", \"17 August 1876\"),\r\n    Opera(\"wagner\", \"Tristan and Isolde\", \"10 June 1865\"),\r\n    Opera(\"wagner\", \"The Master-Singers of Nuremberg\", \"21 June 1868\"),\r\n    Opera(\"wagner\", \"Parsifal\", \"26 July 1882\"),\r\n    Opera(\"beethoven\", \"Fidelio\", \"20 November 1805\"),\r\n    Opera(\"verdi\", \"Nabucco\", \"9 March 1842\"),\r\n    Opera(\"verdi\", \"Ernani\", \"9 March 1844\"),\r\n    Opera(\"verdi\", \"Macbeth\", \"14 March 1847\"),\r\n    Opera(\"verdi\", \"Il corsaro\", \"25 October 1848\"),\r\n    Opera(\"verdi\", \"Rigoletto\", \"11 March 1851\"),\r\n    Opera(\"verdi\", \"La traviata\", \"6 March 1853\"),\r\n    Opera(\"verdi\", \"Aroldo\", \"16 August 1857\"),\r\n    Opera(\"verdi\", \"Macbeth\", \"21 April 1865\"),\r\n    Opera(\"verdi\", \"Don Carlos\", \"11 March 1867\"),\r\n    Opera(\"verdi\", \"Aida\", \"24 December 1871\"),\r\n    Opera(\"verdi\", \"Otello\", \"5 February 1887\"),\r\n    Opera(\"verdi\", \"Falstaff\", \"9 February 1893\"),\r\n]\r\n\r\n\r\ndef _get_date(date_str):\r\n    return datetime.date(datetime.strptime(date_str, \"%d %B %Y\"))\r\n\r\n\r\ndef operas_both_at_premiere(guest, composer):\r\n    \"\"\"Retrieves a list of titles of operas, where the guest and the composer\r\n       could have been together at premiere.\r\n\r\n       That is the Opera.author matches the composer passed in, and both guest\r\n       and composer are alive at the time of Opera.date.\r\n\r\n       If guest and/or composer are not in the composers dict, raise a\r\n       ValueError\r\n\r\n       Args:\r\n       guest (str): one of the composers but not the author of an opera\r\n       composer (str): the author of an opera\r\n\r\n       Returns a list (or generator) of titles of operas.\r\n    \"\"\"\r\n    try:\r\n        _guest = composers[guest]\r\n        _composer = composers[composer]\r\n    except KeyError:\r\n        raise ValueError(f'Input not in composers list')\r\n\r\n    start = max(_get_date(_guest.born), _get_date(_composer.born))\r\n    end = min(_get_date(_guest.died), _get_date(_composer.died))\r\n    \r\n    if start > end:\r\n        return []\r\n\r\n    return [opera.play for opera in operas if start < _get_date(opera.date) < end and opera.author == composer]\r\n    \r\n\r\nprint(operas_both_at_premiere('verdi','wagner'))",
            "date": "2022-12-03 15:41:28.324878+00:00",
            "passed": true
        },
        {
            "bite": "Bite 151. Contemporary Composers",
            "code": "from collections import namedtuple\r\nfrom datetime import datetime\r\n\r\nComposer = namedtuple('Composer', 'name born died')\r\nOpera = namedtuple('Opera', 'author play date')\r\n\r\ncomposers = {\r\n    \"beethoven\": Composer(\"Ludwig van Beethoven\",\r\n                          \"17 December 1770\", \"26 March 1827\"),\r\n    \"wagner\": Composer(\"Richard Wagner\",\r\n                       \"22 May 1813\", \"13 February 1883\"),\r\n    \"verdi\": Composer(\"Giuseppe Verdi\",\r\n                      \"9 October 1813\", \"27 January 1901\"),\r\n    \"mozart\": Composer(\"Wolfgang Amadeus Mozart\",\r\n                       \"27 January 1756\", \"5 December 1791\"),\r\n}\r\n\r\noperas = [\r\n    Opera(\"mozart\", \"Apollo and Hyacinth\", \"13 May 1767\"),\r\n    Opera(\"mozart\", \"Marriage of Figaro\", \"1 May 1786\"),\r\n    Opera(\"mozart\", \"Don Giovanni\", \"29 October 1787\"),\r\n    Opera(\"mozart\", \"Cos\u00ec fan tutte\", \"6 January 1790\"),\r\n    Opera(\"mozart\", \"The Clemency of Titus\", \"6 September 1791\"),\r\n    Opera(\"mozart\", \"The Magic Flute\", \"30 September 1791\"),\r\n    Opera(\"wagner\", \"The Fairies\", \"29 June 1888\"),\r\n    Opera(\"wagner\", \"Rienzi\", \"20 October 1842\"),\r\n    Opera(\"wagner\", \"The Flying Dutchman\", \"2 January 1843\"),\r\n    Opera(\"wagner\", \"Tannh\u00e4user\", \"19 October 1845\"),\r\n    Opera(\"wagner\", \"Lohengrin\", \"28 August 1850\"),\r\n    Opera(\"wagner\", \"The Rhinegold\", \"22 September 1869\"),\r\n    Opera(\"wagner\", \"The Valkyrie\", \"26 June 1870\"),\r\n    Opera(\"wagner\", \"Siegfried\", \"16 August 1876\"),\r\n    Opera(\"wagner\", \"Twilight of the Gods\", \"17 August 1876\"),\r\n    Opera(\"wagner\", \"Tristan and Isolde\", \"10 June 1865\"),\r\n    Opera(\"wagner\", \"The Master-Singers of Nuremberg\", \"21 June 1868\"),\r\n    Opera(\"wagner\", \"Parsifal\", \"26 July 1882\"),\r\n    Opera(\"beethoven\", \"Fidelio\", \"20 November 1805\"),\r\n    Opera(\"verdi\", \"Nabucco\", \"9 March 1842\"),\r\n    Opera(\"verdi\", \"Ernani\", \"9 March 1844\"),\r\n    Opera(\"verdi\", \"Macbeth\", \"14 March 1847\"),\r\n    Opera(\"verdi\", \"Il corsaro\", \"25 October 1848\"),\r\n    Opera(\"verdi\", \"Rigoletto\", \"11 March 1851\"),\r\n    Opera(\"verdi\", \"La traviata\", \"6 March 1853\"),\r\n    Opera(\"verdi\", \"Aroldo\", \"16 August 1857\"),\r\n    Opera(\"verdi\", \"Macbeth\", \"21 April 1865\"),\r\n    Opera(\"verdi\", \"Don Carlos\", \"11 March 1867\"),\r\n    Opera(\"verdi\", \"Aida\", \"24 December 1871\"),\r\n    Opera(\"verdi\", \"Otello\", \"5 February 1887\"),\r\n    Opera(\"verdi\", \"Falstaff\", \"9 February 1893\"),\r\n]\r\n\r\n\r\ndef _get_date(date_str):\r\n    return datetime.date(datetime.strptime(date_str, \"%d %B %Y\"))\r\n\r\n\r\ndef operas_both_at_premiere(guest, composer):\r\n    \"\"\"Retrieves a list of titles of operas, where the guest and the composer\r\n       could have been together at premiere.\r\n\r\n       That is the Opera.author matches the composer passed in, and both guest\r\n       and composer are alive at the time of Opera.date.\r\n\r\n       If guest and/or composer are not in the composers dict, raise a\r\n       ValueError\r\n\r\n       Args:\r\n       guest (str): one of the composers but not the author of an opera\r\n       composer (str): the author of an opera\r\n\r\n       Returns a list (or generator) of titles of operas.\r\n    \"\"\"\r\n    try:\r\n        _guest = composers[guest]\r\n        _composer = composers[composer]\r\n    except KeyError:\r\n        raise ValueError(f'Input not in composers list')\r\n\r\n    start = max(_get_date(_guest.born), _get_date(_composer.born))\r\n    end = min(_get_date(_guest.died), _get_date(_composer.died))\r\n    \r\n    if start > end:\r\n        return []\r\n    print(start, end)\r\n    return [opera.play for opera in operas if start < _get_date(opera.date) < end and opera.author == composer]\r\n    \r\n\r\nprint(operas_both_at_premiere('verdi','wagner'))",
            "date": "2022-12-03 15:41:02.138398+00:00",
            "passed": true
        },
        {
            "bite": "Bite 151. Contemporary Composers",
            "code": "from collections import namedtuple\r\nfrom datetime import datetime\r\n\r\nComposer = namedtuple('Composer', 'name born died')\r\nOpera = namedtuple('Opera', 'author play date')\r\n\r\ncomposers = {\r\n    \"beethoven\": Composer(\"Ludwig van Beethoven\",\r\n                          \"17 December 1770\", \"26 March 1827\"),\r\n    \"wagner\": Composer(\"Richard Wagner\",\r\n                       \"22 May 1813\", \"13 February 1883\"),\r\n    \"verdi\": Composer(\"Giuseppe Verdi\",\r\n                      \"9 October 1813\", \"27 January 1901\"),\r\n    \"mozart\": Composer(\"Wolfgang Amadeus Mozart\",\r\n                       \"27 January 1756\", \"5 December 1791\"),\r\n}\r\n\r\noperas = [\r\n    Opera(\"mozart\", \"Apollo and Hyacinth\", \"13 May 1767\"),\r\n    Opera(\"mozart\", \"Marriage of Figaro\", \"1 May 1786\"),\r\n    Opera(\"mozart\", \"Don Giovanni\", \"29 October 1787\"),\r\n    Opera(\"mozart\", \"Cos\u00ec fan tutte\", \"6 January 1790\"),\r\n    Opera(\"mozart\", \"The Clemency of Titus\", \"6 September 1791\"),\r\n    Opera(\"mozart\", \"The Magic Flute\", \"30 September 1791\"),\r\n    Opera(\"wagner\", \"The Fairies\", \"29 June 1888\"),\r\n    Opera(\"wagner\", \"Rienzi\", \"20 October 1842\"),\r\n    Opera(\"wagner\", \"The Flying Dutchman\", \"2 January 1843\"),\r\n    Opera(\"wagner\", \"Tannh\u00e4user\", \"19 October 1845\"),\r\n    Opera(\"wagner\", \"Lohengrin\", \"28 August 1850\"),\r\n    Opera(\"wagner\", \"The Rhinegold\", \"22 September 1869\"),\r\n    Opera(\"wagner\", \"The Valkyrie\", \"26 June 1870\"),\r\n    Opera(\"wagner\", \"Siegfried\", \"16 August 1876\"),\r\n    Opera(\"wagner\", \"Twilight of the Gods\", \"17 August 1876\"),\r\n    Opera(\"wagner\", \"Tristan and Isolde\", \"10 June 1865\"),\r\n    Opera(\"wagner\", \"The Master-Singers of Nuremberg\", \"21 June 1868\"),\r\n    Opera(\"wagner\", \"Parsifal\", \"26 July 1882\"),\r\n    Opera(\"beethoven\", \"Fidelio\", \"20 November 1805\"),\r\n    Opera(\"verdi\", \"Nabucco\", \"9 March 1842\"),\r\n    Opera(\"verdi\", \"Ernani\", \"9 March 1844\"),\r\n    Opera(\"verdi\", \"Macbeth\", \"14 March 1847\"),\r\n    Opera(\"verdi\", \"Il corsaro\", \"25 October 1848\"),\r\n    Opera(\"verdi\", \"Rigoletto\", \"11 March 1851\"),\r\n    Opera(\"verdi\", \"La traviata\", \"6 March 1853\"),\r\n    Opera(\"verdi\", \"Aroldo\", \"16 August 1857\"),\r\n    Opera(\"verdi\", \"Macbeth\", \"21 April 1865\"),\r\n    Opera(\"verdi\", \"Don Carlos\", \"11 March 1867\"),\r\n    Opera(\"verdi\", \"Aida\", \"24 December 1871\"),\r\n    Opera(\"verdi\", \"Otello\", \"5 February 1887\"),\r\n    Opera(\"verdi\", \"Falstaff\", \"9 February 1893\"),\r\n]\r\n\r\n\r\ndef _get_date(date_str):\r\n    return datetime.date(datetime.strptime(date_str, \"%d %B %Y\"))\r\n\r\n\r\ndef operas_both_at_premiere(guest, composer):\r\n    \"\"\"Retrieves a list of titles of operas, where the guest and the composer\r\n       could have been together at premiere.\r\n\r\n       That is the Opera.author matches the composer passed in, and both guest\r\n       and composer are alive at the time of Opera.date.\r\n\r\n       If guest and/or composer are not in the composers dict, raise a\r\n       ValueError\r\n\r\n       Args:\r\n       guest (str): one of the composers but not the author of an opera\r\n       composer (str): the author of an opera\r\n\r\n       Returns a list (or generator) of titles of operas.\r\n    \"\"\"\r\n    try:\r\n        guest = composers[guest]\r\n        composer = composers[composer]\r\n    except:\r\n        raise ValueError(f'Input not in composers list')\r\n\r\n    start = max(_get_date(guest.born), _get_date(composer.born))\r\n    end = min(_get_date(guest.died), _get_date(composer.died))\r\n    \r\n    if start > end:\r\n        return []\r\n    \r\n    return [opera.play for opera in operas if start < _get_date(opera.date) < end and opera.author == composer]\r\n    \r\n\r\nprint(operas_both_at_premiere('verdi','wagner'))",
            "date": "2022-12-03 15:35:20.225797+00:00",
            "passed": false
        },
        {
            "bite": "Bite 151. Contemporary Composers",
            "code": "from collections import namedtuple\r\nfrom datetime import datetime\r\n\r\nComposer = namedtuple('Composer', 'name born died')\r\nOpera = namedtuple('Opera', 'author play date')\r\n\r\ncomposers = {\r\n    \"beethoven\": Composer(\"Ludwig van Beethoven\",\r\n                          \"17 December 1770\", \"26 March 1827\"),\r\n    \"wagner\": Composer(\"Richard Wagner\",\r\n                       \"22 May 1813\", \"13 February 1883\"),\r\n    \"verdi\": Composer(\"Giuseppe Verdi\",\r\n                      \"9 October 1813\", \"27 January 1901\"),\r\n    \"mozart\": Composer(\"Wolfgang Amadeus Mozart\",\r\n                       \"27 January 1756\", \"5 December 1791\"),\r\n}\r\n\r\noperas = [\r\n    Opera(\"mozart\", \"Apollo and Hyacinth\", \"13 May 1767\"),\r\n    Opera(\"mozart\", \"Marriage of Figaro\", \"1 May 1786\"),\r\n    Opera(\"mozart\", \"Don Giovanni\", \"29 October 1787\"),\r\n    Opera(\"mozart\", \"Cos\u00ec fan tutte\", \"6 January 1790\"),\r\n    Opera(\"mozart\", \"The Clemency of Titus\", \"6 September 1791\"),\r\n    Opera(\"mozart\", \"The Magic Flute\", \"30 September 1791\"),\r\n    Opera(\"wagner\", \"The Fairies\", \"29 June 1888\"),\r\n    Opera(\"wagner\", \"Rienzi\", \"20 October 1842\"),\r\n    Opera(\"wagner\", \"The Flying Dutchman\", \"2 January 1843\"),\r\n    Opera(\"wagner\", \"Tannh\u00e4user\", \"19 October 1845\"),\r\n    Opera(\"wagner\", \"Lohengrin\", \"28 August 1850\"),\r\n    Opera(\"wagner\", \"The Rhinegold\", \"22 September 1869\"),\r\n    Opera(\"wagner\", \"The Valkyrie\", \"26 June 1870\"),\r\n    Opera(\"wagner\", \"Siegfried\", \"16 August 1876\"),\r\n    Opera(\"wagner\", \"Twilight of the Gods\", \"17 August 1876\"),\r\n    Opera(\"wagner\", \"Tristan and Isolde\", \"10 June 1865\"),\r\n    Opera(\"wagner\", \"The Master-Singers of Nuremberg\", \"21 June 1868\"),\r\n    Opera(\"wagner\", \"Parsifal\", \"26 July 1882\"),\r\n    Opera(\"beethoven\", \"Fidelio\", \"20 November 1805\"),\r\n    Opera(\"verdi\", \"Nabucco\", \"9 March 1842\"),\r\n    Opera(\"verdi\", \"Ernani\", \"9 March 1844\"),\r\n    Opera(\"verdi\", \"Macbeth\", \"14 March 1847\"),\r\n    Opera(\"verdi\", \"Il corsaro\", \"25 October 1848\"),\r\n    Opera(\"verdi\", \"Rigoletto\", \"11 March 1851\"),\r\n    Opera(\"verdi\", \"La traviata\", \"6 March 1853\"),\r\n    Opera(\"verdi\", \"Aroldo\", \"16 August 1857\"),\r\n    Opera(\"verdi\", \"Macbeth\", \"21 April 1865\"),\r\n    Opera(\"verdi\", \"Don Carlos\", \"11 March 1867\"),\r\n    Opera(\"verdi\", \"Aida\", \"24 December 1871\"),\r\n    Opera(\"verdi\", \"Otello\", \"5 February 1887\"),\r\n    Opera(\"verdi\", \"Falstaff\", \"9 February 1893\"),\r\n]\r\n\r\n\r\ndef _get_date(date_str):\r\n    return datetime.date(datetime.strptime(date_str, \"%d %B %Y\"))\r\n\r\n\r\ndef operas_both_at_premiere(guest, composer):\r\n    \"\"\"Retrieves a list of titles of operas, where the guest and the composer\r\n       could have been together at premiere.\r\n\r\n       That is the Opera.author matches the composer passed in, and both guest\r\n       and composer are alive at the time of Opera.date.\r\n\r\n       If guest and/or composer are not in the composers dict, raise a\r\n       ValueError\r\n\r\n       Args:\r\n       guest (str): one of the composers but not the author of an opera\r\n       composer (str): the author of an opera\r\n\r\n       Returns a list (or generator) of titles of operas.\r\n    \"\"\"\r\n\r\n    if guest not in composers.values():\r\n        raise ValueError(f'guest {guest} not in list')\r\n    if composer not in composers.values():\r\n        raise ValueError(f'composer {composer} not in list')\r\n    \r\n    start = max(_get_date(guest.born), _get_date(composer.born))\r\n    end = min(_get_date(guest.died), _get_date(composer.died))\r\n    \r\n    if start > end:\r\n        print(start, end)\r\n        return []\r\n    \r\n    return [opera.play for opera in operas if start < _get_date(opera.date) < end and opera.author == composer]\r\n    \r\n\r\nprint(operas_both_at_premiere(composers['verdi'], composers['wagner']))",
            "date": "2022-12-03 11:08:40.745095+00:00",
            "passed": false
        },
        {
            "bite": "Bite 151. Contemporary Composers",
            "code": "from collections import namedtuple\r\nfrom datetime import datetime\r\n\r\nComposer = namedtuple('Composer', 'name born died')\r\nOpera = namedtuple('Opera', 'author play date')\r\n\r\ncomposers = {\r\n    \"beethoven\": Composer(\"Ludwig van Beethoven\",\r\n                          \"17 December 1770\", \"26 March 1827\"),\r\n    \"wagner\": Composer(\"Richard Wagner\",\r\n                       \"22 May 1813\", \"13 February 1883\"),\r\n    \"verdi\": Composer(\"Giuseppe Verdi\",\r\n                      \"9 October 1813\", \"27 January 1901\"),\r\n    \"mozart\": Composer(\"Wolfgang Amadeus Mozart\",\r\n                       \"27 January 1756\", \"5 December 1791\"),\r\n}\r\n\r\noperas = [\r\n    Opera(\"mozart\", \"Apollo and Hyacinth\", \"13 May 1767\"),\r\n    Opera(\"mozart\", \"Marriage of Figaro\", \"1 May 1786\"),\r\n    Opera(\"mozart\", \"Don Giovanni\", \"29 October 1787\"),\r\n    Opera(\"mozart\", \"Cos\u00ec fan tutte\", \"6 January 1790\"),\r\n    Opera(\"mozart\", \"The Clemency of Titus\", \"6 September 1791\"),\r\n    Opera(\"mozart\", \"The Magic Flute\", \"30 September 1791\"),\r\n    Opera(\"wagner\", \"The Fairies\", \"29 June 1888\"),\r\n    Opera(\"wagner\", \"Rienzi\", \"20 October 1842\"),\r\n    Opera(\"wagner\", \"The Flying Dutchman\", \"2 January 1843\"),\r\n    Opera(\"wagner\", \"Tannh\u00e4user\", \"19 October 1845\"),\r\n    Opera(\"wagner\", \"Lohengrin\", \"28 August 1850\"),\r\n    Opera(\"wagner\", \"The Rhinegold\", \"22 September 1869\"),\r\n    Opera(\"wagner\", \"The Valkyrie\", \"26 June 1870\"),\r\n    Opera(\"wagner\", \"Siegfried\", \"16 August 1876\"),\r\n    Opera(\"wagner\", \"Twilight of the Gods\", \"17 August 1876\"),\r\n    Opera(\"wagner\", \"Tristan and Isolde\", \"10 June 1865\"),\r\n    Opera(\"wagner\", \"The Master-Singers of Nuremberg\", \"21 June 1868\"),\r\n    Opera(\"wagner\", \"Parsifal\", \"26 July 1882\"),\r\n    Opera(\"beethoven\", \"Fidelio\", \"20 November 1805\"),\r\n    Opera(\"verdi\", \"Nabucco\", \"9 March 1842\"),\r\n    Opera(\"verdi\", \"Ernani\", \"9 March 1844\"),\r\n    Opera(\"verdi\", \"Macbeth\", \"14 March 1847\"),\r\n    Opera(\"verdi\", \"Il corsaro\", \"25 October 1848\"),\r\n    Opera(\"verdi\", \"Rigoletto\", \"11 March 1851\"),\r\n    Opera(\"verdi\", \"La traviata\", \"6 March 1853\"),\r\n    Opera(\"verdi\", \"Aroldo\", \"16 August 1857\"),\r\n    Opera(\"verdi\", \"Macbeth\", \"21 April 1865\"),\r\n    Opera(\"verdi\", \"Don Carlos\", \"11 March 1867\"),\r\n    Opera(\"verdi\", \"Aida\", \"24 December 1871\"),\r\n    Opera(\"verdi\", \"Otello\", \"5 February 1887\"),\r\n    Opera(\"verdi\", \"Falstaff\", \"9 February 1893\"),\r\n]\r\n\r\n\r\ndef _get_date(date_str):\r\n    return datetime.date(datetime.strptime(date_str, \"%d %B %Y\"))\r\n\r\n\r\ndef operas_both_at_premiere(guest, composer):\r\n    \"\"\"Retrieves a list of titles of operas, where the guest and the composer\r\n       could have been together at premiere.\r\n\r\n       That is the Opera.author matches the composer passed in, and both guest\r\n       and composer are alive at the time of Opera.date.\r\n\r\n       If guest and/or composer are not in the composers dict, raise a\r\n       ValueError\r\n\r\n       Args:\r\n       guest (str): one of the composers but not the author of an opera\r\n       composer (str): the author of an opera\r\n\r\n       Returns a list (or generator) of titles of operas.\r\n    \"\"\"\r\n\r\n    if guest not in composers.values():\r\n        raise ValueError(f'guest {guest} not in list')\r\n    if composer not in composers.values():\r\n        raise ValueError(f'composer {composer} not in list')\r\n    \r\n    start = max(_get_date(guest.born), _get_date(composer.born))\r\n    end = min(_get_date(guest.died), _get_date(composer.died))\r\n    \r\n    if start > end:\r\n        print(start, end)\r\n        return []\r\n    \r\n    return [opera.play for opera in operas if start < _get_date(opera.date) < end]\r\n    \r\n\r\nprint(operas_both_at_premiere(composers['verdi'], composers['wagner']))",
            "date": "2022-12-03 11:07:47.901657+00:00",
            "passed": false
        },
        {
            "bite": "Bite 84. Flatten lists recursively (Droste Bite)",
            "code": "def flatten(list_of_lists):\r\n    flat = []\r\n    for item in list_of_lists:\r\n        if isinstance(item, list) or isinstance(item,tuple):\r\n            for subitem in flatten(item):\r\n                flat.append(subitem) \r\n        else:\r\n            flat.append(item)\r\n    return flat\r\n\r\ntest =[1, [2, 3], [4, 5, [6, 7, [8, 9, 10]]]]\r\n\r\nprint(flatten(test))",
            "date": "2022-12-02 12:08:59.233979+00:00",
            "passed": true
        },
        {
            "bite": "Bite 23. Find words that are > 95% similar",
            "code": "import os\r\nimport re\r\nfrom difflib import SequenceMatcher\r\nimport itertools\r\nfrom urllib.request import urlretrieve\r\nimport string\r\n\r\n# prep\r\nTAG_HTML = re.compile(r'<category>([^<]+)</category>')\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nTEMPFILE = os.path.join(TMP, 'feed')\r\nMIN_TAG_LEN = 10\r\nIDENTICAL = 1.0\r\nSIMILAR = 0.95\r\n\r\nurlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/tags.xml',\r\n    TEMPFILE\r\n)\r\n\r\n\r\ndef _get_tags(tempfile=TEMPFILE):\r\n    \"\"\"Helper to parse all tags from a static copy of PyBites' feed,\r\n       providing this here so you can focus on difflib\"\"\"\r\n    with open(tempfile) as f:\r\n        content = f.read().lower()\r\n    # take a small subset to keep it performant\r\n    tags = TAG_HTML.findall(content)\r\n    tags = [tag for tag in tags if len(tag) > MIN_TAG_LEN]\r\n    return set(tags)\r\n\r\n\r\ndef get_similarities(tags=None):\r\n    \"\"\"Should return a list of similar tag pairs (tuples)\"\"\"\r\n    tags = tags or _get_tags()\r\n    # do your thing ...\r\n    JUNK = string.punctuation + string.whitespace\r\n    pairs = [\r\n        pair for pair in itertools.combinations(tags, 2) \r\n        if SequenceMatcher(\r\n            lambda x: x in JUNK, pair[0], pair[1]\r\n            ).ratio() >= SIMILAR\r\n        ]\r\n    return pairs\r\n    \r\n\r\n# get_similarities()\r\n\r\n",
            "date": "2022-12-02 11:52:07.604047+00:00",
            "passed": true
        },
        {
            "bite": "Bite 23. Find words that are > 95% similar",
            "code": "import os\r\nimport re\r\nfrom difflib import SequenceMatcher\r\nimport itertools\r\nfrom urllib.request import urlretrieve\r\nimport string\r\n\r\n# prep\r\nTAG_HTML = re.compile(r'<category>([^<]+)</category>')\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nTEMPFILE = os.path.join(TMP, 'feed')\r\nMIN_TAG_LEN = 10\r\nIDENTICAL = 1.0\r\nSIMILAR = 0.95\r\n\r\nurlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/tags.xml',\r\n    TEMPFILE\r\n)\r\n\r\n\r\ndef _get_tags(tempfile=TEMPFILE):\r\n    \"\"\"Helper to parse all tags from a static copy of PyBites' feed,\r\n       providing this here so you can focus on difflib\"\"\"\r\n    with open(tempfile) as f:\r\n        content = f.read().lower()\r\n    # take a small subset to keep it performant\r\n    tags = TAG_HTML.findall(content)\r\n    tags = [tag for tag in tags if len(tag) > MIN_TAG_LEN]\r\n    return set(tags)\r\n\r\n\r\ndef get_similarities(tags=None):\r\n    \"\"\"Should return a list of similar tag pairs (tuples)\"\"\"\r\n    tags = tags or _get_tags()\r\n    # do your thing ...\r\n    JUNK = string.punctuation + string.whitespace\r\n    pairs = [\r\n        pair for pair in itertools.combinations(tags, 2) \r\n        if SequenceMatcher(lambda x: x in JUNK, pair[0], pair[1]).ratio() >= SIMILAR\r\n        ]\r\n    return pairs\r\n    \r\n\r\n# get_similarities()\r\n\r\n",
            "date": "2022-12-02 11:51:27.069206+00:00",
            "passed": true
        },
        {
            "bite": "Bite 23. Find words that are > 95% similar",
            "code": "import os\r\nimport re\r\nfrom difflib import SequenceMatcher\r\nimport itertools\r\nfrom urllib.request import urlretrieve\r\nimport string\r\n\r\n# prep\r\nTAG_HTML = re.compile(r'<category>([^<]+)</category>')\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nTEMPFILE = os.path.join(TMP, 'feed')\r\nMIN_TAG_LEN = 10\r\nIDENTICAL = 1.0\r\nSIMILAR = 0.95\r\n\r\nurlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/tags.xml',\r\n    TEMPFILE\r\n)\r\n\r\n\r\ndef _get_tags(tempfile=TEMPFILE):\r\n    \"\"\"Helper to parse all tags from a static copy of PyBites' feed,\r\n       providing this here so you can focus on difflib\"\"\"\r\n    with open(tempfile) as f:\r\n        content = f.read().lower()\r\n    # take a small subset to keep it performant\r\n    tags = TAG_HTML.findall(content)\r\n    tags = [tag for tag in tags if len(tag) > MIN_TAG_LEN]\r\n    return set(tags)\r\n\r\n\r\ndef get_similarities(tags=None):\r\n    \"\"\"Should return a list of similar tag pairs (tuples)\"\"\"\r\n    tags = tags or _get_tags()\r\n    # do your thing ...\r\n    JUNK = string.punctuation + string.whitespace\r\n    pairs = [\r\n        pair for pair in itertools.combinations(tags, 2) \r\n        if SequenceMatcher(lambda x: x in JUNK, pair[0], pair[1]).ratio() >= SIMILAR\r\n        ]\r\n    print(pairs)\r\n    \r\n\r\nget_similarities()\r\n\r\n",
            "date": "2022-12-02 11:50:20.870060+00:00",
            "passed": false
        },
        {
            "bite": "Bite 141. Primitive date format inferrer",
            "code": "from enum import Enum\r\nfrom datetime import datetime\r\nfrom collections import Counter\r\nimport itertools\r\n\r\nclass DateFormat(Enum):\r\n    DDMMYY = 0  # dd/mm/yy\r\n    MMDDYY = 1  # mm/dd/yy\r\n    YYMMDD = 2  # yy/mm/dd\r\n    NONPARSABLE = -999\r\n\r\n\r\n    @classmethod\r\n    def get_d_parse_formats(cls, val=None):\r\n        \"\"\" Arg:\r\n        val(int | None) enum member value\r\n        Returns:\r\n        1. for val=None a list of explicit format strings \r\n            for all supported date formats in this enum\r\n        2. for val=n an explicit format string for a given enum member value\r\n        \"\"\"\r\n        d_parse_formats = [\"%d/%m/%y\", \"%m/%d/%y\", \"%y/%m/%d\"]\r\n        if val is None:\r\n            return d_parse_formats\r\n        if 0 <= val <= len(d_parse_formats):\r\n            return d_parse_formats[val]\r\n        raise ValueError\r\n\r\n\r\nclass InfDateFmtError(Exception):\r\n    \"\"\"custom exception when it is not possible to infer a date format\r\n    e.g. too many NONPARSABLE or a tie \"\"\"\r\n    pass\r\n\r\ndef _maybe_DateFormats(date_str):\r\n    \"\"\" Args:\r\n    date_str (str) string representing a date in unknown format\r\n    Returns:\r\n    a list of enum members, where each member represents\r\n    a possible date format for the input date_str\r\n    \"\"\"\r\n    d_parse_formats = DateFormat.get_d_parse_formats()\r\n    maybe_formats = []\r\n    for idx, d_parse_fmt in enumerate(d_parse_formats):\r\n        try:\r\n            _parsed_date = datetime.strptime(date_str, d_parse_fmt) # pylint: disable=W0612\r\n            maybe_formats.append(DateFormat(idx))\r\n        except ValueError:\r\n            pass\r\n    if len(maybe_formats) == 0:\r\n        maybe_formats.append(DateFormat.NONPARSABLE)\r\n    return maybe_formats\r\n\r\n\r\ndef get_dates(dates):\r\n    \"\"\" Args:\r\n    dates (list) list of date strings\r\n    where each list item represents a date in unknown format\r\n    Returns:\r\n    list of date strings, where each list item represents\r\n    a date in yyyy-mm-dd format. Date format of input date strings is\r\n    inferred based on the most prevalent format in the dates list.\r\n    Allowed/supported date formats are defined in a DF enum class.\r\n    \"\"\"\r\n    # complete this method\r\n\r\n    lst_of_guesses = [_maybe_DateFormats(date) for date in dates]\r\n    most_probable_formats = Counter(itertools.chain.from_iterable(lst_of_guesses)).most_common()\r\n\r\n    # dates are non parsable-> raise exception\r\n    if most_probable_formats[0][0] == DateFormat.NONPARSABLE:\r\n        raise InfDateFmtError\r\n    \r\n    # there are two most frequent formats with the same frequency -> raise exception\r\n    if len(most_probable_formats)>1 and most_probable_formats[0][1]== most_probable_formats[1][1]:\r\n        raise InfDateFmtError\r\n        \r\n    format_str = DateFormat.get_d_parse_formats(most_probable_formats[0][0].value)\r\n    \r\n    result=[]\r\n    for date in dates:\r\n        try:\r\n            result.append(datetime.strftime(datetime.strptime(date,format_str),'%Y-%m-%d'))\r\n        except:\r\n            result.append('Invalid')\r\n    return result\r\n\r\ntest_dates=['11/12/23','23/01/75', '09/04/75', '01/12/22','99/99/99']\r\n\r\nprint(get_dates(test_dates))",
            "date": "2022-12-01 19:05:55.269243+00:00",
            "passed": true
        },
        {
            "bite": "Bite 141. Primitive date format inferrer",
            "code": "from enum import Enum\r\nfrom datetime import datetime\r\nfrom collections import Counter\r\nimport itertools\r\n\r\nclass DateFormat(Enum):\r\n    DDMMYY = 0  # dd/mm/yy\r\n    MMDDYY = 1  # mm/dd/yy\r\n    YYMMDD = 2  # yy/mm/dd\r\n    NONPARSABLE = -999\r\n\r\n\r\n    @classmethod\r\n    def get_d_parse_formats(cls, val=None):\r\n        \"\"\" Arg:\r\n        val(int | None) enum member value\r\n        Returns:\r\n        1. for val=None a list of explicit format strings \r\n            for all supported date formats in this enum\r\n        2. for val=n an explicit format string for a given enum member value\r\n        \"\"\"\r\n        d_parse_formats = [\"%d/%m/%y\", \"%m/%d/%y\", \"%y/%m/%d\"]\r\n        if val is None:\r\n            return d_parse_formats\r\n        if 0 <= val <= len(d_parse_formats):\r\n            return d_parse_formats[val]\r\n        raise ValueError\r\n\r\n\r\nclass InfDateFmtError(Exception):\r\n    \"\"\"custom exception when it is not possible to infer a date format\r\n    e.g. too many NONPARSABLE or a tie \"\"\"\r\n    pass\r\n\r\ndef _maybe_DateFormats(date_str):\r\n    \"\"\" Args:\r\n    date_str (str) string representing a date in unknown format\r\n    Returns:\r\n    a list of enum members, where each member represents\r\n    a possible date format for the input date_str\r\n    \"\"\"\r\n    d_parse_formats = DateFormat.get_d_parse_formats()\r\n    maybe_formats = []\r\n    for idx, d_parse_fmt in enumerate(d_parse_formats):\r\n        try:\r\n            _parsed_date = datetime.strptime(date_str, d_parse_fmt) # pylint: disable=W0612\r\n            maybe_formats.append(DateFormat(idx))\r\n        except ValueError:\r\n            pass\r\n    if len(maybe_formats) == 0:\r\n        maybe_formats.append(DateFormat.NONPARSABLE)\r\n    return maybe_formats\r\n\r\n\r\ndef get_dates(dates):\r\n    \"\"\" Args:\r\n    dates (list) list of date strings\r\n    where each list item represents a date in unknown format\r\n    Returns:\r\n    list of date strings, where each list item represents\r\n    a date in yyyy-mm-dd format. Date format of input date strings is\r\n    inferred based on the most prevalent format in the dates list.\r\n    Allowed/supported date formats are defined in a DF enum class.\r\n    \"\"\"\r\n    # complete this method\r\n\r\n    lst_of_guesses = [_maybe_DateFormats(date) for date in dates]\r\n    most_probable_formats = Counter(itertools.chain.from_iterable(lst_of_guesses)).most_common()\r\n\r\n    if most_probable_formats[0][0] == DateFormat.NONPARSABLE:\r\n        raise InfDateFmtError\r\n    \r\n    if len(most_probable_formats)>1 and most_probable_formats[0][1]== most_probable_formats[1][1]:\r\n        raise InfDateFmtError\r\n        \r\n    format_str = DateFormat.get_d_parse_formats(most_probable_formats[0][0].value)\r\n    \r\n    result=[]\r\n    for date in dates:\r\n        try:\r\n            result.append(datetime.strftime(datetime.strptime(date,format_str),'%Y-%m-%d'))\r\n        except:\r\n            result.append('Invalid')\r\n    return result\r\n\r\ntest_dates=['11/12/23','23/01/75', '09/04/75', '01/12/22','99/99/99']\r\n\r\nprint(get_dates(test_dates))",
            "date": "2022-12-01 19:04:18.444919+00:00",
            "passed": true
        },
        {
            "bite": "Bite 141. Primitive date format inferrer",
            "code": "from enum import Enum\r\nfrom datetime import datetime\r\nfrom collections import Counter\r\nimport itertools\r\n\r\nclass DateFormat(Enum):\r\n    DDMMYY = 0  # dd/mm/yy\r\n    MMDDYY = 1  # mm/dd/yy\r\n    YYMMDD = 2  # yy/mm/dd\r\n    NONPARSABLE = -999\r\n\r\n\r\n    @classmethod\r\n    def get_d_parse_formats(cls, val=None):\r\n        \"\"\" Arg:\r\n        val(int | None) enum member value\r\n        Returns:\r\n        1. for val=None a list of explicit format strings \r\n            for all supported date formats in this enum\r\n        2. for val=n an explicit format string for a given enum member value\r\n        \"\"\"\r\n        d_parse_formats = [\"%d/%m/%y\", \"%m/%d/%y\", \"%y/%m/%d\"]\r\n        if val is None:\r\n            return d_parse_formats\r\n        if 0 <= val <= len(d_parse_formats):\r\n            return d_parse_formats[val]\r\n        raise ValueError\r\n\r\n\r\nclass InfDateFmtError(Exception):\r\n    \"\"\"custom exception when it is not possible to infer a date format\r\n    e.g. too many NONPARSABLE or a tie \"\"\"\r\n    pass\r\n\r\ndef _maybe_DateFormats(date_str):\r\n    \"\"\" Args:\r\n    date_str (str) string representing a date in unknown format\r\n    Returns:\r\n    a list of enum members, where each member represents\r\n    a possible date format for the input date_str\r\n    \"\"\"\r\n    d_parse_formats = DateFormat.get_d_parse_formats()\r\n    maybe_formats = []\r\n    for idx, d_parse_fmt in enumerate(d_parse_formats):\r\n        try:\r\n            _parsed_date = datetime.strptime(date_str, d_parse_fmt) # pylint: disable=W0612\r\n            maybe_formats.append(DateFormat(idx))\r\n        except ValueError:\r\n            pass\r\n    if len(maybe_formats) == 0:\r\n        maybe_formats.append(DateFormat.NONPARSABLE)\r\n    return maybe_formats\r\n\r\n\r\ndef get_dates(dates):\r\n    \"\"\" Args:\r\n    dates (list) list of date strings\r\n    where each list item represents a date in unknown format\r\n    Returns:\r\n    list of date strings, where each list item represents\r\n    a date in yyyy-mm-dd format. Date format of input date strings is\r\n    inferred based on the most prevalent format in the dates list.\r\n    Allowed/supported date formats are defined in a DF enum class.\r\n    \"\"\"\r\n    # complete this method\r\n\r\n    lst_of_guesses = [_maybe_DateFormats(date) for date in dates]\r\n    most_probable_format = Counter(itertools.chain.from_iterable(lst_of_guesses)).most_common(1)[0][0]\r\n\r\n    if most_probable_format == DateFormat.NONPARSABLE:\r\n         raise InfDateFmtError\r\n    format_str = DateFormat.get_d_parse_formats(most_probable_format.value)\r\n    \r\n    result=[]\r\n    for date in dates:\r\n        try:\r\n            result.append(datetime.strftime(datetime.strptime(date,format_str),'%Y-%m-%d'))\r\n        except:\r\n            result.append('Invalid')\r\n    return result\r\n\r\ntest_dates=['11/12/23','23/01/75', '09/04/75', '01/12/22','99/99/99']\r\n\r\nprint(get_dates(test_dates))",
            "date": "2022-12-01 18:58:43.200300+00:00",
            "passed": false
        },
        {
            "bite": "Bite 141. Primitive date format inferrer",
            "code": "from enum import Enum\r\nfrom datetime import datetime\r\nfrom collections import Counter\r\nimport itertools\r\n\r\nclass DateFormat(Enum):\r\n    DDMMYY = 0  # dd/mm/yy\r\n    MMDDYY = 1  # mm/dd/yy\r\n    YYMMDD = 2  # yy/mm/dd\r\n    NONPARSABLE = -999\r\n\r\n\r\n    @classmethod\r\n    def get_d_parse_formats(cls, val=None):\r\n        \"\"\" Arg:\r\n        val(int | None) enum member value\r\n        Returns:\r\n        1. for val=None a list of explicit format strings \r\n            for all supported date formats in this enum\r\n        2. for val=n an explicit format string for a given enum member value\r\n        \"\"\"\r\n        d_parse_formats = [\"%d/%m/%y\", \"%m/%d/%y\", \"%y/%m/%d\"]\r\n        if val is None:\r\n            return d_parse_formats\r\n        if 0 <= val <= len(d_parse_formats):\r\n            return d_parse_formats[val]\r\n        raise ValueError\r\n\r\n\r\nclass InfDateFmtError(Exception):\r\n    \"\"\"custom exception when it is not possible to infer a date format\r\n    e.g. too many NONPARSABLE or a tie \"\"\"\r\n    pass\r\n\r\ndef _maybe_DateFormats(date_str):\r\n    \"\"\" Args:\r\n    date_str (str) string representing a date in unknown format\r\n    Returns:\r\n    a list of enum members, where each member represents\r\n    a possible date format for the input date_str\r\n    \"\"\"\r\n    d_parse_formats = DateFormat.get_d_parse_formats()\r\n    maybe_formats = []\r\n    for idx, d_parse_fmt in enumerate(d_parse_formats):\r\n        try:\r\n            _parsed_date = datetime.strptime(date_str, d_parse_fmt) # pylint: disable=W0612\r\n            maybe_formats.append(DateFormat(idx))\r\n        except ValueError:\r\n            pass\r\n    if len(maybe_formats) == 0:\r\n        maybe_formats.append(DateFormat.NONPARSABLE)\r\n    return maybe_formats\r\n\r\n\r\ndef get_dates(dates):\r\n    \"\"\" Args:\r\n    dates (list) list of date strings\r\n    where each list item represents a date in unknown format\r\n    Returns:\r\n    list of date strings, where each list item represents\r\n    a date in yyyy-mm-dd format. Date format of input date strings is\r\n    inferred based on the most prevalent format in the dates list.\r\n    Allowed/supported date formats are defined in a DF enum class.\r\n    \"\"\"\r\n    # complete this method\r\n\r\n    lst_of_guesses = [_maybe_DateFormats(date) for date in dates]\r\n    most_probable_format = Counter(itertools.chain.from_iterable(lst_of_guesses)).most_common(1)[0][0]\r\n    print(most_probable_format.value)\r\n    format_str = DateFormat.get_d_parse_formats(most_probable_format.value)\r\n\r\n    return [datetime.strftime(datetime.strptime(date,format_str),'%Y-%m-%d') for date in dates]\r\n    \r\n\r\ntest_dates=['11/12/23','23/01/75', '09/04/75', '01/12/22']\r\n\r\nprint(get_dates(test_dates))",
            "date": "2022-12-01 18:52:56.931331+00:00",
            "passed": false
        },
        {
            "bite": "Bite 147. 100 WEEKDays of Code Date Range",
            "code": "from datetime import date\r\n\r\nimport dateutil.rrule as RR\r\n\r\nTODAY = date(year=2018, month=11, day=29)\r\nWEEKDAYS=[RR.MO,RR.TU,RR.WE,RR.TH, RR.FR]\r\n\r\ndef get_hundred_weekdays(start_date=TODAY):\r\n    \"\"\"Return a list of hundred date objects starting from\r\n       start_date up till 100 weekdays later, so +100 days\r\n       skipping Saturdays and Sundays\"\"\"\r\n    \r\n    return [d.date() for d in RR.rrule(freq=RR.DAILY, count=100, dtstart=start_date, byweekday=WEEKDAYS)]\r\n\r\n\r\nprint(get_hundred_weekdays(start_date=date.today()))",
            "date": "2022-12-01 18:08:05.965289+00:00",
            "passed": true
        },
        {
            "bite": "Bite 147. 100 WEEKDays of Code Date Range",
            "code": "from datetime import date\r\n\r\nimport dateutil.rrule as RR\r\n\r\nTODAY = date(year=2018, month=11, day=29)\r\n\r\n\r\ndef get_hundred_weekdays(start_date=TODAY):\r\n    \"\"\"Return a list of hundred date objects starting from\r\n       start_date up till 100 weekdays later, so +100 days\r\n       skipping Saturdays and Sundays\"\"\"\r\n    \r\n    return list(RR.rrule(freq=RR.DAILY, count=100, dtstart=start_date, byweekday=[RR.MO,RR.TU,RR.WE,RR.TH, RR.FR]))\r\n\r\n\r\nprint(get_hundred_weekdays(start_date=date.today()))",
            "date": "2022-12-01 18:04:14.835177+00:00",
            "passed": false
        },
        {
            "bite": "Bite 147. 100 WEEKDays of Code Date Range",
            "code": "from datetime import date\r\n\r\nimport dateutil.rrule as RR\r\n\r\nTODAY = date(year=2018, month=11, day=29)\r\n\r\n\r\ndef get_hundred_weekdays(start_date=TODAY, N=100):\r\n    \"\"\"Return a list of hundred date objects starting from\r\n       start_date up till 100 weekdays later, so +100 days\r\n       skipping Saturdays and Sundays\"\"\"\r\n    \r\n    return list(RR.rrule(freq=RR.DAILY, count=N, dtstart=start_date, byweekday=[RR.MO,RR.TU,RR.WE,RR.TH, RR.FR]))\r\n\r\n\r\nprint(get_hundred_weekdays(start_date=date.today(), N=5))",
            "date": "2022-12-01 18:03:42.024428+00:00",
            "passed": false
        },
        {
            "bite": "Bite 113. Filter words with non-ascii characters",
            "code": "import string\r\nimport unicodedata\r\n\r\ndef _non_ascii_char(c):\r\n    # non-ascii number: it is a number but not an ascii number \r\n    if unicodedata.category(c) in ['Nd'] and c not in string.digits:\r\n            return True\r\n    # non-ascii letter: it is not punctuation or number (i.e. it is a letter) but not an ascii letter\r\n    if unicodedata.category(c) not in ['Po', 'Pd', 'Nd'] and c.lower() not in string.ascii_lowercase:\r\n            return True\r\n    return False\r\n    \r\ndef extract_non_ascii_words(text):\r\n    \"\"\"Filter a text returning a list of non-ascii words\"\"\"\r\n    return [word for word in text.split() if any(_non_ascii_char(c) for c in word.strip())]\r\n\r\n",
            "date": "2022-11-30 23:46:44.883074+00:00",
            "passed": true
        },
        {
            "bite": "Bite 113. Filter words with non-ascii characters",
            "code": "import string\r\nimport unicodedata\r\n\r\ndef _non_ascii_char(c):\r\n    # non-ascii number \r\n    if unicodedata.category(c) in ['Nd'] and c not in string.digits:\r\n            return True\r\n    # non-ascii letter\r\n    if unicodedata.category(c) not in ['Po', 'Pd', 'Nd'] and c.lower() not in string.ascii_lowercase:\r\n            return True\r\n    return False\r\n    \r\ndef extract_non_ascii_words(text):\r\n    \"\"\"Filter a text returning a list of non-ascii words\"\"\"\r\n    return [word for word in text.split() if any(_non_ascii_char(c) for c in word.strip())]\r\n\r\n    \r\nprint(extract_non_ascii_words('He wonede at Ernle\u021de at \u00e6\u00f0elen are chirechen'))\r\nprint(extract_non_ascii_words('Over \\u0e55\\u0e57 57 flavours'))\r\n",
            "date": "2022-11-30 23:43:21.086383+00:00",
            "passed": true
        },
        {
            "bite": "Bite 113. Filter words with non-ascii characters",
            "code": "import string\r\nimport unicodedata\r\n\r\ndef _non_ascii_char(c):\r\n    # non-ascii number \r\n    if unicodedata.category(c) in ['Nd'] and c not in string.digits:\r\n            # print(\"non-ascii number: \",c)\r\n            return True\r\n    # non-ascii letter\r\n    if unicodedata.category(c) not in ['Po', 'Pd', 'Nd'] and c.lower() not in string.ascii_lowercase:\r\n            # print(\"non-ascii letter: \",c)\r\n            return True\r\n    return False\r\n    \r\ndef extract_non_ascii_words(text):\r\n    \"\"\"Filter a text returning a list of non-ascii words\"\"\"\r\n    result=[]\r\n    for word in text.split():\r\n        for c in word.strip():\r\n            if _non_ascii_char(c):\r\n                # print(\"...in: \",word)\r\n                result.append(word)\r\n                break\r\n                \r\n    return result\r\n    \r\nprint(extract_non_ascii_words('He wonede at Ernle\u021de at \u00e6\u00f0elen are chirechen'))\r\nprint(extract_non_ascii_words('Over \\u0e55\\u0e57 57 flavours'))\r\n",
            "date": "2022-11-30 23:40:02.013756+00:00",
            "passed": true
        },
        {
            "bite": "Bite 113. Filter words with non-ascii characters",
            "code": "import string\r\nimport unicodedata\r\n\r\ndef _non_ascii_char(c):\r\n    # non-ascii number \r\n    if unicodedata.category(c) in ['Nd']:\r\n        if c not in string.digits:\r\n            return True\r\n    # non-ascii letter\r\n    if unicodedata.category(c) not in ['Po', 'Pd']: \r\n        if c.lower() not in string.ascii_lowercase:\r\n            return True\r\n    return False\r\n    \r\ndef extract_non_ascii_words(text):\r\n    \"\"\"Filter a text returning a list of non-ascii words\"\"\"\r\n    result=[]\r\n    for word in text.split():\r\n        print(word)\r\n        for c in word.strip():\r\n\r\n            if _non_ascii_char(c): \r\n                print(word)\r\n                result.append(word)\r\n                break\r\n                \r\n    return result\r\n    \r\nprint(extract_non_ascii_words('He wonede at Ernle\u021de at \u00e6\u00f0elen are chirechen'))\r\n\r\n",
            "date": "2022-11-30 23:34:46.385937+00:00",
            "passed": false
        },
        {
            "bite": "Bite 113. Filter words with non-ascii characters",
            "code": "import string\r\nimport unicodedata\r\n\r\ndef extract_non_ascii_words(text):\r\n    \"\"\"Filter a text returning a list of non-ascii words\"\"\"\r\n    result=[]\r\n    for word in text.split():\r\n        print(word)\r\n        for c in word.strip():\r\n            # non-ascii number or non-ascii letter\r\n            if (unicodedata.category(c) in ['Nd'] and c not in string.digits) or \\\r\n            (unicodedata.category(c) not in ['Po', 'Pd'] and c.lower() not in string.ascii_lowercase): \r\n                print(word)\r\n                result.append(word)\r\n                break\r\n                \r\n    return result\r\n    \r\nprint(extract_non_ascii_words('He wonede at Ernle\u021de at \u00e6\u00f0elen are chirechen'))\r\n\r\n",
            "date": "2022-11-30 23:30:42.162179+00:00",
            "passed": false
        },
        {
            "bite": "Bite 342. Food logging CRUD",
            "code": "from datetime import datetime\r\nfrom typing import Any, Dict, List\r\n\r\nfrom fastapi import FastAPI, HTTPException\r\nfrom passlib.context import CryptContext\r\nfrom pydantic import BaseModel\r\n\r\n# https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/\r\n# We'll export authentication further in a later Bite\r\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\r\n\r\n\r\ndef get_password_hash(password):\r\n    return pwd_context.hash(password)\r\n\r\n\r\nclass Food(BaseModel):\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n\r\nclass User(BaseModel):\r\n    id: int\r\n    username: str\r\n    password: str\r\n\r\n    def __init__(self, **data: Any):\r\n        data[\"password\"] = get_password_hash(data[\"password\"])\r\n        super().__init__(**data)\r\n\r\n\r\nclass FoodEntry(BaseModel):\r\n    id: int\r\n    user: User\r\n    food: Food\r\n    date_added: datetime = datetime.now()\r\n    number_servings: float\r\n\r\n    @property\r\n    def total_calories(self):\r\n        return self.food.kcal_per_serving * self.number_servings\r\n\r\n\r\napp = FastAPI()\r\nfood_log: Dict[int, FoodEntry] = {}\r\n\r\n# We've hidden the previous Food CRUD to keep it compact and to force you to\r\n# repeat the API building process (deliberate practice is key!)\r\n\r\n# Create CRUD endpoints for FoodEntry below as per instructions in the Bite ...\r\n\r\n\r\n@app.post('/', status_code=201)\r\nasync def create_food_entry(food_entry: FoodEntry):\r\n    food_log[food_entry.id]=food_entry\r\n    return food_entry\r\n\r\n\r\n@app.get('/{user_id}', response_model=List[FoodEntry])\r\nasync def get_foods_for_user(user_id:int):\r\n    return [food_entry for food_entry in food_log.values() if food_entry.user.id == user_id]\r\n\r\n\r\n@app.put('/{entry_id}')\r\nasync def update_food_entry(entry_id:int, food_entry:FoodEntry):\r\n    if entry_id not in food_log:\r\n        raise HTTPException(404, detail='Food entry not found')\r\n    food_log[entry_id]=food_entry\r\n    return food_entry\r\n\r\n\r\n@app.delete('/{entry_id}')\r\nasync def delete_food_entry(entry_id:int):\r\n    try:\r\n        food_log.pop(entry_id)\r\n    except:\r\n        raise HTTPException(404, detail='Food entry not found')\r\n    return {'ok': True}\r\n\r\n\r\n    \r\n    ",
            "date": "2022-11-29 23:07:41.638526+00:00",
            "passed": true
        },
        {
            "bite": "Bite 342. Food logging CRUD",
            "code": "from datetime import datetime\r\nfrom typing import Any, Dict, List\r\n\r\nfrom fastapi import FastAPI, HTTPException\r\nfrom passlib.context import CryptContext\r\nfrom pydantic import BaseModel\r\n\r\n# https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/\r\n# We'll export authentication further in a later Bite\r\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\r\n\r\n\r\ndef get_password_hash(password):\r\n    return pwd_context.hash(password)\r\n\r\n\r\nclass Food(BaseModel):\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n\r\nclass User(BaseModel):\r\n    id: int\r\n    username: str\r\n    password: str\r\n\r\n    def __init__(self, **data: Any):\r\n        data[\"password\"] = get_password_hash(data[\"password\"])\r\n        super().__init__(**data)\r\n\r\n\r\nclass FoodEntry(BaseModel):\r\n    id: int\r\n    user: User\r\n    food: Food\r\n    date_added: datetime = datetime.now()\r\n    number_servings: float\r\n\r\n    @property\r\n    def total_calories(self):\r\n        return self.food.kcal_per_serving * self.number_servings\r\n\r\n\r\napp = FastAPI()\r\nfood_log: Dict[int, FoodEntry] = {}\r\n\r\n# We've hidden the previous Food CRUD to keep it compact and to force you to\r\n# repeat the API building process (deliberate practice is key!)\r\n\r\n# Create CRUD endpoints for FoodEntry below as per instructions in the Bite ...\r\n\r\n\r\n@app.post('/', status_code=201)\r\nasync def create_food_entry(food_entry: FoodEntry):\r\n    food_log[food_entry.id]=food_entry\r\n    return food_entry\r\n\r\n\r\n@app.get('/{user_id}', response_model=List[FoodEntry])\r\nasync def get_foods_for_user(user_id:int):\r\n    return [food_entry for food_entry in food_log.values() if food_entry.user.id == user_id]\r\n\r\n\r\n@app.put('/{entry_id}')\r\nasync def update_food_entry(entry_id:int, food_entry:FoodEntry):\r\n    if entry_id not in food_log:\r\n        raise HTTPException(404, detail='Food entry not found')\r\n    food_log[entry_id]=food_entry\r\n    return food_entry\r\n\r\n\r\n@app.delete('/{entry_id}')\r\nasync def delete_food_entry(entry_id:int):\r\n    print(f' ** deleting {entry_id=} ** ')\r\n    print(f' ** food_log[ ** ')\r\n    try:\r\n        food_log.pop(entry_id)\r\n    except:\r\n        print(f' ** didnt work ** ')\r\n        raise HTTPException(404, detail='Food entry not found')\r\n    print(f' ** WORKED ** ')\r\n    return {'ok': True}\r\n\r\n\r\n    \r\n    ",
            "date": "2022-11-29 23:07:05.687824+00:00",
            "passed": true
        },
        {
            "bite": "Bite 342. Food logging CRUD",
            "code": "from datetime import datetime\r\nfrom typing import Any, Dict, List\r\n\r\nfrom fastapi import FastAPI\r\nfrom passlib.context import CryptContext\r\nfrom pydantic import BaseModel\r\n\r\n# https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/\r\n# We'll export authentication further in a later Bite\r\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\r\n\r\n\r\ndef get_password_hash(password):\r\n    return pwd_context.hash(password)\r\n\r\n\r\nclass Food(BaseModel):\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n\r\nclass User(BaseModel):\r\n    id: int\r\n    username: str\r\n    password: str\r\n\r\n    def __init__(self, **data: Any):\r\n        data[\"password\"] = get_password_hash(data[\"password\"])\r\n        super().__init__(**data)\r\n\r\n\r\nclass FoodEntry(BaseModel):\r\n    id: int\r\n    user: User\r\n    food: Food\r\n    date_added: datetime = datetime.now()\r\n    number_servings: float\r\n\r\n    @property\r\n    def total_calories(self):\r\n        return self.food.kcal_per_serving * self.number_servings\r\n\r\n\r\napp = FastAPI()\r\nfood_log: Dict[int, FoodEntry] = {}\r\n\r\n# We've hidden the previous Food CRUD to keep it compact and to force you to\r\n# repeat the API building process (deliberate practice is key!)\r\n\r\n# Create CRUD endpoints for FoodEntry below as per instructions in the Bite ...\r\n\r\n\r\n@app.post('/', status_code=201)\r\nasync def create_food_entry(food_entry: FoodEntry):\r\n    food_log[food_entry.id]=food_entry\r\n    return food_entry\r\n\r\n\r\n@app.get('/{user_id}', response_model=List[FoodEntry])\r\nasync def get_foods_for_user(user_id:int):\r\n    return [food_entry for food_entry in food_log.values() if food_entry.user.id == user_id]\r\n\r\n\r\n@app.put('/{entry_id}')\r\nasync def update_food_entry(entry_id:int, food_entry:FoodEntry):\r\n    if entry_id not in food_log:\r\n        raise HTTPException(404, detail='Food entry not found')\r\n    food_log[entry_id]=food_entry\r\n    return food_entry\r\n\r\n\r\n@app.delete('/{entry_id}')\r\nasync def delete_food_entry(entry_id:int):\r\n    print(f' ** deleting {entry_id=} ** ')\r\n    print(f' ** food_log[ ** ')\r\n    try:\r\n        food_log.pop(entry_id)\r\n    except:\r\n        print(f' ** didnt work ** ')\r\n        raise HTTPException(404, detail='Food entry not found')\r\n    print(f' ** WORKED ** ')\r\n    return {'ok': True}\r\n\r\n\r\n    \r\n    ",
            "date": "2022-11-29 23:05:12.501597+00:00",
            "passed": false
        },
        {
            "bite": "Bite 342. Food logging CRUD",
            "code": "from datetime import datetime\r\nfrom typing import Any, Dict, List\r\n\r\nfrom fastapi import FastAPI\r\nfrom passlib.context import CryptContext\r\nfrom pydantic import BaseModel\r\n\r\n# https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/\r\n# We'll export authentication further in a later Bite\r\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\r\n\r\n\r\ndef get_password_hash(password):\r\n    return pwd_context.hash(password)\r\n\r\n\r\nclass Food(BaseModel):\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n\r\nclass User(BaseModel):\r\n    id: int\r\n    username: str\r\n    password: str\r\n\r\n    def __init__(self, **data: Any):\r\n        data[\"password\"] = get_password_hash(data[\"password\"])\r\n        super().__init__(**data)\r\n\r\n\r\nclass FoodEntry(BaseModel):\r\n    id: int\r\n    user: User\r\n    food: Food\r\n    date_added: datetime = datetime.now()\r\n    number_servings: float\r\n\r\n    @property\r\n    def total_calories(self):\r\n        return self.food.kcal_per_serving * self.number_servings\r\n\r\n\r\napp = FastAPI()\r\nfood_log: Dict[int, FoodEntry] = {}\r\n\r\n# We've hidden the previous Food CRUD to keep it compact and to force you to\r\n# repeat the API building process (deliberate practice is key!)\r\n\r\n# Create CRUD endpoints for FoodEntry below as per instructions in the Bite ...\r\n\r\n\r\n@app.post('/', status_code=201)\r\nasync def create_food_entry(food_entry: FoodEntry):\r\n    food_log[food_entry.id]=food_entry\r\n    print(f' ** {food_entry=} ** ')\r\n    return food_entry\r\n\r\n\r\n@app.get('/{user_id}', response_model=List[FoodEntry])\r\nasync def get_foods_for_user(user_id:int):\r\n    return [food_entry for food_entry in food_log.values() if food_entry.user.id == user_id]\r\n\r\n\r\n@app.put('/{entry_id}')\r\nasync def update_food_entry(entry_id:int, food_entry:FoodEntry):\r\n    if entry_id not in food_log:\r\n        raise HTTPException(404, detail='Food entry not found')\r\n    food_log[entry_id]=food_entry\r\n    return food_entry\r\n\r\n\r\n@app.delete('/{entry_id}')\r\nasync def delete_food_entry(user_id:int):\r\n    try:\r\n        food_log.pop(entry_id)\r\n    except:\r\n        raise HTTPException(404, detail='Food entry not found')\r\n    return {'ok': True}\r\n\r\n\r\n    \r\n    ",
            "date": "2022-11-29 23:01:58.200165+00:00",
            "passed": false
        },
        {
            "bite": "Bite 342. Food logging CRUD",
            "code": "from datetime import datetime\r\nfrom typing import Any, Dict, List\r\n\r\nfrom fastapi import FastAPI\r\nfrom passlib.context import CryptContext\r\nfrom pydantic import BaseModel\r\n\r\n# https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/\r\n# We'll export authentication further in a later Bite\r\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\r\n\r\n\r\ndef get_password_hash(password):\r\n    return pwd_context.hash(password)\r\n\r\n\r\nclass Food(BaseModel):\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n\r\nclass User(BaseModel):\r\n    id: int\r\n    username: str\r\n    password: str\r\n\r\n    def __init__(self, **data: Any):\r\n        data[\"password\"] = get_password_hash(data[\"password\"])\r\n        super().__init__(**data)\r\n\r\n\r\nclass FoodEntry(BaseModel):\r\n    id: int\r\n    user: User\r\n    food: Food\r\n    date_added: datetime = datetime.now()\r\n    number_servings: float\r\n\r\n    @property\r\n    def total_calories(self):\r\n        return self.food.kcal_per_serving * self.number_servings\r\n\r\n\r\napp = FastAPI()\r\nfood_log: Dict[int, FoodEntry] = {}\r\n\r\n# We've hidden the previous Food CRUD to keep it compact and to force you to\r\n# repeat the API building process (deliberate practice is key!)\r\n\r\n# Create CRUD endpoints for FoodEntry below as per instructions in the Bite ...\r\n\r\n\r\n@app.post('/', status_code=201)\r\nasync def create_food_entry(food_entry: FoodEntry):\r\n    food_log[food_entry.id]=food_entry\r\n    print(f'{food_entry=}')\r\n    return food_entry\r\n\r\n\r\n@app.get('/{user_id}', response_model=List[FoodEntry])\r\nasync def get_foods_for_user(user_id:int):\r\n    return [food_entry for food_entry in food_log.values() if food_entry.user.id == user_id]\r\n\r\n\r\n@app.put('/{entry_id}')\r\nasync def update_food_entry(entry_id:int, food_entry:FoodEntry):\r\n    if entry_id not in food_log:\r\n        raise HTTPException(404, detail='Food entry not found')\r\n    food_log[entry_id]=food_entry\r\n    return food_entry\r\n\r\n\r\n@app.delete('/{entry_id}')\r\nasync def delete_food_entry(user_id:int):\r\n    try:\r\n        food_log.pop(entry_id)\r\n    except:\r\n        raise HTTPException(404, detail='Food entry not found')\r\n    return {'ok': True}\r\n\r\n\r\n    \r\n    ",
            "date": "2022-11-29 23:00:56.294318+00:00",
            "passed": false
        },
        {
            "bite": "Bite 341. Pydantic part II",
            "code": "from datetime import datetime\r\nfrom typing import Any\r\n\r\nfrom passlib.context import CryptContext\r\nfrom pydantic import BaseModel\r\n\r\n\r\n# https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/\r\n# which we'll further explore in a later Bite\r\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\r\n\r\n\r\ndef get_password_hash(password):\r\n    return pwd_context.hash(password)\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n# Write the User and FoodEntry models here ...\r\n\r\nclass User(BaseModel):\r\n    id: int\r\n    username: str\r\n    password: str  # (needed for authentication later)\r\n\r\n    # For password override the constructor (__init__.py) to hash the password upon creation of the module. \r\n    # You can use the provided get_password_hash()\u00a0function for this.\r\n    \r\n    def __init__(self, *a, **kw):\r\n        super().__init__(*a, **kw)\r\n        self.password = get_password_hash(self.password)\r\n\r\n\r\nclass FoodEntry(BaseModel):\r\n    id: int  # (what in a DB would be the primary key)\r\n    user: User\r\n    food: Food\r\n    date_added: datetime = datetime.now()\r\n    number_servings: float\r\n\r\n    # add a property to calculate the total calories of a food entry \r\n    \r\n    @property\r\n    def total_calories(self):\r\n        return self.food.kcal_per_serving * self.number_servings\r\n        \r\n",
            "date": "2022-11-29 18:06:11.684811+00:00",
            "passed": true
        },
        {
            "bite": "Bite 341. Pydantic part II",
            "code": "from datetime import datetime\r\nfrom typing import Any\r\n\r\nfrom passlib.context import CryptContext\r\nfrom pydantic import BaseModel\r\n\r\nfrom pydantic.dataclasses import dataclass\r\n\r\n\r\n# https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/\r\n# which we'll further explore in a later Bite\r\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\r\n\r\n\r\ndef get_password_hash(password):\r\n    return pwd_context.hash(password)\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n# Write the User and FoodEntry models here ...\r\n\r\nclass User(BaseModel):\r\n    id: int\r\n    username: str\r\n    password: str  # (needed for authentication later)\r\n\r\n    # For password override the constructor (__init__.py) to hash the password upon creation of the module. \r\n    # You can use the provided get_password_hash()\u00a0function for this.\r\n    \r\n    def __init__(self, *a, **kw):\r\n        super().__init__(*a, **kw)\r\n        self.password = get_password_hash(self.password)\r\n\r\n\r\nclass FoodEntry(BaseModel):\r\n    id: int  # (what in a DB would be the primary key)\r\n    user: User\r\n    food: Food\r\n    date_added: datetime = datetime.now()\r\n    number_servings: float\r\n\r\n    # add a property to calculate the total calories of a food entry \r\n    \r\n    @property\r\n    def total_calories(self):\r\n        return self.food.kcal_per_serving * self.number_servings\r\n        \r\n",
            "date": "2022-11-29 18:05:35.114160+00:00",
            "passed": true
        },
        {
            "bite": "Bite 341. Pydantic part II",
            "code": "from datetime import datetime\r\nfrom typing import Any\r\n\r\nfrom passlib.context import CryptContext\r\nfrom pydantic import BaseModel\r\n\r\nfrom pydantic.dataclasses import dataclass\r\n\r\n\r\n# https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/\r\n# which we'll further explore in a later Bite\r\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\r\n\r\n\r\ndef get_password_hash(password):\r\n    return pwd_context.hash(password)\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n# Write the User and FoodEntry models here ...\r\n\r\n@dataclass\r\nclass User(BaseModel):\r\n    id: int\r\n    username: str\r\n    password: str  # (needed for authentication later)\r\n\r\n    # For password override the constructor (__init__.py) to hash the password upon creation of the module. \r\n    # You can use the provided get_password_hash()\u00a0function for this.\r\n    \r\n    def __post_init__(self):\r\n        self.password = get_password_hash(self.password)\r\n\r\n\r\nclass FoodEntry(BaseModel):\r\n    id: int  # (what in a DB would be the primary key)\r\n    user: User\r\n    food: Food\r\n    date_added: datetime = datetime.now()\r\n    number_servings: float\r\n\r\n    # add a property to calculate the total calories of a food entry \r\n    \r\n    @property\r\n    def total_calories(self):\r\n        return self.food.kcal_per_serving * self.number_servings\r\n        \r\n",
            "date": "2022-11-29 17:50:38.167658+00:00",
            "passed": false
        },
        {
            "bite": "Bite 341. Pydantic part II",
            "code": "from datetime import datetime\r\nfrom typing import Any\r\n\r\nfrom passlib.context import CryptContext\r\nfrom pydantic import BaseModel\r\n\r\n\r\n\r\n# https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/\r\n# which we'll further explore in a later Bite\r\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\r\n\r\n\r\ndef get_password_hash(password):\r\n    return pwd_context.hash(password)\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n# Write the User and FoodEntry models here ...\r\n\r\nclass User(BaseModel):\r\n    id: int\r\n    username: str\r\n    password: str  # (needed for authentication later)\r\n\r\n    # For password override the constructor (__init__.py) to hash the password upon creation of the module. \r\n    # You can use the provided get_password_hash()\u00a0function for this.\r\n    \r\n    def __init__(self, **data):\r\n        self.password = get_password_hash(data['password'])\r\n        super().__init__(**data)\r\n\r\nclass FoodEntry(BaseModel):\r\n    id: int  # (what in a DB would be the primary key)\r\n    user: User\r\n    food: Food\r\n    date_added: datetime = datetime.now()\r\n    number_servings: float\r\n\r\n    # add a property to calculate the total calories of a food entry \r\n    \r\n    @property\r\n    def total_calories(self):\r\n        return self.food.kcal_per_serving * self.number_servings\r\n        \r\n",
            "date": "2022-11-29 17:45:22.659876+00:00",
            "passed": false
        },
        {
            "bite": "Bite 341. Pydantic part II",
            "code": "from datetime import datetime\r\nfrom typing import Any\r\n\r\nfrom passlib.context import CryptContext\r\nfrom pydantic import BaseModel\r\n\r\n\r\n\r\n# https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/\r\n# which we'll further explore in a later Bite\r\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\r\n\r\n\r\ndef get_password_hash(password):\r\n    return pwd_context.hash(password)\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n# Write the User and FoodEntry models here ...\r\n\r\nclass User(BaseModel):\r\n    id: int\r\n    username: str\r\n    password: str  # (needed for authentication later)\r\n\r\n    # For password override the constructor (__init__.py) to hash the password upon creation of the module. \r\n    # You can use the provided get_password_hash()\u00a0function for this.\r\n    \r\n    def __init__(self, **data):\r\n        self.password = get_password_hash(data.password)\r\n        super().__init__(**data)\r\n\r\nclass FoodEntry(BaseModel):\r\n    id: int  # (what in a DB would be the primary key)\r\n    user: User\r\n    food: Food\r\n    date_added: datetime = datetime.now()\r\n    number_servings: float\r\n\r\n    # add a property to calculate the total calories of a food entry \r\n    \r\n    @property\r\n    def total_calories(self):\r\n        return self.food.kcal_per_serving * self.number_servings\r\n        \r\n",
            "date": "2022-11-29 17:44:40.859208+00:00",
            "passed": false
        },
        {
            "bite": "Bite 20. Write a context manager",
            "code": "class Account:\r\n\r\n    def __init__(self):\r\n        self._transactions = []\r\n\r\n    @property\r\n    def balance(self):\r\n        return sum(self._transactions)\r\n\r\n    def __add__(self, amount):\r\n        self._transactions.append(amount)\r\n\r\n    def __sub__(self, amount):\r\n        self._transactions.append(-amount)\r\n\r\n    # add 2 dunder methods here to turn this class \r\n    # into a 'rollback' context manager\r\n        \r\n    def __enter__(self):\r\n        return self\r\n        \r\n    def __exit__(self, exc_type, exc_value, exc_traceback):\r\n        if self.balance<0:\r\n            self._transactions.pop(-1)\r\n            \r\n        \r\n\r\n",
            "date": "2022-11-28 19:01:02.674833+00:00",
            "passed": true
        },
        {
            "bite": "Bite 20. Write a context manager",
            "code": "class Account:\r\n\r\n    def __init__(self):\r\n        self._transactions = []\r\n\r\n    @property\r\n    def balance(self):\r\n        return sum(self._transactions)\r\n\r\n    def __add__(self, amount):\r\n        self._transactions.append(amount)\r\n\r\n    def __sub__(self, amount):\r\n        self._transactions.append(-amount)\r\n\r\n    # add 2 dunder methods here to turn this class \r\n    # into a 'rollback' context manager\r\n        \r\n    def __enter__(self):\r\n        self._prev_balance = self.balance\r\n        return self\r\n        \r\n    def __exit__(self, exc_type, exc_value, exc_traceback):\r\n        if self.balance<0:\r\n            self.balance = self._prev_balance\r\n            self._prev_balance = None\r\n  \r\n        \r\n\r\n",
            "date": "2022-11-28 18:58:42.059616+00:00",
            "passed": false
        },
        {
            "bite": "Bite 20. Write a context manager",
            "code": "class Account:\r\n\r\n    def __init__(self):\r\n        self._transactions = []\r\n\r\n    @property\r\n    def balance(self):\r\n        return sum(self._transactions)\r\n\r\n    def __add__(self, amount):\r\n        self._transactions.append(amount)\r\n\r\n    def __sub__(self, amount):\r\n        self._transactions.append(-amount)\r\n\r\n    # add 2 dunder methods here to turn this class \r\n    # into a 'rollback' context manager\r\n        \r\n    def __enter__(self):\r\n        return self\r\n        \r\n    def __exit__(self, exc_type, exc_value, exc_traceback):\r\n        try:\r\n            assert self.balance>=0\r\n        except:\r\n            raise    \r\n        \r\n\r\n",
            "date": "2022-11-28 18:50:34.700347+00:00",
            "passed": false
        },
        {
            "bite": "Bite 217. Capture stdout",
            "code": "from contextlib import redirect_stdout\r\nfrom io import StringIO\r\nfrom types import BuiltinFunctionType\r\n\r\n\r\ndef get_len_help_text(builtin: BuiltinFunctionType) -> int:\r\n    \"\"\"Receives a builtin, and returns the length of its help text.\r\n       You need to redirect stdout from the help builtin.\r\n       If the the object passed in is not a builtin, raise a ValueError.\r\n    \"\"\"\r\n    if not isinstance(builtin, BuiltinFunctionType):\r\n        raise ValueError\r\n    \r\n    with redirect_stdout(StringIO()) as f:\r\n        help(builtin)\r\n    s = f.getvalue()\r\n    return len(s)",
            "date": "2022-11-28 17:42:07.859326+00:00",
            "passed": true
        },
        {
            "bite": "Bite 217. Capture stdout",
            "code": "from contextlib import redirect_stdout\r\nfrom io import StringIO\r\nfrom types import BuiltinFunctionType\r\n\r\n\r\ndef get_len_help_text(builtin: BuiltinFunctionType) -> int:\r\n    \"\"\"Receives a builtin, and returns the length of its help text.\r\n       You need to redirect stdout from the help builtin.\r\n       If the the object passed in is not a builtin, raise a ValueError.\r\n    \"\"\"\r\n    if not isinstance(builtin, BuiltinFunctionType):\r\n        raise ValueError\r\n    \r\n    with redirect_stdout(io.StringIO()) as f:\r\n        help(builtin)\r\n    s = f.getvalue()\r\n    return len(s)",
            "date": "2022-11-28 17:41:33.530008+00:00",
            "passed": false
        },
        {
            "bite": "Bite 202. Analyze some Bite stats data - part II",
            "code": "import csv\r\nimport os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\nimport re\r\nfrom collections import defaultdict, Counter\r\n\r\ndata = 'https://bites-data.s3.us-east-2.amazonaws.com/bite_levels.csv'\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nstats = TMP / 'bites.csv'\r\n\r\nif not stats.exists():\r\n    urlretrieve(data, stats)\r\n\r\n\r\ndef get_most_complex_bites(N=10, stats=stats):\r\n    \"\"\"Parse the bites.csv file (= stats variable passed in), see example\r\n       output in the Bite description.\r\n       Return a list of Bite IDs (int or str values are fine) of the N\r\n       most complex Bites.\r\n    \"\"\"\r\n    with open(stats,encoding=\"utf-8-sig\") as f:\r\n        result=defaultdict(float)\r\n        bites = [(row['Bite'], row['Difficulty']) for row in csv.DictReader(f.read().splitlines(), delimiter=';')]\r\n        for bite, difficulty in bites:\r\n            bite_stripped = re.search('(?<=Bite )[0-9]+(?=\\.)', bite)\r\n            if not bite_stripped: # exclude three special PyCon19 bites which use : not . - Difficulty is None anyway \r\n                # print(bite, difficulty)\r\n                continue\r\n            if difficulty == 'None': # exclude bites with Difficulty None\r\n                continue\r\n            result[bite_stripped[0]]=float(difficulty)\r\n    return [int(item[0]) for item in Counter(result).most_common(N)]  \r\n\r\n\r\nif __name__ == '__main__':\r\n    res = get_most_complex_bites()\r\n    print(res)",
            "date": "2022-11-27 21:27:52.406244+00:00",
            "passed": true
        },
        {
            "bite": "Bite 306. Translate coding sequences to proteins",
            "code": "# TODO: Add imports\r\nfrom Bio.Seq import Seq, CodonTable\r\n\r\nimport string\r\n\r\ndef translate_cds(cds: str, translation_table: str) -> str:\r\n    \"\"\"\r\n    :param cds: str: DNA coding sequence (CDS)\r\n    :param translation_table: str: translation table as defined in Bio.Seq.Seq.CodonTable.ambiguous_generic_by_name\r\n    :return: str: Protein sequence\r\n    \"\"\"\r\n\r\n    # TODO: Put your code here\r\n    cds_clean = \"\".join([letter.upper() for letter in cds if letter.upper() in string.ascii_uppercase])\r\n    sequence=Seq(cds_clean)\r\n    tr_table=CodonTable.ambiguous_generic_by_name[translation_table]\r\n    return str(Seq.translate(sequence, table=tr_table, cds=True))\r\n    \r\n",
            "date": "2022-11-27 20:21:00.694200+00:00",
            "passed": true
        },
        {
            "bite": "Bite 306. Translate coding sequences to proteins",
            "code": "# TODO: Add imports\r\nfrom Bio.Seq import Seq, CodonTable\r\n\r\nimport string\r\n\r\ndef translate_cds(cds: str, translation_table: str) -> str:\r\n    \"\"\"\r\n    :param cds: str: DNA coding sequence (CDS)\r\n    :param translation_table: str: translation table as defined in Bio.Seq.Seq.CodonTable.ambiguous_generic_by_name\r\n    :return: str: Protein sequence\r\n    \"\"\"\r\n\r\n    # TODO: Put your code here\r\n    cds_clean = \"\".join([letter.upper() for letter in cds if letter.upper() in string.ascii_uppercase])\r\n    sequence=Seq.translate(Seq(cds_clean)\r\n    tr_table=CodonTable.ambiguous_generic_by_name[translation_table]\r\n    return str(sequence, table=tr_table, cds=True))\r\n    \r\n",
            "date": "2022-11-27 20:19:19.997416+00:00",
            "passed": false
        },
        {
            "bite": "Bite 306. Translate coding sequences to proteins",
            "code": "# TODO: Add imports\r\nfrom Bio.Seq import Seq, CodonTable\r\n\r\nimport string\r\n\r\ndef translate_cds(cds: str, translation_table: str) -> str:\r\n    \"\"\"\r\n    :param cds: str: DNA coding sequence (CDS)\r\n    :param translation_table: str: translation table as defined in Bio.Seq.Seq.CodonTable.ambiguous_generic_by_name\r\n    :return: str: Protein sequence\r\n    \"\"\"\r\n\r\n    # TODO: Put your code here\r\n    cds_clean = \"\".join([letter.upper() for letter in cds if letter.upper() in string.ascii_uppercase])\r\n    sequence=Seq.translate(Seq(cds_clean)\r\n    table=CodonTable.ambiguous_generic_by_name[translation_table]\r\n    return str(sequence, table=table, cds=True))\r\n    \r\n",
            "date": "2022-11-27 20:18:41.544106+00:00",
            "passed": false
        },
        {
            "bite": "Bite 306. Translate coding sequences to proteins",
            "code": "# TODO: Add imports\r\nfrom Bio.Seq import Seq, CodonTable\r\n\r\nimport string\r\n\r\ndef translate_cds(cds: str, translation_table: str) -> str:\r\n    \"\"\"\r\n    :param cds: str: DNA coding sequence (CDS)\r\n    :param translation_table: str: translation table as defined in Bio.Seq.Seq.CodonTable.ambiguous_generic_by_name\r\n    :return: str: Protein sequence\r\n    \"\"\"\r\n\r\n    # TODO: Put your code here\r\n    cds_clean = \"\".join([letter.upper() for letter in cds if letter.upper() in string.ascii_uppercase])\r\n    return str(Seq.translate(Seq(cds_clean), table=CodonTable.ambiguous_generic_by_name[translation_table], cds=True))\r\n    \r\n\r\nprint(translate_cds(\"ATGCCCGGGAAAGCGCACAAGAAGTGCTCAACGCCCCTACATCATCCGGGGTAA\",\r\n            \"Vertebrate Mitochondrial\"))\r\n\r\n# \"MPGKAHKKCSTPLHHPG\"\r\n",
            "date": "2022-11-27 20:17:23.773705+00:00",
            "passed": true
        },
        {
            "bite": "Bite 306. Translate coding sequences to proteins",
            "code": "# TODO: Add imports\r\nfrom Bio.Seq import Seq, CodonTable\r\n\r\nimport string\r\n\r\ndef translate_cds(cds: str, translation_table: str) -> str:\r\n    \"\"\"\r\n    :param cds: str: DNA coding sequence (CDS)\r\n    :param translation_table: str: translation table as defined in Bio.Seq.Seq.CodonTable.ambiguous_generic_by_name\r\n    :return: str: Protein sequence\r\n    \"\"\"\r\n\r\n    # TODO: Put your code here\r\n    cds_clean = \"\".join([letter.upper() for letter in cds if letter.upper() in string.ascii_uppercase])\r\n    return Seq.translate(Seq(cds_clean), table=CodonTable.ambiguous_generic_by_name[translation_table], cds=True)\r\n    \r\n\"\"\"\r\nprint(translate_cds(\"ATGCCCGGGAAAGCGCACAAGAAGTGCTCAACGCCCCTACATCATCCGGGGTAA\",\r\n            \"Vertebrate Mitochondrial\"))\r\n\r\n# \"MPGKAHKKCSTPLHHPG\"\r\n\"\"\"",
            "date": "2022-11-27 20:14:09.842145+00:00",
            "passed": false
        },
        {
            "bite": "Bite 323. Iterables intersection",
            "code": "import functools\r\nfrom typing import Iterable, Set, Any\r\n\r\n\r\ndef intersection(*args: Iterable) -> Set[Any]:\r\n    sets=[set(arg) for arg in args if arg]\r\n    if not sets:\r\n        return set()\r\n    result=sets[0]\r\n    if len(sets)>1:\r\n        for set_i in sets[1:]:\r\n            result = result.intersection(set_i)\r\n    return result\r\n\r\nprint(intersection({1,2,3}, {2,3,4}, {3,4}))\r\nprint(intersection([1,2,3,\"1\"], {1,-1}, {}))\r\nprint(intersection(None, \"this is a string\"))\r\n",
            "date": "2022-11-27 19:21:54.495792+00:00",
            "passed": true
        },
        {
            "bite": "Bite 323. Iterables intersection",
            "code": "import functools\r\nfrom typing import Iterable, Set, Any\r\n\r\n\r\ndef intersection(*args: Iterable) -> Set[Any]:\r\n    sets=[set(arg) for arg in args if arg]\r\n    result=sets[0]\r\n    if len(sets)>1:\r\n        for set_i in sets[1:]:\r\n            result = result.intersection(set_i)\r\n    return result\r\n\r\nprint(intersection({1,2,3}, {2,3,4}, {3,4}))\r\nprint(intersection([1,2,3,\"1\"], {1,-1}, {}))\r\nprint(intersection(None, \"this is a string\"))\r\n",
            "date": "2022-11-27 19:20:18.092869+00:00",
            "passed": false
        },
        {
            "bite": "Bite 359. Implementation of a More Sophisticated Typer Tests",
            "code": "import pytest\r\nfrom typer.testing import CliRunner\r\n\r\nfrom script import app\r\n\r\n\r\n@pytest.fixture()\r\ndef runner() -> CliRunner:\r\n    return CliRunner()\r\n\r\n\r\n@pytest.mark.parametrize(\r\n    \"command, expected_result\",\r\n    [\r\n        (\"subtract 1 6\", \"The delta is -5\"),\r\n        (\"subtract 8 5\", \"The delta is 3\"),\r\n    ],\r\n)\r\ndef test_subtract(command:str, expected_result:str, runner:CliRunner):\r\n    result = runner.invoke(app, command)\r\n    assert result.exit_code == 0\r\n    assert expected_result in result.stdout\r\n\r\n\r\n@pytest.mark.parametrize(\r\n    \"command, expected_result\",\r\n    [\r\n        (\"compare 10 2\", \"d=2 is not greater than c=10\"),\r\n        (\"compare 0 5\", \"d=5 is greater than c=0\"),\r\n        (\"compare 3 3\", \"d=3 is not greater than c=3\"),\r\n    ],\r\n)\r\ndef test_compare(command:str, expected_result:str, runner:CliRunner):\r\n    result = runner.invoke(app, command)\r\n    assert result.exit_code == 0\r\n    assert expected_result in result.stdout\r\n\r\ndef test_help_msg(runner):\r\n    result = runner.invoke(app, [\"--help\"])\r\n    assert result.exit_code == 0\r\n    assert \"Command that allows you to add two numbers.\" in result.stdout\r\n    assert \"Command that checks whether a number d is greater than a number c.\" in result.stdout\r\n\r\ndef test_help_msg_subtract(runner):\r\n    result = runner.invoke(app, ['subtract', '--help'])\r\n    assert result.exit_code == 0    \r\n    assert \"The value of the first summand\" in result.stdout\r\n    assert \"The value of the second summand\" in result.stdout\r\n\r\ndef test_help_msg_compare(runner):\r\n    result = runner.invoke(app, ['compare', '--help'])\r\n    assert result.exit_code == 0    \r\n    assert \"First number to compare against.\" in result.stdout\r\n    assert \"Second number that is compared against first number.\" in result.stdout    \r\n\r\n\r\n",
            "date": "2022-11-26 15:51:11.784818+00:00",
            "passed": true
        },
        {
            "bite": "Bite 359. Implementation of a More Sophisticated Typer Tests",
            "code": "import pytest\r\nfrom typer.testing import CliRunner\r\n\r\nfrom script import app\r\n\r\n\r\n@pytest.fixture()\r\ndef runner() -> CliRunner:\r\n    return CliRunner()\r\n\r\n\r\n@pytest.mark.parametrize(\r\n    \"command, expected_result\",\r\n    [\r\n        (\"subtract 1 6\", \"The delta is -5\"),\r\n        (\"subtract 8 5\", \"The delta is 3\"),\r\n    ],\r\n)\r\ndef test_subtract(command:str, expected_result:str, runner:CliRunner):\r\n    result = runner.invoke(app, command)\r\n    assert result.exit_code == 0\r\n    assert expected_result in result.stdout\r\n\r\n\r\n@pytest.mark.parametrize(\r\n    \"command, expected_result\",\r\n    [\r\n        (\"compare 10 2\", \"d=2 is not greater than c=10\"),\r\n        (\"compare 0 5\", \"d=5 is greater than c=0\"),\r\n        (\"compare 3 3\", \"d=3 is not greater than c=3\"),\r\n    ],\r\n)\r\ndef test_compare(command:str, expected_result:str, runner:CliRunner):\r\n    result = runner.invoke(app, command)\r\n    assert result.exit_code == 0\r\n    assert expected_result in result.stdout\r\n\r\ndef test_help_msg(runner):\r\n    result = runner.invoke(app, [\"--help\"])\r\n    assert result.exit_code == 0\r\n    assert \"Command that allows you to add two numbers.\" in result.stdout\r\n    assert \"Command that checks whether a number d is greater than a number c.\" in result.stdout\r\n\r\ndef test_help_msg_subtract(runner):\r\n    result = runner.invoke(app, ['subtract', '--help'])\r\n    assert result.exit_code == 0    \r\n    assert \"The value of the first summand\" in result.stdout\r\n    assert \"The value of the second summand\" in result.stdout\r\n\r\ndef test_help_msg_compare(runner):\r\n    result = runner.invoke(app, ['compare', '-help'])\r\n    assert result.exit_code == 0    \r\n    assert \"First number to compare against.\" in result.stdout\r\n    assert \"Second number that is compared against first number.\" in result.stdout    \r\n\r\n\r\n",
            "date": "2022-11-26 15:50:14.978657+00:00",
            "passed": false
        },
        {
            "bite": "Bite 359. Implementation of a More Sophisticated Typer Tests",
            "code": "import pytest\r\nfrom typer.testing import CliRunner\r\n\r\nfrom script import app\r\n\r\n\r\n@pytest.fixture()\r\ndef runner() -> CliRunner:\r\n    return CliRunner()\r\n\r\n\r\n@pytest.mark.parametrize(\r\n    \"command, expected_result\",\r\n    [\r\n        (\"subtract 1 6\", \"The delta is -5\"),\r\n        (\"subtract 8 5\", \"The delta is 3\"),\r\n    ],\r\n)\r\ndef test_subtract(command:str, expected_result:str, runner:CliRunner):\r\n    result = runner.invoke(app, command)\r\n    assert result.exit_code == 0\r\n    assert expected_result in result.stdout\r\n\r\n\r\n@pytest.mark.parametrize(\r\n    \"command, expected_result\",\r\n    [\r\n        (\"compare 10 2\", \"d=2 is not greater than c=10\"),\r\n        (\"compare 0 5\", \"d=5 is greater than c=0\"),\r\n        (\"compare 3 3\", \"d=3 is not greater than c=3\"),\r\n    ],\r\n)\r\ndef test_compare(command:str, expected_result:str, runner:CliRunner):\r\n    result = runner.invoke(app, command)\r\n    assert result.exit_code == 0\r\n    assert expected_result in result.stdout\r\n\r\ndef test_help_msg(runner):\r\n    result = runner.invoke(app, [\"--help\"])\r\n    assert result.exit_code == 0\r\n    assert \"Command that allows you to add two numbers.\" in result.stdout\r\n    assert \"Command that checks whether a number d is greater than a number c.\" in result.stdout\r\n\r\ndef test_help_msg_subtract(runner):\r\n    result = runner.invoke(app, [\"subtract --help\"])\r\n    assert result.exit_code == 0    \r\n    assert \"The value of the first summand\" in result.stdout\r\n    assert \"The value of the second summand\" in result.stdout\r\n\r\ndef test_help_msg_compare(runner):\r\n    result = runner.invoke(app, [\"compare --help\"])\r\n    assert result.exit_code == 0    \r\n    assert \"First number to compare against.\" in result.stdout\r\n    assert \"Second number that is compared against first number.\" in result.stdout    \r\n    \r\n\r\n",
            "date": "2022-11-26 15:48:16.075483+00:00",
            "passed": false
        },
        {
            "bite": "Bite 359. Implementation of a More Sophisticated Typer Tests",
            "code": "import pytest\r\nfrom typer.testing import CliRunner\r\n\r\nfrom script import app\r\n\r\n\r\n@pytest.fixture()\r\ndef runner() -> CliRunner:\r\n    return CliRunner()\r\n\r\n\r\n\r\n@pytest.mark.parametrize(\r\n    \"a, b, expected_result\",\r\n    [\r\n        (\"3\", \"4\", \"The sum is 7\"),\r\n        (\"2\", \"5\", \"The sum is 7\"),\r\n    ],\r\n)\r\n\r\n\r\n@pytest.mark.parametrize(\r\n    \"command, expected_result\",\r\n    [\r\n        (\"subtract 1 6\", \"The delta is -5\"),\r\n        (\"subtract 8 5\", \"The delta is 3\"),\r\n    ],\r\n)\r\ndef test_subtract(command:str, expected_result:str, runner:CliRunner):\r\n    result = runner.invoke(app, command)\r\n    assert result.exit_code == 0\r\n    assert expected_result in result.stdout\r\n\r\n\r\n@pytest.mark.parametrize(\r\n    \"command, expected_result\",\r\n    [\r\n        (\"compare 10 2\", \"d=2 is not greater than c=10\"),\r\n        (\"compare 0 5\", \"d=5 is greater than c=0\"),\r\n        (\"compare 3 3\", \"d=3 is not greater than c=3\"),\r\n    ],\r\n)\r\ndef test_compare(command:str, expected_result:str, runner:CliRunner):\r\n    result = runner.invoke(app, command)\r\n    assert result.exit_code == 0\r\n    assert expected_result in result.stdout\r\n\r\ndef test_help_msg(runner):\r\n    result = runner.invoke(app, [\"--help\"])\r\n    assert result.exit_code == 0\r\n    assert \"Command that allows you to add two numbers.\" in result.stdout\r\n    assert \"Command that checks whether a number d is greater than a number c.\" in result.stdout\r\n\r\ndef test_help_msg_subtract(runner):\r\n    result = runner.invoke(app, [\"subtract --help\"])\r\n    assert result.exit_code == 0    \r\n    assert \"The value of the first summand\" in result.stdout\r\n    assert \"The value of the second summand\" in result.stdout\r\n\r\ndef test_help_msg_compare(runner):\r\n    result = runner.invoke(app, [\"compare --help\"])\r\n    assert result.exit_code == 0    \r\n    assert \"First number to compare against.\" in result.stdout\r\n    assert \"Second number that is compared against first number.\" in result.stdout    \r\n    \r\n\r\n",
            "date": "2022-11-26 15:47:03.088362+00:00",
            "passed": false
        },
        {
            "bite": "Bite 359. Implementation of a More Sophisticated Typer Tests",
            "code": "import pytest\r\nfrom typer.testing import CliRunner\r\n\r\nfrom script import app\r\n\r\n\r\n@pytest.fixture()\r\ndef runner() -> CliRunner:\r\n    return CliRunner()\r\n\r\n\r\n@pytest.mark.parametrize(\r\n    \"command, expected_result\",\r\n    [\r\n        (\"subtract 1 6\", \"The delta is -5\"),\r\n        (\"subtract 8 5\", \"The delta is 3\"),\r\n    ],\r\n)\r\ndef test_subtract(runner):\r\n    result = runner.invoke(app, command)\r\n    assert result.exit_code == 0\r\n    assert expected_result in result.stdout\r\n\r\n\r\n@pytest.mark.parametrize(\r\n    \"command, expected_result\",\r\n    [\r\n        (\"compare 10 2\", \"d=2 is not greater than c=10\"),\r\n        (\"compare 0 5\", \"d=5 is greater than c=0\"),\r\n        (\"compare 3 3\", \"d=3 is not greater than c=3\"),\r\n    ],\r\n)\r\ndef test_compare(runner):\r\n    result = runner.invoke(app, command)\r\n    assert result.exit_code == 0\r\n    assert expected_result in result.stdout\r\n\r\ndef test_help_msg(runner):\r\n    result = runner.invoke(app, [\"--help\"])\r\n    assert result.exit_code == 0\r\n    assert \"Command that allows you to add two numbers.\" in result.stdout\r\n    assert \"Command that checks whether a number d is greater than a number c.\" in result.stdout\r\n\r\ndef test_help_msg_subtract(runner):\r\n    result = runner.invoke(app, [\"subtract --help\"])\r\n    assert result.exit_code == 0    \r\n    assert \"The value of the first summand\" in result.stdout\r\n    assert \"The value of the second summand\" in result.stdout\r\n\r\ndef test_help_msg_compare(runner):\r\n    result = runner.invoke(app, [\"compare --help\"])\r\n    assert result.exit_code == 0    \r\n    assert \"First number to compare against.\" in result.stdout\r\n    assert \"Second number that is compared against first number.\" in result.stdout    \r\n    \r\n\r\n",
            "date": "2022-11-26 15:44:04.113984+00:00",
            "passed": false
        },
        {
            "bite": "Bite 205. Female speakers @ Pycon US",
            "code": "from urllib.request import urlretrieve\r\nimport os\r\nfrom pathlib import Path\r\n\r\nimport gender_guesser.detector as gender\r\nfrom bs4 import BeautifulSoup as Soup\r\nfrom pprint import pprint\r\nimport re\r\nfrom collections import Counter\r\n\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nPYCON_HTML = TMP / \"pycon2019.html\"\r\nPYCON_PAGE = ('https://bites-data.s3.us-east-2.amazonaws.com/'\r\n              'pycon2019.html')\r\n\r\nif not PYCON_HTML.exists():\r\n    urlretrieve(PYCON_PAGE, PYCON_HTML)\r\n\r\n\r\ndef _get_soup(html=PYCON_HTML):\r\n    return Soup(html.read_text(encoding=\"utf-8\"), \"html.parser\")\r\n\r\n\r\ndef get_pycon_speaker_first_names(soup=None):\r\n    \"\"\"Parse the PYCON_HTML using BeautifulSoup, extracting all\r\n       speakers (class \"speaker\"). Note that some items contain\r\n       multiple speakers so you need to extract them.\r\n       Return a list of first names\r\n    \"\"\"\r\n    if not soup:\r\n        soup=_get_soup()\r\n    list_speakers=soup.find_all('span', class_='speaker')\r\n    return [name.strip().split()[0] for item in list_speakers for name in re.split(',|/',item.text.strip()) ]\r\n\r\n\r\ndef get_percentage_of_female_speakers(first_names):\r\n    \"\"\"Run gender_guesser on the names returning a percentage\r\n       of female speakers (female and mostly_female),\r\n       rounded to 2 decimal places.\"\"\"\r\n    d = gender.Detector()\r\n    count = Counter(1 for name in first_names if d.get_gender(name) in {'female', 'mostly_female'})[1]\r\n    return round(100*count/len(first_names),2)\r\n\r\nif __name__ == '__main__':\r\n    names = get_pycon_speaker_first_names()\r\n    # pprint(names)\r\n    perc = get_percentage_of_female_speakers(names)\r\n    print(perc)\r\n",
            "date": "2022-11-26 15:11:45.849164+00:00",
            "passed": true
        },
        {
            "bite": "Bite 193. Most upvoted StackOverflow Python questions",
            "code": "import requests\r\nfrom bs4 import BeautifulSoup\r\nfrom collections import namedtuple\r\nfrom pprint import pprint\r\n\r\n\r\ncached_so_url = 'https://bites-data.s3.us-east-2.amazonaws.com/so_python.html'\r\n\r\nQuestion = namedtuple('Question', 'question votes views')\r\n\r\ndef top_python_questions(url=cached_so_url):\r\n    \"\"\"Use requests to retrieve the url / html,\r\n       parse the questions out of the html with BeautifulSoup,\r\n       filter them by >= 1m views (\"..m views\").\r\n       Return a list of (question, num_votes) tuples ordered\r\n       by num_votes descending (see tests for expected output).\r\n    \"\"\"\r\n    CONTENT = requests.get(url).text\r\n    soup = BeautifulSoup(CONTENT, 'html.parser')\r\n    \r\n    list_questions = soup.find_all(\"div\", class_=\"question-summary\")\r\n\r\n    result = []\r\n    \r\n    for q in list_questions:\r\n        question = q.find('a', {'class': 'question-hyperlink'}).text\r\n        votes = int(q.find('span', {'class': 'vote-count-post'}).text)\r\n        views = q.find('div', {'class': 'views'}).text.strip()\r\n        result.append(Question(question=question,\r\n                votes=votes,\r\n                views=views,\r\n                ))\r\n    \r\n    filtered = [(q.question, q.votes) for q in result if 'm' in q.views]\r\n    return sorted(filtered, key=lambda x:x[1], reverse=True)\r\n    \r\npprint(top_python_questions())\r\n",
            "date": "2022-11-26 14:34:45.749757+00:00",
            "passed": true
        },
        {
            "bite": "Bite 193. Most upvoted StackOverflow Python questions",
            "code": "import requests\r\nfrom bs4 import BeautifulSoup\r\nfrom collections import namedtuple\r\nfrom pprint import pprint\r\n\r\n\r\ncached_so_url = 'https://bites-data.s3.us-east-2.amazonaws.com/so_python.html'\r\n\r\nQuestion = namedtuple('Question', 'question votes views')\r\n\r\ndef top_python_questions(url=cached_so_url):\r\n    \"\"\"Use requests to retrieve the url / html,\r\n       parse the questions out of the html with BeautifulSoup,\r\n       filter them by >= 1m views (\"..m views\").\r\n       Return a list of (question, num_votes) tuples ordered\r\n       by num_votes descending (see tests for expected output).\r\n    \"\"\"\r\n    CONTENT = requests.get(url).text\r\n    soup = BeautifulSoup(CONTENT, 'html.parser')\r\n    \r\n    \r\n    list_questions = soup.find_all(\"div\", class_=\"question-summary\")\r\n\r\n    result = []\r\n    \r\n    for q in list_questions:\r\n        question = q.find('a', {'class': 'question-hyperlink'}).text\r\n        votes = int(q.find('span', {'class': 'vote-count-post'}).text)\r\n        views = q.find('div', {'class': 'views'}).text.strip()\r\n        result.append(Question(question=question,\r\n                votes=votes,\r\n                views=views,\r\n                ))\r\n    \r\n    filtered = [(q.question, q.votes) for q in result if 'm' in q.views]\r\n    return sorted(filtered, key=lambda x:x[1], reverse=True)\r\n    \r\npprint(top_python_questions())\r\n",
            "date": "2022-11-26 14:34:01.066735+00:00",
            "passed": true
        },
        {
            "bite": "Bite 362. Add a Password Prompt to Your Command Line Interface (CLI)",
            "code": "import typer\r\n\r\napp = typer.Typer()\r\n\r\n\r\n@app.command()\r\ndef main(\r\n    name: str = typer.Argument('Robin', help=\"Name\"),\r\n    password: str = typer.Option(\r\n        ..., prompt=True, confirmation_prompt=True, hide_input=True\r\n    ),\r\n):\r\n    print(f\"Hello {name}. Doing something very secure with password.\")\r\n    print(f\"...just kidding, here it is, very insecure: {password}\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app()\r\n    \r\n",
            "date": "2022-11-25 21:47:31.330715+00:00",
            "passed": true
        },
        {
            "bite": "Bite 362. Add a Password Prompt to Your Command Line Interface (CLI)",
            "code": "import typer\r\n\r\napp = typer.Typer()\r\n\r\n\r\n@app.command()\r\ndef main(\r\n    name: str = typer.Argument('Robin', help=\"Name.\"),\r\n    password: str = typer.Option(\r\n        ..., prompt=True, confirmation_prompt=True, hide_input=True\r\n    ),\r\n):\r\n    print(f\"Hello {name}. Doing something very secure with password.\")\r\n    print(f\"...just kidding, here it is, very insecure: {password}\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app()\r\n    \r\n",
            "date": "2022-11-25 21:47:11.912805+00:00",
            "passed": true
        },
        {
            "bite": "Bite 362. Add a Password Prompt to Your Command Line Interface (CLI)",
            "code": "import typer\r\n\r\napp = typer.Typer()\r\n\r\n\r\n@app.command()\r\ndef main(\r\n    name: str = 'Robin',\r\n    password: str = typer.Option(\r\n        ..., prompt=True, confirmation_prompt=True, hide_input=True\r\n    ),\r\n):\r\n    print(f\"Hello {name}. Doing something very secure with password.\")\r\n    print(f\"...just kidding, here it is, very insecure: {password}\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app()\r\n    \r\n",
            "date": "2022-11-25 21:39:54.836422+00:00",
            "passed": false
        },
        {
            "bite": "Bite 362. Add a Password Prompt to Your Command Line Interface (CLI)",
            "code": "import typer\r\n\r\napp = typer.Typer()\r\n\r\n\r\n@app.command()\r\ndef main(\r\n    name: str = 'Manolo',\r\n    password: str = typer.Option(\r\n        ..., prompt=True, confirmation_prompt=True, hide_input=True\r\n    ),\r\n):\r\n    print(f\"Hello {name}. Doing something very secure with password.\")\r\n    print(f\"...just kidding, here it is, very insecure: {password}\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app()\r\n    \r\n",
            "date": "2022-11-25 21:38:57.709980+00:00",
            "passed": false
        },
        {
            "bite": "Bite 361. Rich Excursion - Create Beautiful Tables",
            "code": "import typer\r\nfrom rich.console import Console\r\nfrom rich.table import Table\r\n\r\napp = typer.Typer()\r\n\r\nconsole = Console()\r\n\r\n@app.command()\r\ndef table():\r\n    table = Table(\"Name\", \"Favorite Tool/Framework\")\r\n    table.add_row(\"Bob\", \"Vim\")\r\n    table.add_row(\"Julian\", \"Flask\")\r\n    table.add_row(\"Robin\", \"VS Code\")\r\n    console.print(table)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app()\r\n",
            "date": "2022-11-25 21:34:02.666743+00:00",
            "passed": true
        },
        {
            "bite": "Bite 361. Rich Excursion - Create Beautiful Tables",
            "code": "import typer\r\nfrom rich.console import Console\r\nfrom rich.table import Table\r\n\r\napp = typer.Typer()\r\n\r\nconsole = Console()\r\n\r\ndef table():\r\n    table = Table(\"Name\", \"Favorite Tool/Framework\")\r\n    table.add_row(\"Bob\", \"Vim\")\r\n    table.add_row(\"Julian\", \"Flask\")\r\n    table.add_row(\"Robin\", \"VS Code\")\r\n    console.print(table)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    # app()\r\n    typer.run(table)\r\n    ",
            "date": "2022-11-25 21:32:01.382244+00:00",
            "passed": false
        },
        {
            "bite": "Bite 144. Calculate the Number of Months Passed",
            "code": "from datetime import date\r\n\r\nfrom dateutil.relativedelta import relativedelta\r\n\r\nSTART_DATE = date(2018, 11, 1)\r\nMIN_DAYS_TO_COUNT_AS_MONTH = 10\r\nMONTHS_PER_YEAR = 12\r\n\r\n\r\ndef calc_months_passed(year, month, day):\r\n    \"\"\"Construct a date object from the passed in arguments.\r\n       If this fails due to bad inputs reraise the exception.\r\n       Also if the new date is < START_DATE raise a ValueError.\r\n\r\n       Then calculate how many months have passed since the\r\n       START_DATE constant. We suggest using dateutil.relativedelta!\r\n\r\n       One rule: if a new month is >= 10 (MIN_DAYS_TO_COUNT_AS_MONTH)\r\n       days in, it counts as an extra  month.\r\n\r\n       For example:\r\n       date(2018, 11, 10) = 9 days in => 0 months\r\n       date(2018, 11, 11) = 10 days in => 1 month\r\n       date(2018, 12, 11) = 1 month + 10 days in => 2 months\r\n       date(2019, 12, 11) = 1 year + 1 month + 10 days in => 14 months\r\n       etc.\r\n\r\n       See the tests for more examples.\r\n\r\n       Return the number of months passed int.\r\n    \"\"\"\r\n    try:\r\n        my_date=date(year,month,day)\r\n    except (TypeError, ValueError) as error:\r\n        raise error\r\n    \r\n    if my_date <START_DATE:\r\n        raise ValueError\r\n        \r\n    time_passed=relativedelta(my_date,START_DATE)\r\n    print(time_passed)\r\n    return time_passed.years*12 + time_passed.months + (1 if time_passed.days >= 10 else 0)\r\n    ",
            "date": "2022-11-25 00:04:45.047413+00:00",
            "passed": true
        },
        {
            "bite": "Bite 144. Calculate the Number of Months Passed",
            "code": "from datetime import date\r\n\r\nfrom dateutil.relativedelta import relativedelta\r\n\r\nSTART_DATE = date(2018, 11, 1)\r\nMIN_DAYS_TO_COUNT_AS_MONTH = 10\r\nMONTHS_PER_YEAR = 12\r\n\r\n\r\ndef calc_months_passed(year, month, day):\r\n    \"\"\"Construct a date object from the passed in arguments.\r\n       If this fails due to bad inputs reraise the exception.\r\n       Also if the new date is < START_DATE raise a ValueError.\r\n\r\n       Then calculate how many months have passed since the\r\n       START_DATE constant. We suggest using dateutil.relativedelta!\r\n\r\n       One rule: if a new month is >= 10 (MIN_DAYS_TO_COUNT_AS_MONTH)\r\n       days in, it counts as an extra  month.\r\n\r\n       For example:\r\n       date(2018, 11, 10) = 9 days in => 0 months\r\n       date(2018, 11, 11) = 10 days in => 1 month\r\n       date(2018, 12, 11) = 1 month + 10 days in => 2 months\r\n       date(2019, 12, 11) = 1 year + 1 month + 10 days in => 14 months\r\n       etc.\r\n\r\n       See the tests for more examples.\r\n\r\n       Return the number of months passed int.\r\n    \"\"\"\r\n    try:\r\n        my_date=date(year,month,day)\r\n    except (TypeError, ValueError) as error:\r\n        raise error\r\n    \r\n    if my_date <START_DATE:\r\n        raise ValueError\r\n        \r\n    time_passed=relativedelta(my_date,START_DATE)\r\n    print(time_passed)\r\n    return time_passed.years*12 + time_passed.months + (1 if time_passed.days >= 10 else 0)\r\n    \r\nprint(calc_months_passed(2019, 12, 10))",
            "date": "2022-11-25 00:03:53.296931+00:00",
            "passed": true
        },
        {
            "bite": "Bite 144. Calculate the Number of Months Passed",
            "code": "from datetime import date\r\n\r\nfrom dateutil.relativedelta import relativedelta\r\n\r\nSTART_DATE = date(2018, 11, 1)\r\nMIN_DAYS_TO_COUNT_AS_MONTH = 10\r\nMONTHS_PER_YEAR = 12\r\n\r\n\r\ndef calc_months_passed(year, month, day):\r\n    \"\"\"Construct a date object from the passed in arguments.\r\n       If this fails due to bad inputs reraise the exception.\r\n       Also if the new date is < START_DATE raise a ValueError.\r\n\r\n       Then calculate how many months have passed since the\r\n       START_DATE constant. We suggest using dateutil.relativedelta!\r\n\r\n       One rule: if a new month is >= 10 (MIN_DAYS_TO_COUNT_AS_MONTH)\r\n       days in, it counts as an extra  month.\r\n\r\n       For example:\r\n       date(2018, 11, 10) = 9 days in => 0 months\r\n       date(2018, 11, 11) = 10 days in => 1 month\r\n       date(2018, 12, 11) = 1 month + 10 days in => 2 months\r\n       date(2019, 12, 11) = 1 year + 1 month + 10 days in => 14 months\r\n       etc.\r\n\r\n       See the tests for more examples.\r\n\r\n       Return the number of months passed int.\r\n    \"\"\"\r\n    try:\r\n        my_date=date(year,month,day)\r\n    except (TypeError, ValueError) as error:\r\n        raise error\r\n        \r\n    time_passed=relativedelta(my_date,START_DATE)\r\n    print(time_passed)\r\n    return time_passed.years*12 + time_passed.months + (1 if time_passed.days >= 10 else 0)\r\n    \r\nprint(calc_months_passed(2019, 12, 10))",
            "date": "2022-11-25 00:02:48.691007+00:00",
            "passed": false
        },
        {
            "bite": "Bite 144. Calculate the Number of Months Passed",
            "code": "from datetime import date\r\n\r\nfrom dateutil.relativedelta import relativedelta\r\n\r\nSTART_DATE = date(2018, 11, 1)\r\nMIN_DAYS_TO_COUNT_AS_MONTH = 10\r\nMONTHS_PER_YEAR = 12\r\n\r\n\r\ndef calc_months_passed(year, month, day):\r\n    \"\"\"Construct a date object from the passed in arguments.\r\n       If this fails due to bad inputs reraise the exception.\r\n       Also if the new date is < START_DATE raise a ValueError.\r\n\r\n       Then calculate how many months have passed since the\r\n       START_DATE constant. We suggest using dateutil.relativedelta!\r\n\r\n       One rule: if a new month is >= 10 (MIN_DAYS_TO_COUNT_AS_MONTH)\r\n       days in, it counts as an extra  month.\r\n\r\n       For example:\r\n       date(2018, 11, 10) = 9 days in => 0 months\r\n       date(2018, 11, 11) = 10 days in => 1 month\r\n       date(2018, 12, 11) = 1 month + 10 days in => 2 months\r\n       date(2019, 12, 11) = 1 year + 1 month + 10 days in => 14 months\r\n       etc.\r\n\r\n       See the tests for more examples.\r\n\r\n       Return the number of months passed int.\r\n    \"\"\"\r\n    try:\r\n        my_date=date(year,month,day)\r\n    except (TypeError, ValueError) as error:\r\n        raise error\r\n        \r\n    time_passed=relativedelta(my_date,START_DATE)\r\n    return time_passed.years*12 + time_passed.months + 1 if time_passed.days >= 10 else 0\r\n    \r\nprint(calc_months_passed(2018, 12, 11))",
            "date": "2022-11-25 00:00:37.456806+00:00",
            "passed": false
        },
        {
            "bite": "Bite 330. Simple Math Equation Solver",
            "code": "from itertools import permutations\r\nfrom operator import add, sub, mul\r\nfrom typing import List, Union, Iterable\r\n\r\nALLOWED_OPERATORS = \"+-*\"\r\nALLOWED_NUMBERS = [1,2,3,4,5,6,7,8,9]\r\n\r\ndef _eval(operator_path, numbers):\r\n    _operator_path = operator_path[:]\r\n    _numbers = numbers[:]\r\n\r\n    while '*' in _operator_path:\r\n        i = _operator_path.index('*')\r\n        op = _operator_path.pop(i)\r\n        _numbers[i]*=_numbers.pop(i+1)\r\n\r\n    while len(_operator_path)>0:\r\n        op = _operator_path.pop(0)\r\n        if op=='+':\r\n            _numbers[0]+=_numbers.pop(1)\r\n        if op=='-':\r\n            _numbers[0]-=_numbers.pop(1)\r\n    return _numbers[0]\r\n\r\n\r\ndef find_all_solutions(\r\n    operator_path: List[str], expected_result: int\r\n) -> Union[List[List[int]], Iterable[List[int]]]:\r\n    # TODO: blank canvas to fill\r\n    \r\n    if not isinstance(expected_result, int):\r\n        raise ValueError(\"Result must be of type int\")\r\n        \r\n    if not all(op in ALLOWED_OPERATORS for op in operator_path):\r\n        raise ValueError(\"Result must be of type int\")\r\n        \r\n    num_ops=len(operator_path) + 1\r\n    all_permutations = permutations(ALLOWED_NUMBERS, num_ops)\r\n    \r\n    return [list(perm) for perm in all_permutations if _eval(operator_path, list(perm)) == expected_result]\r\n",
            "date": "2022-11-24 23:35:28.708140+00:00",
            "passed": true
        },
        {
            "bite": "Bite 330. Simple Math Equation Solver",
            "code": "from itertools import permutations\r\nfrom operator import add, sub, mul\r\nfrom typing import List, Union, Iterable\r\n\r\nALLOWED_OPERATORS = \"+-*\"\r\nALLOWED_NUMBERS = [1,2,3,4,5,6,7,8,9]\r\n\r\ndef _eval(operator_path, numbers):\r\n    _operator_path = operator_path[:]\r\n    _numbers = numbers[:]\r\n    # print(f'{_operator_path=} {_numbers=}')\r\n\r\n    while '*' in _operator_path:\r\n        i = _operator_path.index('*')\r\n        op = _operator_path.pop(i)\r\n        # print(f'{op=} {i=}')\r\n        _numbers[i]*=_numbers.pop(i+1)\r\n        # print(f'{_operator_path=} {_numbers=}')\r\n        \r\n    while len(_operator_path)>0:\r\n        op = _operator_path.pop(0)\r\n        # print(f'{op=} {i=}')\r\n        if op=='+':\r\n            _numbers[0]+=_numbers.pop(1)\r\n        if op=='-':\r\n            _numbers[0]-=_numbers.pop(1)\r\n        # print(f'{operator_path=} {numbers=}')\r\n    return _numbers[0]\r\n\r\n\r\ndef find_all_solutions(\r\n    operator_path: List[str], expected_result: int\r\n) -> Union[List[List[int]], Iterable[List[int]]]:\r\n    # TODO: blank canvas to fill\r\n    \r\n    if not isinstance(expected_result, int):\r\n        raise ValueError(\"Result must be of type int\")\r\n        \r\n    if not all(op in ALLOWED_OPERATORS for op in operator_path):\r\n        raise ValueError(\"Result must be of type int\")\r\n        \r\n    num_ops=len(operator_path) + 1\r\n    all_permutations = permutations(ALLOWED_NUMBERS, num_ops)\r\n    \r\n    return [list(perm) for perm in all_permutations if _eval(operator_path, list(perm)) == expected_result]\r\n    \r\nprint(find_all_solutions(['+'],6))\r\n\r\n\r\n# print(_eval(['*'],[3,2]))",
            "date": "2022-11-24 23:34:36.540814+00:00",
            "passed": true
        },
        {
            "bite": "Bite 330. Simple Math Equation Solver",
            "code": "from itertools import permutations\r\nfrom operator import add, sub, mul\r\nfrom typing import List, Union, Iterable\r\n\r\nALLOWED_OPERATORS = \"+-*\"\r\nALLOWED_NUMBERS = [1,2,3,4,5,6,7,8,9]\r\n\r\ndef _eval(operator_path, numbers):\r\n    if isinstance(numbers,tuple):\r\n        numbers = list(numbers)\r\n    while '*' in operator_path:\r\n        i = operator_path.index('*')\r\n        op = operator_path.pop(i)\r\n        # print(f'{op=} {i=}')\r\n        numbers[i]*=numbers.pop(i+1)\r\n        # print(f'{operator_path=} {numbers=}')\r\n        \r\n    while len(operator_path)>0:\r\n        op = operator_path.pop(0)\r\n        # print(f'{op=} {i=}')\r\n        if op=='+':\r\n            numbers[0]+=numbers.pop(1)\r\n        if op=='-':\r\n            numbers[0]-=numbers.pop(1)\r\n        # print(f'{operator_path=} {numbers=}')\r\n    return numbers[0]\r\n\r\n\r\ndef find_all_solutions(\r\n    operator_path: List[str], expected_result: int\r\n) -> Union[List[List[int]], Iterable[List[int]]]:\r\n    # TODO: blank canvas to fill\r\n    \r\n    if not isinstance(expected_result, int):\r\n        raise ValueError(\"Result must be of type int\")\r\n        \r\n    if not all(op in ALLOWED_OPERATORS for op in operator_path):\r\n        raise ValueError(\"Result must be of type int\")\r\n        \r\n    num_ops=len(operator_path) + 1\r\n    all_permutations = permutations(ALLOWED_NUMBERS, num_ops)\r\n    \r\n    return [list(perm) for perm in all_permutations if _eval(operator_path, perm) == expected_result]\r\n    \r\n# print(find_all_solutions(['+'],6))\r\n\r\n\r\n# print(_eval(['*'],[3,2]))",
            "date": "2022-11-24 23:29:32.686274+00:00",
            "passed": false
        },
        {
            "bite": "Bite 330. Simple Math Equation Solver",
            "code": "from itertools import permutations\r\nfrom operator import add, sub, mul\r\nfrom typing import List, Union, Iterable\r\n\r\nALLOWED_OPERATORS = \"+-*\"\r\nALLOWED_NUMBERS = [1,2,3,4,5,6,7,8,9]\r\n\r\ndef _eval(operator_path, numbers):\r\n    op= operator_path[0]\r\n    \r\n    while '*' in operator_path:\r\n        i = operator_path.index('*')\r\n        op = operator_path.pop(i)\r\n        # print(f'{op=} {i=}')\r\n        numbers[i]*=numbers.pop(i+1)\r\n        # print(f'{operator_path=} {numbers=}')\r\n        \r\n    while len(operator_path)>0:\r\n        op = operator_path.pop(0)\r\n        # print(f'{op=} {i=}')\r\n        if op=='+':\r\n            numbers[0]+=numbers.pop(1)\r\n        if op=='-':\r\n            numbers[0]-=numbers.pop(1)\r\n        # print(f'{operator_path=} {numbers=}')\r\n    return numbers[0]\r\n\r\n\r\ndef find_all_solutions(\r\n    operator_path: List[str], expected_result: int\r\n) -> Union[List[List[int]], Iterable[List[int]]]:\r\n    # TODO: blank canvas to fill\r\n    \r\n    if not isinstance(expected_result, int):\r\n        raise ValueError(\"Result must be of type int\")\r\n        \r\n    if not all(op in ALLOWED_OPERATORS for op in operator_path):\r\n        raise ValueError(\"Result must be of type int\")\r\n        \r\n    num_ops=len(operator_path) + 1\r\n    all_permutations = permutations(ALLOWED_NUMBERS, num_ops)\r\n    \r\n    return [list(perm) for perm in all_permutations if _eval(operator_path, perm) == expected_result]\r\n    \r\n# print(find_all_solutions(['+'],6))\r\n\r\n\r\n# print(_eval(['*'],[3,2]))",
            "date": "2022-11-24 23:27:17.982301+00:00",
            "passed": false
        },
        {
            "bite": "Bite 330. Simple Math Equation Solver",
            "code": "from itertools import permutations\r\nfrom operator import add, sub, mul\r\nfrom typing import List, Union, Iterable\r\n\r\nALLOWED_OPERATORS = \"+-*\"\r\nALLOWED_NUMBERS = [1,2,3,4,5,6,7,8,9]\r\n\r\ndef _eval(operator_path, numbers):\r\n    op= operator_path[0]\r\n    \r\n    while '*' in operator_path:\r\n        i = operator_path.index('*')\r\n        op = operator_path.pop(i)\r\n        # print(f'{op=} {i=}')\r\n        numbers[i]*=numbers.pop(i+1)\r\n        # print(f'{operator_path=} {numbers=}')\r\n        \r\n    while len(operator_path)>0:\r\n        op = operator_path.pop(0)\r\n        # print(f'{op=} {i=}')\r\n        if op=='+':\r\n            numbers[0]+=numbers.pop(1)\r\n        if op=='-':\r\n            numbers[0]-=numbers.pop(1)\r\n        # print(f'{operator_path=} {numbers=}')\r\n    return numbers[0]\r\n\r\n\r\ndef find_all_solutions(\r\n    operator_path: List[str], expected_result: int\r\n) -> Union[List[List[int]], Iterable[List[int]]]:\r\n    # TODO: blank canvas to fill\r\n    \r\n    if not isinstance(expected_result, int):\r\n        raise ValueError(\"Result must be of type int\")\r\n        \r\n    if not all(op in ALLOWED_OPERATORS for op in operator_path):\r\n        raise ValueError(\"Result must be of type int\")\r\n        \r\n    num_ops=len(operator_path) + 1\r\n    all_permutations = permutations(ALLOWED_NUMBERS, num_ops)\r\n    \r\n    return [list(perm) for perm in all_permutations if _eval(operator_path, perm) == expected_result]\r\n    \r\n# print(find_all_solutions(['+'],6))\r\n\r\n\r\nprint(_eval(['*'],[3,2]))",
            "date": "2022-11-24 23:26:06.949987+00:00",
            "passed": false
        },
        {
            "bite": "Bite 318. Decode base64 encoded data",
            "code": "import base64\r\nimport csv\r\nfrom typing import List  # will remove with 3.9\r\n\r\ndef get_credit_cards(data: bytes) -> List[str]:\r\n    \"\"\"Decode the base64 encoded data which gives you a csv\r\n    of \"first_name,last_name,credit_card\", from which you have\r\n    to extract the credit card numbers.\r\n    \"\"\"\r\n    string= base64.b64decode(data).decode(\"utf-8\")\r\n    reader = csv.DictReader(string.split('\\n'), delimiter=',')\r\n    return [row['credit_card'] for row in reader if row ]\r\n    \r\n\r\ndata = \"\"\"Zmlyc3RfbmFtZSxsYXN0X25hbWUsY3JlZGl0X2NhcmQKS2VlbGJ5LE1hY0NhZmZlcmt5LD\r\nYzOTM3MTk0MzMzMjk5MjQKTGlubmVsbCxDbGVtbWV0dCwzNTU1NTg0OTI0MDkzOTU0CkVs\r\neXNoYSxNZWlnaGFuLDYzODU3OTU3OTM4OTcxMDYKS2F0YWxpbixFdGhlcnRvbiwzNTg0Mj\r\nMwMDExNjgwNzAwCkZpbmEsUGFzZWssNTEwMDEzNjYzMTY2NDY4NwpBcmRlbGxhLEJyYXpp\r\nZXIsMjAxNzEyNjEzNjUzMzc0CkRvcnRoZWEsS2FycGluc2tpLDMwNTAyNjYxMjUxMTcyCl\r\nJhbm5hLER1ZmYsMzU3NjM5MzA1NjQ5MzMxMgpDaW5uYW1vbixLYWFzbWFuLDU0NDIwMjgx\r\nNTA4MDg1NzAKSmFjbGluLFRvbmdlLDM1NDk4NTIxMDQ3MjQ1MjcK\"\"\"\r\n\r\nprint(get_credit_cards(data))",
            "date": "2022-11-24 22:37:36.497439+00:00",
            "passed": true
        },
        {
            "bite": "Bite 318. Decode base64 encoded data",
            "code": "import base64\r\nimport csv\r\nfrom typing import List  # will remove with 3.9\r\n\r\ndef get_credit_cards(data: bytes) -> List[str]:\r\n    \"\"\"Decode the base64 encoded data which gives you a csv\r\n    of \"first_name,last_name,credit_card\", from which you have\r\n    to extract the credit card numbers.\r\n    \"\"\"\r\n    string= base64.b64decode(data).decode(\"utf-8\")\r\n    \r\n    reader = csv.DictReader(string.split('\\n'), delimiter=',')\r\n    return [row['credit_card'] for row in reader if row ]\r\n    \r\n\r\ndata = \"\"\"Zmlyc3RfbmFtZSxsYXN0X25hbWUsY3JlZGl0X2NhcmQKS2VlbGJ5LE1hY0NhZmZlcmt5LD\r\nYzOTM3MTk0MzMzMjk5MjQKTGlubmVsbCxDbGVtbWV0dCwzNTU1NTg0OTI0MDkzOTU0CkVs\r\neXNoYSxNZWlnaGFuLDYzODU3OTU3OTM4OTcxMDYKS2F0YWxpbixFdGhlcnRvbiwzNTg0Mj\r\nMwMDExNjgwNzAwCkZpbmEsUGFzZWssNTEwMDEzNjYzMTY2NDY4NwpBcmRlbGxhLEJyYXpp\r\nZXIsMjAxNzEyNjEzNjUzMzc0CkRvcnRoZWEsS2FycGluc2tpLDMwNTAyNjYxMjUxMTcyCl\r\nJhbm5hLER1ZmYsMzU3NjM5MzA1NjQ5MzMxMgpDaW5uYW1vbixLYWFzbWFuLDU0NDIwMjgx\r\nNTA4MDg1NzAKSmFjbGluLFRvbmdlLDM1NDk4NTIxMDQ3MjQ1MjcK\"\"\"\r\n\r\nprint(get_credit_cards(data))",
            "date": "2022-11-24 22:37:14.089752+00:00",
            "passed": true
        },
        {
            "bite": "Bite 316. To rent or to stream movies?",
            "code": "from datetime import date\r\nfrom typing import Dict, Sequence, NamedTuple\r\nfrom collections import defaultdict, Counter\r\n\r\nclass MovieRented(NamedTuple):\r\n    title: str\r\n    price: int\r\n    date: date\r\n\r\n\r\nRentingHistory = Sequence[MovieRented]\r\nSTREAMING_COST_PER_MONTH = 12\r\nSTREAM, RENT = 'stream', 'rent'\r\n\r\ndef _best_option(amount):\r\n    return STREAM if amount>STREAMING_COST_PER_MONTH else RENT\r\n\r\ndef rent_or_stream(\r\n    renting_history: RentingHistory,\r\n    streaming_cost_per_month: int = STREAMING_COST_PER_MONTH\r\n) -> Dict[str, str]:\r\n    \"\"\"Function that calculates if renting movies one by one is\r\n       cheaper than streaming movies by months.\r\n\r\n       Determine this PER MONTH for the movies in renting_history.\r\n\r\n       Return a dict of:\r\n       keys = months (YYYY-MM)\r\n       values = 'rent' or 'stream' based on what is cheaper\r\n\r\n       Check out the tests for examples.\r\n    \"\"\"\r\n    monthly_spent=defaultdict(int)\r\n\r\n    for movie in renting_history:\r\n        monthly_spent[movie.date.strftime('%Y-%m')]+=movie.price \r\n\r\n    return {month:_best_option(amount) for month,amount in monthly_spent.items()}\r\n        \r\n",
            "date": "2022-11-23 18:44:57.482800+00:00",
            "passed": true
        },
        {
            "bite": "Bite 316. To rent or to stream movies?",
            "code": "from datetime import date\r\nfrom typing import Dict, Sequence, NamedTuple\r\nfrom collections import defaultdict, Counter\r\n\r\nclass MovieRented(NamedTuple):\r\n    title: str\r\n    price: int\r\n    date: date\r\n\r\n\r\nRentingHistory = Sequence[MovieRented]\r\nSTREAMING_COST_PER_MONTH = 12\r\nSTREAM, RENT = 'stream', 'rent'\r\n\r\ndef _best_option(amount):\r\n    return STREAM if amount>STREAMING_COST_PER_MONTH else RENT\r\n\r\ndef rent_or_stream(\r\n    renting_history: RentingHistory,\r\n    streaming_cost_per_month: int = STREAMING_COST_PER_MONTH\r\n) -> Dict[str, str]:\r\n    \"\"\"Function that calculates if renting movies one by one is\r\n       cheaper than streaming movies by months.\r\n\r\n       Determine this PER MONTH for the movies in renting_history.\r\n\r\n       Return a dict of:\r\n       keys = months (YYYY-MM)\r\n       values = 'rent' or 'stream' based on what is cheaper\r\n\r\n       Check out the tests for examples.\r\n    \"\"\"\r\n    monthly_spent=defaultdict(int)\r\n    for movie in renting_history:\r\n        monthly_spent[movie.date.strftime('%Y-%m')]+=movie.price \r\n    return {month:_best_option(amount) for month,amount in monthly_spent.items()}\r\n        \r\n\r\ntest = [\r\n    MovieRented('Sonic', 10, date(2020, 11, 4)),\r\n    MovieRented('Die Hard', 3, date(2020, 11, 3)),\r\n    MovieRented('Breach', 7, date(2020, 12, 1)),\r\n    MovieRented('Love and Monsters', 5, date(2020, 12, 9)),\r\n    ]\r\n    \r\nprint(rent_or_stream(test))",
            "date": "2022-11-23 18:44:24.065915+00:00",
            "passed": true
        },
        {
            "bite": "Bite 329. Convert dict keys to snake case",
            "code": "from pprint import pprint\r\nimport string\r\nimport re\r\n    \r\ndef _make_snake(word):\r\n    # replace - with _\r\n    # make [0] lower\r\n    # replace upper with _lower\r\n    if len(word)<2:\r\n        return word.lower()\r\n    result = [word[0].lower()]\r\n    for letter in word[1:]:\r\n        if  letter =='-':\r\n            result.append('_')\r\n        elif letter in string.ascii_uppercase:\r\n            result.append('_'+letter.lower())\r\n        else:\r\n            result.append(letter)\r\n    word=\"\".join(result)\r\n    word=re.sub('(?<=[a-z])(?=[0-9])|(?<=[0-9])(?=[a-z])', '_', word)\r\n    return word\r\n\r\ndef snake_case_keys(data):\r\n    print(data)\r\n    if isinstance(data,str):\r\n        return data\r\n    if isinstance(data,list):\r\n        data_list = data\r\n    if isinstance(data, dict):\r\n        data_list = [data]\r\n\r\n    for i,data in enumerate(data_list):\r\n        if isinstance(data,str):\r\n            continue\r\n        if isinstance(data,list):\r\n            for j,item in enumerate(data):\r\n                data[j]=snake_case_keys(item)\r\n            \r\n        if isinstance(data,dict):    \r\n            data = {_make_snake(key): value for key,value in data.items()}\r\n            for key, value in data.items():\r\n                if isinstance(value, dict) or isinstance(value, list):\r\n                    data[key]= snake_case_keys(value)\r\n    \r\n            data_list[i] = data\r\n        \r\n    return data_list if len(data_list)>1 else data_list[0]\r\n        \r\n\r\ndata={\r\n    \"camelCase\": \"Value1\",\r\n    \"camelcase\": \"Value1\",\r\n    \"PascalCase\": \"Value2\",\r\n    \"kebab-case\": \"Value3\",\r\n    \"ACRONYM\": \"Value4\",\r\n    \"number22\": {\r\n                \"helmetColor\": \"black\",\r\n                \"armorColor\": \"black\",\r\n                \"capeColor\": \"black\",\r\n            },\r\n    \"nested_list\": [{\"firstName\": \"Luke\"},\r\n                     {\"firstName\": \"Leia\"}],\r\n    \"random\": [\r\n                \"Luke\",\r\n                [\r\n                    \"blowing up the death star\",\r\n                    {\"skillName\": \"bulls-eye womprats\",\r\n                     \"skillParameters\": \"with my T47\"},\r\n                ],\r\n            ]\r\n}\r\n\r\npprint(snake_case_keys(data))",
            "date": "2022-11-23 18:21:17.457122+00:00",
            "passed": true
        },
        {
            "bite": "Bite 329. Convert dict keys to snake case",
            "code": "from pprint import pprint\r\nimport string\r\nimport re\r\n    \r\ndef _make_snake(word):\r\n    # replace - with _\r\n    # make [0] lower\r\n    # replace upper with _lower\r\n    if len(word)<2:\r\n        return word.lower()\r\n    result = [word[0].lower()]\r\n    for letter in word[1:]:\r\n        if  letter =='-':\r\n            result.append('_')\r\n        elif letter in string.ascii_uppercase:\r\n            result.append('_'+letter.lower())\r\n        else:\r\n            result.append(letter)\r\n    word=\"\".join(result)\r\n    word=re.sub('(?<=[a-z])(?=[0-9])|(?<=[0-9])(?=[a-z])', '_', word)\r\n    return word\r\n\r\ndef snake_case_keys(data):\r\n\r\n    if isinstance(data, dict):\r\n        data_list = [data]\r\n    elif isinstance(data,list):\r\n        data_list = data\r\n\r\n    for i,data in enumerate(data_list):\r\n        if isinstance(data,dict):\r\n            data = {_make_snake(key): value for key,value in data.items()}\r\n            for key, value in data.items():\r\n                if isinstance(value, dict) or isinstance(value, list):\r\n                    data[key]= snake_case_keys(value)\r\n    \r\n            data_list[i] = data\r\n        \r\n    return data_list if len(data_list)>1 else data_list[0]\r\n        \r\n\r\ndata={\r\n    \"camelCase\": \"Value1\",\r\n    \"camelcase\": \"Value1\",\r\n    \"PascalCase\": \"Value2\",\r\n    \"kebab-case\": \"Value3\",\r\n    \"ACRONYM\": \"Value4\",\r\n    \"number22\": {\r\n                \"helmetColor\": \"black\",\r\n                \"armorColor\": \"black\",\r\n                \"capeColor\": \"black\",\r\n            },\r\n    \"nested_list\": [{\"firstName\": \"Luke\"},\r\n                     {\"firstName\": \"Leia\"}],\r\n    \"random\": [\r\n                \"Luke\",\r\n                [\r\n                    \"blowing up the death star\",\r\n                    {\"skillName\": \"bulls-eye womprats\",\r\n                     \"skillParameters\": \"with my T47\"},\r\n                ],\r\n            ]\r\n}\r\n\r\npprint(snake_case_keys(data))",
            "date": "2022-11-23 17:58:44.713950+00:00",
            "passed": false
        },
        {
            "bite": "Bite 329. Convert dict keys to snake case",
            "code": "from pprint import pprint\r\nimport string\r\nimport re\r\n    \r\ndef _make_snake(word):\r\n    # replace - with _\r\n    # make [0] lower\r\n    # replace upper with _lower\r\n    if len(word)<2:\r\n        return word.lower()\r\n    result = [word[0].lower()]\r\n    for letter in word[1:]:\r\n        if  letter =='-':\r\n            result.append('_')\r\n        elif letter in string.ascii_uppercase:\r\n            result.append('_'+letter.lower())\r\n        else:\r\n            result.append(letter)\r\n    word=\"\".join(result)\r\n    word=re.sub('(?<=[a-z])(?=\\d)|(?<=\\d)(?=[a-z])', '_', word)\r\n    return word\r\n\r\ndef snake_case_keys(data):\r\n    data = {_make_snake(key): value for key,value in data.items()}\r\n    \r\n    for key, value in data.items():\r\n        if isinstance(value, dict):\r\n            data[key]= snake_case_keys(value)\r\n        if isinstance(value, list):\r\n            for i,item in enumerate(value):\r\n                if isinstance(item,dict):\r\n                    data[key][i]= snake_case_keys(item)\r\n    return data\r\n        \r\n\r\ndata={\r\n    \"camelCase\": \"Value1\",\r\n    \"camelcase\": \"Value1\",\r\n    \"PascalCase\": \"Value2\",\r\n    \"kebab-case\": \"Value3\",\r\n    \"ACRONYM\": \"Value4\",\r\n    \"number22\": {\r\n                \"helmetColor\": \"black\",\r\n                \"armorColor\": \"black\",\r\n                \"capeColor\": \"black\",\r\n            },\r\n    \"nested_list\": [{\"firstName\": \"Luke\"},\r\n                     {\"firstName\": \"Leia\"}],\r\n}\r\n\r\npprint(snake_case_keys(data))",
            "date": "2022-11-23 14:31:01.249894+00:00",
            "passed": false
        },
        {
            "bite": "Bite 329. Convert dict keys to snake case",
            "code": "from pprint import pprint\r\nimport string\r\nimport re\r\n    \r\ndef _make_snake(word):\r\n    # replace - with _\r\n    # make [0] lower\r\n    # replace upper with _lower\r\n    if len(word)<2:\r\n        return word.lower()\r\n    result = [word[0].lower()]\r\n    for letter in word[1:]:\r\n        if  letter =='-':\r\n            result.append('_')\r\n        elif letter in string.ascii_uppercase:\r\n            result.append('_'+letter.lower())\r\n        else:\r\n            result.append(letter)\r\n    word=\"\".join(result)\r\n    word=re.sub('(?<=[a-z])(?=\\d)|(?<=\\d)(?=[a-z])', '_', word)\r\n    return word\r\n\r\ndef snake_case_keys(data):\r\n    data = {_make_snake(key): value for key,value in data.items()}\r\n    \r\n    for key, value in data.items():\r\n        if isinstance(value, dict):\r\n            data[key]= snake_case_keys(value)\r\n\r\n    return data\r\n        \r\n\r\ndata={\r\n    \"camelCase\": \"Value1\",\r\n    \"camelcase\": \"Value1\",\r\n    \"PascalCase\": \"Value2\",\r\n    \"kebab-case\": \"Value3\",\r\n    \"ACRONYM\": \"Value4\",\r\n    \"number22\": {\r\n                \"helmetColor\": \"black\",\r\n                \"armorColor\": \"black\",\r\n                \"capeColor\": \"black\",\r\n            },\r\n}\r\n\r\npprint(snake_case_keys(data))",
            "date": "2022-11-23 13:02:29.479434+00:00",
            "passed": false
        },
        {
            "bite": "Bite 329. Convert dict keys to snake case",
            "code": "from pprint import pprint\r\nimport string\r\nimport re\r\n    \r\ndef _make_snake(word):\r\n    # replace - with _\r\n    # make [0] lower\r\n    # replace upper with _lower\r\n    if len(word)<2:\r\n        return word.lower()\r\n    result = [word[0].lower()]\r\n    for letter in word[1:]:\r\n        if  letter =='-':\r\n            result.append('_')\r\n        elif letter in string.ascii_uppercase:\r\n            result.append('_'+letter.lower())\r\n        else:\r\n            result.append(letter)\r\n    word=\"\".join(result)\r\n    word=re.sub('(?<=[a-z])(?=\\d)|(?<=\\d)(?=[a-z])', '_', word)\r\n    return word\r\n\r\ndef snake_case_keys(data):\r\n    return {_make_snake(key): value for key,value in data.items()}\r\n        \r\n\r\ndata={\r\n    \"camelCase\": \"Value1\",\r\n    \"camelcase\": \"Value1\",\r\n    \"PascalCase\": \"Value2\",\r\n    \"kebab-case\": \"Value3\",\r\n    \"ACRONYM\": \"Value4\",\r\n    \"number22\": \"Value5\"\r\n}\r\n\r\npprint(snake_case_keys(data))",
            "date": "2022-11-23 12:56:17.191046+00:00",
            "passed": false
        },
        {
            "bite": "Bite 347. Which words can you type with one hand?",
            "code": "from enum import Enum\r\n\r\n\r\nclass Hand(str, Enum):\r\n    RIGHT = \"right\"\r\n    LEFT = \"left\"\r\n    BOTH = \"both\"\r\n\r\n\r\nLEFT_HAND_CHARS = set(\"QWERTASDFGZXCVB\")\r\nRIGHT_HAND_CHARS = set(\"YUIOPHJKLNM\")\r\n\r\n\r\ndef get_hand_for_word(word: str) -> Hand:\r\n    \"\"\"\r\n    Use the LEFT_HAND_CHARS and RIGHT_HAND_CHARS sets to determine\r\n    if the passed in word can be written with only the left or right\r\n    hand, or if both hands are needed.\r\n    \"\"\"\r\n    \r\n    if all(letter.upper() in LEFT_HAND_CHARS for letter in word):\r\n        return Hand.LEFT\r\n    elif all(letter.upper() in RIGHT_HAND_CHARS for letter in word):\r\n        return Hand.RIGHT\r\n    else:\r\n        return Hand.BOTH\r\n",
            "date": "2022-11-22 18:49:55.555822+00:00",
            "passed": true
        },
        {
            "bite": "Bite 347. Which words can you type with one hand?",
            "code": "from enum import Enum\r\n\r\n\r\nclass Hand(str, Enum):\r\n    RIGHT = \"right\"\r\n    LEFT = \"left\"\r\n    BOTH = \"both\"\r\n\r\n\r\nLEFT_HAND_CHARS = set(\"QWERTASDFGZXCVB\")\r\nRIGHT_HAND_CHARS = set(\"YUIOPHJKLNM\")\r\n\r\n\r\ndef get_hand_for_word(word: str) -> Hand:\r\n    \"\"\"\r\n    Use the LEFT_HAND_CHARS and RIGHT_HAND_CHARS sets to determine\r\n    if the passed in word can be written with only the left or right\r\n    hand, or if both hands are needed.\r\n    \"\"\"\r\n    \r\n    if all(letter.upper() in LEFT_HAND_CHARS for letter in word):\r\n        return LEFT\r\n    elif all(letter.upper() in RIGHT_HAND_CHARS for letter in word):\r\n        return LEFT\r\n    else:\r\n        return BOTH\r\n",
            "date": "2022-11-22 18:47:32.963146+00:00",
            "passed": false
        },
        {
            "bite": "Bite 98. Code your way out of a grid",
            "code": "import re\r\nfrom pprint import pprint\r\n\r\nDOWN, UP, LEFT, RIGHT = '\u21d3', '\u21d1', '\u21d0', '\u21d2'\r\nSTART_VALUE = 1\r\n\r\ndef _find_value(value, matrix_2d):\r\n    nrows = len(matrix_2d)\r\n    ncols = len(matrix_2d[0])\r\n    for i in range(nrows):\r\n        for j in range(ncols):\r\n            if matrix_2d[i][j] == value:\r\n                return [i, j]\r\n\r\ndef _search(value, i,j, matrix_2d):\r\n    nrows = len(matrix_2d)\r\n    ncols = len(matrix_2d[0])\r\n    if i>0:\r\n        if matrix_2d[i-1][j] == value:\r\n            return UP, i-1, j\r\n    if i<nrows-1:\r\n        if matrix_2d[i+1][j] == value:\r\n            return DOWN, i+1, j\r\n    if j>0:\r\n        if matrix_2d[i][j-1] == value:\r\n            return LEFT, i, j-1\r\n    if j<ncols-1:\r\n        if matrix_2d[i][j+1] == value:\r\n            return RIGHT, i, j+1\r\n    return None, i, j\r\n\r\n\r\n\r\n\r\ndef print_sequence_route(grid, start_coordinates=None):\r\n    \"\"\"Receive grid string, convert to 2D matrix of ints, find the\r\n       START_VALUE coordinates and move through the numbers in order printing\r\n       them.  Each time you turn append the grid with its corresponding symbol\r\n       (DOWN / UP / LEFT / RIGHT). See the TESTS for more info.\"\"\"\r\n    data=[]\r\n    for line in grid.splitlines():\r\n        row= re.findall('[0-9]+',line)\r\n        if row:\r\n            data.append([int(n) for n in row])\r\n    # pprint(data)\r\n    \r\n    nrows, ncols = len(data), len(row)\r\n    \r\n    if not start_coordinates:\r\n        start_coordinates = _find_value(START_VALUE, data)\r\n    i,j= tuple(start_coordinates)\r\n    # print(f\"Starting at {i} {j}\")\r\n\r\n    value = data[i][j]\r\n    direction = new_direction = RIGHT\r\n    \r\n    print(f\"{value}\",end=\" \")\r\n    \r\n    while True:\r\n# look up for N+1\r\n        value+=1\r\n        new_direction, i,j = _search(value, i,j, data)\r\n        if not new_direction:\r\n            break\r\n        # update direction and print\r\n        if new_direction != direction:\r\n            direction = new_direction\r\n            print(new_direction)         \r\n        # print value\r\n        print(f\"{value}\",end=\" \")\r\n    \r\ntest =\"\"\"\r\n21 - 22 - 23 - 24 - 25\r\n |\r\n20    7 -  8 -  9 - 10\r\n |    |              |\r\n19    6    1 -  2   11\r\n |    |         |    |\r\n18    5 -  4 -  3   12\r\n |                   |\r\n17 - 16 - 15 - 14 - 13\r\n\"\"\"\r\n\r\nprint_sequence_route(test)\r\n\r\n\r\n\"\"\"\r\n1 2 \u21d3\r\n3 \u21d0\r\n4 5 \u21d1\r\n6 7 \u21d2\r\n8 9 10 \u21d3\r\n11 12 13 \u21d0\r\n14 15 16 17 \u21d1\r\n18 19 20 21 \u21d2\r\n22 23 24 25\r\n\"\"\"",
            "date": "2022-11-22 18:39:40.669860+00:00",
            "passed": true
        },
        {
            "bite": "Bite 284. Pascal triangle",
            "code": "from typing import List\r\nfrom math import factorial, ceil\r\n\r\ndef pascal(N: int) -> List[int]:\r\n    \"\"\"\r\n    Return the Nth row of Pascal triangle\r\n    \"\"\"\r\n    # you code ...\r\n    # return row\r\n    \r\n    row = N-1\r\n    result=[0 for _ in range(N)]\r\n\r\n    for col in range(ceil(N/2)):\r\n        result[col]=int(factorial(row)/(factorial(row-col)*factorial(col)))\r\n        result[-col-1]=result[col]\r\n    return result\r\n        \r\nprint(pascal(5))",
            "date": "2022-11-22 16:32:04.556058+00:00",
            "passed": true
        },
        {
            "bite": "Bite 284. Pascal triangle",
            "code": "from typing import List\r\nfrom math import factorial, ceil\r\n\r\ndef pascal(N: int) -> List[int]:\r\n    \"\"\"\r\n    Return the Nth row of Pascal triangle\r\n    \"\"\"\r\n    # you code ...\r\n    # return row\r\n    \r\n    row = N\r\n    result=[0 for _ in range(N+1)]\r\n\r\n    for col in range(ceil((N+1)/2)):\r\n        result[col]=int(factorial(row)/(factorial(row-col)*factorial(col)))\r\n        result[-col-1]=result[col]\r\n    return result\r\n        \r\n",
            "date": "2022-11-22 16:29:22.238036+00:00",
            "passed": false
        },
        {
            "bite": "Bite 332. Searching for an apartment",
            "code": "from typing import List\r\n\r\nEAST = \"E\"\r\nWEST = \"W\"\r\n\r\n\r\ndef _has_a_view(i, buildings, direction):\r\n    if direction.upper() == 'W':\r\n        if i == 0:\r\n            return True\r\n        subset = buildings[:i]\r\n    elif direction.upper() == 'E':\r\n        if i == len(buildings):\r\n            return True\r\n        subset = buildings[i+1:]\r\n    else:\r\n        raise ValueError(\"Direction should be 'W' or 'E'\")\r\n        \r\n    return all(b<buildings[i] for b in subset)\r\n\r\ndef search_apartment(buildings: List[int], direction: str) -> List[int]:\r\n    \"\"\"\r\n    Find and return the indices of those building with\r\n    the desired view: EAST (E) or WEST (W).\r\n\r\n    See sample inputs / outputs below and in the tests.\r\n    \"\"\"\r\n    return [i for i in range(len(buildings)) if _has_a_view(i, buildings, direction)]\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    A = [3, 5, 4, 4, 7, 1, 3, 2]  # central tallest\r\n    B = [1, 1, 1, 1, 1, 2]  # almost flat\r\n    #\r\n    #  W <-                    ->  E(ast)\r\n    #\r\n    print(search_apartment(A, \"W\"))  # [0, 1, 4]\r\n    print(search_apartment(A, \"E\"))  # [4, 6, 7]\r\n    print(search_apartment(B, \"W\"))  # [0, 5]\r\n    print(search_apartment(B, \"E\"))  # [5]\r\n    \r\n    \r\n\r\n        \r\n",
            "date": "2022-11-21 18:16:20.724415+00:00",
            "passed": true
        },
        {
            "bite": "Bite 332. Searching for an apartment",
            "code": "from typing import List\r\n\r\nEAST = \"E\"\r\nWEST = \"W\"\r\n\r\n\r\ndef _has_a_view(i, buildings, direction):\r\n    if direction == 'W':\r\n        if i == 0:\r\n            return True\r\n        subset = buildings[:i]\r\n    elif direction == 'E':\r\n        if i == len(buildings):\r\n            return True\r\n        subset = buildings[i+1:]\r\n        \r\n    return all(b<buildings[i] for b in subset)\r\n\r\ndef search_apartment(buildings: List[int], direction: str) -> List[int]:\r\n    \"\"\"\r\n    Find and return the indices of those building with\r\n    the desired view: EAST (E) or WEST (W).\r\n\r\n    See sample inputs / outputs below and in the tests.\r\n    \"\"\"\r\n    return [i for i,b in enumerate(buildings) if _has_a_view(i, buildings, direction)]\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    A = [3, 5, 4, 4, 7, 1, 3, 2]  # central tallest\r\n    B = [1, 1, 1, 1, 1, 2]  # almost flat\r\n    #\r\n    #  W <-                    ->  E(ast)\r\n    #\r\n    print(search_apartment(A, \"W\"))  # [0, 1, 4]\r\n    print(search_apartment(A, \"E\"))  # [4, 6, 7]\r\n    print(search_apartment(B, \"W\"))  # [0, 5]\r\n    print(search_apartment(B, \"E\"))  # [5]\r\n    \r\n    \r\n\r\n        \r\n",
            "date": "2022-11-21 18:14:28.284887+00:00",
            "passed": true
        },
        {
            "bite": "Bite 175. Find missing dates",
            "code": "import datetime\r\n\r\ndef get_missing_dates(dates):\r\n    \"\"\"Receives a range of dates and returns a sequence\r\n       of missing datetime.date objects (no worries about order).\r\n\r\n       You can assume that the first and last date of the\r\n       range is always present (assumption made in tests).\r\n\r\n       See the Bite description and tests for example outputs.\r\n    \"\"\"\r\n    start, end = min(dates), max(dates)\r\n    \r\n    all_dates_in_range = [start + datetime.timedelta(days=x) for x in range((end-start).days)]\r\n    \r\n    return [date for date in all_dates_in_range if date not in dates]\r\n    \r\n",
            "date": "2022-11-21 17:51:54.493057+00:00",
            "passed": true
        },
        {
            "bite": "Bite 175. Find missing dates",
            "code": "import datetime\r\n\r\ndef get_missing_dates(dates):\r\n    \"\"\"Receives a range of dates and returns a sequence\r\n       of missing datetime.date objects (no worries about order).\r\n\r\n       You can assume that the first and last date of the\r\n       range is always present (assumption made in tests).\r\n\r\n       See the Bite description and tests for example outputs.\r\n    \"\"\"\r\n    start = min(dates)\r\n    end=max(dates)\r\n    all_dates_in_range = [start + datetime.timedelta(days=x) for x in range((end-start).days)]\r\n    return [date for date in all_dates_in_range if date not in dates]\r\n    \r\n    \r\ntest = [datetime.date(2019, 2, 7),\r\ndatetime.date(2019, 2, 4), \r\ndatetime.date(2019, 2, 6), \r\ndatetime.date(2019, 2, 2)]\r\n\r\nprint(get_missing_dates(test))",
            "date": "2022-11-21 17:51:19.140679+00:00",
            "passed": true
        },
        {
            "bite": "Bite 92. Humanize a datetime",
            "code": "from collections import namedtuple\r\nfrom datetime import datetime, timedelta\r\nimport bisect\r\n\r\nTimeOffset = namedtuple('TimeOffset', 'offset date_str divider')\r\n\r\nNOW = datetime.now()\r\nMINUTE, HOUR, DAY = 60, 60*60, 24*60*60\r\nTIME_OFFSETS = (\r\n    TimeOffset(10, 'just now', None),\r\n    TimeOffset(MINUTE, '{} seconds ago', 1),\r\n    TimeOffset(2*MINUTE, 'a minute ago', None),\r\n    TimeOffset(HOUR, '{} minutes ago', MINUTE),\r\n    TimeOffset(2*HOUR, 'an hour ago', None),\r\n    TimeOffset(DAY, '{} hours ago', HOUR),\r\n    TimeOffset(2*DAY, 'yesterday', None),\r\n)\r\n\r\n\r\ndef pretty_date(date):\r\n    \"\"\"Receives a datetime object and converts/returns a readable string\r\n       using TIME_OFFSETS\"\"\"\r\n    \r\n    if not isinstance(date, datetime) or date > NOW:\r\n        raise ValueError\r\n        \r\n    offset= NOW - date\r\n    secs = offset.total_seconds()\r\n\r\n    idx = bisect.bisect([item.offset for item in TIME_OFFSETS], secs)\r\n    if idx>=len(TIME_OFFSETS):\r\n        return date.strftime('%m/%d/%y')\r\n    result = TIME_OFFSETS[idx]\r\n    return result.date_str.format(round(secs/result.divider)) if result.divider else result.date_str\r\n    \r\n",
            "date": "2022-11-21 17:36:52.227539+00:00",
            "passed": true
        },
        {
            "bite": "Bite 92. Humanize a datetime",
            "code": "from collections import namedtuple\r\nfrom datetime import datetime, timedelta\r\nimport bisect\r\n\r\nTimeOffset = namedtuple('TimeOffset', 'offset date_str divider')\r\n\r\nNOW = datetime.now()\r\nMINUTE, HOUR, DAY = 60, 60*60, 24*60*60\r\nTIME_OFFSETS = (\r\n    TimeOffset(10, 'just now', None),\r\n    TimeOffset(MINUTE, '{} seconds ago', 1),\r\n    TimeOffset(2*MINUTE, 'a minute ago', None),\r\n    TimeOffset(HOUR, '{} minutes ago', MINUTE),\r\n    TimeOffset(2*HOUR, 'an hour ago', None),\r\n    TimeOffset(DAY, '{} hours ago', HOUR),\r\n    TimeOffset(2*DAY, 'yesterday', None),\r\n)\r\n\r\n\r\ndef pretty_date(date):\r\n    \"\"\"Receives a datetime object and converts/returns a readable string\r\n       using TIME_OFFSETS\"\"\"\r\n    \r\n    if not isinstance(date, datetime) or date > NOW:\r\n        raise ValueError\r\n        \r\n    offset= NOW - date\r\n    secs = offset.total_seconds()\r\n\r\n    idx = bisect.bisect([item.offset for item in TIME_OFFSETS], secs)\r\n    if idx>=len(TIME_OFFSETS):\r\n        return date.strftime('%m/%d/%y')\r\n    result = TIME_OFFSETS[idx]\r\n    return result.date_str.format(round(secs/result.divider)) if result.divider else result.date_str\r\n    \r\n\r\ntest = [\r\n    (NOW - timedelta(seconds=2), 'just now'),\r\n    (NOW - timedelta(seconds=9), 'just now'),\r\n    (NOW - timedelta(seconds=10), '10 seconds ago'),\r\n    (NOW - timedelta(seconds=59), '59 seconds ago'),\r\n    (NOW - timedelta(minutes=1), 'a minute ago'),\r\n    (NOW - timedelta(minutes=1, seconds=40), 'a minute ago'),\r\n    (NOW - timedelta(minutes=2), '2 minutes ago'),\r\n    (NOW - timedelta(minutes=59), '59 minutes ago'),\r\n    (NOW - timedelta(hours=1), 'an hour ago'),\r\n    (NOW - timedelta(hours=2), '2 hours ago'),\r\n    (NOW - timedelta(hours=23), '23 hours ago'),\r\n    (NOW - timedelta(hours=24), 'yesterday'),\r\n    (NOW - timedelta(hours=47), 'yesterday'),\r\n    (NOW - timedelta(days=1), 'yesterday'),\r\n    (NOW - timedelta(days=2), '05/19/18'),\r\n    (NOW - timedelta(days=7), '05/14/18'),\r\n    (NOW - timedelta(days=100), '02/10/18'),\r\n    (NOW - timedelta(days=365), '05/21/17')\r\n    ]\r\n    \r\nfor item in test:\r\n    print(pretty_date(item[0]))",
            "date": "2022-11-21 17:36:13.938212+00:00",
            "passed": true
        },
        {
            "bite": "Bite 319. Identity and equality",
            "code": "# TODO: Fix age and same_configuration functions (see test results)\r\nclass Car:\r\n    \"\"\"\r\n    Car class\r\n    -> Have a closer look at lines marked with '# *'\r\n    \"\"\"\r\n\r\n    def __init__(self, model, color):\r\n        self.model = model\r\n        self.color = color\r\n\r\n    def __eq__(self, other_car):\r\n        return (\r\n            self.model.lower() == other_car.model.lower()\r\n            and self.color.lower() == other_car.color.lower()\r\n        )\r\n\r\n    @staticmethod\r\n    def age(days):\r\n        \"\"\"if / elif / else for exercise sake, if there would\r\n           be more conditions we would use a dict / mapping\r\n        \"\"\"\r\n        if days == 7:  # *\r\n            return \"A week old\"\r\n        elif days == 365:  # *\r\n            return \"A year old\"\r\n        else:\r\n            return \"Neither a week, nor a year old\"\r\n\r\n    @staticmethod\r\n    def has_same_configuration(config1, config2):\r\n        if not isinstance(config1,list) or not isinstance(config2,list):  # *\r\n            raise TypeError()\r\n        return config1 == config2  # *\r\n\r\n\r\n# TODO: Complete function\r\ndef is_same_car_color_and_model(car1, car2):\r\n    \"\"\"\r\n    Returns true if car1 and car2 are the of same model and color\r\n    \"\"\"\r\n    return car1 == car2\r\n\r\n\r\n# TODO: Complete function\r\ndef is_same_instance_of_car(car1, car2):\r\n    \"\"\"\r\n    Returns true if car1 and car2 are exactly the same object (instance)\r\n    \"\"\"\r\n    return car1 is car2",
            "date": "2022-11-20 23:19:29.495823+00:00",
            "passed": true
        },
        {
            "bite": "Bite 319. Identity and equality",
            "code": "# TODO: Fix age and same_configuration functions (see test results)\r\nclass Car:\r\n    \"\"\"\r\n    Car class\r\n    -> Have a closer look at lines marked with '# *'\r\n    \"\"\"\r\n\r\n    def __init__(self, model, color):\r\n        self.model = model\r\n        self.color = color\r\n\r\n    def __eq__(self, other_car):\r\n        return (\r\n            self.model.lower() == other_car.model.lower()\r\n            and self.color.lower() == other_car.color.lower()\r\n        )\r\n\r\n    @staticmethod\r\n    def age(days):\r\n        \"\"\"if / elif / else for exercise sake, if there would\r\n           be more conditions we would use a dict / mapping\r\n        \"\"\"\r\n        if days == 7:  # *\r\n            return \"A week old\"\r\n        elif days == 365:  # *\r\n            return \"A year old\"\r\n        else:\r\n            return \"Neither a week, nor a year old\"\r\n\r\n    @staticmethod\r\n    def has_same_configuration(config1, config2):\r\n        if type(config1) is not list or type(config2) is not list:  # *\r\n            raise TypeError()\r\n        return config1 == config2  # *\r\n\r\n\r\n# TODO: Complete function\r\ndef is_same_car_color_and_model(car1, car2):\r\n    \"\"\"\r\n    Returns true if car1 and car2 are the of same model and color\r\n    \"\"\"\r\n    return car1 == car2\r\n\r\n\r\n# TODO: Complete function\r\ndef is_same_instance_of_car(car1, car2):\r\n    \"\"\"\r\n    Returns true if car1 and car2 are exactly the same object (instance)\r\n    \"\"\"\r\n    return car1 is car2",
            "date": "2022-11-20 23:17:10.477499+00:00",
            "passed": false
        },
        {
            "bite": "Bite 319. Identity and equality",
            "code": "# TODO: Fix age and same_configuration functions (see test results)\r\nclass Car:\r\n    \"\"\"\r\n    Car class\r\n    -> Have a closer look at lines marked with '# *'\r\n    \"\"\"\r\n\r\n    def __init__(self, model, color):\r\n        self.model = model\r\n        self.color = color\r\n\r\n    def __eq__(self, other_car):\r\n        return (\r\n            self.model.lower() == other_car.model.lower()\r\n            and self.color.lower() == other_car.color.lower()\r\n        )\r\n\r\n    @staticmethod\r\n    def age(days):\r\n        \"\"\"if / elif / else for exercise sake, if there would\r\n           be more conditions we would use a dict / mapping\r\n        \"\"\"\r\n        if days == 7:  # *\r\n            return \"A week old\"\r\n        elif days == 365:  # *\r\n            return \"A year old\"\r\n        else:\r\n            return \"Neither a week, nor a year old\"\r\n\r\n    @staticmethod\r\n    def has_same_configuration(config1, config2):\r\n        if type(config1) is not list or type(config2) is not list:  # *\r\n            raise TypeError()\r\n        return config1 is config2  # *\r\n\r\n\r\n# TODO: Complete function\r\ndef is_same_car_color_and_model(car1, car2):\r\n    \"\"\"\r\n    Returns true if car1 and car2 are the of same model and color\r\n    \"\"\"\r\n    return car1 == car2\r\n\r\n\r\n# TODO: Complete function\r\ndef is_same_instance_of_car(car1, car2):\r\n    \"\"\"\r\n    Returns true if car1 and car2 are exactly the same object (instance)\r\n    \"\"\"\r\n    return car1 is car2",
            "date": "2022-11-20 23:15:05.859439+00:00",
            "passed": false
        },
        {
            "bite": "Bite 319. Identity and equality",
            "code": "# TODO: Fix age and same_configuration functions (see test results)\r\nclass Car:\r\n    \"\"\"\r\n    Car class\r\n    -> Have a closer look at lines marked with '# *'\r\n    \"\"\"\r\n\r\n    def __init__(self, model, color):\r\n        self.model = model\r\n        self.color = color\r\n\r\n    def __eq__(self, other_car):\r\n        return (\r\n            self.model.lower() == other_car.model.lower()\r\n            and self.color.lower() == other_car.color.lower()\r\n        )\r\n\r\n    @staticmethod\r\n    def age(days):\r\n        \"\"\"if / elif / else for exercise sake, if there would\r\n           be more conditions we would use a dict / mapping\r\n        \"\"\"\r\n        if days == 7:  # *\r\n            return \"A week old\"\r\n        elif days == 365:  # *\r\n            return \"A year old\"\r\n        else:\r\n            return \"Neither a week, nor a year old\"\r\n\r\n    @staticmethod\r\n    def has_same_configuration(config1, config2):\r\n        if type(config1) is not list or type(config2) is not list:  # *\r\n            raise TypeError()\r\n        return config1 == config2  # *\r\n\r\n\r\n# TODO: Complete function\r\ndef is_same_car_color_and_model(car1, car2):\r\n    \"\"\"\r\n    Returns true if car1 and car2 are the of same model and color\r\n    \"\"\"\r\n    return car1 == car2\r\n\r\n\r\n# TODO: Complete function\r\ndef is_same_instance_of_car(car1, car2):\r\n    \"\"\"\r\n    Returns true if car1 and car2 are exactly the same object (instance)\r\n    \"\"\"\r\n    return car1 is car2",
            "date": "2022-11-20 23:14:51.554245+00:00",
            "passed": false
        },
        {
            "bite": "Bite 319. Identity and equality",
            "code": "# TODO: Fix age and same_configuration functions (see test results)\r\nclass Car:\r\n    \"\"\"\r\n    Car class\r\n    -> Have a closer look at lines marked with '# *'\r\n    \"\"\"\r\n\r\n    def __init__(self, model, color):\r\n        self.model = model\r\n        self.color = color\r\n\r\n    def __eq__(self, other_car):\r\n        return (\r\n            self.model.lower() == other_car.model.lower()\r\n            and self.color.lower() == other_car.color.lower()\r\n        )\r\n\r\n    @staticmethod\r\n    def age(days):\r\n        \"\"\"if / elif / else for exercise sake, if there would\r\n           be more conditions we would use a dict / mapping\r\n        \"\"\"\r\n        if days == 7:  # *\r\n            return \"A week old\"\r\n        elif days == 365:  # *\r\n            return \"A year old\"\r\n        else:\r\n            return \"Neither a week, nor a year old\"\r\n\r\n    @staticmethod\r\n    def has_same_configuration(config1, config2):\r\n        if type(config1) != list or type(config2) != list:  # *\r\n            raise TypeError()\r\n        return config1 == config2  # *\r\n\r\n\r\n# TODO: Complete function\r\ndef is_same_car_color_and_model(car1, car2):\r\n    \"\"\"\r\n    Returns true if car1 and car2 are the of same model and color\r\n    \"\"\"\r\n    return car1 == car2\r\n\r\n\r\n# TODO: Complete function\r\ndef is_same_instance_of_car(car1, car2):\r\n    \"\"\"\r\n    Returns true if car1 and car2 are exactly the same object (instance)\r\n    \"\"\"\r\n    return car1 is car2",
            "date": "2022-11-20 23:12:04.873875+00:00",
            "passed": false
        },
        {
            "bite": "Bite 322. Reading progress",
            "code": "from datetime import datetime, date\r\nDAYS_IN_YEAR=365\r\n\r\ndef ontrack_reading(books_goal: int, books_read: int,\r\n                    day_of_year: int = None) -> bool:\r\n    if day_of_year is None:\r\n        today = date.today()\r\n        start_year= date(today.year, 1, 1)\r\n        day_of_year = (today - start_year).days\r\n    return books_read >= day_of_year*books_goal/DAYS_IN_YEAR\r\n    \r\n",
            "date": "2022-11-20 22:54:06.598847+00:00",
            "passed": true
        },
        {
            "bite": "Bite 322. Reading progress",
            "code": "from datetime import datetime, date\r\nDAYS_IN_YEAR=365\r\n\r\ndef ontrack_reading(books_goal: int, books_read: int,\r\n                    day_of_year: int = None) -> bool:\r\n    if day_of_year is None:\r\n        today = date.today()\r\n        start_year= date(today.year, 1, 1)\r\n        day_of_year = (today - start_year).days\r\n    return books_read > day_of_year*books_goal/DAYS_IN_YEAR\r\n    \r\n",
            "date": "2022-11-20 22:53:18.166969+00:00",
            "passed": false
        },
        {
            "bite": "Bite 322. Reading progress",
            "code": "from datetime import datetime, date\r\nDAYS_IN_YEAR=365\r\n\r\ndef ontrack_reading(books_goal: int, books_read: int,\r\n                    day_of_year: int = None) -> bool:\r\n    if day_of_year is None:\r\n        day_of_year = (date.today() - datetime.date(date.today().year, 1, 1)).days\r\n    return books_read > day_of_year*books_goal/DAYS_IN_YEAR",
            "date": "2022-11-20 22:49:19.864924+00:00",
            "passed": false
        },
        {
            "bite": "Bite 293. N digit numbers",
            "code": "from typing import List, TypeVar\r\nT = TypeVar('T', int, float)\r\nimport re\r\n\r\ndef n_digit_numbers(numbers: List[T], n: int) -> List[int]:\r\n    result=[]\r\n    for num in numbers:\r\n        num_n_digit=int(re.sub('\\.|-','',str(num)).ljust(n,'0')[:n])\r\n        if num<0:\r\n            num_n_digit*=-1\r\n        result.append(num_n_digit)\r\n    return result\r\n    \r\n",
            "date": "2022-11-19 23:23:41.166357+00:00",
            "passed": true
        },
        {
            "bite": "Bite 293. N digit numbers",
            "code": "from typing import List, TypeVar\r\nT = TypeVar('T', int, float)\r\nimport re\r\n\r\ndef n_digit_numbers(numbers: List[T], n: int) -> List[int]:\r\n    result=[]\r\n    for num in numbers:\r\n        num_n_digit=int(re.sub('\\.|-','',str(num)).ljust(n,'0')[:n])\r\n        if num<0:\r\n            num_n_digit*=-1\r\n        result.append(num_n_digit)\r\n    return result\r\n    \r\n\"\"\"\r\n[], 1, []\r\n[1, 2, 3], 1, [1, 2, 3]\r\n[1, 2, 3], 2, [10, 20, 30]\r\n[0, 1, 2, 3], 2, [0, 10, 20, 30]\r\n[8, 9, 10], 2, [80, 90, 10]\r\n[5.2, 1600, 520, 3600, 13, 55, 4000], 2, [52, 16, 52, 36, 13, 55, 40]\r\n[-1.1, 2.22, -3.333], 3, [-110, 222, -333]\r\n\"\"\"\r\n\r\nprint(n_digit_numbers([-1.1, 2.22, -3.333], 3))",
            "date": "2022-11-19 23:23:11.132385+00:00",
            "passed": true
        },
        {
            "bite": "Bite 293. N digit numbers",
            "code": "from typing import List, TypeVar\r\nT = TypeVar('T', int, float)\r\n\r\n\r\ndef n_digit_numbers(numbers: List[T], n: int) -> List[int]:\r\n    result=[]\r\n    for num in numbers:\r\n        num_n_digit=int(re.sub('.-','',str(num)).ljust(n,'0'))\r\n        if num<0:\r\n            num_n_digit*=-1\r\n        result.append(num_n_digit)\r\n    return result\r\n    \r\n",
            "date": "2022-11-19 23:18:09.706145+00:00",
            "passed": false
        },
        {
            "bite": "Bite 174. String manipulation and metrics",
            "code": "import string\r\nfrom collections import Counter\r\nfrom dataclasses import dataclass, field\r\nfrom typing import List, Set, Tuple\r\n\r\nSTOPWORDS: set = {\r\n    \"she's\", \"wasn\", \"through\", \"won\", \"that'll\", \"his\", \"once\", \"this\",\r\n    \"you\", \"ll\", \"has\", \"because\", \"m\", \"ours\", \"doing\", \"any\", \"aren't\",\r\n    \"they\", \"shouldn't\", \"being\", \"out\", \"is\", \"our\", \"it\", \"don\", \"had\",\r\n    \"nor\", \"your\", \"she\", \"you've\", \"themselves\", \"or\", \"y\", \"needn\", \"on\",\r\n    \"to\", \"at\", \"it's\", \"ve\", \"s\", \"too\", \"up\", \"didn't\", \"during\", \"haven\",\r\n    \"can\", \"haven't\", \"each\", \"couldn\", \"isn't\", \"not\", \"against\", \"where\",\r\n    \"was\", \"aren\", \"all\", \"by\", \"why\", \"hers\", \"theirs\", \"have\", \"as\",\r\n    \"yourself\", \"their\", \"very\", \"who\", \"yourselves\", \"over\", \"and\",\r\n    \"again\", \"do\", \"weren't\", \"which\", \"ma\", \"in\", \"such\", \"herself\",\r\n    \"yours\", \"doesn\", \"if\", \"my\", \"after\", \"into\", \"just\", \"now\", \"isn\",\r\n    \"itself\", \"between\", \"will\", \"other\", \"its\", \"these\", \"should\", \"re\",\r\n    \"below\", \"having\", \"am\", \"both\", \"d\", \"you'll\", \"but\", \"should've\",\r\n    \"won't\", \"himself\", \"shan't\", \"the\", \"me\", \"weren\", \"further\", \"until\",\r\n    \"here\", \"myself\", \"whom\", \"were\", \"hasn\", \"don't\", \"wouldn't\", \"been\",\r\n    \"before\", \"above\", \"he\", \"than\", \"most\", \"shan\", \"them\", \"mustn't\",\r\n    \"couldn't\", \"you'd\", \"for\", \"of\", \"her\", \"those\", \"needn't\", \"you're\",\r\n    \"t\", \"hadn't\", \"down\", \"o\", \"did\", \"about\", \"from\", \"does\", \"wouldn\",\r\n    \"off\", \"then\", \"ain\", \"few\", \"hasn't\", \"some\", \"i\", \"ourselves\", \"an\",\r\n    \"when\", \"are\", \"under\", \"more\", \"with\", \"hadn\", \"what\", \"while\", \"didn\",\r\n    \"doesn't\", \"only\", \"him\", \"mightn\", \"be\", \"mightn't\", \"a\", \"how\", \"no\",\r\n    \"there\", \"that\", \"so\", \"we\", \"same\", \"mustn\", \"wasn't\", \"shouldn\", \"own\",\r\n}\r\nGETTYSBURG: str = \"\"\"Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.\r\n\r\nNow we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battlefield of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this.\r\n\r\nBut, in a larger sense, we cannot dedicate\u2014we cannot consecrate\u2014we cannot hallow\u2014this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us\u2014that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion\u2014that we here highly resolve that these dead shall not have died in vain\u2014that this nation, under God, shall have a new birth of freedom\u2014 and that government of the people, by the people, for the people, shall not perish from the earth.\"\"\"\r\n\r\n\r\n@dataclass\r\nclass Corpora:\r\n    \"\"\"Add the inital variables along with creating any methods that\r\n    will get this working as described in the bite's description.\r\n\r\n    * txt\r\n    * count\r\n    * tag\r\n    * extra\r\n    * stopwords\r\n    \"\"\"\r\n    txt: str\r\n    count: int = 5\r\n    tag: str = \"#\"\r\n    extra: List[str] = field(default_factory=list)\r\n    stopwords: Set[str] = field(default_factory=set)\r\n\r\n    def __post_init__(self):\r\n        self.extra = self.extra if self.extra else []\r\n        self.stopwords = STOPWORDS\r\n\r\n    @property\r\n    def cleaned(self) -> str:\r\n        \"\"\"Takes a corpus and cleans it up.\r\n\r\n        * All text is made lowercase\r\n        * All punctuations are removed\r\n        * If a list of extract objects were given, remove those too\r\n\r\n        :param txt: Corpus of text\r\n        :return: cleaned up corpus\r\n        \"\"\"\r\n        trans = str.maketrans(\"\", \"\", string.punctuation)\r\n        c_txt = \"\"\r\n        for line in self.txt.lower().splitlines():\r\n            c_txt += line.translate(trans) + \" \"\r\n\r\n        if self.extra:\r\n            for char in self.extra:\r\n                c_txt = c_txt.replace(char, \" \")\r\n\r\n        return c_txt\r\n\r\n    @property\r\n    def metrics(self) -> List[Tuple[str, int]]:\r\n        \"\"\"Generates word count metrics.\r\n\r\n        * Using the cleaned up corpus, count up how many times each word is used\r\n        * Exclude stop words using STOPWORDS\r\n        * Use count to return the requested amount of the top words, defaults to 5\r\n\r\n        :return: List of tuples, i.e. (\"word\", count)\r\n        \"\"\"\r\n        txt_lst = [w for w in self.cleaned.strip().split() if w not in self.stopwords]\r\n        return Counter(txt_lst).most_common(self.count)\r\n\r\n    @property\r\n    def graph(self) -> None:\r\n        \"\"\"Generates a textual graph of the words\r\n\r\n        * Prints out the words along with a \"tag\" bar graph, defaults to using\r\n          the # character\r\n        * The word is right-aligned and takes up 10 character spaces\r\n        * The tag is repeated the number of counts of the word\r\n\r\n        For example, the top 10 words in the Gettysburgh address would be\r\n        displayed in this manner:\r\n\r\n            nation #####\r\n         dedicated ####\r\n             great ###\r\n            cannot ###\r\n              dead ###\r\n                us ###\r\n             shall ###\r\n            people ###\r\n               new ##\r\n         conceived ##\r\n\r\n        :param metrics: List of tuples with word counts\r\n        :return: None\r\n        \"\"\"\r\n        for metric in self.metrics:\r\n            word, value = metric\r\n            print(f\"{word:>10} {self.tag * value}\")",
            "date": "2022-11-19 22:31:53.948155+00:00",
            "passed": true
        },
        {
            "bite": "Bite 174. String manipulation and metrics",
            "code": "from dataclasses import dataclass, field\r\nfrom typing import List, Set, Tuple\r\nimport re\r\nimport string\r\nfrom collections import Counter\r\n\r\nSTOPWORDS: set = {\r\n    \"she's\", \"wasn\", \"through\", \"won\", \"that'll\", \"his\", \"once\", \"this\",\r\n    \"you\", \"ll\", \"has\", \"because\", \"m\", \"ours\", \"doing\", \"any\", \"aren't\",\r\n    \"they\", \"shouldn't\", \"being\", \"out\", \"is\", \"our\", \"it\", \"don\", \"had\",\r\n    \"nor\", \"your\", \"she\", \"you've\", \"themselves\", \"or\", \"y\", \"needn\", \"on\",\r\n    \"to\", \"at\", \"it's\", \"ve\", \"s\", \"too\", \"up\", \"didn't\", \"during\", \"haven\",\r\n    \"can\", \"haven't\", \"each\", \"couldn\", \"isn't\", \"not\", \"against\", \"where\",\r\n    \"was\", \"aren\", \"all\", \"by\", \"why\", \"hers\", \"theirs\", \"have\", \"as\",\r\n    \"yourself\", \"their\", \"very\", \"who\", \"yourselves\", \"over\", \"and\",\r\n    \"again\", \"do\", \"weren't\", \"which\", \"ma\", \"in\", \"such\", \"herself\",\r\n    \"yours\", \"doesn\", \"if\", \"my\", \"after\", \"into\", \"just\", \"now\", \"isn\",\r\n    \"itself\", \"between\", \"will\", \"other\", \"its\", \"these\", \"should\", \"re\",\r\n    \"below\", \"having\", \"am\", \"both\", \"d\", \"you'll\", \"but\", \"should've\",\r\n    \"won't\", \"himself\", \"shan't\", \"the\", \"me\", \"weren\", \"further\", \"until\",\r\n    \"here\", \"myself\", \"whom\", \"were\", \"hasn\", \"don't\", \"wouldn't\", \"been\",\r\n    \"before\", \"above\", \"he\", \"than\", \"most\", \"shan\", \"them\", \"mustn't\",\r\n    \"couldn't\", \"you'd\", \"for\", \"of\", \"her\", \"those\", \"needn't\", \"you're\",\r\n    \"t\", \"hadn't\", \"down\", \"o\", \"did\", \"about\", \"from\", \"does\", \"wouldn\",\r\n    \"off\", \"then\", \"ain\", \"few\", \"hasn't\", \"some\", \"i\", \"ourselves\", \"an\",\r\n    \"when\", \"are\", \"under\", \"more\", \"with\", \"hadn\", \"what\", \"while\", \"didn\",\r\n    \"doesn't\", \"only\", \"him\", \"mightn\", \"be\", \"mightn't\", \"a\", \"how\", \"no\",\r\n    \"there\", \"that\", \"so\", \"we\", \"same\", \"mustn\", \"wasn't\", \"shouldn\", \"own\",\r\n}\r\nGETTYSBURG: str = \"\"\"Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.\r\n\r\nNow we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battlefield of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this.\r\n\r\nBut, in a larger sense, we cannot dedicate\u2014we cannot consecrate\u2014we cannot hallow\u2014this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us\u2014that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion\u2014that we here highly resolve that these dead shall not have died in vain\u2014that this nation, under God, shall have a new birth of freedom\u2014 and that government of the people, by the people, for the people, shall not perish from the earth.\"\"\"  # noqa E501\r\n\r\n\r\nTAX_SYSTEM_IN_US = \"\"\"Suppose that every day, ten men go out for beer, and the bill for all ten comes to $100.  If they paid their bill the way we pay our taxes (by taxpayer decile), it would go something like this:\r\n\r\nThe first four men (the poorest) would pay nothing.\r\nThe fifth would pay $1.\r\nThe sixth would pay $3.\r\nThe seventh would pay $7.\r\nThe eighth would pay $12.\r\nThe ninth would pay $18.\r\nThe tenth man (the richest) would pay $59.\r\n\r\nSo, that\u2019s what they decided to do.\r\n\r\nThe ten men drank in the bar every day and seemed quite happy with the arrangement, until one day, the owner threw them a curve ball.  \u201cSince you\u2019re all such good customers,\u201d he said, \u201cI\u2019m going to reduce the cost of your daily beer by $20.\u201d  Drinks for the ten men would now cost just $80.\r\n\r\nThe group still wanted to pay their bill the way we pay our taxes.  So the first four men were unaffected. They would still drink for free.  But what about the other six?  How could they divide up the $20 windfall so that everyone would get his fair share?\r\n\r\nThe bar owner suggested that it would be fair to reduce each man\u2019s bill by a higher percentage the poorer he was, to follow the principle of the tax system they had been using, and he proceeded to suggest the new lower amounts each should now pay.\r\n\r\nAnd so the fifth man, like the first four, now paid nothing (a 100% saving).\r\nThe sixth now paid $2 instead of $3 (a 33% saving).\r\nThe seventh now paid $5 instead of $7 (a 29% saving).\r\nThe eighth now paid $9 instead of $12 (a 25% saving).\r\nThe ninth now paid $14 instead of $18 (a 22% saving).\r\nThe tenth now paid $50 instead of $59 (a 15% saving).\r\n\r\nThe first four continued to drink for free, and the latter six were all better off than before.  But, once outside the bar, the men began to compare their savings.\r\n\r\n\u201cI only got a dollar out of the $20 saving,\u201d declared the fifth man.  He pointed to the tenth man, \u201cBut he got $9!\u201d\r\n\r\n\u201cYeah, that\u2019s right,\u201d exclaimed the sixth man.  \u201cI only saved a dollar, too. It\u2019s unfair that he saved nine times more than me!\u201d\r\n\r\n\u201cThat\u2019s true!\u201d shouted the seventh man.  \u201cWhy should he get $9 back, when I got only $2?  The wealthy get all the breaks!\u201d\r\n\r\n\u201cWait a minute,\u201d yelled the first four men in unison, \u201cwe didn\u2019t get anything at all.  This new tax system exploits the poor!\u201d\r\n\r\nThe nine men surrounded the tenth and beat him up.\r\n\r\nThe next day, the tenth man didn\u2019t show up, so the other nine sat down and had their beers without him.  But when it came time to pay the bill, they discovered something important: They didn\u2019t have enough money between all of them for even half of the bill!\r\n\r\nAnd that is how our tax system works.  The people who already pay the highest taxes will naturally get the most benefit from a tax reduction.  Tax them too much, attack them for being wealthy, and they just may not show up anymore.  In fact, they might start drinking overseas, where the atmosphere is friendlier.\"\"\"\r\n\r\n\r\n\r\n@dataclass\r\nclass Corpora:\r\n    \"\"\"Add the initial variables along with creating any methods that\r\n    will get this working as described in the bite's description.\r\n\r\n    * txt\r\n    * count\r\n    * tag\r\n    * extra\r\n    * stopwords\r\n    \"\"\"\r\n    \r\n    def __init__(self, txt, tag = '#', count = 5, extra = [], stopwords = STOPWORDS):\r\n    \r\n        self.txt = txt\r\n        self.count = count\r\n        self.tag = tag\r\n        self.extra = extra\r\n        self.stopwords = stopwords\r\n    \r\n\r\n    @property\r\n    def cleaned(self) -> str:\r\n        \"\"\"Takes a corpus and cleans it up.\r\n\r\n        * All text is made lowercase\r\n        * All punctuation is removed\r\n        * If a list of extra characters were given, remove those too\r\n\r\n        :param txt: Corpus of text\r\n        :return: cleaned up corpus\r\n        \"\"\"\r\n\r\n        # lowercase\r\n        result = \"\".join([c.lower() for c in self.txt])\r\n        # replace punctuation\r\n        result = re.sub('\u2014', ' ', result)    \r\n        result = re.sub('[^a-z0-9\\s]', '', result)\r\n        # replace newlines with spaces\r\n        result = result.replace('\\n', ' ')\r\n        # remove extra substrings\r\n        for substring in self.extra:\r\n            result= result.replace(substring, ' ')\r\n\r\n        return result\r\n\r\n    @property\r\n    def metrics(self) -> List[Tuple[str, int]]:\r\n        \"\"\"Generates word count metrics.\r\n\r\n        * Using the cleaned up corpus, count up how many times each word is used\r\n        * Exclude stop words using STOPWORDS\r\n        * Use count to return the requested amount of the top words, defaults to 5\r\n\r\n        :return: List of tuples, i.e. (\"word\", count)\r\n        \"\"\"\r\n        return Counter([word for word in self.cleaned.split() if word not in self.stopwords]).most_common(self.count)\r\n\r\n    @property\r\n    def graph(self) -> None:\r\n        \"\"\"Generates a textual graph of the words\r\n\r\n        * Prints out the words along with a \"tag\" bar graph, defaults to using\r\n          the # character\r\n        * The word is right-aligned and takes up 10 character spaces\r\n        * The tag is repeated the number of counts of the word\r\n\r\n        For example, the top 10 words in the Gettysburg address would be\r\n        displayed in this manner:\r\n\r\n            nation #####\r\n         dedicated ####\r\n             great ###\r\n            cannot ###\r\n              dead ###\r\n                us ###\r\n             shall ###\r\n            people ###\r\n               new ##\r\n         conceived ##\r\n\r\n        :param metrics: List of tuples with word counts\r\n        :return: None\r\n        \"\"\"\r\n        for word, count in self.metrics:\r\n            print(f'{word: >10} {self.tag*count}')\r\n\r\n    \r\ng=Corpora(GETTYSBURG, count=10)  # , extra=['man', 'men'])\r\nprint(g.cleaned)\r\nprint(len(GETTYSBURG))\r\nprint(len(g.cleaned))\r\ng.graph\r\n\r\n",
            "date": "2022-11-19 22:28:48.044310+00:00",
            "passed": false
        },
        {
            "bite": "Bite 174. String manipulation and metrics",
            "code": "from dataclasses import dataclass, field\r\nfrom typing import List, Set, Tuple\r\nimport re\r\nimport string\r\nfrom collections import Counter\r\n\r\nSTOPWORDS: set = {\r\n    \"she's\", \"wasn\", \"through\", \"won\", \"that'll\", \"his\", \"once\", \"this\",\r\n    \"you\", \"ll\", \"has\", \"because\", \"m\", \"ours\", \"doing\", \"any\", \"aren't\",\r\n    \"they\", \"shouldn't\", \"being\", \"out\", \"is\", \"our\", \"it\", \"don\", \"had\",\r\n    \"nor\", \"your\", \"she\", \"you've\", \"themselves\", \"or\", \"y\", \"needn\", \"on\",\r\n    \"to\", \"at\", \"it's\", \"ve\", \"s\", \"too\", \"up\", \"didn't\", \"during\", \"haven\",\r\n    \"can\", \"haven't\", \"each\", \"couldn\", \"isn't\", \"not\", \"against\", \"where\",\r\n    \"was\", \"aren\", \"all\", \"by\", \"why\", \"hers\", \"theirs\", \"have\", \"as\",\r\n    \"yourself\", \"their\", \"very\", \"who\", \"yourselves\", \"over\", \"and\",\r\n    \"again\", \"do\", \"weren't\", \"which\", \"ma\", \"in\", \"such\", \"herself\",\r\n    \"yours\", \"doesn\", \"if\", \"my\", \"after\", \"into\", \"just\", \"now\", \"isn\",\r\n    \"itself\", \"between\", \"will\", \"other\", \"its\", \"these\", \"should\", \"re\",\r\n    \"below\", \"having\", \"am\", \"both\", \"d\", \"you'll\", \"but\", \"should've\",\r\n    \"won't\", \"himself\", \"shan't\", \"the\", \"me\", \"weren\", \"further\", \"until\",\r\n    \"here\", \"myself\", \"whom\", \"were\", \"hasn\", \"don't\", \"wouldn't\", \"been\",\r\n    \"before\", \"above\", \"he\", \"than\", \"most\", \"shan\", \"them\", \"mustn't\",\r\n    \"couldn't\", \"you'd\", \"for\", \"of\", \"her\", \"those\", \"needn't\", \"you're\",\r\n    \"t\", \"hadn't\", \"down\", \"o\", \"did\", \"about\", \"from\", \"does\", \"wouldn\",\r\n    \"off\", \"then\", \"ain\", \"few\", \"hasn't\", \"some\", \"i\", \"ourselves\", \"an\",\r\n    \"when\", \"are\", \"under\", \"more\", \"with\", \"hadn\", \"what\", \"while\", \"didn\",\r\n    \"doesn't\", \"only\", \"him\", \"mightn\", \"be\", \"mightn't\", \"a\", \"how\", \"no\",\r\n    \"there\", \"that\", \"so\", \"we\", \"same\", \"mustn\", \"wasn't\", \"shouldn\", \"own\",\r\n}\r\nGETTYSBURG: str = \"\"\"Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.\r\n\r\nNow we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battlefield of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this.\r\n\r\nBut, in a larger sense, we cannot dedicate\u2014we cannot consecrate\u2014we cannot hallow\u2014this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us\u2014that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion\u2014that we here highly resolve that these dead shall not have died in vain\u2014that this nation, under God, shall have a new birth of freedom\u2014 and that government of the people, by the people, for the people, shall not perish from the earth.\"\"\"  # noqa E501\r\n\r\n\r\nTAX_SYSTEM_IN_US = \"\"\"Suppose that every day, ten men go out for beer, and the bill for all ten comes to $100.  If they paid their bill the way we pay our taxes (by taxpayer decile), it would go something like this:\r\n\r\nThe first four men (the poorest) would pay nothing.\r\nThe fifth would pay $1.\r\nThe sixth would pay $3.\r\nThe seventh would pay $7.\r\nThe eighth would pay $12.\r\nThe ninth would pay $18.\r\nThe tenth man (the richest) would pay $59.\r\n\r\nSo, that\u2019s what they decided to do.\r\n\r\nThe ten men drank in the bar every day and seemed quite happy with the arrangement, until one day, the owner threw them a curve ball.  \u201cSince you\u2019re all such good customers,\u201d he said, \u201cI\u2019m going to reduce the cost of your daily beer by $20.\u201d  Drinks for the ten men would now cost just $80.\r\n\r\nThe group still wanted to pay their bill the way we pay our taxes.  So the first four men were unaffected. They would still drink for free.  But what about the other six?  How could they divide up the $20 windfall so that everyone would get his fair share?\r\n\r\nThe bar owner suggested that it would be fair to reduce each man\u2019s bill by a higher percentage the poorer he was, to follow the principle of the tax system they had been using, and he proceeded to suggest the new lower amounts each should now pay.\r\n\r\nAnd so the fifth man, like the first four, now paid nothing (a 100% saving).\r\nThe sixth now paid $2 instead of $3 (a 33% saving).\r\nThe seventh now paid $5 instead of $7 (a 29% saving).\r\nThe eighth now paid $9 instead of $12 (a 25% saving).\r\nThe ninth now paid $14 instead of $18 (a 22% saving).\r\nThe tenth now paid $50 instead of $59 (a 15% saving).\r\n\r\nThe first four continued to drink for free, and the latter six were all better off than before.  But, once outside the bar, the men began to compare their savings.\r\n\r\n\u201cI only got a dollar out of the $20 saving,\u201d declared the fifth man.  He pointed to the tenth man, \u201cBut he got $9!\u201d\r\n\r\n\u201cYeah, that\u2019s right,\u201d exclaimed the sixth man.  \u201cI only saved a dollar, too. It\u2019s unfair that he saved nine times more than me!\u201d\r\n\r\n\u201cThat\u2019s true!\u201d shouted the seventh man.  \u201cWhy should he get $9 back, when I got only $2?  The wealthy get all the breaks!\u201d\r\n\r\n\u201cWait a minute,\u201d yelled the first four men in unison, \u201cwe didn\u2019t get anything at all.  This new tax system exploits the poor!\u201d\r\n\r\nThe nine men surrounded the tenth and beat him up.\r\n\r\nThe next day, the tenth man didn\u2019t show up, so the other nine sat down and had their beers without him.  But when it came time to pay the bill, they discovered something important: They didn\u2019t have enough money between all of them for even half of the bill!\r\n\r\nAnd that is how our tax system works.  The people who already pay the highest taxes will naturally get the most benefit from a tax reduction.  Tax them too much, attack them for being wealthy, and they just may not show up anymore.  In fact, they might start drinking overseas, where the atmosphere is friendlier.\"\"\"\r\n\r\n\r\n\r\n@dataclass\r\nclass Corpora:\r\n    \"\"\"Add the initial variables along with creating any methods that\r\n    will get this working as described in the bite's description.\r\n\r\n    * txt\r\n    * count\r\n    * tag\r\n    * extra\r\n    * stopwords\r\n    \"\"\"\r\n    \r\n    def __init__(self, txt, tag = '#', count = 5, extra = [], stopwords = STOPWORDS):\r\n    \r\n        self.txt = txt\r\n        self.count = count\r\n        self.tag = tag\r\n        self.extra = extra\r\n        self.stopwords = stopwords\r\n    \r\n\r\n    @property\r\n    def cleaned(self) -> str:\r\n        \"\"\"Takes a corpus and cleans it up.\r\n\r\n        * All text is made lowercase\r\n        * All punctuation is removed\r\n        * If a list of extra characters were given, remove those too\r\n\r\n        :param txt: Corpus of text\r\n        :return: cleaned up corpus\r\n        \"\"\"\r\n        NOT_PUNCTUATION = string.ascii_lowercase +'0123456789'+'\\n'\r\n        # lowercase and replace punctuation by spaces\r\n        result = \"\".join([c.lower() if c.lower() in NOT_PUNCTUATION else \" \" for c in self.txt])\r\n        # remove extra substrings\r\n        for substring in self.extra:\r\n            result= result.replace(substring, ' ')\r\n        # remove duplicated spaces\r\n        result = re.sub(' +', ' ', result)\r\n        # replace newlines with spaces\r\n        result = result.replace('\\n', ' ')\r\n        return result.strip()\r\n\r\n    @property\r\n    def metrics(self) -> List[Tuple[str, int]]:\r\n        \"\"\"Generates word count metrics.\r\n\r\n        * Using the cleaned up corpus, count up how many times each word is used\r\n        * Exclude stop words using STOPWORDS\r\n        * Use count to return the requested amount of the top words, defaults to 5\r\n\r\n        :return: List of tuples, i.e. (\"word\", count)\r\n        \"\"\"\r\n        return Counter([word for word in self.cleaned.split() if word not in self.stopwords]).most_common(self.count)\r\n\r\n    @property\r\n    def graph(self) -> None:\r\n        \"\"\"Generates a textual graph of the words\r\n\r\n        * Prints out the words along with a \"tag\" bar graph, defaults to using\r\n          the # character\r\n        * The word is right-aligned and takes up 10 character spaces\r\n        * The tag is repeated the number of counts of the word\r\n\r\n        For example, the top 10 words in the Gettysburg address would be\r\n        displayed in this manner:\r\n\r\n            nation #####\r\n         dedicated ####\r\n             great ###\r\n            cannot ###\r\n              dead ###\r\n                us ###\r\n             shall ###\r\n            people ###\r\n               new ##\r\n         conceived ##\r\n\r\n        :param metrics: List of tuples with word counts\r\n        :return: None\r\n        \"\"\"\r\n        for word, count in self.metrics:\r\n            print(f'{word: >10} {self.tag*count}')\r\n\r\n    \r\ng=Corpora(GETTYSBURG, count=10)  # , extra=['man', 'men'])\r\nprint(g.cleaned)\r\nprint(len(GETTYSBURG))\r\nprint(len(g.cleaned))\r\ng.graph\r\n\r\n",
            "date": "2022-11-19 21:56:31.820591+00:00",
            "passed": false
        },
        {
            "bite": "Bite 174. String manipulation and metrics",
            "code": "from dataclasses import dataclass, field\r\nfrom typing import List, Set, Tuple\r\nimport re\r\nimport string\r\nfrom collections import Counter\r\n\r\nSTOPWORDS: set = {\r\n    \"she's\", \"wasn\", \"through\", \"won\", \"that'll\", \"his\", \"once\", \"this\",\r\n    \"you\", \"ll\", \"has\", \"because\", \"m\", \"ours\", \"doing\", \"any\", \"aren't\",\r\n    \"they\", \"shouldn't\", \"being\", \"out\", \"is\", \"our\", \"it\", \"don\", \"had\",\r\n    \"nor\", \"your\", \"she\", \"you've\", \"themselves\", \"or\", \"y\", \"needn\", \"on\",\r\n    \"to\", \"at\", \"it's\", \"ve\", \"s\", \"too\", \"up\", \"didn't\", \"during\", \"haven\",\r\n    \"can\", \"haven't\", \"each\", \"couldn\", \"isn't\", \"not\", \"against\", \"where\",\r\n    \"was\", \"aren\", \"all\", \"by\", \"why\", \"hers\", \"theirs\", \"have\", \"as\",\r\n    \"yourself\", \"their\", \"very\", \"who\", \"yourselves\", \"over\", \"and\",\r\n    \"again\", \"do\", \"weren't\", \"which\", \"ma\", \"in\", \"such\", \"herself\",\r\n    \"yours\", \"doesn\", \"if\", \"my\", \"after\", \"into\", \"just\", \"now\", \"isn\",\r\n    \"itself\", \"between\", \"will\", \"other\", \"its\", \"these\", \"should\", \"re\",\r\n    \"below\", \"having\", \"am\", \"both\", \"d\", \"you'll\", \"but\", \"should've\",\r\n    \"won't\", \"himself\", \"shan't\", \"the\", \"me\", \"weren\", \"further\", \"until\",\r\n    \"here\", \"myself\", \"whom\", \"were\", \"hasn\", \"don't\", \"wouldn't\", \"been\",\r\n    \"before\", \"above\", \"he\", \"than\", \"most\", \"shan\", \"them\", \"mustn't\",\r\n    \"couldn't\", \"you'd\", \"for\", \"of\", \"her\", \"those\", \"needn't\", \"you're\",\r\n    \"t\", \"hadn't\", \"down\", \"o\", \"did\", \"about\", \"from\", \"does\", \"wouldn\",\r\n    \"off\", \"then\", \"ain\", \"few\", \"hasn't\", \"some\", \"i\", \"ourselves\", \"an\",\r\n    \"when\", \"are\", \"under\", \"more\", \"with\", \"hadn\", \"what\", \"while\", \"didn\",\r\n    \"doesn't\", \"only\", \"him\", \"mightn\", \"be\", \"mightn't\", \"a\", \"how\", \"no\",\r\n    \"there\", \"that\", \"so\", \"we\", \"same\", \"mustn\", \"wasn't\", \"shouldn\", \"own\",\r\n}\r\nGETTYSBURG: str = \"\"\"Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.\r\n\r\nNow we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battlefield of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this.\r\n\r\nBut, in a larger sense, we cannot dedicate\u2014we cannot consecrate\u2014we cannot hallow\u2014this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us\u2014that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion\u2014that we here highly resolve that these dead shall not have died in vain\u2014that this nation, under God, shall have a new birth of freedom\u2014 and that government of the people, by the people, for the people, shall not perish from the earth.\"\"\"  # noqa E501\r\n\r\n\r\nTAX_SYSTEM_IN_US = \"\"\"Suppose that every day, ten men go out for beer, and the bill for all ten comes to $100.  If they paid their bill the way we pay our taxes (by taxpayer decile), it would go something like this:\r\n\r\nThe first four men (the poorest) would pay nothing.\r\nThe fifth would pay $1.\r\nThe sixth would pay $3.\r\nThe seventh would pay $7.\r\nThe eighth would pay $12.\r\nThe ninth would pay $18.\r\nThe tenth man (the richest) would pay $59.\r\n\r\nSo, that\u2019s what they decided to do.\r\n\r\nThe ten men drank in the bar every day and seemed quite happy with the arrangement, until one day, the owner threw them a curve ball.  \u201cSince you\u2019re all such good customers,\u201d he said, \u201cI\u2019m going to reduce the cost of your daily beer by $20.\u201d  Drinks for the ten men would now cost just $80.\r\n\r\nThe group still wanted to pay their bill the way we pay our taxes.  So the first four men were unaffected. They would still drink for free.  But what about the other six?  How could they divide up the $20 windfall so that everyone would get his fair share?\r\n\r\nThe bar owner suggested that it would be fair to reduce each man\u2019s bill by a higher percentage the poorer he was, to follow the principle of the tax system they had been using, and he proceeded to suggest the new lower amounts each should now pay.\r\n\r\nAnd so the fifth man, like the first four, now paid nothing (a 100% saving).\r\nThe sixth now paid $2 instead of $3 (a 33% saving).\r\nThe seventh now paid $5 instead of $7 (a 29% saving).\r\nThe eighth now paid $9 instead of $12 (a 25% saving).\r\nThe ninth now paid $14 instead of $18 (a 22% saving).\r\nThe tenth now paid $50 instead of $59 (a 15% saving).\r\n\r\nThe first four continued to drink for free, and the latter six were all better off than before.  But, once outside the bar, the men began to compare their savings.\r\n\r\n\u201cI only got a dollar out of the $20 saving,\u201d declared the fifth man.  He pointed to the tenth man, \u201cBut he got $9!\u201d\r\n\r\n\u201cYeah, that\u2019s right,\u201d exclaimed the sixth man.  \u201cI only saved a dollar, too. It\u2019s unfair that he saved nine times more than me!\u201d\r\n\r\n\u201cThat\u2019s true!\u201d shouted the seventh man.  \u201cWhy should he get $9 back, when I got only $2?  The wealthy get all the breaks!\u201d\r\n\r\n\u201cWait a minute,\u201d yelled the first four men in unison, \u201cwe didn\u2019t get anything at all.  This new tax system exploits the poor!\u201d\r\n\r\nThe nine men surrounded the tenth and beat him up.\r\n\r\nThe next day, the tenth man didn\u2019t show up, so the other nine sat down and had their beers without him.  But when it came time to pay the bill, they discovered something important: They didn\u2019t have enough money between all of them for even half of the bill!\r\n\r\nAnd that is how our tax system works.  The people who already pay the highest taxes will naturally get the most benefit from a tax reduction.  Tax them too much, attack them for being wealthy, and they just may not show up anymore.  In fact, they might start drinking overseas, where the atmosphere is friendlier.\"\"\"\r\n\r\n\r\n\r\n@dataclass\r\nclass Corpora:\r\n    \"\"\"Add the initial variables along with creating any methods that\r\n    will get this working as described in the bite's description.\r\n\r\n    * txt\r\n    * count\r\n    * tag\r\n    * extra\r\n    * stopwords\r\n    \"\"\"\r\n    \r\n    def __init__(self, txt, tag = '#', count = 5, extra = [], stopwords = STOPWORDS):\r\n    \r\n        self.txt = txt\r\n        self.count = count\r\n        self.tag = tag\r\n        self.extra = extra\r\n        self.stopwords = stopwords\r\n    \r\n\r\n    @property\r\n    def cleaned(self) -> str:\r\n        \"\"\"Takes a corpus and cleans it up.\r\n\r\n        * All text is made lowercase\r\n        * All punctuation is removed\r\n        * If a list of extra characters were given, remove those too\r\n\r\n        :param txt: Corpus of text\r\n        :return: cleaned up corpus\r\n        \"\"\"\r\n        NOT_PUNCTUATION = string.ascii_lowercase +'0123456789'\r\n        # lowercase and replace punctuation by spaces\r\n        result = \"\".join([c.lower() if c.lower() in NOT_PUNCTUATION else \" \" for c in self.txt])\r\n        # replace newlines with spaces\r\n        result = re.sub('\\n', ' ', result)\r\n        # remove extra substrings\r\n        for substring in self.extra:\r\n            result= result.replace(substring, ' ')\r\n        # remove duplicated spaces\r\n        result = re.sub(' +', ' ', result)\r\n        return result\r\n\r\n    @property\r\n    def metrics(self) -> List[Tuple[str, int]]:\r\n        \"\"\"Generates word count metrics.\r\n\r\n        * Using the cleaned up corpus, count up how many times each word is used\r\n        * Exclude stop words using STOPWORDS\r\n        * Use count to return the requested amount of the top words, defaults to 5\r\n\r\n        :return: List of tuples, i.e. (\"word\", count)\r\n        \"\"\"\r\n        return Counter([word for word in self.cleaned.split() if word not in self.stopwords]).most_common(self.count)\r\n\r\n    @property\r\n    def graph(self) -> None:\r\n        \"\"\"Generates a textual graph of the words\r\n\r\n        * Prints out the words along with a \"tag\" bar graph, defaults to using\r\n          the # character\r\n        * The word is right-aligned and takes up 10 character spaces\r\n        * The tag is repeated the number of counts of the word\r\n\r\n        For example, the top 10 words in the Gettysburg address would be\r\n        displayed in this manner:\r\n\r\n            nation #####\r\n         dedicated ####\r\n             great ###\r\n            cannot ###\r\n              dead ###\r\n                us ###\r\n             shall ###\r\n            people ###\r\n               new ##\r\n         conceived ##\r\n\r\n        :param metrics: List of tuples with word counts\r\n        :return: None\r\n        \"\"\"\r\n        for word, count in self.metrics:\r\n            print(f'{word: >10} {self.tag*count}')\r\n\r\n    \r\ng=Corpora(TAX_SYSTEM_IN_US, count=10, extra=['man', 'men'])\r\nprint(g.cleaned)\r\ng.graph\r\n\r\n\"\"\"\r\n        \"       pay #############\",\r\n        \"     would ############\",\r\n        \"       men ########\",\r\n        \"       man ########\",\r\n        \"      paid #######\",\r\n        \"    saving #######\",\r\n        \"      bill ######\",\r\n        \"     first #####\",\r\n        \"      four #####\",\r\n        \"     tenth #####\",\r\n\"\"\"\r\n",
            "date": "2022-11-19 21:44:17.868836+00:00",
            "passed": false
        },
        {
            "bite": "Bite 174. String manipulation and metrics",
            "code": "from dataclasses import dataclass, field\r\nfrom typing import List, Set, Tuple\r\nimport re\r\nimport string\r\nfrom collections import Counter\r\n\r\nSTOPWORDS: set = {\r\n    \"she's\", \"wasn\", \"through\", \"won\", \"that'll\", \"his\", \"once\", \"this\",\r\n    \"you\", \"ll\", \"has\", \"because\", \"m\", \"ours\", \"doing\", \"any\", \"aren't\",\r\n    \"they\", \"shouldn't\", \"being\", \"out\", \"is\", \"our\", \"it\", \"don\", \"had\",\r\n    \"nor\", \"your\", \"she\", \"you've\", \"themselves\", \"or\", \"y\", \"needn\", \"on\",\r\n    \"to\", \"at\", \"it's\", \"ve\", \"s\", \"too\", \"up\", \"didn't\", \"during\", \"haven\",\r\n    \"can\", \"haven't\", \"each\", \"couldn\", \"isn't\", \"not\", \"against\", \"where\",\r\n    \"was\", \"aren\", \"all\", \"by\", \"why\", \"hers\", \"theirs\", \"have\", \"as\",\r\n    \"yourself\", \"their\", \"very\", \"who\", \"yourselves\", \"over\", \"and\",\r\n    \"again\", \"do\", \"weren't\", \"which\", \"ma\", \"in\", \"such\", \"herself\",\r\n    \"yours\", \"doesn\", \"if\", \"my\", \"after\", \"into\", \"just\", \"now\", \"isn\",\r\n    \"itself\", \"between\", \"will\", \"other\", \"its\", \"these\", \"should\", \"re\",\r\n    \"below\", \"having\", \"am\", \"both\", \"d\", \"you'll\", \"but\", \"should've\",\r\n    \"won't\", \"himself\", \"shan't\", \"the\", \"me\", \"weren\", \"further\", \"until\",\r\n    \"here\", \"myself\", \"whom\", \"were\", \"hasn\", \"don't\", \"wouldn't\", \"been\",\r\n    \"before\", \"above\", \"he\", \"than\", \"most\", \"shan\", \"them\", \"mustn't\",\r\n    \"couldn't\", \"you'd\", \"for\", \"of\", \"her\", \"those\", \"needn't\", \"you're\",\r\n    \"t\", \"hadn't\", \"down\", \"o\", \"did\", \"about\", \"from\", \"does\", \"wouldn\",\r\n    \"off\", \"then\", \"ain\", \"few\", \"hasn't\", \"some\", \"i\", \"ourselves\", \"an\",\r\n    \"when\", \"are\", \"under\", \"more\", \"with\", \"hadn\", \"what\", \"while\", \"didn\",\r\n    \"doesn't\", \"only\", \"him\", \"mightn\", \"be\", \"mightn't\", \"a\", \"how\", \"no\",\r\n    \"there\", \"that\", \"so\", \"we\", \"same\", \"mustn\", \"wasn't\", \"shouldn\", \"own\",\r\n}\r\nGETTYSBURG: str = \"\"\"Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.\r\n\r\nNow we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battlefield of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this.\r\n\r\nBut, in a larger sense, we cannot dedicate\u2014we cannot consecrate\u2014we cannot hallow\u2014this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us\u2014that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion\u2014that we here highly resolve that these dead shall not have died in vain\u2014that this nation, under God, shall have a new birth of freedom\u2014 and that government of the people, by the people, for the people, shall not perish from the earth.\"\"\"  # noqa E501\r\n\r\n\r\nTAX_SYSTEM_IN_US = \"\"\"Suppose that every day, ten men go out for beer, and the bill for all ten comes to $100.  If they paid their bill the way we pay our taxes (by taxpayer decile), it would go something like this:\r\n\r\nThe first four men (the poorest) would pay nothing.\r\nThe fifth would pay $1.\r\nThe sixth would pay $3.\r\nThe seventh would pay $7.\r\nThe eighth would pay $12.\r\nThe ninth would pay $18.\r\nThe tenth man (the richest) would pay $59.\r\n\r\nSo, that\u2019s what they decided to do.\r\n\r\nThe ten men drank in the bar every day and seemed quite happy with the arrangement, until one day, the owner threw them a curve ball.  \u201cSince you\u2019re all such good customers,\u201d he said, \u201cI\u2019m going to reduce the cost of your daily beer by $20.\u201d  Drinks for the ten men would now cost just $80.\r\n\r\nThe group still wanted to pay their bill the way we pay our taxes.  So the first four men were unaffected. They would still drink for free.  But what about the other six?  How could they divide up the $20 windfall so that everyone would get his fair share?\r\n\r\nThe bar owner suggested that it would be fair to reduce each man\u2019s bill by a higher percentage the poorer he was, to follow the principle of the tax system they had been using, and he proceeded to suggest the new lower amounts each should now pay.\r\n\r\nAnd so the fifth man, like the first four, now paid nothing (a 100% saving).\r\nThe sixth now paid $2 instead of $3 (a 33% saving).\r\nThe seventh now paid $5 instead of $7 (a 29% saving).\r\nThe eighth now paid $9 instead of $12 (a 25% saving).\r\nThe ninth now paid $14 instead of $18 (a 22% saving).\r\nThe tenth now paid $50 instead of $59 (a 15% saving).\r\n\r\nThe first four continued to drink for free, and the latter six were all better off than before.  But, once outside the bar, the men began to compare their savings.\r\n\r\n\u201cI only got a dollar out of the $20 saving,\u201d declared the fifth man.  He pointed to the tenth man, \u201cBut he got $9!\u201d\r\n\r\n\u201cYeah, that\u2019s right,\u201d exclaimed the sixth man.  \u201cI only saved a dollar, too. It\u2019s unfair that he saved nine times more than me!\u201d\r\n\r\n\u201cThat\u2019s true!\u201d shouted the seventh man.  \u201cWhy should he get $9 back, when I got only $2?  The wealthy get all the breaks!\u201d\r\n\r\n\u201cWait a minute,\u201d yelled the first four men in unison, \u201cwe didn\u2019t get anything at all.  This new tax system exploits the poor!\u201d\r\n\r\nThe nine men surrounded the tenth and beat him up.\r\n\r\nThe next day, the tenth man didn\u2019t show up, so the other nine sat down and had their beers without him.  But when it came time to pay the bill, they discovered something important: They didn\u2019t have enough money between all of them for even half of the bill!\r\n\r\nAnd that is how our tax system works.  The people who already pay the highest taxes will naturally get the most benefit from a tax reduction.  Tax them too much, attack them for being wealthy, and they just may not show up anymore.  In fact, they might start drinking overseas, where the atmosphere is friendlier.\"\"\"\r\n\r\n\r\n\r\n@dataclass\r\nclass Corpora:\r\n    \"\"\"Add the initial variables along with creating any methods that\r\n    will get this working as described in the bite's description.\r\n\r\n    * txt\r\n    * count\r\n    * tag\r\n    * extra\r\n    * stopwords\r\n    \"\"\"\r\n    \r\n    def __init__(self, txt, tag = '#', count = 5, extra = [], stopwords = STOPWORDS):\r\n    \r\n        self.txt = txt\r\n        self.count = count\r\n        self.tag = tag\r\n        self.extra = extra\r\n        self.stopwords = stopwords\r\n    \r\n\r\n    @property\r\n    def cleaned(self) -> str:\r\n        \"\"\"Takes a corpus and cleans it up.\r\n\r\n        * All text is made lowercase\r\n        * All punctuation is removed\r\n        * If a list of extra characters were given, remove those too\r\n\r\n        :param txt: Corpus of text\r\n        :return: cleaned up corpus\r\n        \"\"\"\r\n        NOT_PUNCTUATION = string.ascii_lowercase +'0123456789'\r\n        # lowercase and replace punctuation by spaces\r\n        result = \"\".join([c.lower() if c.lower() in NOT_PUNCTUATION else \" \" for c in self.txt])\r\n        # remove extra substrings\r\n        for substring in self.extra:\r\n            result= result.replace(substring, '')\r\n        # remove duplicated spaces\r\n        result = re.sub(' +', ' ', result)\r\n        # replace newlines with spaces\r\n        result = re.sub('\\n', ' ', result)\r\n        return result\r\n\r\n    @property\r\n    def metrics(self) -> List[Tuple[str, int]]:\r\n        \"\"\"Generates word count metrics.\r\n\r\n        * Using the cleaned up corpus, count up how many times each word is used\r\n        * Exclude stop words using STOPWORDS\r\n        * Use count to return the requested amount of the top words, defaults to 5\r\n\r\n        :return: List of tuples, i.e. (\"word\", count)\r\n        \"\"\"\r\n        return Counter([word for word in self.cleaned.split() if word not in self.stopwords]).most_common(self.count)\r\n\r\n    @property\r\n    def graph(self) -> None:\r\n        \"\"\"Generates a textual graph of the words\r\n\r\n        * Prints out the words along with a \"tag\" bar graph, defaults to using\r\n          the # character\r\n        * The word is right-aligned and takes up 10 character spaces\r\n        * The tag is repeated the number of counts of the word\r\n\r\n        For example, the top 10 words in the Gettysburg address would be\r\n        displayed in this manner:\r\n\r\n            nation #####\r\n         dedicated ####\r\n             great ###\r\n            cannot ###\r\n              dead ###\r\n                us ###\r\n             shall ###\r\n            people ###\r\n               new ##\r\n         conceived ##\r\n\r\n        :param metrics: List of tuples with word counts\r\n        :return: None\r\n        \"\"\"\r\n        for word, count in self.metrics:\r\n            print(f'{word: >10} {self.tag*count}')\r\n\r\n    \r\ng=Corpora(TAX_SYSTEM_IN_US, count=10, extra=['man', 'men'])\r\nprint(g.cleaned)\r\ng.graph\r\n\r\n\"\"\"\r\n        \"       pay #############\",\r\n        \"     would ############\",\r\n        \"       men ########\",\r\n        \"       man ########\",\r\n        \"      paid #######\",\r\n        \"    saving #######\",\r\n        \"      bill ######\",\r\n        \"     first #####\",\r\n        \"      four #####\",\r\n        \"     tenth #####\",\r\n\"\"\"\r\n",
            "date": "2022-11-19 21:41:29.686659+00:00",
            "passed": false
        },
        {
            "bite": "Bite 178. Parse PyBites blog git commit log",
            "code": "from collections import Counter, defaultdict\r\nimport os\r\nfrom typing import Tuple\r\nfrom urllib.request import urlretrieve\r\nimport re\r\n\r\nfrom dateutil.parser import parse\r\n\r\ncommits = os.path.join(os.getenv(\"TMP\", \"/tmp\"), 'commits')\r\nurlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/git_log_stat.out',\r\n    commits\r\n)\r\n\r\n# you can use this constant as key to the yyyymm:count dict\r\nYEAR_MONTH = '{y}-{m:02d}'\r\n\r\n\r\ndef get_min_max_amount_of_commits(\r\n    commit_log: str = commits,\r\n    year: int = None\r\n) -> Tuple[str, str]:\r\n    \"\"\"\r\n    Calculate the amount of inserts / deletes per month from the\r\n    provided commit log.\r\n\r\n    Takes optional year arg, if provided only look at lines for\r\n    that year, if not, use the entire file.\r\n\r\n    Returns a tuple of (least_active_month, most_active_month)\r\n    \"\"\"\r\n    \r\n    result=defaultdict(int)\r\n    \r\n    with open(commit_log) as f:\r\n        lines=f.readlines()\r\n    \r\n    for line in lines:\r\n\r\n        date, changes = line.split('|')\r\n\r\n        date=parse(date.strip(),ignoretz=True, fuzzy_with_tokens=True)[0]\r\n        if year and year!=date.year:\r\n            continue\r\n\r\n        key=date.strftime(\"%Y-%m\")\r\n\r\n        insertions = re.findall('([0-9]+) insertion',changes) or [0]\r\n        deletions = re.findall('([0-9]+) deletion',changes) or [0]\r\n        count=int(deletions[0])+int(insertions[0])\r\n\r\n        result[key]+=count\r\n        \r\n    sorted_count = Counter(result).most_common()\r\n\r\n    return sorted_count[-1][0],sorted_count[0][0]\r\n    \r\n\r\nprint(get_min_max_amount_of_commits(commits,2019))\r\n    ",
            "date": "2022-11-19 13:21:34.406673+00:00",
            "passed": true
        },
        {
            "bite": "Bite 178. Parse PyBites blog git commit log",
            "code": "from collections import Counter, defaultdict\r\nimport os\r\nfrom typing import Tuple\r\nfrom urllib.request import urlretrieve\r\nimport re\r\n\r\nfrom dateutil.parser import parse\r\n\r\ncommits = os.path.join(os.getenv(\"TMP\", \"/tmp\"), 'commits')\r\nurlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/git_log_stat.out',\r\n    commits\r\n)\r\n\r\n# you can use this constant as key to the yyyymm:count dict\r\nYEAR_MONTH = '{y}-{m:02d}'\r\n\r\n\r\ndef get_min_max_amount_of_commits(\r\n    commit_log: str = commits,\r\n    year: int = None\r\n) -> Tuple[str, str]:\r\n    \"\"\"\r\n    Calculate the amount of inserts / deletes per month from the\r\n    provided commit log.\r\n\r\n    Takes optional year arg, if provided only look at lines for\r\n    that year, if not, use the entire file.\r\n\r\n    Returns a tuple of (least_active_month, most_active_month)\r\n    \"\"\"\r\n    \r\n    result=defaultdict(int)\r\n    \r\n    with open(commit_log) as f:\r\n        lines=f.readlines()\r\n    \r\n    for line in lines:\r\n        \"\"\"\r\n        print(line)\r\n        \"\"\"\r\n        date, changes = line.split('|')\r\n\r\n        date=parse(date.strip(),ignoretz=True, fuzzy_with_tokens=True)[0]\r\n        \r\n        if year and year!=date.year:\r\n            continue\r\n        key=date.strftime(\"%Y-%m\")\r\n\r\n        insertions = re.findall('([0-9]+) insertion',changes) or [0]\r\n        deletions = re.findall('([0-9]+) deletion',changes) or [0]\r\n        \"\"\"\r\n        print(f'{date.year=} {date.month=} {insertions=} {deletions=}')\r\n        \"\"\"\r\n        count=int(deletions[0])+int(insertions[0])\r\n\r\n        result[key]+=count\r\n        \r\n        \"\"\"\r\n        print(f'{key=} {count=}')\r\n        \"\"\"\r\n        \r\n    sorted_count = Counter(result).most_common()\r\n    \"\"\"\r\n    print(sorted_count)\r\n    \"\"\"\r\n    return sorted_count[-1][0],sorted_count[0][0]\r\n    \r\nprint(get_min_max_amount_of_commits(commits,2019))\r\n    ",
            "date": "2022-11-19 13:19:38.069161+00:00",
            "passed": true
        },
        {
            "bite": "Bite 148. Print Car Data Grouped by Manufacturer",
            "code": "from itertools import groupby\r\n\r\ncars = [\r\n    # need mock data? -> https://www.mockaroo.com == awesome\r\n    ('Mercedes-Benz', '300D'), ('Mercedes-Benz', '600SEL'),\r\n    ('Toyota', 'Avalon'), ('Ford', 'Bronco'),\r\n    ('Chevrolet', 'Cavalier'), ('Chevrolet', 'Corvette'),\r\n    ('Mercedes-Benz', 'E-Class'), ('Hyundai', 'Elantra'),\r\n    ('Volkswagen', 'GTI'), ('Toyota', 'Highlander'),\r\n    ('Chevrolet', 'Impala'), ('Nissan', 'Maxima'),\r\n    ('Ford', 'Mustang'), ('Kia', 'Optima'),\r\n    ('Volkswagen', 'Passat'), ('Nissan', 'Pathfinder'),\r\n    ('Volkswagen', 'Routan'), ('Hyundai', 'Sonata'),\r\n    ('Kia', 'Sorento'), ('Kia', 'Sportage'),\r\n    ('Ford', 'Taurus'), ('Nissan', 'Titan'),\r\n    ('Toyota', 'Tundra'), ('Hyundai', 'Veracruz'),\r\n]\r\n\r\n\r\ndef group_cars_by_manufacturer(cars):\r\n    \"\"\"Iterate though the list of (manufacturer, model) tuples\r\n       of the cars list defined above and generate the output as described\r\n       in the Bite description (see the tests for the full output).\r\n       \r\n       No return here, just print to the console. We use pytest > capfd to\r\n       validate your output :)\r\n    \"\"\"\r\n    for key, group in groupby(sorted(cars), lambda x: x[0]):\r\n        print(key.upper())\r\n        for car in group:\r\n            print(f\"- {car[1]}\")\r\n        print(\"\")        \r\n\r\ngroup_cars_by_manufacturer(cars)",
            "date": "2022-11-19 12:16:45.376928+00:00",
            "passed": true
        },
        {
            "bite": "Bite 148. Print Car Data Grouped by Manufacturer",
            "code": "from itertools import groupby\r\n\r\ncars = [\r\n    # need mock data? -> https://www.mockaroo.com == awesome\r\n    ('Mercedes-Benz', '300D'), ('Mercedes-Benz', '600SEL'),\r\n    ('Toyota', 'Avalon'), ('Ford', 'Bronco'),\r\n    ('Chevrolet', 'Cavalier'), ('Chevrolet', 'Corvette'),\r\n    ('Mercedes-Benz', 'E-Class'), ('Hyundai', 'Elantra'),\r\n    ('Volkswagen', 'GTI'), ('Toyota', 'Highlander'),\r\n    ('Chevrolet', 'Impala'), ('Nissan', 'Maxima'),\r\n    ('Ford', 'Mustang'), ('Kia', 'Optima'),\r\n    ('Volkswagen', 'Passat'), ('Nissan', 'Pathfinder'),\r\n    ('Volkswagen', 'Routan'), ('Hyundai', 'Sonata'),\r\n    ('Kia', 'Sorento'), ('Kia', 'Sportage'),\r\n    ('Ford', 'Taurus'), ('Nissan', 'Titan'),\r\n    ('Toyota', 'Tundra'), ('Hyundai', 'Veracruz'),\r\n]\r\n\r\n\r\ndef group_cars_by_manufacturer(cars):\r\n    \"\"\"Iterate though the list of (manufacturer, model) tuples\r\n       of the cars list defined above and generate the output as described\r\n       in the Bite description (see the tests for the full output).\r\n       \r\n       No return here, just print to the console. We use pytest > capfd to\r\n       validate your output :)\r\n    \"\"\"\r\n    for key, group in groupby(sorted(cars), lambda x: x[0]):\r\n        print(key.upper())\r\n        for car in group:\r\n            print(f\" - {car[1]}\")\r\n        print(\"\")        \r\n\r\ngroup_cars_by_manufacturer(cars)",
            "date": "2022-11-19 12:16:12.452925+00:00",
            "passed": false
        },
        {
            "bite": "Bite 289. Round to next number",
            "code": "from math import ceil\r\n\r\ndef round_to_next(number: int, multiple: int):\r\n    return ceil(number/multiple)*multiple\r\n    \r\n\r\nnums = [0,2,5,42,-6,-6]\r\nmults = [5,5,5,5,-10,-10]\r\n\r\nfor num,mult in zip(nums,mults):\r\n    print(f'{num=} -> {mult=} = {round_to_next(num,mult)}')",
            "date": "2022-11-19 12:04:00.938996+00:00",
            "passed": true
        },
        {
            "bite": "Bite 63. Use an infinite iterator to simulate a traffic light",
            "code": "from collections import namedtuple\r\nfrom itertools import cycle, islice\r\nfrom time import sleep\r\n\r\nState = namedtuple('State', 'color command timeout')\r\n\r\n\r\ndef traffic_light():\r\n    \"\"\"Returns an itertools.cycle iterator that\r\n       when iterated over returns State namedtuples\r\n       as shown in the Bite's description\"\"\"\r\n    states = [\r\n                State(color='red', command='Stop', timeout=2),\r\n                State(color='green', command='Go', timeout=2),\r\n                State(color='amber', command='Caution', timeout=0.5)\r\n            ]\r\n    for state in cycle(states):\r\n            yield state\r\n\r\n\r\nif __name__ == '__main__':\r\n    # print a sample of 10 states if run as standalone program\r\n    for state in islice(traffic_light(), 10):\r\n        print(f'{state.command}! The light is {state.color}')\r\n        sleep(state.timeout)",
            "date": "2022-11-18 19:25:46.978344+00:00",
            "passed": true
        },
        {
            "bite": "Bite 99. Write an infinite sequence generator",
            "code": "import string\r\nfrom itertools import cycle\r\n\r\ndef sequence_generator():\r\n    lst=zip(enumerate(string.ascii_uppercase,1))\r\n    lst=list(sum(lst,())) # flatten tuples\r\n    lst=list(sum(lst,())) # flatten tuples again\r\n    \r\n    for item in cycle(lst):\r\n        yield item\r\n\r\na=sequence_generator()\r\n\r\nfor _ in range(60):\r\n    print(next(a))\r\n",
            "date": "2022-11-18 19:11:16.064195+00:00",
            "passed": true
        },
        {
            "bite": "Bite 288. Smallest number",
            "code": "from typing import List\r\nfrom itertools import permutations\r\n\r\ndef _int_from_digits(digits:tuple):\r\n    return int(\"\".join(str(n) for n in digits))\r\n    \r\n    \r\ndef minimum_number(digits: List[int]) -> int:\r\n    if digits:\r\n        return min(_int_from_digits(item) for item in list(permutations(set(digits))))\r\n    return 0\r\n    \r\ntest=[1,9,5,9,1]\r\nprint(minimum_number(test))",
            "date": "2022-11-18 12:04:36.755317+00:00",
            "passed": true
        },
        {
            "bite": "Bite 288. Smallest number",
            "code": "from typing import List\r\nfrom itertools import permutations\r\n\r\ndef _int_from_digits(digits:tuple):\r\n    return int(\"\".join(str(n) for n in digits))\r\n    \r\n    \r\ndef minimum_number(digits: List[int]) -> int:\r\n    return min(_int_from_digits(item) for item in list(permutations(set(digits))))\r\n\r\ntest=[1,9,5,9,1]\r\nprint(minimum_number(test))",
            "date": "2022-11-18 12:03:16.388050+00:00",
            "passed": false
        },
        {
            "bite": "Bite 40. Write a binary search algorithm",
            "code": "import string \r\n\r\ndef binary_search(sequence, target):\r\n    start = 0\r\n    end = len(sequence)\r\n\r\n    while start<=end:\r\n        midp=(end+start)//2\r\n\r\n        if sequence[midp]==target: \r\n            return midp\r\n\r\n        if sequence[midp]<target: \r\n            start = midp+1\r\n            continue\r\n\r\n        if sequence[midp]>target: \r\n            end = midp-1\r\n            continue\r\n        \r\n    return None\r\n",
            "date": "2022-11-17 13:00:10.019155+00:00",
            "passed": true
        },
        {
            "bite": "Bite 40. Write a binary search algorithm",
            "code": "import string \r\n\r\ndef binary_search(sequence, target):\r\n    start = 0\r\n    end = len(sequence)\r\n    while start<=end:\r\n        midp=(end+start)//2\r\n\r\n        if sequence[midp]==target: \r\n            return midp\r\n\r\n        if sequence[midp]<target: \r\n            start = midp+1\r\n            continue\r\n\r\n        if sequence[midp]>target: \r\n            end = midp-1\r\n            continue\r\n    return None\r\n",
            "date": "2022-11-17 12:59:13.146791+00:00",
            "passed": true
        },
        {
            "bite": "Bite 40. Write a binary search algorithm",
            "code": "import string \r\n\r\ndef binary_search(sequence, target):\r\n    start = 0\r\n    end = len(sequence)\r\n    while start=end:\r\n        midp=(end+start)//2\r\n\r\n        if sequence[midp]==target: \r\n            return midp\r\n\r\n        if sequence[midp]<target: \r\n            start = midp+1\r\n            continue\r\n\r\n        if sequence[midp]>target: \r\n            end = midp-1\r\n            continue\r\n    return None\r\n",
            "date": "2022-11-17 12:58:57.036180+00:00",
            "passed": false
        },
        {
            "bite": "Bite 40. Write a binary search algorithm",
            "code": "import string \r\n\r\ndef binary_search(sequence, target):\r\n    start = 0\r\n    end = len(sequence)\r\n    while start<end:\r\n        midp=(end+start)//2\r\n\r\n        if sequence[midp]==target: \r\n            return midp\r\n\r\n        if sequence[midp]<target: \r\n            start = midp+1\r\n            continue\r\n\r\n        if sequence[midp]>target: \r\n            end = midp-1\r\n            continue\r\n    return None\r\n",
            "date": "2022-11-17 12:54:53.459104+00:00",
            "passed": false
        },
        {
            "bite": "Bite 40. Write a binary search algorithm",
            "code": "import string \r\n\r\ndef binary_search(sequence, target):\r\n    start = 0\r\n    end = len(sequence)\r\n    while start<end:\r\n        midp=(end+start)//2\r\n\r\n        if sequence[midp]==target: \r\n            return midp\r\n\r\n        if sequence[midp]<target: \r\n            start = midp\r\n            continue\r\n\r\n        if sequence[midp]>target: \r\n            end = midp\r\n            continue\r\n    return None\r\nPRIMES = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]\r\n\r\nprint(binary_search(PRIMES, 59))",
            "date": "2022-11-17 10:54:50.793117+00:00",
            "passed": false
        },
        {
            "bite": "Bite 274. Number conversion problem",
            "code": "def dec_to_base(number, base):\r\n    \"\"\"\r\n    Input: number is the number to be converted\r\n           base is the new base  (eg. 2, 6, or 8)\r\n    Output: the converted number in the new base without the prefix (eg. '0b')\r\n    \"\"\"\r\n    # your code\r\n    if number <= base:\r\n        return int(str(number//base) +str(number%base))\r\n    else:\r\n        return int(str(dec_to_base(number//base, base)) +str(number%base))\r\n\r\nprint(dec_to_base(256,8))",
            "date": "2022-11-17 09:13:36.499608+00:00",
            "passed": true
        },
        {
            "bite": "Bite 274. Number conversion problem",
            "code": "def dec_to_base(number, base):\r\n    \"\"\"\r\n    Input: number is the number to be converted\r\n           base is the new base  (eg. 2, 6, or 8)\r\n    Output: the converted number in the new base without the prefix (eg. '0b')\r\n    \"\"\"\r\n    # your code\r\n    if number <= base:\r\n        return int(str(number//base) +str(number%base))\r\n    else:\r\n        return int(dec_to_base(number//base, base) +str(number%base))\r\n\r\nprint(dec_to_base(256,8))",
            "date": "2022-11-17 09:12:54.046299+00:00",
            "passed": false
        },
        {
            "bite": "Bite 274. Number conversion problem",
            "code": "def dec_to_base(number, base):\r\n    \"\"\"\r\n    Input: number is the number to be converted\r\n           base is the new base  (eg. 2, 6, or 8)\r\n    Output: the converted number in the new base without the prefix (eg. '0b')\r\n    \"\"\"\r\n    # your code\r\n    if number <= base:\r\n        return int(\"\".join(str(item) for item in [number//base, number%base]))\r\n    else:\r\n        return int(\"\".join(str(item) for item in [dec_to_base(number//base, base), number%base]))\r\n\r\nprint(dec_to_base(256,8))",
            "date": "2022-11-17 09:11:34.628940+00:00",
            "passed": true
        },
        {
            "bite": "Bite 274. Number conversion problem",
            "code": "def dec_to_base(number, base):\r\n    \"\"\"\r\n    Input: number is the number to be converted\r\n           base is the new base  (eg. 2, 6, or 8)\r\n    Output: the converted number in the new base without the prefix (eg. '0b')\r\n    \"\"\"\r\n    # your code\r\n    if number <= base:\r\n        return str(number//base) +str(number%base)\r\n    else:\r\n        return dec_to_base(number//base, base) + str(number%base)\r\n\r\nprint(dec_to_base(256,8))",
            "date": "2022-11-17 09:03:59.833127+00:00",
            "passed": false
        },
        {
            "bite": "Bite 314. Print names to columns",
            "code": "from typing import List  # not needed when we upgrade to 3.9\r\n\r\n\r\ndef print_names_to_columns(names: List[str], cols: int = 2) -> None:\r\n    formatted=['| '+'{0: <10}'.format(name) for name in names]\r\n\r\n    n=len(names)\r\n    rows=n//cols\r\n    if rows:\r\n        for i in range(rows):\r\n            print(\"\".join(formatted[i*cols:(i+1)*cols]))\r\n    if n%cols:\r\n        print(\"\".join(formatted[rows*cols:n]))\r\n    \r\n    \r\n\r\nnames = 'Sara Tim Ana Julian Manolo Juan'.split()\r\nprint_names_to_columns(names,4)",
            "date": "2022-11-16 23:01:25.982347+00:00",
            "passed": true
        },
        {
            "bite": "Bite 314. Print names to columns",
            "code": "from typing import List  # not needed when we upgrade to 3.9\r\n\r\n\r\ndef print_names_to_columns(names: List[str], cols: int = 2) -> None:\r\n    n=len(names)\r\n    rows=n//cols\r\n    formatted=['| '+'{0: <10}'.format(name) for name in names]\r\n\r\n    if rows:\r\n        for i in range(rows):\r\n            print(\"\".join(formatted[i*cols:(i+1)*cols]))\r\n    if n%cols:\r\n        print(\"\".join(formatted[rows*cols:n]))\r\n    \r\n    \r\n\r\nnames = 'Sara Tim Ana Julian Manolo Juan'.split()\r\nprint_names_to_columns(names,4)",
            "date": "2022-11-16 23:00:47.165067+00:00",
            "passed": true
        },
        {
            "bite": "Bite 314. Print names to columns",
            "code": "from typing import List  # not needed when we upgrade to 3.9\r\n\r\n\r\ndef print_names_to_columns(names: List[str], cols: int = 2) -> None:\r\n    n=len(names)\r\n    formatted=['| '+'{0: <10}'.format(name) for name in names]\r\n\r\n    if n//cols:\r\n        for i in range(n//cols):\r\n            print(\"\".join(formatted[i*cols:(i+1)*cols]))\r\n    if n%cols:\r\n        print(\"\".join(formatted[rows*cols:n]))\r\n    \r\n    \r\n\r\nnames = 'Sara Tim Ana Julian Manolo Juan'.split()\r\nprint_names_to_columns(names,4)",
            "date": "2022-11-16 22:59:46.627177+00:00",
            "passed": false
        },
        {
            "bite": "Bite 363. Movie Theater (Refactoring)",
            "code": "\"\"\"\r\nRefactor the code below. Try go get the functions' bodies\r\nas close to the left side as possible (only one indentation deep).\r\n\"\"\"\r\navailable_movies = {\r\n    \"Tomorrow Never Dies\": {\r\n        \"id\": \"tomorrow_never_dies\",\r\n        \"quality\": \"IMAX\",\r\n        \"genre\": \"Action\",\r\n    },\r\n    \"Robin Hood\": {\"id\": \"robin_hood\", \"quality\": \"regular\", \"genre\": \"Adventure\"},\r\n    \"Pulp Fiction\": {\"id\": \"pulp_fiction\", \"quality\": \"regular\", \"genre\": \"Crime\"},\r\n}\r\n\r\n\r\ndef invoice_to_be_refactored(movie, tickets):\r\n    amount = 0\r\n    movie_in_available_movies = False\r\n    for title in available_movies:\r\n        if title == movie:\r\n            movie_in_available_movies = True\r\n            if tickets != 0:\r\n                if available_movies[movie][\"quality\"] == \"IMAX\":\r\n                    price = 12\r\n                    if tickets >= 5:\r\n                        discount = 10\r\n                    else:\r\n                        discount = 0\r\n                else:\r\n                    price = 10\r\n                    if tickets >= 5:\r\n                        discount = 10\r\n                    else:\r\n                        discount = 0\r\n            else:\r\n                raise ValueError(\"Cannot calculate price for 0 tickets\")\r\n    if movie_in_available_movies is False:\r\n        raise LookupError(\"Movie not available\")\r\n    else:\r\n        total_amount = amount + (tickets * price) - discount\r\n        return total_amount\r\n\r\ndef _price(movie):\r\n    if movie not in available_movies.keys():\r\n        raise LookupError(\"Movie not available\")\r\n    return 12 if available_movies[movie][\"quality\"] == \"IMAX\" else 10\r\n    \r\ndef _discount(tickets):\r\n    if tickets==0:\r\n        raise ValueError(\"Cannot calculate price for 0 tickets\")\r\n    return 10 if tickets >= 5 else 0\r\n    \r\ndef invoice_refactored(movie, tickets):\r\n    \"\"\"\"Refactor the above code getting rid of the arrow shape\"\"\"\r\n    return tickets * _price(movie) - _discount(tickets)\r\n",
            "date": "2022-11-16 22:34:40.231571+00:00",
            "passed": true
        },
        {
            "bite": "Bite 363. Movie Theater (Refactoring)",
            "code": "\"\"\"\r\nRefactor the code below. Try go get the functions' bodies\r\nas close to the left side as possible (only one indentation deep).\r\n\"\"\"\r\navailable_movies = {\r\n    \"Tomorrow Never Dies\": {\r\n        \"id\": \"tomorrow_never_dies\",\r\n        \"quality\": \"IMAX\",\r\n        \"genre\": \"Action\",\r\n    },\r\n    \"Robin Hood\": {\"id\": \"robin_hood\", \"quality\": \"regular\", \"genre\": \"Adventure\"},\r\n    \"Pulp Fiction\": {\"id\": \"pulp_fiction\", \"quality\": \"regular\", \"genre\": \"Crime\"},\r\n}\r\n\r\n\r\ndef invoice_to_be_refactored(movie, tickets):\r\n    amount = 0\r\n    movie_in_available_movies = False\r\n    for title in available_movies:\r\n        if title == movie:\r\n            movie_in_available_movies = True\r\n            if tickets != 0:\r\n                if available_movies[movie][\"quality\"] == \"IMAX\":\r\n                    price = 12\r\n                    if tickets >= 5:\r\n                        discount = 10\r\n                    else:\r\n                        discount = 0\r\n                else:\r\n                    price = 10\r\n                    if tickets >= 5:\r\n                        discount = 10\r\n                    else:\r\n                        discount = 0\r\n            else:\r\n                raise ValueError(\"Cannot calculate price for 0 tickets\")\r\n    if movie_in_available_movies is False:\r\n        raise LookupError(\"Movie not available\")\r\n    else:\r\n        total_amount = amount + (tickets * price) - discount\r\n        return total_amount\r\n\r\ndef _price(movie):\r\n    return 12 if available_movies[movie][\"quality\"] == \"IMAX\" else 10\r\n    \r\ndef _discount(tickets):\r\n    return 10 if tickets >= 5 else 0\r\n    \r\ndef invoice_refactored(movie, tickets):\r\n    \"\"\"\"Refactor the above code getting rid of the arrow shape\"\"\"\r\n    \r\n    if tickets==0:\r\n        raise ValueError(\"Cannot calculate price for 0 tickets\")\r\n    if movie not in available_movies.keys():\r\n        raise LookupError(\"Movie not available\")\r\n\r\n    return tickets * _price(movie) - _discount(tickets)\r\n",
            "date": "2022-11-16 22:33:18.738786+00:00",
            "passed": true
        },
        {
            "bite": "Bite 363. Movie Theater (Refactoring)",
            "code": "\"\"\"\r\nRefactor the code below. Try go get the functions' bodies\r\nas close to the left side as possible (only one indentation deep).\r\n\"\"\"\r\navailable_movies = {\r\n    \"Tomorrow Never Dies\": {\r\n        \"id\": \"tomorrow_never_dies\",\r\n        \"quality\": \"IMAX\",\r\n        \"genre\": \"Action\",\r\n    },\r\n    \"Robin Hood\": {\"id\": \"robin_hood\", \"quality\": \"regular\", \"genre\": \"Adventure\"},\r\n    \"Pulp Fiction\": {\"id\": \"pulp_fiction\", \"quality\": \"regular\", \"genre\": \"Crime\"},\r\n}\r\n\r\n\r\ndef invoice_to_be_refactored(movie, tickets):\r\n    amount = 0\r\n    movie_in_available_movies = False\r\n    for title in available_movies:\r\n        if title == movie:\r\n            movie_in_available_movies = True\r\n            if tickets != 0:\r\n                if available_movies[movie][\"quality\"] == \"IMAX\":\r\n                    price = 12\r\n                    if tickets >= 5:\r\n                        discount = 10\r\n                    else:\r\n                        discount = 0\r\n                else:\r\n                    price = 10\r\n                    if tickets >= 5:\r\n                        discount = 10\r\n                    else:\r\n                        discount = 0\r\n            else:\r\n                raise ValueError(\"Cannot calculate price for 0 tickets\")\r\n    if movie_in_available_movies is False:\r\n        raise LookupError(\"Movie not available\")\r\n    else:\r\n        total_amount = amount + (tickets * price) - discount\r\n        return total_amount\r\n\r\n\r\ndef invoice_refactored(movie, tickets):\r\n    \"\"\"\"Refactor the above code getting rid of the arrow shape\"\"\"\r\n    \r\n    if tickets==0:\r\n        raise ValueError(\"Cannot calculate price for 0 tickets\")\r\n    if movie not in available_movies.keys():\r\n        raise LookupError(\"Movie not available\")\r\n\r\n    discount = 10 if tickets >= 5 else 0\r\n    price = 12 if available_movies[movie][\"quality\"] == \"IMAX\" else 10\r\n\r\n    return tickets * price - discount\r\n",
            "date": "2022-11-16 22:29:02.924831+00:00",
            "passed": true
        },
        {
            "bite": "Bite 363. Movie Theater (Refactoring)",
            "code": "\"\"\"\r\nRefactor the code below. Try go get the functions' bodies\r\nas close to the left side as possible (only one indentation deep).\r\n\"\"\"\r\navailable_movies = {\r\n    \"Tomorrow Never Dies\": {\r\n        \"id\": \"tomorrow_never_dies\",\r\n        \"quality\": \"IMAX\",\r\n        \"genre\": \"Action\",\r\n    },\r\n    \"Robin Hood\": {\"id\": \"robin_hood\", \"quality\": \"regular\", \"genre\": \"Adventure\"},\r\n    \"Pulp Fiction\": {\"id\": \"pulp_fiction\", \"quality\": \"regular\", \"genre\": \"Crime\"},\r\n}\r\n\r\n\r\ndef invoice_to_be_refactored(movie, tickets):\r\n    amount = 0\r\n    movie_in_available_movies = False\r\n    for title in available_movies:\r\n        if title == movie:\r\n            movie_in_available_movies = True\r\n            if tickets != 0:\r\n                if available_movies[movie][\"quality\"] == \"IMAX\":\r\n                    price = 12\r\n                    if tickets >= 5:\r\n                        discount = 10\r\n                    else:\r\n                        discount = 0\r\n                else:\r\n                    price = 10\r\n                    if tickets >= 5:\r\n                        discount = 10\r\n                    else:\r\n                        discount = 0\r\n            else:\r\n                raise ValueError(\"Cannot calculate price for 0 tickets\")\r\n    if movie_in_available_movies is False:\r\n        raise LookupError(\"Movie not available\")\r\n    else:\r\n        total_amount = tickets * price - discount\r\n        return total_amount\r\n\r\n\r\ndef invoice_refactored(movie, tickets):\r\n    \"\"\"\"Refactor the above code getting rid of the arrow shape\"\"\"\r\n    \r\n    if tickets==0:\r\n        raise ValueError(\"Cannot calculate price for 0 tickets\")\r\n    if movie not in available_movies.keys():\r\n        raise LookupError(\"Movie not available\")\r\n\r\n    discount = 10 if tickets >= 5 else 0\r\n    price = 12 if available_movies[movie][\"quality\"] == \"IMAX\" else 10\r\n\r\n    return amount + (tickets * price) - discount\r\n",
            "date": "2022-11-16 22:28:02.312454+00:00",
            "passed": false
        },
        {
            "bite": "Bite 363. Movie Theater (Refactoring)",
            "code": "\"\"\"\r\nRefactor the code below. Try go get the functions' bodies\r\nas close to the left side as possible (only one indentation deep).\r\n\"\"\"\r\navailable_movies = {\r\n    \"Tomorrow Never Dies\": {\r\n        \"id\": \"tomorrow_never_dies\",\r\n        \"quality\": \"IMAX\",\r\n        \"genre\": \"Action\",\r\n    },\r\n    \"Robin Hood\": {\"id\": \"robin_hood\", \"quality\": \"regular\", \"genre\": \"Adventure\"},\r\n    \"Pulp Fiction\": {\"id\": \"pulp_fiction\", \"quality\": \"regular\", \"genre\": \"Crime\"},\r\n}\r\n\r\n\r\ndef invoice_to_be_refactored(movie, tickets):\r\n    amount = 0\r\n    movie_in_available_movies = False\r\n    for title in available_movies:\r\n        if title == movie:\r\n            movie_in_available_movies = True\r\n            if tickets != 0:\r\n                if available_movies[movie][\"quality\"] == \"IMAX\":\r\n                    price = 12\r\n                    if tickets >= 5:\r\n                        discount = 10\r\n                    else:\r\n                        discount = 0\r\n                else:\r\n                    price = 10\r\n                    if tickets >= 5:\r\n                        discount = 10\r\n                    else:\r\n                        discount = 0\r\n            else:\r\n                raise ValueError(\"Cannot calculate price for 0 tickets\")\r\n    if movie_in_available_movies is False:\r\n        raise LookupError(\"Movie not available\")\r\n    else:\r\n        total_amount = amount + (tickets * price) - discount\r\n        return total_amount\r\n\r\n\r\ndef invoice_refactored(movie, tickets):\r\n    \"\"\"\"Refactor the above code getting rid of the arrow shape\"\"\"\r\n    \r\n    if tickets==0:\r\n        raise ValueError(\"Cannot calculate price for 0 tickets\")\r\n    if movie not in available_movies.keys():\r\n        raise LookupError(\"Movie not available\")\r\n\r\n    discount = 10 if tickets >= 5 else 0\r\n    price = 12 if available_movies[movie][\"quality\"] == \"IMAX\" else 10\r\n\r\n    return amount + (tickets * price) - discount\r\n",
            "date": "2022-11-16 22:27:28.134636+00:00",
            "passed": false
        },
        {
            "bite": "Bite 179. Strip comments from Python code",
            "code": "SINGLE_LINE = '#'\r\nINLINE = '  # '\r\nMULTI_LINE = '\"\"\"'\r\n\r\ndef strip_comments(code):\r\n    # see Bite description\r\n    result=[]\r\n    inside_multiline=False\r\n    for line in code.splitlines():\r\n        if inside_multiline:\r\n            if MULTI_LINE in line:\r\n                inside_multiline= False\r\n            continue\r\n        if line.lstrip().startswith(SINGLE_LINE):\r\n            continue\r\n        if INLINE in line:\r\n            result.append(line[:line.find(INLINE)])\r\n            continue\r\n        if line.lstrip().startswith(MULTI_LINE):\r\n            if MULTI_LINE in line.lstrip()[3:]:\r\n                continue\r\n            inside_multiline=True\r\n            continue\r\n       \r\n        result.append(line)\r\n    return \"\\n\".join(result)\r\n\r\n\r\ncode = '''\"\"\"this is\r\nmy awesome script\r\n\"\"\"\r\n# importing modules\r\nimport re\r\n\r\ndef hello(name):\r\n    \"\"\"my function docstring\"\"\"\r\n    return f'hello {name}'  # my inline comment\r\n'''   \r\n    \r\n    \r\nprint(strip_comments(code))",
            "date": "2022-11-16 21:59:05.098105+00:00",
            "passed": true
        },
        {
            "bite": "Bite 179. Strip comments from Python code",
            "code": "def strip_comments(code):\r\n    # see Bite description\r\n    pass\r\n\r\n\r\ncode = \"\"\"this is\r\nmy awesome script\r\n\"\"\"\r\n# importing modules\r\nimport re\r\n\r\ndef hello(name):\r\n    \"\"\"my function docstring\"\"\"\r\n    return f'hello {name}'  # my inline comment\r\n    \r\n    \r\n    \r\nprint(strip_comments(code))",
            "date": "2022-11-15 20:35:32.704952+00:00",
            "passed": false
        },
        {
            "bite": "Bite 166. Complete a tox ini file parser class",
            "code": "import configparser\r\nimport re\r\n\r\nclass ToxIniParser:\r\n\r\n    def __init__(self, ini_file):\r\n        \"\"\"Use configparser to load ini_file into self.config\"\"\"\r\n        self.config = configparser.ConfigParser()\r\n        self.config.read(ini_file)\r\n\r\n    @property\r\n    def number_of_sections(self):\r\n        \"\"\"Return the number of sections in the ini file.\r\n           New to properties? -> https://pybit.es/property-decorator.html\r\n        \"\"\"\r\n        return len(self.config.sections())\r\n\r\n    @property\r\n    def environments(self):\r\n        \"\"\"Return a list of environments\r\n           (= \"envlist\" attribute of [tox] section)\"\"\"\r\n        envlist_raw = self.config['tox']['envlist']\r\n        return [item.strip() for item in re.split('\\n|,',envlist_raw) if item.strip()]\r\n        \r\n    @property\r\n    def base_python_versions(self):\r\n        \"\"\"Return a list of all basepython across the ini file\"\"\"\r\n        basepython_raw = [self.config[section].get('basepython') for section in self.config.sections()]\r\n        return list(set(item for item in basepython_raw if item)) \r\n    \r\n\r\nsample_ini_file = django = \"\"\"[tox]\r\nenvlist = py27, py34, py35, py36, pypy, flake8\r\n\r\n[testenv]\r\npassenv = LC_ALL, LANG, HOME\r\ncommands = pytest --cov=cookiecutter {posargs:tests}\r\ndeps = -rtest_requirements.txt\r\n\r\n[testenv:flake8]\r\ndeps =\r\n    flake8==3.5.0\r\ncommands =\r\n    flake8 cookiecutter tests setup.py\r\n\r\n[testenv:cov-report]\r\ncommands = pytest --cov=cookiecutter --cov-report=term --cov-report=html\"\"\"\r\n    \r\n    \r\nfilename = \"/tmp/test_file.ini\"\r\nwith open(filename,'w') as f:\r\n    f.write(sample_ini_file)\r\n\r\n\r\n\r\ntox = ToxIniParser(filename)\r\nprint(tox.number_of_sections)\r\nprint(tox.environments)\r\nprint(tox.base_python_versions)\r\n",
            "date": "2022-11-15 20:31:42.040963+00:00",
            "passed": true
        },
        {
            "bite": "Bite 166. Complete a tox ini file parser class",
            "code": "import configparser\r\nimport re\r\nimport shlex\r\n\r\nclass ToxIniParser:\r\n\r\n    def __init__(self, ini_file):\r\n        \"\"\"Use configparser to load ini_file into self.config\"\"\"\r\n        self.config = configparser.ConfigParser()\r\n        self.config.read(ini_file)\r\n\r\n    @property\r\n    def number_of_sections(self):\r\n        \"\"\"Return the number of sections in the ini file.\r\n           New to properties? -> https://pybit.es/property-decorator.html\r\n        \"\"\"\r\n        return len(self.config.sections())\r\n\r\n    @property\r\n    def environments(self):\r\n        \"\"\"Return a list of environments\r\n           (= \"envlist\" attribute of [tox] section)\"\"\"\r\n        # return shlex.split(self.config['tox']['envlist'])\r\n        envs= re.split('\\n|,',self.config['tox']['envlist'])\r\n        return [item.strip() for item in envs if item.strip()]\r\n        \r\n    @property\r\n    def base_python_versions(self):\r\n        \"\"\"Return a list of all basepython across the ini file\"\"\"\r\n        python_found = [self.config[section].get('basepython') for section in self.config.sections()]\r\n        return list(set(item for item in python_found if item)) \r\n    \r\n\r\nsample_ini_file = django = \"\"\"[tox]\r\nenvlist = py27, py34, py35, py36, pypy, flake8\r\n\r\n[testenv]\r\npassenv = LC_ALL, LANG, HOME\r\ncommands = pytest --cov=cookiecutter {posargs:tests}\r\ndeps = -rtest_requirements.txt\r\n\r\n[testenv:flake8]\r\ndeps =\r\n    flake8==3.5.0\r\ncommands =\r\n    flake8 cookiecutter tests setup.py\r\n\r\n[testenv:cov-report]\r\ncommands = pytest --cov=cookiecutter --cov-report=term --cov-report=html\"\"\"\r\n    \r\n    \r\nfilename = \"/tmp/test_file.ini\"\r\nwith open(filename,'w') as f:\r\n    f.write(sample_ini_file)\r\n\r\n\r\n\r\ntox = ToxIniParser(filename)\r\nprint(tox.number_of_sections)\r\nprint(tox.environments)\r\nprint(tox.base_python_versions)\r\n",
            "date": "2022-11-15 20:27:20.230921+00:00",
            "passed": true
        },
        {
            "bite": "Bite 166. Complete a tox ini file parser class",
            "code": "import configparser\r\nimport re\r\nimport shlex\r\n\r\nclass ToxIniParser:\r\n\r\n    def __init__(self, ini_file):\r\n        \"\"\"Use configparser to load ini_file into self.config\"\"\"\r\n        self.config = configparser.ConfigParser()\r\n        self.config.read(ini_file)\r\n\r\n    @property\r\n    def number_of_sections(self):\r\n        \"\"\"Return the number of sections in the ini file.\r\n           New to properties? -> https://pybit.es/property-decorator.html\r\n        \"\"\"\r\n        return len(self.config.sections())\r\n\r\n    @property\r\n    def environments(self):\r\n        \"\"\"Return a list of environments\r\n           (= \"envlist\" attribute of [tox] section)\"\"\"\r\n        return shlex.split(self.config['tox']['envlist'])\r\n        \"\"\"envs= re.split('\\n|,',self.config['tox']['envlist'])\r\n        return [item.strip() for item in envs if item.strip()]\r\n        \"\"\"\r\n\r\n    @property\r\n    def base_python_versions(self):\r\n        \"\"\"Return a list of all basepython across the ini file\"\"\"\r\n        python_found = [self.config[section].get('basepython') for section in self.config.sections()]\r\n        return list(set(item for item in python_found if item)) \r\n    \r\n\r\nsample_ini_file = django = \"\"\"# Tox (https://tox.readthedocs.io/) is a tool for running tests in multiple\r\n# virtualenvs. This configuration file helps to run the test suite on all\r\n# supported Python versions. To use it, \"pip install tox\" and then run \"tox\"\r\n# from this directory.\r\n#\r\n# copied from: https://github.com/django/django/blob/master/tox.ini\r\n\r\n[tox]\r\nskipsdist = true\r\nenvlist =\r\n    py3,\r\n    flake8,\r\n    docs,\r\n    isort\r\n\r\n# Add environment to use the default python3 installation\r\n[testenv:py3]\r\nbasepython = python3\r\n\r\n[testenv]\r\nusedevelop = true\r\npassenv = DJANGO_SETTINGS_MODULE PYTHONPATH HOME DISPLAY\r\nsetenv =\r\n    PYTHONDONTWRITEBYTECODE=1\r\ndeps =\r\n    py{3,35,36,37}: -rtests/requirements/py3.txt\r\n    postgres: -rtests/requirements/postgres.txt\r\n    mysql: -rtests/requirements/mysql.txt\r\n    oracle: -rtests/requirements/oracle.txt\r\nchangedir = tests\r\ncommands =\r\n    {envpython} runtests.py {posargs}\r\n\r\n[testenv:flake8]\r\nbasepython = python3\r\nusedevelop = false\r\ndeps = flake8\r\nchangedir = {toxinidir}\r\ncommands = flake8 .\r\n\r\n[testenv:docs]\r\nbasepython = python3\r\nusedevelop = false\r\nwhitelist_externals =\r\n    make\r\ndeps =\r\n    Sphinx\r\n    pyenchant\r\n    sphinxcontrib-spelling\r\nchangedir = docs\r\ncommands =\r\n    make spelling\r\n\r\n[testenv:isort]\r\nbasepython = python3\r\nusedevelop = false\r\ndeps = isort\r\nchangedir = {toxinidir}\r\ncommands = isort --recursive --check-only --diff django tests scripts\r\n\r\n[testenv:javascript]\r\nusedevelop = false\r\ndeps =\r\nchangedir = {toxinidir}\r\nwhitelist_externals = npm\r\ncommands =\r\n    npm install\r\n    npm test\"\"\"\r\n    \r\n    \r\nfilename = \"/tmp/test_file.ini\"\r\nwith open(filename,'w') as f:\r\n    f.write(sample_ini_file)\r\n\r\n\r\n\r\ntox = ToxIniParser(filename)\r\nprint(tox.number_of_sections)\r\nprint(tox.environments)\r\nprint(tox.base_python_versions)\r\n",
            "date": "2022-11-15 20:26:02.857447+00:00",
            "passed": false
        },
        {
            "bite": "Bite 166. Complete a tox ini file parser class",
            "code": "import configparser\r\n\r\n\r\nclass ToxIniParser:\r\n\r\n    def __init__(self, ini_file):\r\n        \"\"\"Use configparser to load ini_file into self.config\"\"\"\r\n        self.config = configparser.ConfigParser()\r\n        self.config.read(ini_file)\r\n\r\n    @property\r\n    def number_of_sections(self):\r\n        \"\"\"Return the number of sections in the ini file.\r\n           New to properties? -> https://pybit.es/property-decorator.html\r\n        \"\"\"\r\n        return len(self.config.sections())\r\n\r\n    @property\r\n    def environments(self):\r\n        \"\"\"Return a list of environments\r\n           (= \"envlist\" attribute of [tox] section)\"\"\"\r\n        return self.config['tox']['envlist']\r\n\r\n    @property\r\n    def base_python_versions(self):\r\n        \"\"\"Return a list of all basepython across the ini file\"\"\"\r\n        return [self.config[section].get('basepython') for section in self.config.sections()]\r\n            \r\n    \r\n\r\nsample_ini_file = \"\"\"[tox]\r\nenvlist = py27, py34, py35, py36, pypy, flake8\r\n\r\n[testenv]\r\npassenv = LC_ALL, LANG, HOME\r\ncommands = pytest --cov=cookiecutter {posargs:tests}\r\ndeps = -rtest_requirements.txt\r\n\r\n[testenv:flake8]\r\ndeps =\r\n    flake8==3.5.0\r\ncommands =\r\n    flake8 cookiecutter tests setup.py\r\n\r\n[testenv:cov-report]\r\ncommands = pytest --cov=cookiecutter --cov-report=term --cov-report=html\"\"\"\r\n\r\nfilename = \"/tmp/test_file.ini\"\r\nwith open(filename,'w') as f:\r\n    f.write(sample_ini_file)\r\n\r\n\r\n#config = configparser.ConfigParser()\r\n#config.read(filename)\r\n#print(config.sections())\r\ntox = ToxIniParser(filename)\r\nprint(tox.number_of_sections)\r\nprint(tox.environments)\r\nprint(tox.base_python_versions)\r\n",
            "date": "2022-11-15 20:11:57.085588+00:00",
            "passed": false
        },
        {
            "bite": "Bite 166. Complete a tox ini file parser class",
            "code": "import configparser\r\n\r\n\r\nclass ToxIniParser:\r\n\r\n    def __init__(self, ini_file):\r\n        \"\"\"Use configparser to load ini_file into self.config\"\"\"\r\n        self.config = configparser.ConfigParser().read(ini_file)\r\n\r\n    @property\r\n    def number_of_sections(self):\r\n        \"\"\"Return the number of sections in the ini file.\r\n           New to properties? -> https://pybit.es/property-decorator.html\r\n        \"\"\"\r\n        return len(self.config.sections())\r\n\r\n    @property\r\n    def environments(self):\r\n        \"\"\"Return a list of environments\r\n           (= \"envlist\" attribute of [tox] section)\"\"\"\r\n        return self.config['tox']['envlist']\r\n\r\n    @property\r\n    def base_python_versions(self):\r\n        \"\"\"Return a list of all basepython across the ini file\"\"\"\r\n        pass\r\n    \r\n\r\n",
            "date": "2022-11-15 18:30:01.841540+00:00",
            "passed": false
        },
        {
            "bite": "Bite 157. Filter out accented characters",
            "code": "import unicodedata \r\nimport string\r\n\r\ndef filter_accents(text):\r\n    \"\"\"Return a sequence of accented characters found in\r\n       the passed in lowercased text string\r\n    \"\"\"\r\n    all_accented_chars= [c for c in text.lower() if unicodedata.category(c)=='Ll' and c not in string.ascii_lowercase]\r\n    return sorted(list(set(all_accented_chars)))\r\ntxt= (\"The 5 French accents;\"\r\n     \"The c\u00e9dille (cedilla) \u00c7 ...\"\r\n     \"The accent aigu (acute accent) \u00e9 ...\"\r\n     \"The accent circonflexe (circumflex) \u00e2, \u00ea, \u00ee, \u00f4, \u00fb ...\"\r\n     \"The accent grave (grave accent) \u00e0, \u00e8, \u00f9 ...\"\r\n     \"The accent tr\u00e9ma (dieresis/umlaut) \u00eb, \u00ef, \u00fc\")\r\n\r\n\r\nprint(filter_accents(txt))\r\n\r\n#    ['\u00e1', '\u00e9', '\u00ed', '\u00f1'],\r\n#    ['\u00e0', '\u00e2', '\u00e7', '\u00e8', '\u00e9', '\u00ea', '\u00eb', '\u00ee', '\u00ef', '\u00f4', '\u00f9', '\u00fb', '\u00fc'],\r\n",
            "date": "2022-11-15 18:15:28.219070+00:00",
            "passed": true
        },
        {
            "bite": "Bite 157. Filter out accented characters",
            "code": "import unicodedata \r\nimport string\r\n\r\ndef filter_accents(text):\r\n    \"\"\"Return a sequence of accented characters found in\r\n       the passed in lowercased text string\r\n    \"\"\"\r\n    all_accented_chars= [c for c in text if unicodedata.category(c)=='Ll' and c.lower() not in string.ascii_lowercase]\r\n    return sorted(list(set(all_accented_chars)))\r\ntxt=(\"Sevilla es la capital de Andaluc\u00eda, y para muchos, \"\r\n    \"la ciudad m\u00e1s bonita de Espa\u00f1a. Pasear por sus calles, \"\r\n    \"contemplar la Giralda, la Catedral o la Torre del Oro \"\r\n    \"es una aut\u00e9ntica gozada. En primavera el olor a azahar \"\r\n    \"lo envuelve todo. Al igual que Granada, toda la ciudad \"\r\n    \"es una aut\u00e9ntica delicia. Su clima hace propensa la \"\r\n    \"visita en casi cualquier \u00e9poca del a\u00f1o.\")\r\n\r\n\r\nprint(filter_accents(txt))\r\n\r\n#    ['\u00e1', '\u00e9', '\u00ed', '\u00f1'],",
            "date": "2022-11-15 18:06:02.986085+00:00",
            "passed": false
        },
        {
            "bite": "Bite 139. Calculate a coding streak in days",
            "code": "from datetime import datetime, timedelta, date\r\n\r\nTODAY = date(2018, 11, 12)\r\n\r\n\r\ndef extract_dates(data):\r\n    \"\"\"Extract unique dates from DB table representation as shown in Bite\"\"\"\r\n    lines=data.strip().splitlines()\r\n    result=[]\r\n    for line in lines[3:-1]:\r\n        _,date_str,*_=line.split('|')\r\n        date_obj=datetime.strptime(date_str.strip(), \"%Y-%m-%d\").date()\r\n        result.append(date_obj)\r\n    return sorted(list(set(result)), reverse=True)\r\n\r\n\r\ndef calculate_streak(dates):\r\n    \"\"\"Receives sequence (set) of dates and returns number of days\r\n       on coding streak.\r\n\r\n       Note that a coding streak is defined as consecutive days coded\r\n       since yesterday, because today is not over yet, however if today\r\n       was coded, it counts too of course.\r\n\r\n       So as today is 12th of Nov, having dates 11th/10th/9th of Nov in\r\n       the table makes for a 3 days coding streak.\r\n\r\n       See the tests for more examples that will be used to pass your code.\r\n    \"\"\"\r\n    dates.insert(0, TODAY)\r\n    intervals= [(dates[n-1]-dates[n]).days for n in range(1,len(dates))]\r\n    streak_breaks= list(filter(lambda i: i> 1, intervals))\r\n    if streak_breaks:\r\n        return intervals.index(streak_breaks[0])\r\n    else:\r\n        return len(intervals)\r\n    \r\n\r\n    print(dates)\r\n    print(intervals)\r\n    \r\n\r\ndata = \"\"\"\r\n    +------------+------------+---------+\r\n    | date       | activity   | count   |\r\n    |------------+------------+---------|\r\n    | 2018-11-11 | pcc        | 1       |\r\n    | 2018-11-10 | 100d       | 1       |\r\n    | 2018-11-09 | 100d       | 2       |\r\n    | 2018-10-23 | pcc        | 1       |\r\n    | 2018-10-15 | pcc        | 1       |\r\n    | 2018-10-05 | bite       | 1       |\r\n    | 2018-09-21 | bite       | 4       |\r\n    | 2018-09-18 | bite       | 2       |\r\n    | 2018-09-18 | bite       | 4       |\r\n    +------------+------------+---------+\r\n\"\"\"\r\n\r\ndates=extract_dates(data)\r\nprint(dates)\r\nprint(calculate_streak(dates))\r\n",
            "date": "2022-11-14 17:57:45.831956+00:00",
            "passed": true
        },
        {
            "bite": "Bite 139. Calculate a coding streak in days",
            "code": "from datetime import datetime, timedelta, date\r\n\r\nTODAY = date(2018, 11, 12)\r\n\r\n\r\ndef extract_dates(data):\r\n    \"\"\"Extract unique dates from DB table representation as shown in Bite\"\"\"\r\n    lines=data.strip().splitlines()\r\n    result=[]\r\n    for line in lines[3:-1]:\r\n        _,date_str,*_=line.split('|')\r\n        date_obj=datetime.strptime(date_str.strip(), \"%Y-%m-%d\").date()\r\n        result.append(date_obj)\r\n    return sorted(list(set(result)), reverse=True)\r\n\r\n\r\ndef calculate_streak(dates):\r\n    \"\"\"Receives sequence (set) of dates and returns number of days\r\n       on coding streak.\r\n\r\n       Note that a coding streak is defined as consecutive days coded\r\n       since yesterday, because today is not over yet, however if today\r\n       was coded, it counts too of course.\r\n\r\n       So as today is 12th of Nov, having dates 11th/10th/9th of Nov in\r\n       the table makes for a 3 days coding streak.\r\n\r\n       See the tests for more examples that will be used to pass your code.\r\n    \"\"\"\r\n    dates.insert(0, TODAY)\r\n    intervals= [(dates[n-1]-dates[n]).days for n in range(1,len(dates))]\r\n    streak_breaks= list(filter(lambda i: i> 1, intervals)\r\n    if streak_breaks:\r\n        return streak_breaks[0]\r\n    else:\r\n        return len(intervals)\r\n    \r\n\r\n    print(dates)\r\n    print(intervals)\r\n    \r\n\r\ndata = \"\"\"\r\n    +------------+------------+---------+\r\n    | date       | activity   | count   |\r\n    |------------+------------+---------|\r\n    | 2018-11-11 | pcc        | 1       |\r\n    | 2018-11-10 | 100d       | 1       |\r\n    | 2018-11-09 | 100d       | 2       |\r\n    | 2018-10-23 | pcc        | 1       |\r\n    | 2018-10-15 | pcc        | 1       |\r\n    | 2018-10-05 | bite       | 1       |\r\n    | 2018-09-21 | bite       | 4       |\r\n    | 2018-09-18 | bite       | 2       |\r\n    | 2018-09-18 | bite       | 4       |\r\n    +------------+------------+---------+\r\n\"\"\"\r\n\r\ndates=extract_dates(data)\r\nprint(dates)\r\nprint(calculate_streak(dates))\r\n",
            "date": "2022-11-14 17:53:15.381316+00:00",
            "passed": false
        },
        {
            "bite": "Bite 139. Calculate a coding streak in days",
            "code": "from datetime import datetime, timedelta, date\r\n\r\nTODAY = date(2018, 11, 12)\r\n\r\n\r\ndef extract_dates(data):\r\n    \"\"\"Extract unique dates from DB table representation as shown in Bite\"\"\"\r\n    lines=data.strip().splitlines()\r\n    result=[]\r\n    for line in lines[3:-1]:\r\n        _,date_str,*_=line.split('|')\r\n        date_obj=datetime.strptime(date_str.strip(), \"%Y-%m-%d\").date()\r\n        result.append(date_obj)\r\n    return sorted(list(set(result)), reverse=True)\r\n\r\n\r\ndef calculate_streak(dates):\r\n    \"\"\"Receives sequence (set) of dates and returns number of days\r\n       on coding streak.\r\n\r\n       Note that a coding streak is defined as consecutive days coded\r\n       since yesterday, because today is not over yet, however if today\r\n       was coded, it counts too of course.\r\n\r\n       So as today is 12th of Nov, having dates 11th/10th/9th of Nov in\r\n       the table makes for a 3 days coding streak.\r\n\r\n       See the tests for more examples that will be used to pass your code.\r\n    \"\"\"\r\n    dates.insert(0, TODAY)\r\n    intervals= [(dates[n-1]-dates[n]).days for n in range(1,len(dates))]\r\n    return list(map(lambda i: i> 1, intervals)).index(True)\r\n    \r\n\r\n    print(dates)\r\n    print(intervals)\r\n    \r\n\r\ndata = \"\"\"\r\n    +------------+------------+---------+\r\n    | date       | activity   | count   |\r\n    |------------+------------+---------|\r\n    | 2018-11-11 | pcc        | 1       |\r\n    | 2018-11-10 | 100d       | 1       |\r\n    | 2018-11-09 | 100d       | 2       |\r\n    | 2018-10-23 | pcc        | 1       |\r\n    | 2018-10-15 | pcc        | 1       |\r\n    | 2018-10-05 | bite       | 1       |\r\n    | 2018-09-21 | bite       | 4       |\r\n    | 2018-09-18 | bite       | 2       |\r\n    | 2018-09-18 | bite       | 4       |\r\n    +------------+------------+---------+\r\n\"\"\"\r\n\r\ndates=extract_dates(data)\r\nprint(dates)\r\nprint(calculate_streak(dates))\r\n",
            "date": "2022-11-14 17:48:03.480925+00:00",
            "passed": false
        },
        {
            "bite": "Bite 139. Calculate a coding streak in days",
            "code": "from datetime import datetime, timedelta, date\r\n\r\nTODAY = date(2018, 11, 12)\r\n\r\n\r\ndef extract_dates(data):\r\n    \"\"\"Extract unique dates from DB table representation as shown in Bite\"\"\"\r\n    lines=data.strip().splitlines()\r\n    result=[]\r\n    for line in lines[3:-1]:\r\n        _,date_str,*_=line.split('|')\r\n        date_obj=datetime.strptime(date_str.strip(), \"%Y-%m-%d\").date()\r\n        result.append(date_obj)\r\n    return result\r\n\r\n\r\ndef calculate_streak(dates):\r\n    \"\"\"Receives sequence (set) of dates and returns number of days\r\n       on coding streak.\r\n\r\n       Note that a coding streak is defined as consecutive days coded\r\n       since yesterday, because today is not over yet, however if today\r\n       was coded, it counts too of course.\r\n\r\n       So as today is 12th of Nov, having dates 11th/10th/9th of Nov in\r\n       the table makes for a 3 days coding streak.\r\n\r\n       See the tests for more examples that will be used to pass your code.\r\n    \"\"\"\r\n    dates.insert(0, TODAY)\r\n    intervals= [(dates[n-1]-dates[n]).days for n in range(1,len(dates))]\r\n    return list(map(lambda i: i> 1, intervals)).index(True)\r\n    \r\n\r\n    print(dates)\r\n    print(intervals)\r\n    \r\n\r\ndata = \"\"\"\r\n    +------------+------------+---------+\r\n    | date       | activity   | count   |\r\n    |------------+------------+---------|\r\n    | 2018-11-11 | pcc        | 1       |\r\n    | 2018-11-10 | 100d       | 1       |\r\n    | 2018-11-09 | 100d       | 2       |\r\n    | 2018-10-23 | pcc        | 1       |\r\n    | 2018-10-15 | pcc        | 1       |\r\n    | 2018-10-05 | bite       | 1       |\r\n    | 2018-09-21 | bite       | 4       |\r\n    | 2018-09-18 | bite       | 2       |\r\n    | 2018-09-18 | bite       | 4       |\r\n    +------------+------------+---------+\r\n\"\"\"\r\n\r\ndates=extract_dates(data)\r\nprint(calculate_streak(dates))\r\n",
            "date": "2022-11-14 17:42:44.403172+00:00",
            "passed": false
        },
        {
            "bite": "Bite 278. Major and minor numbers",
            "code": "from collections import Counter\r\n\r\ndef major_n_minor(numbers):\r\n    \"\"\"\r\n    Input: an array with integer numbers\r\n    Output: the majority and minority number\r\n    \"\"\"\r\n\r\n    # you code ...\r\n    cnt=Counter(numbers).most_common()\r\n    major = cnt[0][0]\r\n    minor = cnt[-1][0]\r\n    \r\n    return major, minor\r\n    \r\n    \r\nprint(major_n_minor([5,3,2,3,3,2,2,3,4,4]))\r\n    \r\n    ",
            "date": "2022-11-14 17:03:05.392403+00:00",
            "passed": true
        },
        {
            "bite": "Bite 171. Make a terminal spinner animation",
            "code": "from itertools import cycle\r\nimport sys\r\nfrom time import time, sleep\r\n\r\nSPINNER_STATES = ['-', '\\\\', '|', '/']  # had to escape \\\r\nSTATE_TRANSITION_TIME = 0.1\r\n\r\n\r\ndef spinner(seconds):\r\n    \"\"\"Make a terminal loader/spinner animation using the imports above.\r\n       Takes seconds argument = time for the spinner to run.\r\n       Does not return anything, only prints to stdout.\"\"\"\r\n\r\n    start = time()\r\n    print(\" \", end='', flush=True)\r\n    # Back up one character then print our next frame in the animation\r\n    for frame in cycle(SPINNER_STATES):\r\n        print('\\r', frame, sep='', end='', flush=True)\r\n        sleep(STATE_TRANSITION_TIME)\r\n        if time()-start > seconds:\r\n            break\r\n    print('\\r ')\r\n\r\n\r\nif __name__ == '__main__':\r\n    spinner(2)",
            "date": "2022-11-13 21:35:43.692515+00:00",
            "passed": true
        },
        {
            "bite": "Bite 171. Make a terminal spinner animation",
            "code": "from itertools import cycle\r\nimport sys\r\nfrom time import time, sleep\r\n\r\nSPINNER_STATES = ['-', '\\\\', '|', '/']  # had to escape \\\r\nSTATE_TRANSITION_TIME = 0.1\r\n\r\n\r\ndef spinner(seconds):\r\n    \"\"\"Make a terminal loader/spinner animation using the imports above.\r\n       Takes seconds argument = time for the spinner to run.\r\n       Does not return anything, only prints to stdout.\"\"\"\r\n\r\n    start = time()\r\n    print(\" \", end='', flush=True)\r\n    # Back up one character then print our next frame in the animation\r\n    for frame in cycle(SPINNER_STATES):\r\n        print(r'\\b', frame, sep='', end='', flush=True)\r\n        sleep(STATE_TRANSITION_TIME)\r\n        if time()-start > seconds:\r\n            break\r\n    print(r'\\b ')\r\n\r\n\r\nif __name__ == '__main__':\r\n    spinner(2)",
            "date": "2022-11-13 20:31:56.006133+00:00",
            "passed": false
        },
        {
            "bite": "Bite 171. Make a terminal spinner animation",
            "code": "from itertools import cycle\r\nimport sys\r\nfrom time import time, sleep\r\n\r\nSPINNER_STATES = ['-', '\\\\', '|', '/']  # had to escape \\\r\nSTATE_TRANSITION_TIME = 0.1\r\n\r\n\r\ndef spinner(seconds):\r\n    \"\"\"Make a terminal loader/spinner animation using the imports above.\r\n       Takes seconds argument = time for the spinner to run.\r\n       Does not return anything, only prints to stdout.\"\"\"\r\n\r\n    start = time()\r\n    print(\" \", end='', flush=True)\r\n    # Back up one character then print our next frame in the animation\r\n    for frame in cycle(SPINNER_STATES):\r\n        print('\\b', frame, sep='', end='', flush=True)\r\n        sleep(STATE_TRANSITION_TIME)\r\n        if time()-start > seconds:\r\n            break\r\n    print('\\b ')\r\n\r\n\r\nif __name__ == '__main__':\r\n    spinner(2)",
            "date": "2022-11-13 20:26:37.459043+00:00",
            "passed": false
        },
        {
            "bite": "Bite 171. Make a terminal spinner animation",
            "code": "from itertools import cycle\r\nimport sys\r\nfrom time import time, sleep\r\n\r\nSPINNER_STATES = ['-', '\\\\', '|', '/']  # had to escape \\\r\nSTATE_TRANSITION_TIME = 0.1\r\n\r\n\r\ndef spinner(seconds):\r\n    \"\"\"Make a terminal loader/spinner animation using the imports above.\r\n       Takes seconds argument = time for the spinner to run.\r\n       Does not return anything, only prints to stdout.\"\"\"\r\n\r\n    print(\" \", end='', flush=True)\r\n    # Back up one character then print our next frame in the animation\r\n    for i, frame in enumerate(cycle(SPINNER_STATES)):\r\n        print('\\b', frame, sep='', end='', flush=True)\r\n        sleep(STATE_TRANSITION_TIME)\r\n        if i > seconds/STATE_TRANSITION_TIME:\r\n            break\r\n    print('\\b ')\r\n\r\n\r\nif __name__ == '__main__':\r\n    spinner(2)\r\n",
            "date": "2022-11-13 20:22:03.992984+00:00",
            "passed": false
        },
        {
            "bite": "Bite 131. Screen scraper",
            "code": "output = \"\"\"\r\n                                       mohh@SERENiTY\r\n MMMMMMMMMMMMMMMMMMMMMMMMMmds+.        OS: Mint 19 tara\r\n MMm----::-://////////////oymNMd+'     Kernel: x86_64 Linux 4.15.0-34-generic\r\n MMd      /++                -sNMd:    Uptime: 1d 4m\r\n MMNso/'  dMM    '.::-. .-::.' .hMN:   Packages: 2351\r\n ddddMMh  dMM   :hNMNMNhNMNMNh: 'NMm   Shell: zsh 5.4.2\r\n     NMm  dMM  .NMN/-+MMM+-/NMN' dMM   Resolution: 1366x768\r\n     NMm  dMM  -MMm  'MMM   dMM. dMM   DE: Cinnamon 3.8.9\r\n     NMm  dMM  -MMm  'MMM   dMM. dMM   WM: Muffin\r\n     NMm  dMM  .mmd  'mmm   yMM. dMM   WM Theme: Linux Mint (Mint-Y)\r\n     NMm  dMM'  ..'   ...   ydm. dMM   GTK Theme: Mint-Y [GTK2/3]\r\n     hMM- +MMd/-------...-:sdds  dMM   Icon Theme: Mint-Y\r\n     -NMm- :hNMNNNmdddddddddy/'  dMM   Font: Noto Sans 9\r\n      -dMNs-''-::::-------.''    dMM   CPU: AMD A10-7400P Radeon R6, 10 Compute Cores 4C+6G @ 4x 2.5GHz [101.0\u00b0C]\r\n       '/dMNmy+/:-------------:/yMMM   GPU: AMD KAVERI (DRM 2.50.0 / 4.15.0-34-generic, LLVM 6.0.0)\r\n          ./ydNMMMMMMMMMMMMMMMMMMMMM   RAM: 1886MiB / 6915MiB\r\n             \\.MMMMMMMMMMMMMMMMMMM    \r\n\"\"\"\r\n\r\ndef sysinfo_scrape(output):\r\n    \"\"\"Scrapes the output from screenfetch and returns a dictionary\"\"\"\r\n    lines=output.splitlines()\r\n    graph, name_raw = lines[1].rsplit(' ',1)\r\n    graph_width=len(graph)\r\n\r\n    result= {}\r\n    result['Name']=name_raw.strip()\r\n\r\n    for line in lines[2:]:\r\n        if line[graph_width:].strip():\r\n            key_raw, value_raw = line[graph_width:].split(':',1)\r\n            result[key_raw.strip()] = value_raw.strip()\r\n    return result\r\n\r\n# print(sysinfo_scrape(output))",
            "date": "2022-11-13 19:15:10.082253+00:00",
            "passed": true
        },
        {
            "bite": "Bite 131. Screen scraper",
            "code": "",
            "date": "2022-11-13 19:12:55.548688+00:00",
            "passed": false
        },
        {
            "bite": "Bite 131. Screen scraper",
            "code": "output = \"\"\"\r\n                                       mohh@SERENiTY\r\n MMMMMMMMMMMMMMMMMMMMMMMMMmds+.        OS: Mint 19 tara\r\n MMm----::-://////////////oymNMd+'     Kernel: x86_64 Linux 4.15.0-34-generic\r\n MMd      /++                -sNMd:    Uptime: 1d 4m\r\n MMNso/'  dMM    '.::-. .-::.' .hMN:   Packages: 2351\r\n ddddMMh  dMM   :hNMNMNhNMNMNh: 'NMm   Shell: zsh 5.4.2\r\n     NMm  dMM  .NMN/-+MMM+-/NMN' dMM   Resolution: 1366x768\r\n     NMm  dMM  -MMm  'MMM   dMM. dMM   DE: Cinnamon 3.8.9\r\n     NMm  dMM  -MMm  'MMM   dMM. dMM   WM: Muffin\r\n     NMm  dMM  .mmd  'mmm   yMM. dMM   WM Theme: Linux Mint (Mint-Y)\r\n     NMm  dMM'  ..'   ...   ydm. dMM   GTK Theme: Mint-Y [GTK2/3]\r\n     hMM- +MMd/-------...-:sdds  dMM   Icon Theme: Mint-Y\r\n     -NMm- :hNMNNNmdddddddddy/'  dMM   Font: Noto Sans 9\r\n      -dMNs-''-::::-------.''    dMM   CPU: AMD A10-7400P Radeon R6, 10 Compute Cores 4C+6G @ 4x 2.5GHz [101.0\u00b0C]\r\n       '/dMNmy+/:-------------:/yMMM   GPU: AMD KAVERI (DRM 2.50.0 / 4.15.0-34-generic, LLVM 6.0.0)\r\n          ./ydNMMMMMMMMMMMMMMMMMMMMM   RAM: 1886MiB / 6915MiB\r\n             \\.MMMMMMMMMMMMMMMMMMM    \r\n\"\"\"\r\n\r\nSKIP_GRAPHIC=38\r\ndef sysinfo_scrape(output):\r\n    \"\"\"Scrapes the output from screenfetch and returns a dictionary\"\"\"\r\n    lines=output.strip().splitlines()\r\n\r\n    result= {}\r\n    result['Name']=lines[0].strip().split()[-1]\r\n\r\n    for line in lines[1:]:\r\n        key_raw, value_raw = tuple(line.rsplit(':',1))\r\n        # print(f'{key_raw=}, {value_raw=}')\r\n        key = key_raw.rsplit(' ',1)[-1]\r\n        value = value_raw.strip()\r\n        # print(f'{key=}, {value=}')\r\n        if key:\r\n            result[key] = value\r\n    return result\r\n\r\n\r\nmac = \"\"\"\r\n                -/+:.          ejo@BlackOil\r\n               :++++.          OS: 64bit Mac OS X 10.13.6 17G65\r\n              /+++/.           Kernel: x86_64 Darwin 17.7.0\r\n      .:-::- .+/:-''.::-       Uptime: 1d 49m\r\n   .:/++++++/::::/++++++/:'    Packages: 236\r\n .:///////////////////////:'   Shell: bash 4.4.23\r\n ////////////////////////'     Resolution: 2560x1600\r\n-+++++++++++++++++++++++'      DE: Aqua\r\n/++++++++++++++++++++++/       WM: Quartz Compositor\r\n/sssssssssssssssssssssss.      WM Theme: Blue\r\n:ssssssssssssssssssssssss-     Font: SourceCodePro-Medium\r\n osssssssssssssssssssssssso/'  CPU: Intel Core i7-4980HQ @ 2.80GHz\r\n 'syyyyyyyyyyyyyyyyyyyyyyyy+'  GPU: Intel Iris Pro / NVIDIA GeForce GT 750M\r\n  'ossssssssssssssssssssss/    RAM: 9960MiB / 16384MiB\r\n    :ooooooooooooooooooo+.    \r\n     ':+oo+/:-..-:/+o+/-      \r\n\"\"\"\r\n\r\nprint(sysinfo_scrape(mac))",
            "date": "2022-11-13 18:57:03.158239+00:00",
            "passed": false
        },
        {
            "bite": "Bite 131. Screen scraper",
            "code": "output = \"\"\"\r\n                                       mohh@SERENiTY\r\n MMMMMMMMMMMMMMMMMMMMMMMMMmds+.        OS: Mint 19 tara\r\n MMm----::-://////////////oymNMd+'     Kernel: x86_64 Linux 4.15.0-34-generic\r\n MMd      /++                -sNMd:    Uptime: 1d 4m\r\n MMNso/'  dMM    '.::-. .-::.' .hMN:   Packages: 2351\r\n ddddMMh  dMM   :hNMNMNhNMNMNh: 'NMm   Shell: zsh 5.4.2\r\n     NMm  dMM  .NMN/-+MMM+-/NMN' dMM   Resolution: 1366x768\r\n     NMm  dMM  -MMm  'MMM   dMM. dMM   DE: Cinnamon 3.8.9\r\n     NMm  dMM  -MMm  'MMM   dMM. dMM   WM: Muffin\r\n     NMm  dMM  .mmd  'mmm   yMM. dMM   WM Theme: Linux Mint (Mint-Y)\r\n     NMm  dMM'  ..'   ...   ydm. dMM   GTK Theme: Mint-Y [GTK2/3]\r\n     hMM- +MMd/-------...-:sdds  dMM   Icon Theme: Mint-Y\r\n     -NMm- :hNMNNNmdddddddddy/'  dMM   Font: Noto Sans 9\r\n      -dMNs-''-::::-------.''    dMM   CPU: AMD A10-7400P Radeon R6, 10 Compute Cores 4C+6G @ 4x 2.5GHz [101.0\u00b0C]\r\n       '/dMNmy+/:-------------:/yMMM   GPU: AMD KAVERI (DRM 2.50.0 / 4.15.0-34-generic, LLVM 6.0.0)\r\n          ./ydNMMMMMMMMMMMMMMMMMMMMM   RAM: 1886MiB / 6915MiB\r\n             \\.MMMMMMMMMMMMMMMMMMM    \r\n\"\"\"\r\n\r\nSKIP_GRAPHIC=38\r\ndef sysinfo_scrape(output):\r\n    \"\"\"Scrapes the output from screenfetch and returns a dictionary\"\"\"\r\n    lines=output.strip().splitlines()\r\n\r\n    result= {}\r\n    result['Name']=lines[0].strip()\r\n\r\n    keys_values_raw = [tuple(line[SKIP_GRAPHIC:].split(':')) for line in lines[1:]]\r\n    for item in keys_values_raw:\r\n        if item[0]:\r\n            result[item[0].strip()] = item[1].strip()\r\n    return result\r\n    \r\nprint(sysinfo_scrape(output))",
            "date": "2022-11-13 18:40:19.709982+00:00",
            "passed": false
        },
        {
            "bite": "Bite 75. Parse Unix cal to a weekday mapping",
            "code": "def get_weekdays(calendar_output):\r\n    \"\"\"Receives a multiline Unix cal output and returns a mapping (dict) where\r\n       keys are int days and values are the 2 letter weekdays (Su Mo Tu ...)\"\"\"\r\n    \r\n    cal_lines= calendar_output.splitlines()\r\n    weekdays=[item.strip() for item in cal_lines[1].split()]\r\n    \r\n    result ={}\r\n    for line in cal_lines[2:]:\r\n        cal_days= [line[i:i+3] for i in range(0, len(line), 3)]\r\n        for i, day in enumerate(cal_days):\r\n            label = day.strip()\r\n            if label:\r\n                result[int(label)]=weekdays[i]\r\n    return result\r\n\r\napril_1981 = \"\"\"     April 1981\r\nSu Mo Tu We Th Fr Sa\r\n          1  2  3  4\r\n 5  6  7  8  9 10 11\r\n12 13 14 15 16 17 18\r\n19 20 21 22 23 24 25\r\n26 27 28 29 30\r\n\"\"\"\r\n\r\n\r\nprint(get_weekdays(april_1981))",
            "date": "2022-11-13 18:12:44.773039+00:00",
            "passed": true
        },
        {
            "bite": "Bite 75. Parse Unix cal to a weekday mapping",
            "code": "def get_weekdays(calendar_output):\r\n    \"\"\"Receives a multiline Unix cal output and returns a mapping (dict) where\r\n       keys are int days and values are the 2 letter weekdays (Su Mo Tu ...)\"\"\"\r\n    \r\n    cal_lines= calendar_output.splitlines()\r\n    weekdays=[day.strip() for day in cal_lines[1].split()]\r\n    \r\n    result ={}\r\n    for line in cal_lines[2:]:\r\n        days= [line[i:i+3] for i in range(0, len(line), 3)]\r\n        for i,day in enumerate(days):\r\n            label = day.strip()\r\n            if label:\r\n                result[label]=weekdays[i]\r\n    return result\r\n\r\napril_1981 = \"\"\"     April 1981\r\nSu Mo Tu We Th Fr Sa\r\n          1  2  3  4\r\n 5  6  7  8  9 10 11\r\n12 13 14 15 16 17 18\r\n19 20 21 22 23 24 25\r\n26 27 28 29 30\r\n\"\"\"\r\n\r\n\r\nprint(get_weekdays(april_1981))",
            "date": "2022-11-13 18:09:25.852979+00:00",
            "passed": false
        },
        {
            "bite": "Bite 75. Parse Unix cal to a weekday mapping",
            "code": "def get_weekdays(calendar_output):\r\n    \"\"\"Receives a multiline Unix cal output and returns a mapping (dict) where\r\n       keys are int days and values are the 2 letter weekdays (Su Mo Tu ...)\"\"\"\r\n    \r\n    cal_lines= calendar_output.splitlines()\r\n    weekdays=cal_lines[1].split()\r\n    \r\n    result ={}\r\n    for line in cal_lines[2:]:\r\n        days= [line[i:i+3] for i in range(0, len(line), 3)]\r\n        for i,day in enumerate(days):\r\n            label = day.strip()\r\n            if label:\r\n                result[label]=weekdays[i]\r\n    return result\r\n\r\napril_1981 = \"\"\"     April 1981\r\nSu Mo Tu We Th Fr Sa\r\n          1  2  3  4\r\n 5  6  7  8  9 10 11\r\n12 13 14 15 16 17 18\r\n19 20 21 22 23 24 25\r\n26 27 28 29 30\r\n\"\"\"\r\n\r\n\r\nprint(get_weekdays(april_1981))",
            "date": "2022-11-13 18:08:11.952507+00:00",
            "passed": false
        },
        {
            "bite": "Bite 155. Split a string by spaces or quoted text",
            "code": "import re\r\ndef split_words_and_quoted_text(text):\r\n    \"\"\"Split string text by space unless it is\r\n       wrapped inside double quotes, returning a list\r\n       of the elements.\r\n\r\n       For example\r\n       if text =\r\n       'Should give \"3 elements only\"'\r\n\r\n       the resulting list would be:\r\n       ['Should', 'give', '3 elements only']\r\n    \"\"\"\r\n    matches = re.findall('\"(.+?)\"|([\\w-]+)', text)\r\n    return [\"\".join(item) for item in matches]\r\n\r\n\r\ntext = 'Should give \"3 elements only\"'\r\n       \r\nprint(split_words_and_quoted_text(text))",
            "date": "2022-11-13 17:53:44.253478+00:00",
            "passed": true
        },
        {
            "bite": "Bite 53. Convert text into multiple columns",
            "code": "import textwrap\r\nimport itertools \r\nfrom pprint import pprint \r\n\r\nCOL_WIDTH = 20\r\nCOL_MARGIN = 4\r\n\r\n\r\ndef text_to_columns(text):\r\n    \"\"\"Split text (input arg) to columns, the amount of double\r\n       newlines (\\n\\n) in text determines the amount of columns.\r\n       Return a string with the column output like:\r\n       line1\\nline2\\nline3\\n ... etc ...\r\n       See also the tests for more info.\"\"\"\r\n\r\n    paragraphs = text.split('\\n\\n')\r\n    \r\n    paragraphs_wrapped = [textwrap.wrap(par.strip(), width=COL_WIDTH) for par in paragraphs]\r\n\r\n    lines_zipped_by_column= list(itertools.zip_longest(*paragraphs_wrapped, fillvalue=\"\"))\r\n\r\n    result = []\r\n    for line in lines_zipped_by_column:\r\n        result.append(\"\".join(col.ljust(COL_WIDTH+COL_MARGIN) for col in line))\r\n    return \"\\n\".join(result)\r\n    \r\n    \r\ntext = \"\"\"My house is small but cosy.\r\n\r\n    It has a white kitchen and an empty fridge.\"\"\"\r\n    \r\npprint(text_to_columns(text))",
            "date": "2022-11-12 19:37:53.065851+00:00",
            "passed": true
        },
        {
            "bite": "Bite 53. Convert text into multiple columns",
            "code": "import textwrap\r\nimport itertools \r\nfrom pprint import pprint \r\n\r\nCOL_WIDTH = 20\r\nCOL_MARGIN = 4\r\n\r\n\r\ndef text_to_columns(text):\r\n    \"\"\"Split text (input arg) to columns, the amount of double\r\n       newlines (\\n\\n) in text determines the amount of columns.\r\n       Return a string with the column output like:\r\n       line1\\nline2\\nline3\\n ... etc ...\r\n       See also the tests for more info.\"\"\"\r\n\r\n    paragraphs = text.split('\\n\\n')\r\n    \r\n    paragraphs_wrapped = [textwrap.wrap(par.strip(), width=COL_WIDTH) for par in paragraphs]\r\n\r\n    list_by_cols= list(itertools.zip_longest(*paragraphs_wrapped, fillvalue=\"\"))\r\n\r\n    result =[]\r\n    for line in list_by_cols:\r\n        result.append(\"\".join(col.ljust(COL_WIDTH+COL_MARGIN) for col in line))\r\n    return \"\\n\".join(result)\r\n    \r\n    \r\ntext = \"\"\"My house is small but cosy.\r\n\r\n    It has a white kitchen and an empty fridge.\"\"\"\r\n    \r\npprint(text_to_columns(text))",
            "date": "2022-11-12 19:36:08.667576+00:00",
            "passed": true
        },
        {
            "bite": "Bite 184. Analyze some Bite stats data",
            "code": "from csv import DictReader\r\nimport os\r\nfrom urllib.request import urlretrieve\r\nfrom collections import Counter\r\n\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nLOGS = 'bite_output_log.txt'\r\nDATA = os.path.join(TMP, LOGS)\r\nS3 = 'https://bites-data.s3.us-east-2.amazonaws.com'\r\nif not os.path.isfile(DATA):\r\n    urlretrieve(f'{S3}/{LOGS}', DATA)\r\n\r\n\r\nclass BiteStats:\r\n\r\n    def __init__(self, data=DATA):\r\n        self.rows = []\r\n        # you code ...\r\n        with open(data, newline='') as csvfile:\r\n            for row in DictReader(csvfile):\r\n                self.rows.append(row)\r\n        print(self.rows)\r\n\r\n    @property\r\n    def number_bites_accessed(self) -> int:\r\n        \"\"\"Get the number of unique Bites accessed\"\"\"\r\n        return len(set([row['bite'] for row in self.rows]))\r\n\r\n    @property\r\n    def number_bites_resolved(self) -> int:\r\n        \"\"\"Get the number of unique Bites resolved (completed=True)\"\"\"\r\n        return len(set([row['bite'] for row in self.rows if row['completed']=='True']))\r\n\r\n    @property\r\n    def number_users_active(self) -> int:\r\n        \"\"\"Get the number of unique users in the data set\"\"\"\r\n        return len(set([row['user'] for row in self.rows]))\r\n\r\n    @property\r\n    def number_users_solving_bites(self) -> int:\r\n        \"\"\"Get the number of unique users that resolved\r\n           one or more Bites\"\"\"\r\n        return len(set([row['user'] for row in self.rows if row['completed']=='True']))\r\n\r\n    @property\r\n    def top_bite_by_number_of_clicks(self) -> str:\r\n        \"\"\"Get the Bite that got accessed the most\r\n           (= in most rows)\"\"\"\r\n        bites_accessed_most=Counter([row['bite'] for row in self.rows]).most_common()\r\n        return bites_accessed_most[0][0]\r\n\r\n    @property\r\n    def top_user_by_bites_completed(self) -> str:\r\n        \"\"\"Get the user that completed the most Bites\"\"\"\r\n        bites_completed_most=Counter([row['user'] for row in self.rows if row['completed']=='True']).most_common()\r\n        return bites_completed_most[0][0]\r\n    \r\na=BiteStats()\r\nprint(a.number_bites_accessed)\r\nprint(a.number_bites_resolved)\r\nprint(a.number_users_active)\r\nprint(a.number_users_solving_bites)\r\nprint(a.top_bite_by_number_of_clicks)\r\nprint(a.top_user_by_bites_completed)",
            "date": "2022-11-12 13:30:35.188880+00:00",
            "passed": true
        },
        {
            "bite": "Bite 156. Make an index of story characters",
            "code": "import re \r\nfrom collections import defaultdict\r\n\r\nCHARACTERS = ['Red Riding Hood',\r\n              # we're omitting 'mother' here for simplicity\r\n              #\u00a0(= substring grandmother)\r\n              ('Grandmother', 'Grandma', 'Granny'),\r\n              'wolf', 'woodsman']\r\n\r\ntext = \"\"\"\r\nOnce upon a time, there was a little girl who lived in a village near the forest.  Whenever she went out, the little girl wore a red riding cloak, so everyone in the village called her Little Red Riding Hood.\r\nOne morning, Little Red Riding Hood asked her mother if she could go to visit her grandmother as it had been awhile since they'd seen each other.\r\n\"That's a good idea,\" her mother said.  So they packed a nice basket for Little Red Riding Hood to take to her grandmother.\r\nWhen the basket was ready, the little girl put on her red cloak and kissed her mother goodbye.\r\n\"Remember, go straight to Grandma's house,\" her mother cautioned.  \"Don't dawdle along the way and please don't talk to strangers!  The woods are dangerous.\"\r\n\"Don't worry, mommy,\" said Little Red Riding Hood, \"I'll be careful.\"\r\nBut when Little Red Riding Hood noticed some lovely flowers in the woods, she forgot her promise to her mother.  She picked a few, watched the butterflies flit about for awhile, listened to the frogs croaking and then picked a few more.\r\nLittle Red Riding Hood was enjoying the warm summer day so much, that she didn't notice a dark shadow approaching out of the forest behind her...\r\nSuddenly, the wolf appeared beside her.\r\n\"What are you doing out here, little girl?\" the wolf asked in a voice as friendly as he could muster.\r\n\"I'm on my way to see my Grandma who lives through the forest, near the brook,\"  Little Red Riding Hood replied.\r\nThen she realized how late she was and quickly excused herself, rushing down the path to her Grandma's house.\r\nThe wolf, in the meantime, took a shortcut...\r\nThe wolf, a little out of breath from running, arrived at Grandma's and knocked lightly at the door.\r\n\"Oh thank goodness dear!  Come in, come in!  I was worried sick that something had happened to you in the forest,\" said Grandma thinking that the knock was her granddaughter.\r\nThe wolf let himself in.  Poor Granny did not have time to say another word, before the wolf gobbled her up!\r\nThe wolf let out a satisfied burp, and then poked through Granny's wardrobe to find a nightgown that he liked.  He added a frilly sleeping cap, and for good measure, dabbed some of Granny's perfume behind his pointy ears.\r\nA few minutes later, Red Riding Hood knocked on the door.  The wolf jumped into bed and pulled the covers over his nose.  \"Who is it?\" he called in a cackly voice.\r\n\"It's me, Little Red Riding Hood.\"\r\n\"Oh how lovely!  Do come in, my dear,\" croaked the wolf.\r\nWhen Little Red Riding Hood entered the little cottage, she could scarcely recognize her Grandmother.\r\n\"Grandmother!  Your voice sounds so odd.  Is something the matter?\" she asked.\r\n\"Oh, I just have touch of a cold,\" squeaked the wolf adding a cough at the end to prove the point.\r\n\"But Grandmother!  What big ears you have,\" said Little Red Riding Hood as she edged closer to the bed.\r\n\"The better to hear you with, my dear,\" replied the wolf.\r\n\"But Grandmother!  What big eyes you have,\" said Little Red Riding Hood.\r\n\"The better to see you with, my dear,\" replied the wolf.\r\n\"But Grandmother!  What big teeth you have,\" said Little Red Riding Hood her voice quivering slightly.\r\n\"The better to eat you with, my dear,\" roared the wolf and he leapt out of the bed and began to chase the little girl.\r\nAlmost too late, Little Red Riding Hood realized that the person in the bed was not her Grandmother, but a hungry wolf.\r\nShe ran across the room and through the door, shouting, \"Help!  Wolf!\" as loudly as she could.\r\nA woodsman who was chopping logs nearby heard her cry and ran towards the cottage as fast as he could.\r\nHe grabbed the wolf and made him spit out the poor Grandmother who was a bit frazzled by the whole experience, but still in one piece.\"Oh Grandma, I was so scared!\"  sobbed Little Red Riding Hood, \"I'll never speak to strangers or dawdle in the forest again.\"\r\n\"There, there, child.  You've learned an important lesson.  Thank goodness you shouted loud enough for this kind woodsman to hear you!\"\r\nThe woodsman knocked out the wolf and carried him deep into the forest where he wouldn't bother people any longer.\r\nLittle Red Riding Hood and her Grandmother had a nice lunch and a long chat.\r\n\"\"\"\r\n\r\n\r\ndef _is_char_in_text(line, character):\r\n\r\n    line = line.lower()\r\n\r\n    if isinstance(character, str):\r\n        character = character,\r\n    return any([synonym.lower() in line for synonym in character])\r\n\r\n\r\ndef _label(character):\r\n    \r\n    if isinstance(character, tuple):\r\n        character= character[0]\r\n    return character.lower()\r\n\r\ndef make_character_index(text=text, characters=CHARACTERS):\r\n    \"\"\"Return a dict with keys are characters (lowercased) and values\r\n       the lines they appear in sorted order.\r\n       Matches should be case insensitive.\r\n       If a character has multiple synonyms\r\n       - e.g. ('Grandmother', 'Grandma', 'Granny') -\r\n       then return the former as key.\r\n    \"\"\"\r\n    result=defaultdict(list)\r\n    for idx,line in enumerate(text.splitlines()):\r\n        # print(line)\r\n        for character in characters:\r\n            if _is_char_in_text(line, character):\r\n                result[_label(character)].append(idx)\r\n\r\n    return result \r\n\r\n\r\n# print(make_character_index())\r\n",
            "date": "2022-11-12 12:57:40.366731+00:00",
            "passed": true
        },
        {
            "bite": "Bite 156. Make an index of story characters",
            "code": "import re \r\nfrom collections import defaultdict\r\n\r\nCHARACTERS = ['Red Riding Hood',\r\n              # we're omitting 'mother' here for simplicity\r\n              #\u00a0(= substring grandmother)\r\n              ('Grandmother', 'Grandma', 'Granny'),\r\n              'wolf', 'woodsman']\r\n\r\ntext = \"\"\"\r\nOnce upon a time, there was a little girl who lived in a village near the forest.  Whenever she went out, the little girl wore a red riding cloak, so everyone in the village called her Little Red Riding Hood.\r\nOne morning, Little Red Riding Hood asked her mother if she could go to visit her grandmother as it had been awhile since they'd seen each other.\r\n\"That's a good idea,\" her mother said.  So they packed a nice basket for Little Red Riding Hood to take to her grandmother.\r\nWhen the basket was ready, the little girl put on her red cloak and kissed her mother goodbye.\r\n\"Remember, go straight to Grandma's house,\" her mother cautioned.  \"Don't dawdle along the way and please don't talk to strangers!  The woods are dangerous.\"\r\n\"Don't worry, mommy,\" said Little Red Riding Hood, \"I'll be careful.\"\r\nBut when Little Red Riding Hood noticed some lovely flowers in the woods, she forgot her promise to her mother.  She picked a few, watched the butterflies flit about for awhile, listened to the frogs croaking and then picked a few more.\r\nLittle Red Riding Hood was enjoying the warm summer day so much, that she didn't notice a dark shadow approaching out of the forest behind her...\r\nSuddenly, the wolf appeared beside her.\r\n\"What are you doing out here, little girl?\" the wolf asked in a voice as friendly as he could muster.\r\n\"I'm on my way to see my Grandma who lives through the forest, near the brook,\"  Little Red Riding Hood replied.\r\nThen she realized how late she was and quickly excused herself, rushing down the path to her Grandma's house.\r\nThe wolf, in the meantime, took a shortcut...\r\nThe wolf, a little out of breath from running, arrived at Grandma's and knocked lightly at the door.\r\n\"Oh thank goodness dear!  Come in, come in!  I was worried sick that something had happened to you in the forest,\" said Grandma thinking that the knock was her granddaughter.\r\nThe wolf let himself in.  Poor Granny did not have time to say another word, before the wolf gobbled her up!\r\nThe wolf let out a satisfied burp, and then poked through Granny's wardrobe to find a nightgown that he liked.  He added a frilly sleeping cap, and for good measure, dabbed some of Granny's perfume behind his pointy ears.\r\nA few minutes later, Red Riding Hood knocked on the door.  The wolf jumped into bed and pulled the covers over his nose.  \"Who is it?\" he called in a cackly voice.\r\n\"It's me, Little Red Riding Hood.\"\r\n\"Oh how lovely!  Do come in, my dear,\" croaked the wolf.\r\nWhen Little Red Riding Hood entered the little cottage, she could scarcely recognize her Grandmother.\r\n\"Grandmother!  Your voice sounds so odd.  Is something the matter?\" she asked.\r\n\"Oh, I just have touch of a cold,\" squeaked the wolf adding a cough at the end to prove the point.\r\n\"But Grandmother!  What big ears you have,\" said Little Red Riding Hood as she edged closer to the bed.\r\n\"The better to hear you with, my dear,\" replied the wolf.\r\n\"But Grandmother!  What big eyes you have,\" said Little Red Riding Hood.\r\n\"The better to see you with, my dear,\" replied the wolf.\r\n\"But Grandmother!  What big teeth you have,\" said Little Red Riding Hood her voice quivering slightly.\r\n\"The better to eat you with, my dear,\" roared the wolf and he leapt out of the bed and began to chase the little girl.\r\nAlmost too late, Little Red Riding Hood realized that the person in the bed was not her Grandmother, but a hungry wolf.\r\nShe ran across the room and through the door, shouting, \"Help!  Wolf!\" as loudly as she could.\r\nA woodsman who was chopping logs nearby heard her cry and ran towards the cottage as fast as he could.\r\nHe grabbed the wolf and made him spit out the poor Grandmother who was a bit frazzled by the whole experience, but still in one piece.\"Oh Grandma, I was so scared!\"  sobbed Little Red Riding Hood, \"I'll never speak to strangers or dawdle in the forest again.\"\r\n\"There, there, child.  You've learned an important lesson.  Thank goodness you shouted loud enough for this kind woodsman to hear you!\"\r\nThe woodsman knocked out the wolf and carried him deep into the forest where he wouldn't bother people any longer.\r\nLittle Red Riding Hood and her Grandmother had a nice lunch and a long chat.\r\n\"\"\"\r\n\r\n\r\ndef _character_in_text(line, character):\r\n\r\n    match=False\r\n    line = line.lower()\r\n    \r\n    if isinstance(character, str):\r\n        character = character,\r\n    \r\n    return any([synonym.lower() in line for synonym in character])\r\n\r\n\r\ndef _label(character):\r\n    if isinstance(character, str):\r\n        return character.lower()\r\n    if isinstance(character, tuple):\r\n        return character[0].lower()\r\n            \r\n\r\ndef make_character_index(text=text, characters=CHARACTERS):\r\n    \"\"\"Return a dict with keys are characters (lowercased) and values\r\n       the lines they appear in sorted order.\r\n       Matches should be case insensitive.\r\n       If a character has multiple synonyms\r\n       - e.g. ('Grandmother', 'Grandma', 'Granny') -\r\n       then return the former as key.\r\n    \"\"\"\r\n    result=defaultdict(list)\r\n    for line_num,line in enumerate(text.splitlines()):\r\n        # print(line)\r\n        for character in characters:\r\n            if _character_in_text(line, character):\r\n                result[_label(character)].append(line_num)\r\n\r\n    return result \r\n\r\n    \"\"\"\r\n        [1, 2, 3, 6, 7, 8, 11, 18, 19, 21, 24, 26, 28, 30, 33, 36],\r\n        [2, 3, 5, 11, 12, 14, 15, 16, 17, 21, 22, 24, 26, 28, 30, 33, 36],\r\n        [9, 10, 13, 14, 16, 17, 18, 20, 23, 25, 27, 29, 30, 31, 33, 35],\r\n        [32, 34, 35]\r\n    \"\"\"\r\n    \r\nprint(make_character_index())\r\n",
            "date": "2022-11-12 12:53:44.186783+00:00",
            "passed": true
        },
        {
            "bite": "Bite 156. Make an index of story characters",
            "code": "import re \r\nfrom collections import defaultdict\r\n\r\nCHARACTERS = ['Red Riding Hood',\r\n              # we're omitting 'mother' here for simplicity\r\n              #\u00a0(= substring grandmother)\r\n              ('Grandmother', 'Grandma', 'Granny'),\r\n              'wolf', 'woodsman']\r\n\r\ntext = \"\"\"\r\nOnce upon a time, there was a little girl who lived in a village near the forest.  Whenever she went out, the little girl wore a red riding cloak, so everyone in the village called her Little Red Riding Hood.\r\nOne morning, Little Red Riding Hood asked her mother if she could go to visit her grandmother as it had been awhile since they'd seen each other.\r\n\"That's a good idea,\" her mother said.  So they packed a nice basket for Little Red Riding Hood to take to her grandmother.\r\nWhen the basket was ready, the little girl put on her red cloak and kissed her mother goodbye.\r\n\"Remember, go straight to Grandma's house,\" her mother cautioned.  \"Don't dawdle along the way and please don't talk to strangers!  The woods are dangerous.\"\r\n\"Don't worry, mommy,\" said Little Red Riding Hood, \"I'll be careful.\"\r\nBut when Little Red Riding Hood noticed some lovely flowers in the woods, she forgot her promise to her mother.  She picked a few, watched the butterflies flit about for awhile, listened to the frogs croaking and then picked a few more.\r\nLittle Red Riding Hood was enjoying the warm summer day so much, that she didn't notice a dark shadow approaching out of the forest behind her...\r\nSuddenly, the wolf appeared beside her.\r\n\"What are you doing out here, little girl?\" the wolf asked in a voice as friendly as he could muster.\r\n\"I'm on my way to see my Grandma who lives through the forest, near the brook,\"  Little Red Riding Hood replied.\r\nThen she realized how late she was and quickly excused herself, rushing down the path to her Grandma's house.\r\nThe wolf, in the meantime, took a shortcut...\r\nThe wolf, a little out of breath from running, arrived at Grandma's and knocked lightly at the door.\r\n\"Oh thank goodness dear!  Come in, come in!  I was worried sick that something had happened to you in the forest,\" said Grandma thinking that the knock was her granddaughter.\r\nThe wolf let himself in.  Poor Granny did not have time to say another word, before the wolf gobbled her up!\r\nThe wolf let out a satisfied burp, and then poked through Granny's wardrobe to find a nightgown that he liked.  He added a frilly sleeping cap, and for good measure, dabbed some of Granny's perfume behind his pointy ears.\r\nA few minutes later, Red Riding Hood knocked on the door.  The wolf jumped into bed and pulled the covers over his nose.  \"Who is it?\" he called in a cackly voice.\r\n\"It's me, Little Red Riding Hood.\"\r\n\"Oh how lovely!  Do come in, my dear,\" croaked the wolf.\r\nWhen Little Red Riding Hood entered the little cottage, she could scarcely recognize her Grandmother.\r\n\"Grandmother!  Your voice sounds so odd.  Is something the matter?\" she asked.\r\n\"Oh, I just have touch of a cold,\" squeaked the wolf adding a cough at the end to prove the point.\r\n\"But Grandmother!  What big ears you have,\" said Little Red Riding Hood as she edged closer to the bed.\r\n\"The better to hear you with, my dear,\" replied the wolf.\r\n\"But Grandmother!  What big eyes you have,\" said Little Red Riding Hood.\r\n\"The better to see you with, my dear,\" replied the wolf.\r\n\"But Grandmother!  What big teeth you have,\" said Little Red Riding Hood her voice quivering slightly.\r\n\"The better to eat you with, my dear,\" roared the wolf and he leapt out of the bed and began to chase the little girl.\r\nAlmost too late, Little Red Riding Hood realized that the person in the bed was not her Grandmother, but a hungry wolf.\r\nShe ran across the room and through the door, shouting, \"Help!  Wolf!\" as loudly as she could.\r\nA woodsman who was chopping logs nearby heard her cry and ran towards the cottage as fast as he could.\r\nHe grabbed the wolf and made him spit out the poor Grandmother who was a bit frazzled by the whole experience, but still in one piece.\"Oh Grandma, I was so scared!\"  sobbed Little Red Riding Hood, \"I'll never speak to strangers or dawdle in the forest again.\"\r\n\"There, there, child.  You've learned an important lesson.  Thank goodness you shouted loud enough for this kind woodsman to hear you!\"\r\nThe woodsman knocked out the wolf and carried him deep into the forest where he wouldn't bother people any longer.\r\nLittle Red Riding Hood and her Grandmother had a nice lunch and a long chat.\r\n\"\"\"\r\n\r\n\r\ndef _character_in_text(line, character):\r\n\r\n    match=False\r\n    line = line.lower()\r\n    \r\n    if isinstance(character, str):\r\n        character = character,\r\n    \r\n    return any([synonym.lower() in line for synonym in character])\r\n\r\n\r\ndef _lower(character):\r\n    if isinstance(character, str):\r\n        return character.lower()\r\n    if isinstance(character, tuple):\r\n        return tuple(synonym.lower() for synonym in character)\r\n            \r\n\r\ndef make_character_index(text=text, characters=CHARACTERS):\r\n    \"\"\"Return a dict with keys are characters (lowercased) and values\r\n       the lines they appear in sorted order.\r\n       Matches should be case insensitive.\r\n       If a character has multiple synonyms\r\n       - e.g. ('Grandmother', 'Grandma', 'Granny') -\r\n       then return the former as key.\r\n    \"\"\"\r\n    result=defaultdict(list)\r\n    for line_num,line in enumerate(text.splitlines()):\r\n        # print(line)\r\n        for character in characters:\r\n            if _character_in_text(line, character):\r\n                result[_lower(character)].append(line_num)\r\n\r\n    return result \r\n\r\n    \"\"\"\r\n        [1, 2, 3, 6, 7, 8, 11, 18, 19, 21, 24, 26, 28, 30, 33, 36],\r\n        [2, 3, 5, 11, 12, 14, 15, 16, 17, 21, 22, 24, 26, 28, 30, 33, 36],\r\n        [9, 10, 13, 14, 16, 17, 18, 20, 23, 25, 27, 29, 30, 31, 33, 35],\r\n        [32, 34, 35]\r\n    \"\"\"\r\n    \r\nprint(make_character_index())\r\n",
            "date": "2022-11-12 12:52:06.716224+00:00",
            "passed": false
        },
        {
            "bite": "Bite 156. Make an index of story characters",
            "code": "import re \r\nfrom collections import defaultdict\r\n\r\nCHARACTERS = ['Red Riding Hood',\r\n              # we're omitting 'mother' here for simplicity\r\n              #\u00a0(= substring grandmother)\r\n              ('Grandmother', 'Grandma', 'Granny'),\r\n              'wolf', 'woodsman']\r\n\r\ntext = \"\"\"\r\nOnce upon a time, there was a little girl who lived in a village near the forest.  Whenever she went out, the little girl wore a red riding cloak, so everyone in the village called her Little Red Riding Hood.\r\nOne morning, Little Red Riding Hood asked her mother if she could go to visit her grandmother as it had been awhile since they'd seen each other.\r\n\"That's a good idea,\" her mother said.  So they packed a nice basket for Little Red Riding Hood to take to her grandmother.\r\nWhen the basket was ready, the little girl put on her red cloak and kissed her mother goodbye.\r\n\"Remember, go straight to Grandma's house,\" her mother cautioned.  \"Don't dawdle along the way and please don't talk to strangers!  The woods are dangerous.\"\r\n\"Don't worry, mommy,\" said Little Red Riding Hood, \"I'll be careful.\"\r\nBut when Little Red Riding Hood noticed some lovely flowers in the woods, she forgot her promise to her mother.  She picked a few, watched the butterflies flit about for awhile, listened to the frogs croaking and then picked a few more.\r\nLittle Red Riding Hood was enjoying the warm summer day so much, that she didn't notice a dark shadow approaching out of the forest behind her...\r\nSuddenly, the wolf appeared beside her.\r\n\"What are you doing out here, little girl?\" the wolf asked in a voice as friendly as he could muster.\r\n\"I'm on my way to see my Grandma who lives through the forest, near the brook,\"  Little Red Riding Hood replied.\r\nThen she realized how late she was and quickly excused herself, rushing down the path to her Grandma's house.\r\nThe wolf, in the meantime, took a shortcut...\r\nThe wolf, a little out of breath from running, arrived at Grandma's and knocked lightly at the door.\r\n\"Oh thank goodness dear!  Come in, come in!  I was worried sick that something had happened to you in the forest,\" said Grandma thinking that the knock was her granddaughter.\r\nThe wolf let himself in.  Poor Granny did not have time to say another word, before the wolf gobbled her up!\r\nThe wolf let out a satisfied burp, and then poked through Granny's wardrobe to find a nightgown that he liked.  He added a frilly sleeping cap, and for good measure, dabbed some of Granny's perfume behind his pointy ears.\r\nA few minutes later, Red Riding Hood knocked on the door.  The wolf jumped into bed and pulled the covers over his nose.  \"Who is it?\" he called in a cackly voice.\r\n\"It's me, Little Red Riding Hood.\"\r\n\"Oh how lovely!  Do come in, my dear,\" croaked the wolf.\r\nWhen Little Red Riding Hood entered the little cottage, she could scarcely recognize her Grandmother.\r\n\"Grandmother!  Your voice sounds so odd.  Is something the matter?\" she asked.\r\n\"Oh, I just have touch of a cold,\" squeaked the wolf adding a cough at the end to prove the point.\r\n\"But Grandmother!  What big ears you have,\" said Little Red Riding Hood as she edged closer to the bed.\r\n\"The better to hear you with, my dear,\" replied the wolf.\r\n\"But Grandmother!  What big eyes you have,\" said Little Red Riding Hood.\r\n\"The better to see you with, my dear,\" replied the wolf.\r\n\"But Grandmother!  What big teeth you have,\" said Little Red Riding Hood her voice quivering slightly.\r\n\"The better to eat you with, my dear,\" roared the wolf and he leapt out of the bed and began to chase the little girl.\r\nAlmost too late, Little Red Riding Hood realized that the person in the bed was not her Grandmother, but a hungry wolf.\r\nShe ran across the room and through the door, shouting, \"Help!  Wolf!\" as loudly as she could.\r\nA woodsman who was chopping logs nearby heard her cry and ran towards the cottage as fast as he could.\r\nHe grabbed the wolf and made him spit out the poor Grandmother who was a bit frazzled by the whole experience, but still in one piece.\"Oh Grandma, I was so scared!\"  sobbed Little Red Riding Hood, \"I'll never speak to strangers or dawdle in the forest again.\"\r\n\"There, there, child.  You've learned an important lesson.  Thank goodness you shouted loud enough for this kind woodsman to hear you!\"\r\nThe woodsman knocked out the wolf and carried him deep into the forest where he wouldn't bother people any longer.\r\nLittle Red Riding Hood and her Grandmother had a nice lunch and a long chat.\r\n\"\"\"\r\n\r\n\r\ndef _character_in_text(line, character):\r\n\r\n    match=False\r\n    line = line.lower()\r\n    \r\n    if isinstance(character, str):\r\n        character = character,\r\n    \r\n    return any([synonym.lower() in line for synonym in character])\r\n\r\n\r\ndef _lower(character):\r\n    if isinstance(character, str):\r\n        return character.lower()\r\n    if isinstance(character, tuple):\r\n        return tuple(synonym.lower() for synonym in character)\r\n            \r\n\r\ndef make_character_index(text=text, characters=CHARACTERS):\r\n    \"\"\"Return a dict with keys are characters (lowercased) and values\r\n       the lines they appear in sorted order.\r\n       Matches should be case insensitive.\r\n       If a character has multiple synonyms\r\n       - e.g. ('Grandmother', 'Grandma', 'Granny') -\r\n       then return the former as key.\r\n    \"\"\"\r\n    result=defaultdict(list)\r\n    for line_num,line in enumerate(text.splitlines()):\r\n        # print(line)\r\n        for character in characters:\r\n            if _character_in_text(line, character):\r\n                result[_lower(character)].append(line_num)\r\n\r\n    return result \r\n\r\n    \r\nprint(make_character_index())\r\n",
            "date": "2022-11-12 12:48:09.520261+00:00",
            "passed": false
        },
        {
            "bite": "Bite 156. Make an index of story characters",
            "code": "import re \r\nfrom collections import defaultdict\r\n\r\nCHARACTERS = ['Red Riding Hood',\r\n              # we're omitting 'mother' here for simplicity\r\n              #\u00a0(= substring grandmother)\r\n              ('Grandmother', 'Grandma', 'Granny'),\r\n              'wolf', 'woodsman']\r\n\r\ntext = \"\"\"\r\nOnce upon a time, there was a little girl who lived in a village near the forest.  Whenever she went out, the little girl wore a red riding cloak, so everyone in the village called her Little Red Riding Hood.\r\nOne morning, Little Red Riding Hood asked her mother if she could go to visit her grandmother as it had been awhile since they'd seen each other.\r\n\"That's a good idea,\" her mother said.  So they packed a nice basket for Little Red Riding Hood to take to her grandmother.\r\nWhen the basket was ready, the little girl put on her red cloak and kissed her mother goodbye.\r\n\"Remember, go straight to Grandma's house,\" her mother cautioned.  \"Don't dawdle along the way and please don't talk to strangers!  The woods are dangerous.\"\r\n\"Don't worry, mommy,\" said Little Red Riding Hood, \"I'll be careful.\"\r\nBut when Little Red Riding Hood noticed some lovely flowers in the woods, she forgot her promise to her mother.  She picked a few, watched the butterflies flit about for awhile, listened to the frogs croaking and then picked a few more.\r\nLittle Red Riding Hood was enjoying the warm summer day so much, that she didn't notice a dark shadow approaching out of the forest behind her...\r\nSuddenly, the wolf appeared beside her.\r\n\"What are you doing out here, little girl?\" the wolf asked in a voice as friendly as he could muster.\r\n\"I'm on my way to see my Grandma who lives through the forest, near the brook,\"  Little Red Riding Hood replied.\r\nThen she realized how late she was and quickly excused herself, rushing down the path to her Grandma's house.\r\nThe wolf, in the meantime, took a shortcut...\r\nThe wolf, a little out of breath from running, arrived at Grandma's and knocked lightly at the door.\r\n\"Oh thank goodness dear!  Come in, come in!  I was worried sick that something had happened to you in the forest,\" said Grandma thinking that the knock was her granddaughter.\r\nThe wolf let himself in.  Poor Granny did not have time to say another word, before the wolf gobbled her up!\r\nThe wolf let out a satisfied burp, and then poked through Granny's wardrobe to find a nightgown that he liked.  He added a frilly sleeping cap, and for good measure, dabbed some of Granny's perfume behind his pointy ears.\r\nA few minutes later, Red Riding Hood knocked on the door.  The wolf jumped into bed and pulled the covers over his nose.  \"Who is it?\" he called in a cackly voice.\r\n\"It's me, Little Red Riding Hood.\"\r\n\"Oh how lovely!  Do come in, my dear,\" croaked the wolf.\r\nWhen Little Red Riding Hood entered the little cottage, she could scarcely recognize her Grandmother.\r\n\"Grandmother!  Your voice sounds so odd.  Is something the matter?\" she asked.\r\n\"Oh, I just have touch of a cold,\" squeaked the wolf adding a cough at the end to prove the point.\r\n\"But Grandmother!  What big ears you have,\" said Little Red Riding Hood as she edged closer to the bed.\r\n\"The better to hear you with, my dear,\" replied the wolf.\r\n\"But Grandmother!  What big eyes you have,\" said Little Red Riding Hood.\r\n\"The better to see you with, my dear,\" replied the wolf.\r\n\"But Grandmother!  What big teeth you have,\" said Little Red Riding Hood her voice quivering slightly.\r\n\"The better to eat you with, my dear,\" roared the wolf and he leapt out of the bed and began to chase the little girl.\r\nAlmost too late, Little Red Riding Hood realized that the person in the bed was not her Grandmother, but a hungry wolf.\r\nShe ran across the room and through the door, shouting, \"Help!  Wolf!\" as loudly as she could.\r\nA woodsman who was chopping logs nearby heard her cry and ran towards the cottage as fast as he could.\r\nHe grabbed the wolf and made him spit out the poor Grandmother who was a bit frazzled by the whole experience, but still in one piece.\"Oh Grandma, I was so scared!\"  sobbed Little Red Riding Hood, \"I'll never speak to strangers or dawdle in the forest again.\"\r\n\"There, there, child.  You've learned an important lesson.  Thank goodness you shouted loud enough for this kind woodsman to hear you!\"\r\nThe woodsman knocked out the wolf and carried him deep into the forest where he wouldn't bother people any longer.\r\nLittle Red Riding Hood and her Grandmother had a nice lunch and a long chat.\r\n\"\"\"\r\n\r\n\r\ndef _character_in_text(line, character):\r\n    # print(character)\r\n    match=False\r\n    line = line.lower()\r\n    if isinstance(character,tuple):\r\n        match= any([synonym.lower() in line for synonym in character])\r\n    if isinstance(character, str):\r\n        match= character.lower() in line\r\n    # print(match)\r\n    return match\r\n\r\ndef make_character_index(text=text, characters=CHARACTERS):\r\n    \"\"\"Return a dict with keys are characters (lowercased) and values\r\n       the lines they appear in sorted order.\r\n       Matches should be case insensitive.\r\n       If a character has multiple synonyms\r\n       - e.g. ('Grandmother', 'Grandma', 'Granny') -\r\n       then return the former as key.\r\n    \"\"\"\r\n    result=defaultdict(list)\r\n    for line_num,line in enumerate(text.splitlines()):\r\n        # print(line)\r\n        for character in characters:\r\n            if _character_in_text(line, character):\r\n                result[character].append(line_num)\r\n\r\n    return result \r\n\r\n    \r\nprint(make_character_index())\r\n",
            "date": "2022-11-12 12:39:58.096240+00:00",
            "passed": false
        },
        {
            "bite": "Bite 257. Extract users dict from a multiline string",
            "code": "import re        \r\n\r\ndef get_users(passwd: str) -> dict:\r\n    \"\"\"Split password output by newline,\r\n      extract user and name (1st and 5th columns),\r\n      strip trailing commas from name,\r\n      replace multiple commas in name with a single space\r\n      return dict of keys = user, values = name.\r\n    \"\"\"\r\n    result_dict={}\r\n    for line in passwd.strip().splitlines():\r\n        user, _, _, _, name, *_ =line.split(':')\r\n        name = re.sub(',+', ' ', name.rstrip(',')) or 'unknown'\r\n        result_dict[user]=name\r\n\r\n    return result_dict\r\n\r\n\r\ntest= \"\"\"\r\npostfix:x:108:112::/var/spool/postfix:/bin/false\r\nssh-rsa:x:1004:1004::/home/ssh-rsa:/bin/bash\r\nartagnon:x:1005:1005:Ramkumar R,,,,Git GSOC:/home/artagnon:/bin/bash\r\n\"\"\"\r\n\r\nprint(get_users(test))",
            "date": "2022-11-12 09:30:40.765619+00:00",
            "passed": true
        },
        {
            "bite": "Bite 257. Extract users dict from a multiline string",
            "code": "import re        \r\n\r\ndef get_users(passwd: str) -> dict:\r\n    \"\"\"Split password output by newline,\r\n      extract user and name (1st and 5th columns),\r\n      strip trailing commas from name,\r\n      replace multiple commas in name with a single space\r\n      return dict of keys = user, values = name.\r\n    \"\"\"\r\n    result_dict={}\r\n    for line in passwd.splitlines():\r\n        if line:\r\n            user, _, _, _, name, *_ =line.split(':')\r\n            if name:\r\n                name = re.sub(',{2,}', ' ', name).rstrip()\r\n            else: \r\n                name ='unknown'\r\n            \r\n            result_dict[user]=name\r\n    return result_dict\r\n\r\n\r\ntest= \"\"\"\r\npostfix:x:108:112::/var/spool/postfix:/bin/false\r\nssh-rsa:x:1004:1004::/home/ssh-rsa:/bin/bash\r\nartagnon:x:1005:1005:Ramkumar R,,,,Git GSOC:/home/artagnon:/bin/bash\r\n\"\"\"\r\n\r\nprint(get_users(test))",
            "date": "2022-11-12 09:24:33.368235+00:00",
            "passed": true
        },
        {
            "bite": "Bite 257. Extract users dict from a multiline string",
            "code": "import re        \r\n\r\ndef get_users(passwd: str) -> dict:\r\n    \"\"\"Split password output by newline,\r\n      extract user and name (1st and 5th columns),\r\n      strip trailing commas from name,\r\n      replace multiple commas in name with a single space\r\n      return dict of keys = user, values = name.\r\n    \"\"\"\r\n    result_dict={}\r\n    for line in passwd.splitlines():\r\n        if line:\r\n            user, _, _, _, name, *_ =line.split(':')\r\n            if name:\r\n                name = re.sub(',{2,}', ' ', name)\r\n            else: \r\n                name ='unknown'\r\n            \r\n            result_dict[user]=name\r\n    return result_dict\r\n\r\n\r\ntest= \"\"\"\r\npostfix:x:108:112::/var/spool/postfix:/bin/false\r\nssh-rsa:x:1004:1004::/home/ssh-rsa:/bin/bash\r\nartagnon:x:1005:1005:Ramkumar R,,,,Git GSOC:/home/artagnon:/bin/bash\r\n\"\"\"\r\n\r\nprint(get_users(test))",
            "date": "2022-11-12 09:23:52.958516+00:00",
            "passed": false
        },
        {
            "bite": "Bite 324. Pretty string",
            "code": "import pprint\r\nfrom typing import Any\r\n\r\n\r\ndef pretty_string(obj: Any) -> str:\r\n    # TODO: your code\r\n    return pprint.pformat(obj, width=60, depth = 2, sort_dicts= True)\r\n   \r\n\"\"\" \r\nd={\"Z\": \"Z\"*40,\r\n       \"B\": [1,[2,[3]]],\r\n       \"A\": \"A\"*40}\r\nprint(d)\r\nprint(pretty_string(d))\r\n\"\"\"",
            "date": "2022-11-11 23:04:12.657227+00:00",
            "passed": true
        },
        {
            "bite": "Bite 324. Pretty string",
            "code": "import pprint\r\nfrom typing import Any\r\n\r\n\r\ndef pretty_string(obj: Any) -> str:\r\n    # TODO: your code\r\n    return pprint.pformat(obj, width=60, depth = 2, sort_dicts= True)\r\n    \r\nd={\"Z\": \"Z\"*40,\r\n       \"B\": [1,[2,[3]]],\r\n       \"A\": \"A\"*40}\r\nprint(d)\r\nprint(pretty_string(d))",
            "date": "2022-11-11 23:03:58.961097+00:00",
            "passed": true
        },
        {
            "bite": "Bite 150. Turn messy CSV into JSON",
            "code": "import json\r\nimport re\r\nfrom pprint import pprint\r\n\r\nmembers = \"\"\"\r\nid,first_name,last_name,email\r\n1,Junie,Kybert;jkybert0@army.mil\r\n2,Sid,Churching|schurching1@tumblr.com\r\n3,Cherry;Dudbridge,cdudbridge2@nifty.com\r\n4,Merrilee,Kleiser;mkleiser3@reference.com\r\n5,Umeko,Cray;ucray4@foxnews.com\r\n6,Jenifer,Dale|jdale@hubpages.com\r\n7,Deeanne;Gabbett,dgabbett6@ucoz.com\r\n8,Hymie,Valentin;hvalentin7@blogs.com\r\n9,Alphonso,Berwick|aberwick8@symantec.com\r\n10,Wyn;Serginson,wserginson9@naver.com\r\n\"\"\"\r\n\r\n\r\ndef convert_to_json(members=members):\r\n    \r\n    data=[]\r\n    for i,line in enumerate(members.lstrip().splitlines()):\r\n        words = re.split('[,;|]',line)\r\n        if i==0:\r\n            headers=words\r\n        else:\r\n            item=dict((key,value) for key, value in zip(headers,words))\r\n            data.append(item)\r\n    \r\n    return json.dumps(data, indent=4)\r\n\r\npprint(convert_to_json())",
            "date": "2022-11-11 22:51:22.234855+00:00",
            "passed": true
        },
        {
            "bite": "Bite 150. Turn messy CSV into JSON",
            "code": "import json\r\nimport re\r\nfrom pprint import pprint\r\n\r\nmembers = \"\"\"\r\nid,first_name,last_name,email\r\n1,Junie,Kybert;jkybert0@army.mil\r\n2,Sid,Churching|schurching1@tumblr.com\r\n3,Cherry;Dudbridge,cdudbridge2@nifty.com\r\n4,Merrilee,Kleiser;mkleiser3@reference.com\r\n5,Umeko,Cray;ucray4@foxnews.com\r\n6,Jenifer,Dale|jdale@hubpages.com\r\n7,Deeanne;Gabbett,dgabbett6@ucoz.com\r\n8,Hymie,Valentin;hvalentin7@blogs.com\r\n9,Alphonso,Berwick|aberwick8@symantec.com\r\n10,Wyn;Serginson,wserginson9@naver.com\r\n\"\"\"\r\n\r\n\r\ndef convert_to_json(members=members):\r\n    \r\n    lst=[]\r\n    for i,line in enumerate(members.lstrip().splitlines()):\r\n        words = re.split('[,;|]',line)\r\n        if i==0:\r\n            headers=words\r\n        else:\r\n            item=dict((key,value) for key, value in zip(headers,words))\r\n            lst.append(item)\r\n    \r\n    return lst\r\n\r\npprint(convert_to_json())",
            "date": "2022-11-11 22:49:30.780808+00:00",
            "passed": false
        },
        {
            "bite": "Bite 129. Analyze Stock Data",
            "code": "import requests\r\nfrom collections import Counter\r\n\r\nSTOCK_DATA = 'https://bites-data.s3.us-east-2.amazonaws.com/stocks.json'\r\n\r\n# pre-work: load JSON data into program\r\n\r\nwith requests.Session() as s:\r\n    data = s.get(STOCK_DATA).json()\r\n\r\n\r\n# your turn:\r\n\r\ndef _cap_str_to_mln_float(cap):\r\n    \"\"\"If cap = 'n/a' return 0, else:\r\n       - strip off leading '$',\r\n       - if 'M' in cap value, strip it off and return value as float,\r\n       - if 'B', strip it off, multiply by 1,000 and return\r\n         value as float\"\"\"\r\n    if cap == \"n/a\":\r\n        return 0.0\r\n    num=float(cap[1:-1])\r\n    if cap[-1].lower() == 'b':\r\n        num*=1000\r\n    return round(num,2)\r\n\r\n\r\ndef get_industry_cap(industry):\r\n    \"\"\"Return the sum of all cap values for given industry, use\r\n       the _cap_str_to_mln_float to parse the cap values,\r\n       return a float with 2 digit precision\"\"\"\r\n    result =sum(_cap_str_to_mln_float(item['cap']) for item in data if item['industry'] == industry)\r\n    return round(result,2)\r\n\r\n\r\ndef get_stock_symbol_with_highest_cap():\r\n    \"\"\"Return the stock symbol (e.g. PACD) with the highest cap, use\r\n       the _cap_str_to_mln_float to parse the cap values\"\"\"\r\n    symbol_and_cap_dict = dict((item['symbol'], _cap_str_to_mln_float(item['cap'])) for item in data )\r\n    # print(symbol_and_cap_dict)\r\n    return max(symbol_and_cap_dict, key=symbol_and_cap_dict.get)\r\n\r\n\r\ndef get_sectors_with_max_and_min_stocks():\r\n    \"\"\"Return a tuple of the sectors with most and least stocks,\r\n       discard n/a\"\"\"\r\n    sectors_sorted_per_size = Counter(item['sector'] for item in data if item['sector'] != \"n/a\").most_common()\r\n    return sectors_sorted_per_size[0][0], sectors_sorted_per_size[-1][0]\r\n\r\ntest = ['$1M', '$1B', 'n/a']\r\nfor item in test: \r\n    print(_cap_str_to_mln_float(item))\r\n    \r\nprint(get_industry_cap(\"Medical/Dental Instruments\"))\r\nprint(get_stock_symbol_with_highest_cap())\r\nprint(get_sectors_with_max_and_min_stocks())",
            "date": "2022-11-11 22:27:52.363930+00:00",
            "passed": true
        },
        {
            "bite": "Bite 129. Analyze Stock Data",
            "code": "import requests\r\nfrom collections import Counter\r\n\r\nSTOCK_DATA = 'https://bites-data.s3.us-east-2.amazonaws.com/stocks.json'\r\n\r\n# pre-work: load JSON data into program\r\n\r\nwith requests.Session() as s:\r\n    data = s.get(STOCK_DATA).json()\r\n\r\n\r\n# your turn:\r\n\r\ndef _cap_str_to_mln_float(cap):\r\n    \"\"\"If cap = 'n/a' return 0, else:\r\n       - strip off leading '$',\r\n       - if 'M' in cap value, strip it off and return value as float,\r\n       - if 'B', strip it off, multiply by 1,000 and return\r\n         value as float\"\"\"\r\n    if cap == \"n/a\":\r\n        return 0.0\r\n    num=float(cap[1:-1])\r\n    if cap[-1].lower() == 'b':\r\n        num*=1000\r\n    return round(num,2)\r\n\r\n\r\ndef get_industry_cap(industry):\r\n    \"\"\"Return the sum of all cap values for given industry, use\r\n       the _cap_str_to_mln_float to parse the cap values,\r\n       return a float with 2 digit precision\"\"\"\r\n    return round(sum(_cap_str_to_mln_float(item['cap']) for item in data if item['industry'] == industry),2)\r\n\r\n\r\ndef get_stock_symbol_with_highest_cap():\r\n    \"\"\"Return the stock symbol (e.g. PACD) with the highest cap, use\r\n       the _cap_str_to_mln_float to parse the cap values\"\"\"\r\n    symbol_and_cap_dict = dict((item['symbol'], _cap_str_to_mln_float(item['cap'])) for item in data )\r\n    # print(symbol_and_cap_dict)\r\n    return max(symbol_and_cap_dict, key=symbol_and_cap_dict.get)\r\n\r\n\r\ndef get_sectors_with_max_and_min_stocks():\r\n    \"\"\"Return a tuple of the sectors with most and least stocks,\r\n       discard n/a\"\"\"\r\n    sectors_sorted_per_size = Counter(item['sector'] for item in data if item['sector'] != \"n/a\").most_common()\r\n    return sectors_sorted_per_size[0][0], sectors_sorted_per_size[-1][0]\r\n\r\ntest = ['$1M', '$1B', 'n/a']\r\nfor item in test: \r\n    print(_cap_str_to_mln_float(item))\r\n    \r\nprint(get_industry_cap(\"Medical/Dental Instruments\"))\r\nprint(get_stock_symbol_with_highest_cap())\r\nprint(get_sectors_with_max_and_min_stocks())",
            "date": "2022-11-11 22:27:01.801376+00:00",
            "passed": true
        },
        {
            "bite": "Bite 129. Analyze Stock Data",
            "code": "import requests\r\nfrom collections import Counter\r\n\r\nSTOCK_DATA = 'https://bites-data.s3.us-east-2.amazonaws.com/stocks.json'\r\n\r\n# pre-work: load JSON data into program\r\n\r\nwith requests.Session() as s:\r\n    data = s.get(STOCK_DATA).json()\r\n\r\n\r\n# your turn:\r\n\r\ndef _cap_str_to_mln_float(cap):\r\n    \"\"\"If cap = 'n/a' return 0, else:\r\n       - strip off leading '$',\r\n       - if 'M' in cap value, strip it off and return value as float,\r\n       - if 'B', strip it off, multiply by 1,000 and return\r\n         value as float\"\"\"\r\n    if cap == \"n/a\":\r\n        return 0.0\r\n    num=float(cap[1:-1])\r\n    if cap[-1].lower() == 'b':\r\n        num*=1000\r\n    return round(num,2)\r\n\r\n\r\ndef get_industry_cap(industry):\r\n    \"\"\"Return the sum of all cap values for given industry, use\r\n       the _cap_str_to_mln_float to parse the cap values,\r\n       return a float with 2 digit precision\"\"\"\r\n    return sum(_cap_str_to_mln_float(item['cap']) for item in data if item['industry'] == industry)\r\n\r\n\r\ndef get_stock_symbol_with_highest_cap():\r\n    \"\"\"Return the stock symbol (e.g. PACD) with the highest cap, use\r\n       the _cap_str_to_mln_float to parse the cap values\"\"\"\r\n    symbol_and_cap_dict = dict((item['symbol'], _cap_str_to_mln_float(item['cap'])) for item in data )\r\n    # print(symbol_and_cap_dict)\r\n    return max(symbol_and_cap_dict, key=symbol_and_cap_dict.get)\r\n\r\n\r\ndef get_sectors_with_max_and_min_stocks():\r\n    \"\"\"Return a tuple of the sectors with most and least stocks,\r\n       discard n/a\"\"\"\r\n    sectors_sorted_per_size = Counter(item['sector'] for item in data if item['sector'] != \"n/a\").most_common()\r\n    return sectors_sorted_per_size[0][0], sectors_sorted_per_size[-1][0]\r\n\r\ntest = ['$1M', '$1B', 'n/a']\r\nfor item in test: \r\n    print(_cap_str_to_mln_float(item))\r\n    \r\nprint(get_industry_cap(\"Medical/Dental Instruments\"))\r\nprint(get_stock_symbol_with_highest_cap())\r\nprint(get_sectors_with_max_and_min_stocks())",
            "date": "2022-11-11 22:25:57.508021+00:00",
            "passed": false
        },
        {
            "bite": "Bite 129. Analyze Stock Data",
            "code": "import requests\r\nfrom collections import Counter\r\n\r\nSTOCK_DATA = 'https://bites-data.s3.us-east-2.amazonaws.com/stocks.json'\r\n\r\n# pre-work: load JSON data into program\r\n\r\nwith requests.Session() as s:\r\n    data = s.get(STOCK_DATA).json()\r\n\r\n\r\n# your turn:\r\n\r\ndef _cap_str_to_mln_float(cap):\r\n    \"\"\"If cap = 'n/a' return 0, else:\r\n       - strip off leading '$',\r\n       - if 'M' in cap value, strip it off and return value as float,\r\n       - if 'B', strip it off, multiply by 1,000 and return\r\n         value as float\"\"\"\r\n    if cap == \"n/a\":\r\n        return 0.0\r\n    num=float(cap[1:-1])\r\n    if cap[-1].lower() == 'b':\r\n        num*=1000\r\n    return num\r\n\r\n\r\ndef get_industry_cap(industry):\r\n    \"\"\"Return the sum of all cap values for given industry, use\r\n       the _cap_str_to_mln_float to parse the cap values,\r\n       return a float with 2 digit precision\"\"\"\r\n    return sum(_cap_str_to_mln_float(item['cap']) for item in data if item['industry'] == industry)\r\n\r\n\r\ndef get_stock_symbol_with_highest_cap():\r\n    \"\"\"Return the stock symbol (e.g. PACD) with the highest cap, use\r\n       the _cap_str_to_mln_float to parse the cap values\"\"\"\r\n    symbol_and_cap_dict = dict((item['symbol'], _cap_str_to_mln_float(item['cap'])) for item in data )\r\n    # print(symbol_and_cap_dict)\r\n    return max(symbol_and_cap_dict, key=symbol_and_cap_dict.get)\r\n\r\n\r\ndef get_sectors_with_max_and_min_stocks():\r\n    \"\"\"Return a tuple of the sectors with most and least stocks,\r\n       discard n/a\"\"\"\r\n    sectors_sorted_per_size = Counter(item['sector'] for item in data if item['sector'] != \"n/a\").most_common()\r\n    return sectors_sorted_per_size[0][0], sectors_sorted_per_size[-1][0]\r\n\r\ntest = ['$1M', '$1B', 'n/a']\r\nfor item in test: \r\n    print(_cap_str_to_mln_float(item))\r\n    \r\nprint(get_industry_cap(\"Medical/Dental Instruments\"))\r\nprint(get_stock_symbol_with_highest_cap())\r\nprint(get_sectors_with_max_and_min_stocks())",
            "date": "2022-11-11 22:25:22.632088+00:00",
            "passed": false
        },
        {
            "bite": "Bite 254. Global vs local variables",
            "code": "num_hundreds = -1\r\n\r\n\r\ndef sum_numbers(numbers: list) -> int:\r\n    \"\"\"Sums passed in numbers returning the total, also\r\n       update the global variable num_hundreds with the amount\r\n       of times 100 fits in total\"\"\"\r\n    global num_hundreds\r\n    result = sum(numbers)\r\n    num_hundreds+= result//100\r\n    return result\r\n\r\n\r\n\"\"\"\r\nfor i in range(5):\r\n    print(sum_numbers([10, 50, 90]))\r\n    print(f\"{num_hundreds=}\")\r\n\"\"\"",
            "date": "2022-11-11 21:39:22.152106+00:00",
            "passed": true
        },
        {
            "bite": "Bite 252. Let's play with Pandas Series",
            "code": "import numpy as np\r\nimport pandas as pd\r\n\r\n\r\ndef return_at_index(ser: pd.Series, idx: int) -> object:\r\n    \"\"\"Return the Object at the given index of the Series\r\n    If you want to be extra careful catch and raise an error if\r\n       the index does not exist.\r\n    \"\"\"\r\n    \r\n    try:\r\n        return ser.iloc[idx]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef get_slice(ser: pd.Series, start: int, end: int) -> pd.core.series.Series:\r\n    \"\"\"Return the slice of the given Series in the range between\r\n    start and end.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[start:end]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef get_slice_inclusive(ser: pd.Series,\r\n                        start: int, end: int) -> pd.core.series.Series:\r\n    \"\"\"Return the slice of the given Series in the range between\r\n    start and end inclusive.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[start:end+1]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef return_head(ser: pd.Series, num: int) -> pd.core.series.Series:\r\n    \"\"\"Return the first num elements of the given Series.\r\n    \"\"\"\r\n    return ser.head(num)\r\n\r\n\r\ndef return_tail(ser: pd.Series, num: int) -> pd.core.series.Series:\r\n    \"\"\"Return the last num elements of the given Series.\r\n    \"\"\"\r\n    return ser.tail(num)\r\n\r\n\r\ndef get_index(ser: pd.Series) -> pd.core.indexes.base.Index:\r\n    \"\"\"Return all indexes of the given Series.\r\n    \"\"\"\r\n    return ser.index\r\n\r\n\r\n\r\ndef get_values(ser: pd.Series) -> np.ndarray:\r\n    \"\"\"Return all the values of the given Series.\r\n    \"\"\"\r\n    return ser.values\r\n\r\n\r\ndef get_every_second_indexes(ser: pd.Series,\r\n                             even_index=True) -> pd.core.series.Series:\r\n    \"\"\"Return all rows where the index is either even or odd.\r\n    If even_index is True return every index where idx % 2 == 0\r\n    If even_index is False return every index where idx % 2 != 0\r\n    Assume default indexing i.e. 0 -> n\r\n    \"\"\"\r\n    if even_index:\r\n        rows = [idx%2==0 for idx in ser.index]\r\n    else:\r\n        rows = [idx%2!=0 for idx in ser.index]\r\n    return ser.iloc[rows]\r\n",
            "date": "2022-11-10 18:51:20.057531+00:00",
            "passed": true
        },
        {
            "bite": "Bite 252. Let's play with Pandas Series",
            "code": "import numpy as np\r\nimport pandas as pd\r\n\r\n\r\ndef return_at_index(ser: pd.Series, idx: int) -> object:\r\n    \"\"\"Return the Object at the given index of the Series\r\n    If you want to be extra careful catch and raise an error if\r\n       the index does not exist.\r\n    \"\"\"\r\n    \r\n    try:\r\n        return ser.iloc[idx]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef get_slice(ser: pd.Series, start: int, end: int) -> pd.core.series.Series:\r\n    \"\"\"Return the slice of the given Series in the range between\r\n    start and end.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[start:end]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef get_slice_inclusive(ser: pd.Series,\r\n                        start: int, end: int) -> pd.core.series.Series:\r\n    \"\"\"Return the slice of the given Series in the range between\r\n    start and end inclusive.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[start:end+1]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef return_head(ser: pd.Series, num: int) -> pd.core.series.Series:\r\n    \"\"\"Return the first num elements of the given Series.\r\n    \"\"\"\r\n    return ser.head[num]\r\n\r\n\r\ndef return_tail(ser: pd.Series, num: int) -> pd.core.series.Series:\r\n    \"\"\"Return the last num elements of the given Series.\r\n    \"\"\"\r\n    return ser.tail[num]\r\n\r\n\r\ndef get_index(ser: pd.Series) -> pd.core.indexes.base.Index:\r\n    \"\"\"Return all indexes of the given Series.\r\n    \"\"\"\r\n    return ser.index\r\n\r\n\r\n\r\ndef get_values(ser: pd.Series) -> np.ndarray:\r\n    \"\"\"Return all the values of the given Series.\r\n    \"\"\"\r\n    return ser.values\r\n\r\n\r\ndef get_every_second_indexes(ser: pd.Series,\r\n                             even_index=True) -> pd.core.series.Series:\r\n    \"\"\"Return all rows where the index is either even or odd.\r\n    If even_index is True return every index where idx % 2 == 0\r\n    If even_index is False return every index where idx % 2 != 0\r\n    Assume default indexing i.e. 0 -> n\r\n    \"\"\"\r\n    if even_index:\r\n        rows = [idx%2==0 for idx in ser.index]\r\n    else:\r\n        rows = [idx%2!=0 for idx in ser.index]\r\n    return ser.iloc[rows]\r\n",
            "date": "2022-11-10 18:50:09.114921+00:00",
            "passed": false
        },
        {
            "bite": "Bite 252. Let's play with Pandas Series",
            "code": "import numpy as np\r\nimport pandas as pd\r\n\r\n\r\ndef return_at_index(ser: pd.Series, idx: int) -> object:\r\n    \"\"\"Return the Object at the given index of the Series\r\n    If you want to be extra careful catch and raise an error if\r\n       the index does not exist.\r\n    \"\"\"\r\n    \r\n    try:\r\n        return ser.iloc[idx]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef get_slice(ser: pd.Series, start: int, end: int) -> pd.core.series.Series:\r\n    \"\"\"Return the slice of the given Series in the range between\r\n    start and end.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[start:end]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef get_slice_inclusive(ser: pd.Series,\r\n                        start: int, end: int) -> pd.core.series.Series:\r\n    \"\"\"Return the slice of the given Series in the range between\r\n    start and end inclusive.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[start:end+1]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef return_head(ser: pd.Series, num: int) -> pd.core.series.Series:\r\n    \"\"\"Return the first num elements of the given Series.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[0:num]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef return_tail(ser: pd.Series, num: int) -> pd.core.series.Series:\r\n    \"\"\"Return the last num elements of the given Series.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[-num:]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef get_index(ser: pd.Series) -> pd.core.indexes.base.Index:\r\n    \"\"\"Return all indexes of the given Series.\r\n    \"\"\"\r\n    return ser.index\r\n\r\n\r\n\r\ndef get_values(ser: pd.Series) -> np.ndarray:\r\n    \"\"\"Return all the values of the given Series.\r\n    \"\"\"\r\n    return ser.values\r\n\r\n\r\ndef get_every_second_indexes(ser: pd.Series,\r\n                             even_index=True) -> pd.core.series.Series:\r\n    \"\"\"Return all rows where the index is either even or odd.\r\n    If even_index is True return every index where idx % 2 == 0\r\n    If even_index is False return every index where idx % 2 != 0\r\n    Assume default indexing i.e. 0 -> n\r\n    \"\"\"\r\n    if even_index:\r\n        rows = [idx%2==0 for idx in ser.index]\r\n    else:\r\n        rows = [idx%2!=0 for idx in ser.index]\r\n    return ser.iloc[rows]\r\n",
            "date": "2022-11-10 18:47:29.059724+00:00",
            "passed": false
        },
        {
            "bite": "Bite 252. Let's play with Pandas Series",
            "code": "import numpy as np\r\nimport pandas as pd\r\n\r\n\r\ndef return_at_index(ser: pd.Series, idx: int) -> object:\r\n    \"\"\"Return the Object at the given index of the Series\r\n    If you want to be extra careful catch and raise an error if\r\n       the index does not exist.\r\n    \"\"\"\r\n    \r\n    try:\r\n        return ser.iloc[idx]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef get_slice(ser: pd.Series, start: int, end: int) -> pd.core.series.Series:\r\n    \"\"\"Return the slice of the given Series in the range between\r\n    start and end.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[start:end]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef get_slice_inclusive(ser: pd.Series,\r\n                        start: int, end: int) -> pd.core.series.Series:\r\n    \"\"\"Return the slice of the given Series in the range between\r\n    start and end inclusive.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[start:end+1]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef return_head(ser: pd.Series, num: int) -> pd.core.series.Series:\r\n    \"\"\"Return the first num elements of the given Series.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[0:num]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef return_tail(ser: pd.Series, num: int) -> pd.core.series.Series:\r\n    \"\"\"Return the last num elements of the given Series.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[-num:]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef get_index(ser: pd.Series) -> pd.core.indexes.base.Index:\r\n    \"\"\"Return all indexes of the given Series.\r\n    \"\"\"\r\n    return ser.index\r\n\r\n\r\n\r\ndef get_values(ser: pd.Series) -> np.ndarray:\r\n    \"\"\"Return all the values of the given Series.\r\n    \"\"\"\r\n    return ser.array\r\n\r\n\r\ndef get_every_second_indexes(ser: pd.Series,\r\n                             even_index=True) -> pd.core.series.Series:\r\n    \"\"\"Return all rows where the index is either even or odd.\r\n    If even_index is True return every index where idx % 2 == 0\r\n    If even_index is False return every index where idx % 2 != 0\r\n    Assume default indexing i.e. 0 -> n\r\n    \"\"\"\r\n    if even_index:\r\n        rows = [idx%2==0 for idx in ser.index]\r\n    else:\r\n        rows = [idx%2!=0 for idx in ser.index]\r\n    return ser.iloc[rows]\r\n",
            "date": "2022-11-10 18:45:08.878321+00:00",
            "passed": false
        },
        {
            "bite": "Bite 252. Let's play with Pandas Series",
            "code": "import numpy as np\r\nimport pandas as pd\r\n\r\n\r\ndef return_at_index(ser: pd.Series, idx: int) -> object:\r\n    \"\"\"Return the Object at the given index of the Series\r\n    If you want to be extra careful catch and raise an error if\r\n       the index does not exist.\r\n    \"\"\"\r\n    \r\n    try:\r\n        return ser.iloc[idx]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef get_slice(ser: pd.Series, start: int, end: int) -> pd.core.series.Series:\r\n    \"\"\"Return the slice of the given Series in the range between\r\n    start and end.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[start:end]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef get_slice_inclusive(ser: pd.Series,\r\n                        start: int, end: int) -> pd.core.series.Series:\r\n    \"\"\"Return the slice of the given Series in the range between\r\n    start and end inclusive.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[start:end+1]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef return_head(ser: pd.Series, num: int) -> pd.core.series.Series:\r\n    \"\"\"Return the first num elements of the given Series.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[:num]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef return_tail(ser: pd.Series, num: int) -> pd.core.series.Series:\r\n    \"\"\"Return the last num elements of the given Series.\r\n    \"\"\"\r\n    try:\r\n        return ser.iloc[-num:]\r\n    except IndexError:\r\n        raise IndexError(\"Index out of bounds\")\r\n\r\n\r\ndef get_index(ser: pd.Series) -> pd.core.indexes.base.Index:\r\n    \"\"\"Return all indexes of the given Series.\r\n    \"\"\"\r\n    return ser.index\r\n\r\n\r\n\r\ndef get_values(ser: pd.Series) -> np.ndarray:\r\n    \"\"\"Return all the values of the given Series.\r\n    \"\"\"\r\n    return ser.index\r\n\r\n\r\ndef get_every_second_indexes(ser: pd.Series,\r\n                             even_index=True) -> pd.core.series.Series:\r\n    \"\"\"Return all rows where the index is either even or odd.\r\n    If even_index is True return every index where idx % 2 == 0\r\n    If even_index is False return every index where idx % 2 != 0\r\n    Assume default indexing i.e. 0 -> n\r\n    \"\"\"\r\n    if even_index:\r\n        rows = [idx%2==0 for idx in ser.index]\r\n    else:\r\n        rows = [idx%2!=0 for idx in ser.index]\r\n    return ser.iloc[rows]\r\n",
            "date": "2022-11-10 18:29:54.090668+00:00",
            "passed": false
        },
        {
            "bite": "Bite 251. Introducing Pandas Series",
            "code": "import string\r\n\r\nimport pandas as pd\r\n\r\n\r\ndef basic_series() -> pd.Series:\r\n    \"\"\"Create a pandas Series containing the values 1, 2, 3, 4, 5\r\n    Don't worry about the indexes for now.\r\n    The name of the series should be 'Fred'\r\n    \"\"\"\r\n    return pd.Series([1, 2, 3, 4, 5], name=\"Fred\", dtype='int64')\r\n\r\n\r\ndef float_series() -> pd.Series:\r\n    \"\"\"Create a pandas Series containing the all the values\r\n    from 0.000 -> 1.000 e.g. 0.000, 0.001, 0.002... 0.999, 1.000\r\n    Don't worry about the indexes or the series name.\r\n    \"\"\"\r\n    PRECISION = 1000\r\n    lst=[i/PRECISION for i in range(PRECISION+1)]\r\n    return pd.Series(lst, dtype='float64')\r\n\r\n\r\ndef alpha_index_series() -> pd.Series:\r\n    \"\"\"Create a Series with values 1, 2, ... 25, 26 of type int64\r\n    and add an index with values a, b, ... y, z\r\n    so index 'a'=1, 'b'=2 ... 'y'=25, 'z'=26\r\n    Don't worry about the series name.\r\n    \"\"\"\r\n    gen=((label,value) for value, label in enumerate(string.ascii_lowercase, start=1))\r\n    return pd.Series(dict(gen), dtype='int64')\r\n\r\ndef object_values_series() -> pd.Series:\r\n    \"\"\"Create a Series with values A, B, ... Y, Z of type object\r\n    and add an index with values 101, 102, ... 125, 126\r\n    so index 101='A', 102='B' ... 125='Y', 126='Z'\r\n    Don't worry about the series name.\r\n    \"\"\"\r\n    gen=((label,value) for label,value in enumerate(string.ascii_uppercase, start=101))\r\n    return pd.Series(dict(gen), dtype='object')\r\n\r\n\r\nprint(float_series())\r\nprint(alpha_index_series())\r\nprint(object_values_series())",
            "date": "2022-11-09 20:14:42.068512+00:00",
            "passed": true
        },
        {
            "bite": "Bite 358. Implementation of a Simple Typer Test",
            "code": "import pytest\r\nfrom typer.testing import CliRunner\r\n\r\nfrom script import app\r\n\r\n\r\n@pytest.fixture()\r\ndef runner() -> CliRunner:\r\n    return CliRunner()\r\n\r\n    \r\ndef test_app(runner):\r\n    result = runner.invoke(app, [\"Manolo\"])\r\n    assert result.exit_code == 0\r\n    assert \"Hello Manolo!\" in result.stdout\r\n\r\n\r\ndef test_help_msg(runner):\r\n    result = runner.invoke(app, [\"--help\"])\r\n    assert result.exit_code == 0\r\n    assert \"CLI that allows you to greet a person.\" in result.stdout\r\n    assert \"The name of the person to greet.\" in result.stdout\r\n",
            "date": "2022-11-08 18:35:40.382549+00:00",
            "passed": true
        },
        {
            "bite": "Bite 358. Implementation of a Simple Typer Test",
            "code": "import pytest\r\nfrom typer.testing import CliRunner\r\n\r\nfrom script import app\r\n\r\n\r\n@pytest.fixture()\r\ndef runner() -> CliRunner:\r\n    return CliRunner()\r\n    \r\n    \r\nrunner = CliRunner()\r\n\r\n\r\ndef test_app(runner):\r\n    result = runner.invoke(app, [\"Manolo\"])\r\n    assert result.exit_code == 0\r\n    assert \"Hello Manolo!\" in result.stdout\r\n\r\n\r\ndef test_help_msg(runner):\r\n    result = runner.invoke(app, [\"--help\"])\r\n    assert result.exit_code == 0\r\n    assert \"CLI that allows you to greet a person.\" in result.stdout\r\n    assert \"The name of the person to greet.\" in result.stdout\r\n",
            "date": "2022-11-08 18:34:45.689649+00:00",
            "passed": false
        },
        {
            "bite": "Bite 356. Using Typer Callbacks to Create Command Line Interface (CLI) Parameters",
            "code": "import typer\r\n\r\n\r\ndef sum_numbers(a: int, b: int):\r\n    return a + b\r\n\r\n\r\napp = typer.Typer()\r\nstate = {\"verbose\": False} # MH\r\n\r\n\r\n@app.command()\r\ndef sum(\r\n    a: int = typer.Argument(..., help=\"The value of the first summand\"),\r\n    b: int = typer.Argument(..., help=\"The value of the second summand\"),\r\n):\r\n    \"\"\"Command that allows you to add two numbers.\"\"\"\r\n    sum_ab = sum_numbers(a, b)\r\n\r\n    # MH: add an if-else to write verbose output as a function of the callback setting\r\n    if state[\"verbose\"]:\r\n        print(f\"The sum is {sum_ab}\")\r\n    else:\r\n        print(f\"{sum_ab}\")\r\n\r\n\r\n@app.command()\r\ndef compare(\r\n    c: int = typer.Argument(..., help=\"First number to compare against.\"),\r\n    d: int = typer.Argument(\r\n        ..., help=\"Second number that is compared against first number.\"\r\n    ),\r\n):\r\n    \"\"\"Command that checks whether a number d is greater than a number c.\"\"\"\r\n\r\n    STRING_TRUE = \"greater\"\r\n    STRING_FALSE = \"not greater\"\r\n\r\n    d_greater_c = d > c\r\n\r\n    c_evaluation = STRING_TRUE if d_greater_c else STRING_FALSE\r\n\r\n    # MM: add an if-else to write verbose output as a function of the callback setting\r\n    if state[\"verbose\"]:\r\n        print(f\"{d=} is {c_evaluation} than {c=}\")\r\n    else:\r\n        print(f\"d > c: {d_greater_c}\")\r\n\r\n\r\n# MH: decorate this\r\n@app.callback()\r\ndef main(\r\n    verbose: bool = False\r\n):\r\n    \"\"\"\r\n    Have sum fun with numbers.\r\n    \"\"\"\r\n    # MH: inform user and set state according to user input about verbosity\r\n    if verbose:\r\n        print(\"Will write verbose output\")\r\n        state[\"verbose\"] = True\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app()",
            "date": "2022-11-08 18:26:42.905767+00:00",
            "passed": true
        },
        {
            "bite": "Bite 356. Using Typer Callbacks to Create Command Line Interface (CLI) Parameters",
            "code": "import typer\r\n\r\n\r\ndef sum_numbers(a: int, b: int):\r\n    return a + b\r\n\r\n\r\napp = typer.Typer()\r\nstate = {\"verbose\": False} # TODO: edit this\r\n\r\n\r\n@app.command()\r\ndef sum(\r\n    a: int = typer.Argument(..., help=\"The value of the first summand\"),\r\n    b: int = typer.Argument(..., help=\"The value of the second summand\"),\r\n):\r\n    \"\"\"Command that allows you to add two numbers.\"\"\"\r\n    sum_ab = sum_numbers(a, b)\r\n\r\n    # TODO: add an if-else to write verbose output as a function of the callback setting\r\n    if state[\"verbose\"]:\r\n        print(f\"The sum is {sum_ab}\")\r\n    else:\r\n        print(f\"{sum_ab}\")\r\n\r\n\r\n@app.command()\r\ndef compare(\r\n    c: int = typer.Argument(..., help=\"First number to compare against.\"),\r\n    d: int = typer.Argument(\r\n        ..., help=\"Second number that is compared against first number.\"\r\n    ),\r\n):\r\n    \"\"\"Command that checks whether a number d is greater than a number c.\"\"\"\r\n\r\n    STRING_TRUE = \"greater\"\r\n    STRING_FALSE = \"not greater\"\r\n\r\n    d_greater_c = d > c\r\n\r\n    c_evaluation = STRING_TRUE if d_greater_c else STRING_FALSE\r\n\r\n    # TODO: add an if-else to write verbose output as a function of the callback setting\r\n    if state[\"verbose\"]:\r\n        print(f\"{d=} is {c_evaluation} than {c=}\")\r\n    else:\r\n        print(f\"d > c: {d_greater_c}\")\r\n\r\n\r\n# TODO: decorate this\r\n@app.callback()\r\ndef main(\r\n    verbose: bool = False\r\n):\r\n    \"\"\"\r\n    Have sum fun with numbers.\r\n    \"\"\"\r\n    # TODO: inform user and set state according to user input about verbosity\r\n    if verbose:\r\n        print(\"Will write verbose output\")\r\n        state[\"verbose\"] = True\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app()",
            "date": "2022-11-08 18:25:09.965495+00:00",
            "passed": true
        },
        {
            "bite": "Bite 356. Using Typer Callbacks to Create Command Line Interface (CLI) Parameters",
            "code": "import typer\r\n\r\n\r\ndef sum_numbers(a: int, b: int):\r\n    return a + b\r\n\r\n\r\napp = typer.Typer()\r\nstate = {\"verbose\": False} # TODO: edit this\r\n\r\n\r\n@app.command()\r\ndef sum(\r\n    a: int = typer.Argument(..., help=\"The value of the first summand\"),\r\n    b: int = typer.Argument(..., help=\"The value of the second summand\"),\r\n):\r\n    \"\"\"Command that allows you to add two numbers.\"\"\"\r\n    sum_ab = sum_numbers(a, b)\r\n\r\n    # TODO: add an if-else to write verbose output as a function of the callback setting\r\n    if state[\"verbose\"]:\r\n        print(\"Will write verbose output\")\r\n        print(f\"The sum is {sum_ab}\")\r\n    else:\r\n        print(f\"{sum_ab}\")\r\n\r\n\r\n@app.command()\r\ndef compare(\r\n    c: int = typer.Argument(..., help=\"First number to compare against.\"),\r\n    d: int = typer.Argument(\r\n        ..., help=\"Second number that is compared against first number.\"\r\n    ),\r\n):\r\n    \"\"\"Command that checks whether a number d is greater than a number c.\"\"\"\r\n\r\n    STRING_TRUE = \"greater\"\r\n    STRING_FALSE = \"not greater\"\r\n\r\n    d_greater_c = d > c\r\n\r\n    c_evaluation = STRING_TRUE if d_greater_c else STRING_FALSE\r\n\r\n    # TODO: add an if-else to write verbose output as a function of the callback setting\r\n    if state[\"verbose\"]:\r\n        print(\"Will write verbose output\")\r\n        print(f\"{d=} is {c_evaluation} than {c=}\")\r\n    else:\r\n        print(f\"d > c: {d_greater_c}\")\r\n\r\n\r\n# TODO: decorate this\r\n@app.callback()\r\ndef main(\r\n    verbose: bool = False\r\n):\r\n    \"\"\"\r\n    Have sum fun with numbers.\r\n    \"\"\"\r\n    # TODO: inform user and set state according to user input about verbosity\r\n    if verbose:\r\n        print(\"Will write verbose output\")\r\n        state[\"verbose\"] = True\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app()",
            "date": "2022-11-08 18:23:18.630470+00:00",
            "passed": false
        },
        {
            "bite": "Bite 72. Retrieve the right Ninja Belt based on score",
            "code": "from bisect import bisect\r\n\r\nscores = [10, 50, 100, 175, 250, 400, 600, 800, 1000]\r\nbelts = 'white yellow orange green blue brown black paneled red'.split()\r\n\r\n\r\ndef get_belt(user_score, scores=scores, belts=belts):\r\n    # scores_belts= list(zip(scores,belts))\r\n    ind= bisect(scores, user_score)\r\n    if ind==0:\r\n        return None\r\n    elif ind>=len(belts):\r\n        return belts[-1]\r\n    else:\r\n        return belts[ind-1]\r\n\r\nfor score, expected in [(3,'None'),(10,'white'),(12,'white'),(900,'paneled'),(1000,'red'),(1001,'red')]:\r\n    print(f\"{score=} {expected=} result={get_belt(score)}\")",
            "date": "2022-11-08 12:20:44.055206+00:00",
            "passed": true
        },
        {
            "bite": "Bite 72. Retrieve the right Ninja Belt based on score",
            "code": "from bisect import bisect\r\n\r\nscores = [10, 50, 100, 175, 250, 400, 600, 800, 1000]\r\nbelts = 'white yellow orange green blue brown black paneled red'.split()\r\n\r\n\r\ndef get_belt(user_score, scores=scores, belts=belts):\r\n    # scores_belts= list(zip(scores,belts))\r\n    ind= bisect(scores, user_score)\r\n    if ind==0:\r\n        return \"None\"\r\n    elif ind>=len(belts):\r\n        return belts[-1]\r\n    else:\r\n        return belts[ind-1]\r\n\r\nfor score, expected in [(3,'None'),(10,'white'),(12,'white'),(900,'paneled'),(1000,'red'),(1001,'red')]:\r\n    print(f\"{score=} {expected=} result={get_belt(score)}\")",
            "date": "2022-11-08 12:20:17.926123+00:00",
            "passed": false
        },
        {
            "bite": "Bite 65. Get all valid dictionary words for a draw of letters",
            "code": "import itertools\r\nimport os\r\nimport urllib.request\r\n\r\nimport functools\r\nimport operator\r\nfrom pprint import pprint\r\n\r\n# PREWORK\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nDICT = 'dictionary.txt'\r\nDICTIONARY = os.path.join(TMP, DICT)\r\nurllib.request.urlretrieve(\r\n    f'https://bites-data.s3.us-east-2.amazonaws.com/{DICT}',\r\n    DICTIONARY\r\n)\r\n\r\nwith open(DICTIONARY) as f:\r\n    dictionary = set([word.strip().lower() for word in f.read().split()])\r\n# pprint(list(word for word in dictionary if len(word)==2))\r\n\r\ndef get_possible_dict_words(draw):\r\n    \"\"\"Get all possible words from a draw (list of letters) which are\r\n       valid dictionary words. Use _get_permutations_draw and provided\r\n       dictionary\"\"\"\r\n       \r\n    return [word for word in _get_permutations_draw(draw) if word.lower() in dictionary]\r\n\r\ndef _get_permutations_draw(draw):\r\n    \"\"\"Helper to get all permutations of a draw (list of letters), hint:\r\n       use itertools.permutations (order of letters matters)\"\"\"\r\n    draw = list(map(lambda x: x.lower(), draw))\r\n    nested_lst= [itertools.permutations(draw,r=l) for l in range(2,len(draw)+1)]\r\n    lst_of_tups = functools.reduce(operator.iconcat, nested_lst, [])\r\n    return [\"\".join(elem) for elem in lst_of_tups]\r\n    \r\n\r\n\"\"\"\r\ndraw= ['G', 'A', 'R', 'Y', 'T', 'E', 'V' ]\r\nprint(_get_permutations_draw(draw))\r\nprint(get_possible_dict_words(draw))\r\n\"\"\"",
            "date": "2022-11-08 11:49:20.541833+00:00",
            "passed": true
        },
        {
            "bite": "Bite 154. Write your own Data Class",
            "code": "from dataclasses import dataclass\r\n\r\n@dataclass(order=True)\r\nclass Bite:\r\n    \"\"\"Class for describing PyBites.\"\"\"\r\n    number: int\r\n    title: str\r\n    level: str = \"Beginner\"\r\n\r\n    def __post_init__(self):\r\n        self.title = self.title.capitalize()\r\n",
            "date": "2022-11-08 09:39:29.291067+00:00",
            "passed": true
        },
        {
            "bite": "Bite 154. Write your own Data Class",
            "code": "from dataclasses import dataclass\r\n\r\n@dataclass(order=True)\r\nclass Bite:\r\n    \"\"\"Class for describing PyBites.\"\"\"\r\n    number: int\r\n    title: str\r\n    level: str = \"Beginner\"\r\n\r\n    def __post_init__(self):\r\n        self.title = self.title.title()\r\n",
            "date": "2022-11-08 09:35:06.914464+00:00",
            "passed": false
        },
        {
            "bite": "Bite 354. When to Use Command Line Option (CLI) Options and When CLI Arguments?",
            "code": "import typer\r\n\r\n\r\ndef sum_numbers(a: int, b: int):\r\n    return a + b\r\n\r\n\r\ndef main(\r\n    a: int = typer.Argument(..., help=\"The value of the first summand\"),\r\n    b: int = typer.Argument(..., help=\"The value of the second summand\"),\r\n    c: int = typer.Option(None, help=\"The value to compare the sum.\"),\r\n):\r\n    \"\"\"CLI that allows you to add two numbers\"\"\"\r\n\r\n    if not c:\r\n        COMPARISON = None\r\n    elif c<sum_numbers(a, b):\r\n        COMPARISON = \"smaller\" \r\n    else:\r\n        COMPARISON = \"not smaller\"\r\n\r\n    print(f\"The sum is {sum_numbers(a, b)} and c is {COMPARISON}\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    typer.run(main)",
            "date": "2022-11-07 16:36:08.039009+00:00",
            "passed": true
        },
        {
            "bite": "Bite 354. When to Use Command Line Option (CLI) Options and When CLI Arguments?",
            "code": "import typer\r\n\r\n\r\ndef sum_numbers(a: int, b: int):\r\n    return a + b\r\n\r\n\r\ndef main(\r\n    a: int = typer.Argument(..., help=\"The value of the first summand\"),\r\n    b: int = typer.Argument(..., help=\"The value of the second summand\"),\r\n    c: int = typer.Option(None, help=\"The value to compare the sum.\"),\r\n):\r\n    \"\"\"CLI that allows you to add two numbers\"\"\"\r\n\r\n    if not c:\r\n        COMPARISON = None\r\n    elif c<sum_numbers(a, b):\r\n        COMPARISON = \"smaller\" \r\n    elif c>=sum_numbers(a, b):\r\n        COMPARISON = \"not smaller\"\r\n\r\n    print(f\"The sum is {sum_numbers(a, b)} and c is {COMPARISON}\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    typer.run(main)",
            "date": "2022-11-07 16:35:07.082375+00:00",
            "passed": true
        },
        {
            "bite": "Bite 298. Fasta to 2-Line Fasta",
            "code": "import os\r\nimport urllib\r\nfrom Bio import SeqIO\r\n\r\n# Fetched and truncated from\r\n# https://www.uniprot.org/uniprot/?query=database%3A%28type%3Aembl+AE017195%29&format=fasta (Aug 01, 2020)\r\nURL = \"https://bites-data.s3.us-east-2.amazonaws.com/fasta_genes.fasta\"\r\nFASTA_FILE = os.path.join(os.getenv(\"TMP\", \"/tmp\"), \"fasta_genes.fasta\")\r\nif not os.path.isfile(FASTA_FILE):\r\n    urllib.request.urlretrieve(URL, FASTA_FILE)\r\n\r\ndef fasta_to_2line_fasta(fasta_file: str, fasta_2line_file: str) -> int:\r\n    \"\"\"\r\n    :param fasta_file: Filename of multi-line FASTA file\r\n    :param fasta_2line_file: Filename of 2-line FASTA file\r\n    :return: Number of records\r\n    \"\"\"\r\n    with open(fasta_file) as f:\r\n        content=f.read()\r\n    \r\n    result=[]\r\n    item=''\r\n    count =0\r\n    for line in content.splitlines():\r\n        if line.startswith(\">\"):\r\n            if item:\r\n                result.append(item+'\\n')    \r\n            item=line+\"\\n\"\r\n            count+=1\r\n        elif item:\r\n            item+=line\r\n    output=\"\".join(result)\r\n    print(output)\r\n    \r\n    with open(fasta_2line_file,'w') as f:\r\n        f.write(output)\r\n    \r\n    return count\r\n    \r\nif __name__ == \"__main__\":\r\n    fasta_to_2line_fasta(FASTA_FILE, f\"{FASTA_FILE}_converted.fasta\")",
            "date": "2022-11-06 14:28:50.621030+00:00",
            "passed": true
        },
        {
            "bite": "Bite 298. Fasta to 2-Line Fasta",
            "code": "import os\r\nimport urllib\r\nfrom Bio import SeqIO\r\n\r\n# Fetched and truncated from\r\n# https://www.uniprot.org/uniprot/?query=database%3A%28type%3Aembl+AE017195%29&format=fasta (Aug 01, 2020)\r\nURL = \"https://bites-data.s3.us-east-2.amazonaws.com/fasta_genes.fasta\"\r\nFASTA_FILE = os.path.join(os.getenv(\"TMP\", \"/tmp\"), \"fasta_genes.fasta\")\r\nif not os.path.isfile(FASTA_FILE):\r\n    urllib.request.urlretrieve(URL, FASTA_FILE)\r\n\r\ndef fasta_to_2line_fasta(fasta_file: str, fasta_2line_file: str) -> int:\r\n    \"\"\"\r\n    :param fasta_file: Filename of multi-line FASTA file\r\n    :param fasta_2line_file: Filename of 2-line FASTA file\r\n    :return: Number of records\r\n    \"\"\"\r\n    with open(fasta_file) as f:\r\n        content=f.read()\r\n    \r\n    result=[]\r\n    count =0\r\n    for line in content.splitlines():\r\n        if line.startswith(\">\"):\r\n            result.append(\"\\n\"+line+\"\\n\")\r\n            count+=1\r\n        else:\r\n            result.append(line)\r\n    output=\"\".join(result)[1:]\r\n    #print(output)\r\n    \r\n    with open(fasta_2line_file,'w') as f:\r\n        f.write(output)\r\n    \r\n    return count\r\n    \r\nif __name__ == \"__main__\":\r\n    fasta_to_2line_fasta(FASTA_FILE, f\"{FASTA_FILE}_converted.fasta\")",
            "date": "2022-11-06 14:18:11.423248+00:00",
            "passed": false
        },
        {
            "bite": "Bite 298. Fasta to 2-Line Fasta",
            "code": "import os\r\nimport urllib\r\nfrom Bio import SeqIO\r\n\r\n# Fetched and truncated from\r\n# https://www.uniprot.org/uniprot/?query=database%3A%28type%3Aembl+AE017195%29&format=fasta (Aug 01, 2020)\r\nURL = \"https://bites-data.s3.us-east-2.amazonaws.com/fasta_genes.fasta\"\r\nFASTA_FILE = os.path.join(os.getenv(\"TMP\", \"/tmp\"), \"fasta_genes.fasta\")\r\nif not os.path.isfile(FASTA_FILE):\r\n    urllib.request.urlretrieve(URL, FASTA_FILE)\r\n\r\ndef fasta_to_2line_fasta(fasta_file: str, fasta_2line_file: str) -> int:\r\n    \"\"\"\r\n    :param fasta_file: Filename of multi-line FASTA file\r\n    :param fasta_2line_file: Filename of 2-line FASTA file\r\n    :return: Number of records\r\n    \"\"\"\r\n    with open(fasta_file) as f:\r\n        content=f.read()\r\n    \r\n    result=[]\r\n    count =0\r\n    for line in content.splitlines():\r\n        if line.startswith(\">\"):\r\n            result.append(\"\\n\"+line+\"\\n\")\r\n            count+=1\r\n        else:\r\n            result.append(line)\r\n    output=\"\".join(result)\r\n    print (output[1:])\r\n    \r\n    with open(fasta_2line_file,'w') as f:\r\n        f.write(output)\r\n    \r\n    return count\r\n    \r\nif __name__ == \"__main__\":\r\n    fasta_to_2line_fasta(FASTA_FILE, f\"{FASTA_FILE}_converted.fasta\")",
            "date": "2022-11-06 14:16:48.785456+00:00",
            "passed": false
        },
        {
            "bite": "Bite 298. Fasta to 2-Line Fasta",
            "code": "import os\r\nimport urllib\r\nfrom Bio import SeqIO\r\n\r\n# Fetched and truncated from\r\n# https://www.uniprot.org/uniprot/?query=database%3A%28type%3Aembl+AE017195%29&format=fasta (Aug 01, 2020)\r\nURL = \"https://bites-data.s3.us-east-2.amazonaws.com/fasta_genes.fasta\"\r\nFASTA_FILE = os.path.join(os.getenv(\"TMP\", \"/tmp\"), \"fasta_genes.fasta\")\r\nif not os.path.isfile(FASTA_FILE):\r\n    urllib.request.urlretrieve(URL, FASTA_FILE)\r\n\r\ndef fasta_to_2line_fasta(fasta_file: str, fasta_2line_file: str) -> int:\r\n    \"\"\"\r\n    :param fasta_file: Filename of multi-line FASTA file\r\n    :param fasta_2line_file: Filename of 2-line FASTA file\r\n    :return: Number of records\r\n    \"\"\"\r\n    with open(fasta_file) as f:\r\n        content=f.read()\r\n    \r\n    result=[]\r\n    count =0\r\n    for line in content.splitlines():\r\n        if line.startswith(\">\"):\r\n            result.append(\"\\n\"+line+\"\\n\")\r\n            count+=1\r\n        else:\r\n            result.append(line)\r\n    output=\"\".join(result)\r\n    # print (output)\r\n    \r\n    with open(fasta_2line_file,'w') as f:\r\n        f.write(output)\r\n    \r\n    return count\r\n    \r\nif __name__ == \"__main__\":\r\n    fasta_to_2line_fasta(FASTA_FILE, f\"{FASTA_FILE}_converted.fasta\")",
            "date": "2022-11-06 14:09:34.786035+00:00",
            "passed": false
        },
        {
            "bite": "Bite 298. Fasta to 2-Line Fasta",
            "code": "import os\r\nimport urllib\r\nfrom Bio import SeqIO\r\n\r\n# Fetched and truncated from\r\n# https://www.uniprot.org/uniprot/?query=database%3A%28type%3Aembl+AE017195%29&format=fasta (Aug 01, 2020)\r\nURL = \"https://bites-data.s3.us-east-2.amazonaws.com/fasta_genes.fasta\"\r\nFASTA_FILE = os.path.join(os.getenv(\"TMP\", \"/tmp\"), \"fasta_genes.fasta\")\r\nif not os.path.isfile(FASTA_FILE):\r\n    urllib.request.urlretrieve(URL, FASTA_FILE)\r\n\r\ndef fasta_to_2line_fasta(fasta_file: str, fasta_2line_file: str) -> int:\r\n    \"\"\"\r\n    :param fasta_file: Filename of multi-line FASTA file\r\n    :param fasta_2line_file: Filename of 2-line FASTA file\r\n    :return: Number of records\r\n    \"\"\"\r\n    with open(fasta_file) as f:\r\n        content=f.read()\r\n    \r\n    result=[]\r\n    count =0\r\n    for line in content.splitlines():\r\n        if line.startswith(\">\"):\r\n            result.append(\"\\n\"+line+\"\\n\")\r\n            count+=1\r\n        else:\r\n            result.append(line)\r\n    output=\"\".join(result)\r\n    print (output)\r\n    \r\n    with open(fasta_2line_file,'w') as f:\r\n        f.write(output)\r\n    \r\n    return count\r\n    \r\nif __name__ == \"__main__\":\r\n    fasta_to_2line_fasta(FASTA_FILE, f\"{FASTA_FILE}_converted.fasta\")",
            "date": "2022-11-06 14:07:49.910486+00:00",
            "passed": false
        },
        {
            "bite": "Bite 360. Add a progress bar to Your Command Line Interface (CLI)",
            "code": "import time\r\n\r\nimport typer\r\nfrom rich.progress import track\r\n\r\n\r\napp = typer.Typer()\r\n\r\n\r\n@app.command()\r\ndef progress():\r\n    total = 0\r\n    for value in track(range(100), description=\"Processing...\"):\r\n        # Fake processing time\r\n        time.sleep(0.01)\r\n        total += 1\r\n    print(f\"Processed {total} things.\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app()",
            "date": "2022-11-06 13:43:46.721571+00:00",
            "passed": true
        },
        {
            "bite": "Bite 357. Implement your First Subcommands and Command Groups",
            "code": "import os\r\nfrom pathlib import Path\r\nimport sys\r\nfrom urllib.request import urlretrieve\r\nfrom zipfile import ZipFile\r\n\r\nimport typer\r\n\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nS3 = \"https://bites-data.s3.us-east-2.amazonaws.com\"\r\n\r\n\r\ndef _setup():\r\n    data_zipfile = '357-data.zip'\r\n    urlretrieve(f'{S3}/{data_zipfile}', TMP / data_zipfile)\r\n    ZipFile(TMP / data_zipfile).extractall(TMP)\r\n    sys.path.append(TMP)\r\n\r\n\r\n_setup()\r\n\r\nimport algorithms  # noqa E402\r\nimport comparisons  # noqa E402\r\n\r\n\r\napp = typer.Typer()\r\napp.add_typer(algorithms.app, name=\"algorithms\")\r\napp.add_typer(comparisons.app, name=\"comparisons\")\r\n\r\nif __name__ == \"__main__\":\r\n    app()",
            "date": "2022-11-06 13:40:30.988760+00:00",
            "passed": true
        },
        {
            "bite": "Bite 355. Create Your First Typer Command Line Interface (CLI) Application",
            "code": "import typer\r\n\r\n\r\ndef sum_numbers(a: int, b: int):\r\n    return a + b\r\n\r\n\r\napp = typer.Typer()\r\n\r\n\r\n@app.command()\r\ndef sum(\r\n    a:int = typer.Argument(..., help=\"The value of the first summand\"),\r\n    b:int = typer.Argument(..., help=\"The value of the second summand\"),\r\n):\r\n    \"\"\"Command that allows you to add two numbers.\"\"\"\r\n    sum_ab = sum_numbers(a, b)\r\n\r\n    print(f\"The sum is {sum_ab}\")\r\n\r\n\r\n@app.command()\r\ndef compare(\r\n    c:int = typer.Argument(..., help=\"First number to compare against.\"),\r\n    d:int = typer.Argument(..., help=\"Second number that is compared against first number.\"),\r\n):\r\n    \"\"\"Command that checks whether a number d is greater than a number c.\"\"\"\r\n\r\n    STRING_TRUE = \"greater\"\r\n    STRING_FALSE = \"not greater\"\r\n\r\n    c_evaluation = STRING_TRUE if d > c else STRING_FALSE\r\n\r\n    print(f\"{d=} is {c_evaluation} than {c=}\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app()\r\n\r\n\r\n\r\n\r\n\r\n",
            "date": "2022-11-06 13:34:29.148043+00:00",
            "passed": true
        },
        {
            "bite": "Bite 355. Create Your First Typer Command Line Interface (CLI) Application",
            "code": "import typer\r\n\r\n\r\ndef sum_numbers(a: int, b: int):\r\n    return a + b\r\n\r\n\r\napp = typer.Typer()\r\n\r\n\r\n    \r\n\r\n@app.command()\r\ndef sum(\r\n    a:int = typer.Argument(..., help=\"The value of the first summand\"),\r\n    b:int = typer.Argument(..., help=\"The value of the second summand\"),\r\n):\r\n    \"\"\"Command that allows you to add two numbers.\"\"\"\r\n    sum_ab = sum_numbers(a, b)\r\n\r\n    print(f\"The sum is {sum_ab}\")\r\n\r\n\r\n@app.command()\r\ndef compare(\r\n    c:int = typer.Argument(..., help=\"First number to compare against.\"),\r\n    d:int = typer.Argument(..., help=\"Second number that is compared against first number.\"),\r\n):\r\n    \"\"\"Command that checks whether a number d is greater than a number c.\"\"\"\r\n\r\n    STRING_TRUE = \"greater\"\r\n    STRING_FALSE = \"not greater\"\r\n\r\n    c_evaluation = STRING_TRUE if d > c else STRING_FALSE\r\n\r\n    print(f\"{d=} is {c_evaluation} than {c=}\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app()\r\n\r\n\r\n\r\n\r\n\r\n",
            "date": "2022-11-06 13:33:09.336256+00:00",
            "passed": true
        },
        {
            "bite": "Bite 73. Organize a meeting between timezones (pytz)",
            "code": "import pytz\r\n\r\nMIN_MEETING_HOUR = 6\r\nMAX_MEETING_HOUR = 22\r\nTIMEZONES = set(pytz.all_timezones)\r\n\r\n\r\ndef within_schedule(utc, *timezones):\r\n    \"\"\"\r\n    Receive a utc datetime and one or more timezones and check if\r\n    they are all within MIN_MEETING_HOUR and MAX_MEETING_HOUR\r\n    (both included).\r\n    \"\"\"\r\n    \r\n    # make naive utc aware\r\n    utc_aware = utc.replace(tzinfo=pytz.utc)\r\n    \r\n    for zone in timezones:\r\n        if zone not in TIMEZONES:\r\n            raise ValueError\r\n        local_time=utc_aware.astimezone(pytz.timezone(zone))\r\n        if not (MIN_MEETING_HOUR <= local_time.hour <= MAX_MEETING_HOUR):\r\n            return False\r\n    return True\r\n",
            "date": "2022-11-05 12:21:29.999445+00:00",
            "passed": true
        },
        {
            "bite": "Bite 73. Organize a meeting between timezones (pytz)",
            "code": "import pytz\r\n\r\nMIN_MEETING_HOUR = 6\r\nMAX_MEETING_HOUR = 22\r\nTIMEZONES = set(pytz.all_timezones)\r\n\r\n\r\ndef within_schedule(utc, *timezones):\r\n    \"\"\"\r\n    Receive a utc datetime and one or more timezones and check if\r\n    they are all within MIN_MEETING_HOUR and MAX_MEETING_HOUR\r\n    (both included).\r\n    \"\"\"\r\n    for zone in timezones:\r\n        if zone not in TIMEZONES:\r\n            raise ValueError\r\n        if not (6 <= utc.astimezone(pytz.timezone(zone)).hour <= 22):\r\n            return False\r\n    return True\r\n",
            "date": "2022-11-05 12:14:55.477217+00:00",
            "passed": true
        },
        {
            "bite": "Bite 73. Organize a meeting between timezones (pytz)",
            "code": "import pytz\r\n\r\nMIN_MEETING_HOUR = 6\r\nMAX_MEETING_HOUR = 22\r\nTIMEZONES = set(pytz.all_timezones)\r\n\r\n\r\ndef within_schedule(utc, *timezones):\r\n    \"\"\"\r\n    Receive a utc datetime and one or more timezones and check if\r\n    they are all within MIN_MEETING_HOUR and MAX_MEETING_HOUR\r\n    (both included).\r\n    \"\"\"\r\n    for zone in timezones:\r\n        if zone not in TIMEZONES:\r\n            raise ValueError\r\n        if not (6 <= utc.astimezone(timezone(zone)).hour <= 22):\r\n            return False\r\n    return True\r\n",
            "date": "2022-11-05 12:12:20.790842+00:00",
            "passed": false
        },
        {
            "bite": "Bite 73. Organize a meeting between timezones (pytz)",
            "code": "import pytz\r\n\r\nMIN_MEETING_HOUR = 6\r\nMAX_MEETING_HOUR = 22\r\nTIMEZONES = set(pytz.all_timezones)\r\n\r\n\r\ndef within_schedule(utc, *timezones):\r\n    \"\"\"\r\n    Receive a utc datetime and one or more timezones and check if\r\n    they are all within MIN_MEETING_HOUR and MAX_MEETING_HOUR\r\n    (both included).\r\n    \"\"\"\r\n    for zone in timezones:\r\n        if zone not in TIMEZONES:\r\n            raise ValueError\r\n        if not (6 <= utc.astimezone(zone).hour <= 22):\r\n            return False\r\n    return True\r\n",
            "date": "2022-11-05 12:10:35.034483+00:00",
            "passed": false
        },
        {
            "bite": "Bite 353. Transform a Script Into a Command Line Interface (CLI)",
            "code": "import typer  # use typer.run and typer.Argument\r\n\r\n\r\ndef sum_numbers(a: int, b: int):\r\n    \"\"\"Sums two numbers\"\"\"\r\n    return a + b\r\n\r\n\r\ndef main(\r\n        a:int = typer.Argument(..., help=\"The value of the first summand\"),\r\n        b:int = typer.Argument(..., help=\"The value of the second summand\")\r\n        ):\r\n    \"\"\"\r\n    CLI that allows you to add two numbers\r\n    \"\"\"\r\n    print(sum_numbers(a,b))\r\n\r\nif __name__ == \"__main__\":\r\n    typer.run(main)",
            "date": "2022-11-05 11:56:35.305796+00:00",
            "passed": true
        },
        {
            "bite": "Bite 353. Transform a Script Into a Command Line Interface (CLI)",
            "code": "import typer  # use typer.run and typer.Argument\r\n\r\n\r\ndef sum_numbers(a: int, b: int):\r\n    \"\"\"Sums two numbers\"\"\"\r\n    return a + b\r\n\r\n\r\ndef main(\r\n        a:int = typer.Argument(..., help=\"The value of the first summand\"),\r\n        b:int = typer.Argument(..., help=\"The value of the second summand\")\r\n        ):\r\n    \"\"\"\r\n    CLI that allows you to add two numbers\r\n    \"\"\"\r\n   \r\n    print(sum_numbers(a,b))\r\n\r\nif __name__ == \"__main__\":\r\n    typer.run(main)",
            "date": "2022-11-05 11:56:12.067131+00:00",
            "passed": true
        },
        {
            "bite": "Bite 353. Transform a Script Into a Command Line Interface (CLI)",
            "code": "import typer  # use typer.run and typer.Argument\r\n\r\n\r\ndef sum_numbers(a: int, b: int):\r\n    \"\"\"Sums two numbers\"\"\"\r\n    return a + b\r\n\r\n\r\ndef main(a: int, b:int):\r\n    print(sum_numbers(a,b))\r\n\r\nif __name__ == \"__main__\":\r\n    typer.run(main)",
            "date": "2022-11-05 11:48:26.690145+00:00",
            "passed": false
        },
        {
            "bite": "Bite 231. Where are the emojis?",
            "code": "import re\r\nfrom typing import List\r\n\r\n# https://stackoverflow.com/a/43147265\r\n# just for exercise sake, real life use emoji lib\r\nIS_EMOJI = re.compile(r'[^\\w\\s,]')\r\n\r\n\r\ndef get_emoji_indices(text: str) -> List[int]:\r\n    \"\"\"Given a text return indices of emoji characters\"\"\"\r\n    return [i for i, ch in enumerate(text) if ch in IS_EMOJI.findall(text)]\r\n\r\n\r\ntext = \"We see more and more \ud83d\udc0d Python \ud83e\udd4b ninjas, keep it up \ud83d\udcaa\"\r\nprint(get_emoji_indices(text))",
            "date": "2022-11-05 11:36:05.667535+00:00",
            "passed": true
        },
        {
            "bite": "Bite 90. What South Park characters talk most?",
            "code": "from collections import Counter, defaultdict\r\nimport csv\r\n\r\nimport requests\r\n\r\nfrom pprint import pprint\r\n\r\nCSV_URL = 'https://raw.githubusercontent.com/pybites/SouthParkData/master/by-season/Season-{}.csv' # noqa E501\r\n\r\n\r\ndef get_season_csv_file(season):\r\n    \"\"\"Receives a season int, and downloads loads in its\r\n       corresponding CSV_URL\"\"\"\r\n    with requests.Session() as s:\r\n        download = s.get(CSV_URL.format(season))\r\n        return download.content.decode('utf-8')\r\n\r\n\r\ndef get_num_words_spoken_by_character_per_episode(content):\r\n    \"\"\"Receives loaded csv content (str) and returns a dict of\r\n       keys=characters and values=Counter object,\r\n       which is a mapping of episode=>words spoken\"\"\"\r\n    result = defaultdict(Counter)\r\n    \r\n    reader = csv.DictReader(content.splitlines(), delimiter=',')\r\n    for row in reader:\r\n        result[row['Character']][row['Episode']] += len(row['Line'].split())\r\n    return(result)    \r\n    \r\n\"\"\"    \r\ncontent=get_season_csv_file(1)\r\npprint(get_num_words_spoken_by_character_per_episode(content))\r\n\"\"\"",
            "date": "2022-11-05 11:25:46.531216+00:00",
            "passed": true
        },
        {
            "bite": "Bite 225. Swap case PyBites characters",
            "code": "PYBITES = \"pybites\"\r\n\r\n\r\ndef convert_pybites_chars(text):\r\n    \"\"\"Swap case all characters in the word pybites for the given text.\r\n       Return the resulting string.\"\"\"\r\n    result=[]\r\n    for letter in text:\r\n        if letter in PYBITES:\r\n            letter = letter.upper()\r\n        elif letter in PYBITES.upper():\r\n            letter = letter.lower()\r\n        result.append(letter)\r\n    return \"\".join(result)\r\n    \r\ntext = \"Today we added TWO NEW Bites to our Platform, exciting!\"\r\nprint(convert_pybites_chars(text))",
            "date": "2022-11-04 07:37:01.549502+00:00",
            "passed": true
        },
        {
            "bite": "Bite 272. Find common words",
            "code": "from collections import Counter\r\n\r\nfrom typing import List\r\n\r\n\r\ndef common_words(sentence1: List[str], sentence2: List[str]) -> List[str]:\r\n    \"\"\"\r\n    Input:  Two sentences - each is a  list of words in case insensitive ways.\r\n    Output: those common words appearing in both sentences. Capital and lowercase \r\n            words are treated as the same word. \r\n\r\n            If there are duplicate words in the results, just choose one word. \r\n            Returned words should be sorted by word's length.\r\n    \"\"\"\r\n    \r\n    # all lower() to make case insensitive\r\n    sentence2_lower = [word.lower() for word in sentence2]\r\n\r\n    # set() eliminates duplicates\r\n    result = set(word.lower() for word in sentence1 if word.lower() in sentence2_lower)\r\n    \r\n    return sorted(result,key=len)\r\n    \r\n\r\nS = ['You', 'can', 'do', 'anything', 'but', 'not', 'everything', 'do']\r\nT = ['We', 'are', 'what', 'we', 'repeatedly', 'do', 'is', 'not', 'an', 'act', 'do']\r\nprint(common_words(S,T))",
            "date": "2022-11-03 17:54:20.214626+00:00",
            "passed": true
        },
        {
            "bite": "Bite 272. Find common words",
            "code": "from collections import Counter\r\n\r\nfrom typing import List\r\n\r\n\r\ndef common_words(sentence1: List[str], sentence2: List[str]) -> List[str]:\r\n    \"\"\"\r\n    Input:  Two sentences - each is a  list of words in case insensitive ways.\r\n    Output: those common words appearing in both sentences. Capital and lowercase \r\n            words are treated as the same word. \r\n\r\n            If there are duplicate words in the results, just choose one word. \r\n            Returned words should be sorted by word's length.\r\n    \"\"\"\r\n    sentence2_lower = [word.lower() for word in sentence2]\r\n    \r\n    result = set(word.lower() for word in sentence1 if word.lower() in sentence2_lower)\r\n    \r\n    return sorted(result,key=len)\r\n    \r\n\r\nS = ['You', 'can', 'do', 'anything', 'but', 'not', 'everything', 'do']\r\nT = ['We', 'are', 'what', 'we', 'repeatedly', 'do', 'is', 'not', 'an', 'act', 'do']\r\nprint(common_words(S,T))",
            "date": "2022-11-03 17:50:56.140451+00:00",
            "passed": true
        },
        {
            "bite": "Bite 272. Find common words",
            "code": "from collections import Counter\r\n\r\nfrom typing import List\r\n\r\n\r\ndef common_words(sentence1: List[str], sentence2: List[str]) -> List[str]:\r\n    \"\"\"\r\n    Input:  Two sentences - each is a  list of words in case insensitive ways.\r\n    Output: those common words appearing in both sentences. Capital and lowercase \r\n            words are treated as the same word. \r\n\r\n            If there are duplicate words in the results, just choose one word. \r\n            Returned words should be sorted by word's length.\r\n    \"\"\"\r\n    sentence2_lower = [word.lower() for word in sentence2]\r\n    \r\n    result = list(set([word.lower() for word in sentence1 if word.lower() in sentence2_lower]))\r\n    \r\n    return sorted(result,key=len)\r\n    \r\n\r\nS = ['You', 'can', 'do', 'anything', 'but', 'not', 'everything', 'do']\r\nT = ['We', 'are', 'what', 'we', 'repeatedly', 'do', 'is', 'not', 'an', 'act', 'do']\r\nprint(common_words(S,T))",
            "date": "2022-11-03 17:50:12.088727+00:00",
            "passed": true
        },
        {
            "bite": "Bite 272. Find common words",
            "code": "from typing import List\r\n\r\n\r\ndef common_words(sentence1: List[str], sentence2: List[str]) -> List[str]:\r\n    \"\"\"\r\n    Input:  Two sentences - each is a  list of words in case insensitive ways.\r\n    Output: those common words appearing in both sentences. Capital and lowercase \r\n            words are treated as the same word. \r\n\r\n            If there are duplicate words in the results, just choose one word. \r\n            Returned words should be sorted by word's length.\r\n    \"\"\"\r\n    sentence2_lower = [word.lower() for word in sentence2]\r\n    \r\n    result = [word.lower() for word in sentence1 if word.lower() in sentence2_lower]\r\n    \r\n    return sorted(result,key=len)\r\n    \r\n\r\nS = ['You', 'can', 'do', 'anything', 'but', 'not', 'everything']\r\nT = ['We', 'are', 'what', 'we', 'repeatedly', 'do', 'is', 'not', 'an', 'act']\r\nprint(common_words(S,T))",
            "date": "2022-11-03 17:47:39.555315+00:00",
            "passed": false
        },
        {
            "bite": "Bite 191. Starwars character with highest BMI",
            "code": "data = \"\"\"Luke Skywalker,172,77\r\n          C-3PO,167,75\r\n          R2-D2,96,32\r\n          Darth Vader,202,136\r\n          Leia Organa,150,49\r\n          Owen Lars,178,120\r\n          Beru Whitesun lars,165,75\r\n          R5-D4,97,32\r\n          Biggs Darklighter,183,84\r\n          Obi-Wan Kenobi,182,77\r\n          Anakin Skywalker,188,84\r\n          Chewbacca,228,112\r\n          Han Solo,180,80\r\n          Greedo,173,74\r\n          Jek Tono Porkins,180,110\r\n          Yoda,66,17\r\n          Palpatine,170,75\r\n          Boba Fett,183,78.2\r\n          IG-88,200,140\r\n          Bossk,190,113\r\n\"\"\"\r\n\r\n\r\ndef person_max_bmi(data=data):\r\n    \"\"\"Return (name, BMI float) of the character in data that\r\n       has the highest BMI (rounded on 2 decimals)\"\"\"\r\n    max_BMI = 0\r\n    for line in data.splitlines():\r\n        name, height, weight = line.split(\",\") \r\n        BMI =  round(float(weight) / ((int(height) / 100) ** 2), 2)\r\n        if BMI > max_BMI:\r\n            max_BMI, max_name = BMI, name\r\n    return (max_name.strip(), max_BMI)\r\n    \r\nprint(person_max_bmi())",
            "date": "2022-11-02 23:24:37.524456+00:00",
            "passed": true
        },
        {
            "bite": "Bite 191. Starwars character with highest BMI",
            "code": "data = \"\"\"Luke Skywalker,172,77\r\n          C-3PO,167,75\r\n          R2-D2,96,32\r\n          Darth Vader,202,136\r\n          Leia Organa,150,49\r\n          Owen Lars,178,120\r\n          Beru Whitesun lars,165,75\r\n          R5-D4,97,32\r\n          Biggs Darklighter,183,84\r\n          Obi-Wan Kenobi,182,77\r\n          Anakin Skywalker,188,84\r\n          Chewbacca,228,112\r\n          Han Solo,180,80\r\n          Greedo,173,74\r\n          Jek Tono Porkins,180,110\r\n          Yoda,66,17\r\n          Palpatine,170,75\r\n          Boba Fett,183,78.2\r\n          IG-88,200,140\r\n          Bossk,190,113\r\n\"\"\"\r\n\r\n\r\ndef person_max_bmi(data=data):\r\n    \"\"\"Return (name, BMI float) of the character in data that\r\n       has the highest BMI (rounded on 2 decimals)\"\"\"\r\n    lst=[line.split(\",\") for line in data.splitlines()]\r\n    result = []\r\n    for item in lst:\r\n        name, height, weight = tuple(item)\r\n        BMI =  round(float(weight) / ((int(height) / 100) ** 2), 2)\r\n        result.append((name.strip(), BMI))\r\n    return max(result, key = lambda tup: tup[1])\r\n    \r\nprint(person_max_bmi())",
            "date": "2022-11-02 23:19:19.707142+00:00",
            "passed": true
        },
        {
            "bite": "Bite 190. Parse income distribution from Latin America XML",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\n\r\nimport xml.etree.ElementTree as ET\r\nfrom collections import defaultdict\r\n\r\n# import the countries xml file\r\ntmp = Path(os.getenv(\"TMP\", \"/tmp\"))\r\ncountries = tmp / 'countries.xml'\r\n\r\nif not countries.exists():\r\n    urlretrieve(\r\n        'https://bites-data.s3.us-east-2.amazonaws.com/countries.xml',\r\n        countries\r\n    )\r\n\r\n\r\ndef get_income_distribution(xml=countries):\r\n    \"\"\"\r\n    - Read in the countries xml as stored in countries variable.\r\n    - Parse the XML\r\n    - Return a dict of:\r\n      - keys = incomes (wb:incomeLevel)\r\n      - values = list of country names (wb:name)\r\n    \"\"\"\r\n    result = defaultdict(list)\r\n\r\n    for country in ET.parse(xml).getroot():\r\n        name = country.find('{http://www.worldbank.org}name').text\r\n        income = country.find('{http://www.worldbank.org}incomeLevel').text\r\n        result[income].append(name) \r\n\r\n    return result\r\n    ",
            "date": "2022-11-02 19:19:58.230979+00:00",
            "passed": true
        },
        {
            "bite": "Bite 190. Parse income distribution from Latin America XML",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom urllib.request import urlretrieve\r\nimport xml.etree.ElementTree as ET\r\nfrom collections import defaultdict\r\nfrom pprint import pprint\r\n\r\n# import the countries xml file\r\ntmp = Path(os.getenv(\"TMP\", \"/tmp\"))\r\ncountries = tmp / 'countries.xml'\r\n\r\nif not countries.exists():\r\n    urlretrieve(\r\n        'https://bites-data.s3.us-east-2.amazonaws.com/countries.xml',\r\n        countries\r\n    )\r\n\r\n\r\ndef get_income_distribution(xml=countries):\r\n    \"\"\"\r\n    - Read in the countries xml as stored in countries variable.\r\n    - Parse the XML\r\n    - Return a dict of:\r\n      - keys = incomes (wb:incomeLevel)\r\n      - values = list of country names (wb:name)\r\n    \"\"\"\r\n    result = defaultdict(list)\r\n\r\n    for country in ET.parse(xml).getroot():\r\n        name = country.find('{http://www.worldbank.org}name').text\r\n        income = country.find('{http://www.worldbank.org}incomeLevel').text\r\n        # print(f\"{name=}, {income=}\")\r\n        result[income].append(name) \r\n\r\n    return result\r\n    \r\n\r\nprint(get_income_distribution())",
            "date": "2022-11-02 19:18:54.923819+00:00",
            "passed": true
        },
        {
            "bite": "Bite 122. Check if two words are anagrams",
            "code": "from collections import Counter \r\n\r\ndef is_anagram(word1, word2):\r\n    \"\"\"Receives two words and returns True/False (boolean) if word2 is\r\n       an anagram of word1, ignore case and spacing.\r\n       About anagrams: https://en.wikipedia.org/wiki/Anagram\"\"\"\r\n    return _letters(word1) == _letters(word2) \r\n        \r\ndef _letters(word):\r\n    return Counter([letter.lower() for letter in word if letter.isalnum() ])\r\n\r\n\"\"\"\r\ntests=[\r\n    (\"rail safety\", \"fairy tales\"),\r\n    (\"roast beef\", \"eat for BSE\"),\r\n    (\"restful\", \"fluster\"),\r\n    (\"funeral\", \"real fun\"),\r\n    (\"adultery\", \"true lady\"),\r\n    (\"customers\", \"store scum\"),\r\n    (\"forty five\", \"over fifty\"),\r\n    (\"William Shakespeare\", \"I am a weakish speller\"),\r\n    (\"Madam Curie\", \"Radium came\"),\r\n    ]\r\n    \r\nfor word1, word2 in tests:\r\n    print(is_anagram(word1, word2))\r\n    \r\n\"\"\"",
            "date": "2022-11-02 18:16:15.257513+00:00",
            "passed": true
        },
        {
            "bite": "Bite 122. Check if two words are anagrams",
            "code": "from collections import Counter \r\n\r\ndef is_anagram(word1, word2):\r\n    \"\"\"Receives two words and returns True/False (boolean) if word2 is\r\n       an anagram of word1, ignore case and spacing.\r\n       About anagrams: https://en.wikipedia.org/wiki/Anagram\"\"\"\r\n    return _letters(word1) == _letters(word2) \r\n        \r\ndef _letters(word):\r\n    return Counter([letter.lower() for letter in word if letter.isalpha() ])\r\n\r\n\"\"\"\r\ntests=[\r\n    (\"rail safety\", \"fairy tales\"),\r\n    (\"roast beef\", \"eat for BSE\"),\r\n    (\"restful\", \"fluster\"),\r\n    (\"funeral\", \"real fun\"),\r\n    (\"adultery\", \"true lady\"),\r\n    (\"customers\", \"store scum\"),\r\n    (\"forty five\", \"over fifty\"),\r\n    (\"William Shakespeare\", \"I am a weakish speller\"),\r\n    (\"Madam Curie\", \"Radium came\"),\r\n    ]\r\n    \r\nfor word1, word2 in tests:\r\n    print(is_anagram(word1, word2))\r\n    \r\n\"\"\"",
            "date": "2022-11-02 18:14:00.111594+00:00",
            "passed": false
        },
        {
            "bite": "Bite 79. Parse a csv file and create a bar chart",
            "code": "import csv\r\nfrom collections import Counter\r\n\r\nimport requests\r\n\r\nCSV_URL = 'https://bites-data.s3.us-east-2.amazonaws.com/community.csv'\r\n\r\n\r\ndef get_csv():\r\n    \"\"\"Use requests to download the csv and return the\r\n       decoded content\"\"\"\r\n\r\n    with requests.Session() as s:\r\n        data = s.get(CSV_URL)\r\n\r\n    return data.content.decode('utf-8')\r\n    \r\n\r\ndef create_user_bar_chart(content):\r\n    \"\"\"Receives csv file (decoded) content and print a table of timezones\r\n       and their corresponding member counts in pluses to standard output\r\n    \"\"\"\r\n    lst = list(csv.reader(content.splitlines(), delimiter=','))\r\n    \r\n    count = Counter([row[2] for row in lst[1:]])\r\n    \r\n    for timezone in sorted(count.keys()):\r\n        print(f\"{timezone:20s}| \"+ \"+\"*count[timezone])\r\n\r\n# create_user_bar_chart(get_csv())",
            "date": "2022-11-01 22:10:06.514166+00:00",
            "passed": true
        },
        {
            "bite": "Bite 79. Parse a csv file and create a bar chart",
            "code": "import csv\r\nfrom collections import Counter\r\n\r\nimport requests\r\n\r\nCSV_URL = 'https://bites-data.s3.us-east-2.amazonaws.com/community.csv'\r\n\r\n\r\ndef get_csv():\r\n    \"\"\"Use requests to download the csv and return the\r\n       decoded content\"\"\"\r\n    pass\r\n\r\n    with requests.Session() as s:\r\n        data = s.get(CSV_URL)\r\n\r\n    decoded_content = data.content.decode('utf-8')\r\n    \r\n    return decoded_content\r\n\r\ndef create_user_bar_chart(content):\r\n    \"\"\"Receives csv file (decoded) content and print a table of timezones\r\n       and their corresponding member counts in pluses to standard output\r\n    \"\"\"\r\n    lst = list(csv.reader(content.splitlines(), delimiter=','))\r\n    count = Counter([row[2] for row in lst[1:]])\r\n    for timezone in sorted(count.keys()):\r\n        print(f\"{timezone:20s}| \"+ \"+\"*count[timezone])\r\n\r\ncreate_user_bar_chart(get_csv())",
            "date": "2022-11-01 22:08:43.376947+00:00",
            "passed": true
        },
        {
            "bite": "Bite 138. OOP fun at the Zoo",
            "code": "from pprint import pprint\r\n\r\nclass Animal:\r\n    sequence=10000\r\n    animals = []\r\n    \r\n    def __init__(self, name):\r\n        self.__class__.sequence +=1\r\n        self.id = self.__class__.sequence\r\n        self.name  = name.title()\r\n        self.__class__.animals.append(self)\r\n\r\n    def __str__(self):\r\n        return f\"{self.id}. {self.name}\"\r\n        \r\n    @classmethod\r\n    def zoo(cls):\r\n        return \"\\n\".join([str(item) for item in cls.animals])\r\n            ",
            "date": "2022-11-01 21:39:48.259155+00:00",
            "passed": true
        },
        {
            "bite": "Bite 212. Suppressing exceptions",
            "code": "from contextlib import suppress\r\n\r\n\r\ndef sum_numbers(numbers):\r\n    \"\"\"This generator divides each number by its consecutive number.\r\n       So if it gets passed in [4, 2, 1] it yields 4/2 and 2/1.\r\n       It ignores ZeroDivisionError and TypeError exceptions (latter happens\r\n       when a string or other non-numeric data type is in numbers)\r\n\r\n       Task: use contextlib's suppress twice to make the code below more concise.\r\n    \"\"\"\r\n    for i, j in zip(numbers, numbers[1:]):\r\n        # replace the block below\r\n        with suppress(TypeError):\r\n            with suppress(ZeroDivisionError):\r\n                yield i/j\r\n    ",
            "date": "2022-11-01 20:52:19.906085+00:00",
            "passed": true
        },
        {
            "bite": "Bite 212. Suppressing exceptions",
            "code": "from contextlib import suppress\r\n\r\n\r\ndef sum_numbers(numbers):\r\n    \"\"\"This generator divides each number by its consecutive number.\r\n       So if it gets passed in [4, 2, 1] it yields 4/2 and 2/1.\r\n       It ignores ZeroDivisionError and TypeError exceptions (latter happens\r\n       when a string or other non-numeric data type is in numbers)\r\n\r\n       Task: use contextlib's suppress twice to make the code below more concise.\r\n    \"\"\"\r\n    for i, j in zip(numbers, numbers[1:]):\r\n        # replace the block below\r\n        with supress(TypeError):\r\n            with supress(ZeroDivisionError):\r\n                yield i/j\r\n    ",
            "date": "2022-11-01 20:51:28.110958+00:00",
            "passed": false
        },
        {
            "bite": "Bite 214. A countdown generator",
            "code": "def countdown():\r\n    \"\"\"Write a generator that counts from 100 to 1\"\"\"\r\n    COUNT = 100\r\n    for i in range(COUNT):\r\n        yield COUNT-i\r\n\r\n\"\"\"test for COUNT =5\r\n\r\ncd = countdown()\r\nprint(next(cd))\r\nprint(next(cd))\r\nprint(next(cd))\r\nprint(next(cd))\r\nprint(next(cd))\r\n\r\nnext(cd)\r\n\"\"\"",
            "date": "2022-11-01 20:43:01.495809+00:00",
            "passed": true
        },
        {
            "bite": "Bite 214. A countdown generator",
            "code": "def countdown():\r\n    \"\"\"Write a generator that counts from 100 to 1\"\"\"\r\n    COUNT = 100\r\n    for i in range(COUNT):\r\n        yield COUNT-i\r\n    raise StopIteration\r\n    \r\n\"\"\"test for COUNT =5\r\ncd = countdown()\r\nprint(next(cd))\r\nprint(next(cd))\r\nprint(next(cd))\r\nprint(next(cd))\r\nprint(next(cd))\r\n\r\nnext(cd)\r\n\"\"\"",
            "date": "2022-11-01 20:36:28.467322+00:00",
            "passed": false
        },
        {
            "bite": "Bite 210. Add Type Annotations",
            "code": "from typing import List\r\n\r\ndef sum_numbers(numbers: List[int]) -> int:\r\n    \"\"\"Sums numbers\r\n\r\n    :param numbers: a list of numbers\r\n    :type numbers: list\r\n    :raises TypeError: if not all numeric values passed in\r\n    :return: sum of numbers\r\n    :rtype: int\r\n    \"\"\"\r\n    pass",
            "date": "2022-10-31 10:39:29.333371+00:00",
            "passed": true
        },
        {
            "bite": "Bite 210. Add Type Annotations",
            "code": "from typing import List\r\n\r\ndef sum_numbers(numbers: List) -> int:\r\n    \"\"\"Sums numbers\r\n\r\n    :param numbers: a list of numbers\r\n    :type numbers: list\r\n    :raises TypeError: if not all numeric values passed in\r\n    :return: sum of numbers\r\n    :rtype: int\r\n    \"\"\"\r\n    pass",
            "date": "2022-10-31 10:38:55.492686+00:00",
            "passed": false
        },
        {
            "bite": "Bite 51. When does Python 2 die on Planet Miller?",
            "code": "from datetime import datetime\r\n\r\n# https://pythonclock.org/\r\nPY2_DEATH_DT = datetime(year=2020, month=1, day=1)\r\nBITE_CREATED_DT = datetime.strptime('2018-02-26 23:24:04', '%Y-%m-%d %H:%M:%S')\r\n\r\n\r\ndef py2_earth_hours_left(start_date=BITE_CREATED_DT):\r\n    \"\"\"Return how many hours, rounded to 2 decimals, Python 2 has\r\n       left on Planet Earth (calculated from start_date)\"\"\"\r\n    earth_tdelta = PY2_DEATH_DT - start_date\r\n    return round(earth_tdelta.total_seconds()/3600, 2)\r\n\r\ndef py2_miller_min_left(start_date=BITE_CREATED_DT):\r\n    \"\"\"Return how many minutes, rounded to 2 decimals, Python 2 has\r\n       left on Planet Miller (calculated from start_date)\"\"\"\r\n    earth_hours = py2_earth_hours_left(start_date)\r\n    return round(60*earth_hours/(7*365*24), 2)\r\n\r\n# print(py2_earth_hours_left())\r\n# print(py2_miller_min_left())",
            "date": "2022-10-30 10:18:15.235491+00:00",
            "passed": true
        },
        {
            "bite": "Bite 51. When does Python 2 die on Planet Miller?",
            "code": "from datetime import datetime\r\n\r\n# https://pythonclock.org/\r\nPY2_DEATH_DT = datetime(year=2020, month=1, day=1)\r\nBITE_CREATED_DT = datetime.strptime('2018-02-26 23:24:04', '%Y-%m-%d %H:%M:%S')\r\n\r\n\r\ndef py2_earth_hours_left(start_date=BITE_CREATED_DT):\r\n    \"\"\"Return how many hours, rounded to 2 decimals, Python 2 has\r\n       left on Planet Earth (calculated from start_date)\"\"\"\r\n    earth_duration = PY2_DEATH_DT - start_date\r\n    return round(earth_duration.total_seconds()/3600.0,2)\r\n\r\n\r\ndef py2_miller_min_left(start_date=BITE_CREATED_DT):\r\n    \"\"\"Return how many minutes, rounded to 2 decimals, Python 2 has\r\n       left on Planet Miller (calculated from start_date)\"\"\"\r\n    earth_hours = py2_earth_hours_left(start_date)\r\n    miller_mins = round(60*earth_hours/(7*365*24),2)\r\n    return miller_mins\r\n\r\nprint(py2_earth_hours_left())\r\nprint(py2_miller_min_left())",
            "date": "2022-10-30 10:16:02.240158+00:00",
            "passed": true
        },
        {
            "bite": "Bite 209. Write a Sphinx docstring",
            "code": "def sum_numbers(numbers):\r\n    \"\"\"Sums numbers\r\n    \r\n    :param numbers: List of numbers to add, defaults to None\r\n    :type numbers: list, optional\r\n\r\n    :raises TypeError: not all numeric values passed in\r\n    \r\n    :return: Sum of numbers\r\n    :rtype: int\r\n    \"\"\"\r\n    pass",
            "date": "2022-10-30 09:51:56.802966+00:00",
            "passed": true
        },
        {
            "bite": "Bite 209. Write a Sphinx docstring",
            "code": "def sum_numbers(numbers):\r\n    \"\"\"Takes a list of numbers and returns the sum\r\n    \r\n    :param numbers: List of numbers to add, defaults to None\r\n    :type numbers: list, optional\r\n\r\n    :raises TypeError: not all numeric values passed in\r\n    \r\n    :return: Sum of numbers\r\n    :rtype: int\r\n    \"\"\"\r\n    pass",
            "date": "2022-10-30 09:50:19.168407+00:00",
            "passed": false
        },
        {
            "bite": "Bite 209. Write a Sphinx docstring",
            "code": "def sum_numbers(numbers):\r\n    \"\"\"takes a list of numbers and returns the sum\r\n    \r\n    :param numbers: List of numbers to add, defaults to None\r\n    :type numbers: list, optional\r\n    ...\r\n    :raises TypeError: not all numeric values passed in\r\n    ...\r\n    :return: Sum of numbers\r\n    :rtype: int\r\n    \"\"\"\r\n    pass",
            "date": "2022-10-30 09:49:13.273279+00:00",
            "passed": false
        },
        {
            "bite": "Bite 209. Write a Sphinx docstring",
            "code": "def sum_numbers(numbers):\r\n    \"\"\"takes a list of numbers and returns the sum\r\n    \r\n    :param numbers: List of numbers to add, defaults to [None]\r\n    :type numbers: list\r\n    ...\r\n    :raises TypeError: not all numeric values passed in\r\n    ...\r\n    :return: Sum of numbers\r\n    :rtype: int\r\n    \"\"\"\r\n    pass",
            "date": "2022-10-30 09:46:23.853055+00:00",
            "passed": false
        },
        {
            "bite": "Newbie Bite 13. Dict data retrieval methods",
            "code": "ninjabelt_scores = {'white': 10, 'yellow': 20, 'orange': 30, 'green': 40, 'blue': 50, 'brown': 60, 'black': 70}\r\n\r\n# Try the 3 functions against the ninjabelts_scores dict below this line:\r\nninjabelt_scores.items()\r\nninjabelt_scores.keys()\r\nninjabelt_scores.values()",
            "date": "2022-10-29 18:29:20.361472+00:00",
            "passed": true
        },
        {
            "bite": "Newbie Bite 13. Dict data retrieval methods",
            "code": "ninjabelt_scores = {'white': 10, 'yellow': 20, 'orange': 30, 'green': 40, 'blue': 50, 'brown': 60, 'black': 70}\r\n\r\n# Try the 3 functions against the ninjabelts_scores dict below this line:\r\nninja_scores.items()\r\nninja_scores.keys()\r\nninja_scores.values()",
            "date": "2022-10-29 18:28:46.558219+00:00",
            "passed": false
        },
        {
            "bite": "Bite 192. Some logging practice",
            "code": "import logging\r\nfrom typing import Callable\r\n\r\nlogger=logging.getLogger(\"pybites_logger\")\r\n\r\nDEBUG = logger.debug\r\nINFO = logger.info\r\nWARNING = logger.warning\r\nERROR = logger.error\r\nCRITICAL = logger.critical\r\n\r\n\r\ndef log_it(level: Callable, msg: str) -> None:\r\n    level(msg)\r\n\r\nif __name__ == \"__main__\":\r\n    log_it(DEBUG, \"This is a debug message.\")\r\n    log_it(INFO, \"This is an info message.\")\r\n    log_it(WARNING, \"This is a warning message.\")\r\n    log_it(ERROR, \"This is an error message.\")\r\n    log_it(CRITICAL, \"This is a critical message.\")",
            "date": "2022-10-28 13:28:25.507551+00:00",
            "passed": true
        },
        {
            "bite": "Bite 192. Some logging practice",
            "code": "import logging\r\nfrom typing import Callable\r\n\r\nFORMAT = '%(message)s'\r\nlogging.basicConfig(format=FORMAT)\r\npybites_logger=logging.getLogger(\"pybites_logger\")\r\n\r\nDEBUG = pybites_logger.debug\r\nINFO = pybites_logger.info\r\nWARNING = pybites_logger.warning\r\nERROR = pybites_logger.error\r\nCRITICAL = pybites_logger.critical\r\n\r\n\r\ndef log_it(level: Callable, msg: str) -> None:\r\n    level(msg)\r\n\r\nif __name__ == \"__main__\":\r\n    log_it(DEBUG, \"This is a debug message.\")\r\n    log_it(INFO, \"This is an info message.\")\r\n    log_it(WARNING, \"This is a warning message.\")\r\n    log_it(ERROR, \"This is an error message.\")\r\n    log_it(CRITICAL, \"This is a critical message.\")",
            "date": "2022-10-28 13:26:29.504382+00:00",
            "passed": true
        },
        {
            "bite": "Bite 192. Some logging practice",
            "code": "import logging\r\nfrom typing import Callable\r\n\r\nFORMAT = '%(message)s'\r\nlogging.basicConfig(format=FORMAT)\r\npybites_logger=logging.getLogger(\"pybites_logger\")\r\n# pybites_logger.setLevel(logging.DEBUG)\r\n\r\nDEBUG = pybites_logger.debug\r\nINFO = pybites_logger.info\r\nWARNING = pybites_logger.warning\r\nERROR = pybites_logger.error\r\nCRITICAL = pybites_logger.critical\r\n\r\n\r\ndef log_it(level: Callable, msg: str) -> None:\r\n    level(msg)\r\n\r\nif __name__ == \"__main__\":\r\n    log_it(DEBUG, \"This is a debug message.\")\r\n    log_it(INFO, \"This is an info message.\")\r\n    log_it(WARNING, \"This is a warning message.\")\r\n    log_it(ERROR, \"This is an error message.\")\r\n    log_it(CRITICAL, \"This is a critical message.\")",
            "date": "2022-10-28 13:25:48.668701+00:00",
            "passed": true
        },
        {
            "bite": "Bite 192. Some logging practice",
            "code": "import logging\r\nfrom typing import Callable\r\n\r\nFORMAT = '%(message)s'\r\nlogging.basicConfig(format=FORMAT)\r\npybites_logger=logging.getLogger(\"pybites_logger\")\r\npybites_logger.setLevel(logging.DEBUG)\r\n\r\nDEBUG = pybites_logger.debug\r\nINFO = pybites_logger.info\r\nWARNING = pybites_logger.warning\r\nERROR = pybites_logger.error\r\nCRITICAL = pybites_logger.critical\r\n\r\n\r\ndef log_it(level: Callable, msg: str) -> None:\r\n    level(msg)\r\n\r\nif __name__ == \"__main__\":\r\n    log_it(DEBUG, \"This is a debug message.\")\r\n    log_it(INFO, \"This is an info message.\")\r\n    log_it(WARNING, \"This is a warning message.\")\r\n    log_it(ERROR, \"This is an error message.\")\r\n    log_it(CRITICAL, \"This is a critical message.\")",
            "date": "2022-10-28 13:23:49.879326+00:00",
            "passed": false
        },
        {
            "bite": "Bite 192. Some logging practice",
            "code": "import logging\r\nfrom typing import Callable\r\n\r\nFORMAT = '%(message)s'\r\nlogging.basicConfig(format=FORMAT)\r\npybites_logger=logging.getLogger(\"pybites_logger\")\r\npybites_logger.setLevel(logging.DEBUG)\r\n\r\nDEBUG = pybites_logger.debug\r\nINFO = pybites_logger.info\r\nWARNING = pybites_logger.warning\r\nERROR = pybites_logger.error\r\nCRITICAL = pybites_logger.critical\r\n\r\n\r\ndef log_it(level: Callable, msg: str) -> None:\r\n    level(msg)\r\n\r\nif __name__ == \"__main__\":\r\n    log_it(DEBUG, \"This is a debug message\")\r\n    log_it(INFO, \"This is an info message\")\r\n    log_it(WARNING, \"This is a warning message\")\r\n    log_it(ERROR, \"This is an error message\")\r\n    log_it(CRITICAL, \"This is a critical message\")",
            "date": "2022-10-28 13:23:10.604957+00:00",
            "passed": false
        },
        {
            "bite": "Bite 267. Measure the size of an island",
            "code": "# Hint:\r\n# You can define a helper funtion: get_others(map, row, col) to assist you.\r\n# Then in the main island_size function just call it when traversing the map.\r\n\r\n\r\ndef get_shores(map_, r, c):\r\n    \"\"\"Go through the map and check the size of the island\r\n       (= summing up all the 1s that are part of the island)\r\n\r\n       Input - the map, row, column position\r\n       Output - return the total number)\r\n    \"\"\"\r\n    nums = 0\r\n    rows= len(map_)\r\n    cols= (len(map_[0]))\r\n    # your code here\r\n    # print(f\"{r=},{c=}\")\r\n    #check N\r\n    if r==0:\r\n        nums+=1\r\n    else:\r\n        nums+=map_[r-1][c]==0\r\n    \r\n    #check S\r\n    if r==rows-1:\r\n        nums+=1\r\n    else:\r\n        nums+=map_[r+1][c]==0\r\n\r\n    #check E\r\n    if c==0:\r\n        nums+=1\r\n    else:\r\n        nums+=map_[r][c-1]==0\r\n\r\n    #check W\r\n    if c==cols-1:\r\n        nums+=1\r\n    else:\r\n        nums+=map_[r][c+1]==0\r\n    \r\n    return nums\r\n\r\n\r\ndef island_size(map_):\r\n    \"\"\"Hint: use the get_others helper\r\n\r\n    Input: the map\r\n    Output: the perimeter of the island\r\n    \"\"\"\r\n    perimeter = 0\r\n    rows= len(map_)\r\n    cols= (len(map_[0]))\r\n    # your code here\r\n    for i in range(rows):\r\n        for j in range(cols):\r\n            if map_[i][j] == 1:\r\n                perimeter +=get_shores(map_, i, j) \r\n    return perimeter\r\n    \r\n    \r\n",
            "date": "2022-10-27 18:37:17.307515+00:00",
            "passed": true
        },
        {
            "bite": "Bite 189. Filter a list of names",
            "code": "import string\r\nIGNORE_CHAR = 'b'\r\nQUIT_CHAR = 'q'\r\nMAX_NAMES = 5\r\n\r\n\r\ndef filter_names(names):\r\n    lst=[] \r\n    for name in names:\r\n        if name.startswith(IGNORE_CHAR) or any(char.isdigit() for char in name):\r\n            continue\r\n        if name.startswith(QUIT_CHAR):\r\n            break\r\n        lst.append(name)\r\n        if len(lst) >= MAX_NAMES:\r\n            break\r\n    return lst\r\n\r\nlst=['pet1e', 'milly', 'quit', 'me', 'you' ]\r\nprint(filter_names(lst))",
            "date": "2022-10-27 17:58:58.593730+00:00",
            "passed": true
        },
        {
            "bite": "Bite 189. Filter a list of names",
            "code": "import string\r\nIGNORE_CHAR = 'b'\r\nQUIT_CHAR = 'q'\r\nMAX_NAMES = 5\r\n\r\n\r\ndef filter_names(names):\r\n    lst=[] \r\n    for name in names:\r\n        if name.startswith(IGNORE_CHAR) or string.digits in name:\r\n            continue\r\n        if name.startswith(QUIT_CHAR):\r\n            break\r\n        lst.append(name)\r\n        if len(lst) >= MAX_NAMES:\r\n            break\r\n    return lst\r\n\r\nlst=['bob', 'milly', 'quit', 'me', 'you' ]\r\nprint(filter_names(lst))",
            "date": "2022-10-27 17:55:30.582692+00:00",
            "passed": false
        },
        {
            "bite": "Bite 189. Filter a list of names",
            "code": "IGNORE_CHAR = 'b'\r\nQUIT_CHAR = 'q'\r\nMAX_NAMES = 5\r\n\r\n\r\ndef filter_names(names):\r\n    lst=[] \r\n    for name in names:\r\n        if name.startswith(IGNORE_CHAR) or string.digits in name:\r\n            continue\r\n        if name.startswith(QUIT_CHAR):\r\n            break\r\n        lst.append(name)\r\n        if len(lst) >= MAX_NAMES:\r\n            break\r\n    retunr lst\r\n",
            "date": "2022-10-27 17:52:39.388226+00:00",
            "passed": false
        },
        {
            "bite": "Newbie Bite 12. Dicts",
            "code": "# This is the old list of ninjabelts for your reference.\r\nninjabelts = [\"white\", \"yellow\", \"orange\", \"green\", \"blue\", \"brown\", \"black\"]\r\n\r\n# Create your dictionary below this line:\r\nninjabelt_scores = {\r\n    \"white\": 10,\r\n    \"yellow\": 20,\r\n    \"orange\": 30,\r\n    \"green\": 40,\r\n    \"blue\": 50,\r\n    \"brown\": 60,\r\n    \"black\": 70,\r\n}",
            "date": "2022-10-26 21:56:29.474954+00:00",
            "passed": true
        },
        {
            "bite": "Bite 86. Create a RGB-to-Hex converter",
            "code": "def rgb_to_hex(rgb):\r\n    \"\"\"Receives (r, g, b)  tuple, checks if each rgb int is within RGB\r\n       boundaries (0, 255) and returns its converted hex, for example:\r\n       Silver: input tuple = (192,192,192) -> output hex str = #C0C0C0\"\"\"\r\n    if all(0<=col<=255 for col in rgb):\r\n        return f\"#{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}\".upper()\r\n    raise ValueError\r\n\r\n# print(rgb_to_hex((128, 128, 0)))",
            "date": "2022-10-25 18:14:49.902981+00:00",
            "passed": true
        },
        {
            "bite": "Bite 86. Create a RGB-to-Hex converter",
            "code": "def rgb_to_hex(rgb):\r\n    \"\"\"Receives (r, g, b)  tuple, checks if each rgb int is within RGB\r\n       boundaries (0, 255) and returns its converted hex, for example:\r\n       Silver: input tuple = (192,192,192) -> output hex str = #C0C0C0\"\"\"\r\n    if all(0<col<255 for col in rgb):\r\n        return f\"#{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}\".upper()\r\n    raise ValueError\r\n\r\n# print(rgb_to_hex((128, 128, 0)))",
            "date": "2022-10-25 18:13:08.403479+00:00",
            "passed": false
        },
        {
            "bite": "Bite 86. Create a RGB-to-Hex converter",
            "code": "def rgb_to_hex(rgb):\r\n    \"\"\"Receives (r, g, b)  tuple, checks if each rgb int is within RGB\r\n       boundaries (0, 255) and returns its converted hex, for example:\r\n       Silver: input tuple = (192,192,192) -> output hex str = #C0C0C0\"\"\"\r\n    return f\"#{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}\"\r\n    \r\n\r\n# print(rgb_to_hex((128, 128, 0)))",
            "date": "2022-10-25 18:11:10.601664+00:00",
            "passed": false
        },
        {
            "bite": "Bite 86. Create a RGB-to-Hex converter",
            "code": "def rgb_to_hex(rgb):\r\n    \"\"\"Receives (r, g, b)  tuple, checks if each rgb int is within RGB\r\n       boundaries (0, 255) and returns its converted hex, for example:\r\n       Silver: input tuple = (192,192,192) -> output hex str = #C0C0C0\"\"\"\r\n    return f\"#{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}\"\r\n    \r\n\r\nprint(rgb_to_hex((128, 128, 0)))",
            "date": "2022-10-25 18:10:54.630317+00:00",
            "passed": false
        },
        {
            "bite": "Bite 181. Keep a list sorted upon insert",
            "code": "import bisect\r\n\r\n\r\nclass OrderedList:\r\n\r\n    def __init__(self):\r\n        self._numbers = []\r\n\r\n    def add(self, num):\r\n        bisect.insort(self._numbers, num) # you complete\r\n\r\n    def __str__(self):\r\n        return ', '.join(str(num) for num in self._numbers)\r\n\r\nif __name__ == \"__main__\":\r\n    order = OrderedList()\r\n    order.add(10)\r\n    print(order)  # __str__ already provided\r\n    order.add(1)\r\n    print(order)\r\n    order.add(16)\r\n    print(order)\r\n    order.add(5)\r\n    print(order)\r\n",
            "date": "2022-10-25 17:53:55.628868+00:00",
            "passed": true
        },
        {
            "bite": "Bite 181. Keep a list sorted upon insert",
            "code": "import bisect\r\n\r\n\r\nclass OrderedList:\r\n\r\n    def __init__(self):\r\n        self._numbers = []\r\n\r\n    def add(self, num):\r\n        bisect.insort(self._numbers, num) # you complete\r\n\r\n    def __str__(self):\r\n        return ', '.join(str(num) for num in self._numbers)\r\n\r\nif ___name__ == \"__main__\":\r\n    order = OrderedList()\r\n    order.add(10)\r\n    print(order)  # __str__ already provided\r\n    order.add(1)\r\n    print(order)\r\n    order.add(16)\r\n    print(order)\r\n    order.add(5)\r\n    print(order)\r\n",
            "date": "2022-10-25 17:53:42.480819+00:00",
            "passed": false
        },
        {
            "bite": "Bite 180. Group names by country",
            "code": "from collections import defaultdict\r\nfrom pprint import pprint \r\n\r\n# fake data from https://www.mockaroo.com\r\ndata = \"\"\"last_name,first_name,country_code\r\nWatsham,Husain,ID\r\nHarrold,Alphonso,BR\r\nApdell,Margo,CN\r\nTomblings,Deerdre,RU\r\nWasielewski,Sula,ID\r\nJeffry,Rudolph,TD\r\nBrenston,Luke,SE\r\nParrett,Ines,CN\r\nBraunle,Kermit,PL\r\nHalbard,Davie,CN\"\"\"\r\n\r\n\r\ndef group_names_by_country(data: str = data) -> defaultdict:\r\n    countries = defaultdict(list)\r\n    # your code\r\n    for line in data.splitlines():\r\n        surname, name, country = tuple(line.split(\",\"))\r\n        if country != \"country_code\":\r\n            countries[country].append(\" \".join([name,surname]))\r\n    return countries\r\n    \r\npprint(group_names_by_country())",
            "date": "2022-10-24 21:44:59.948990+00:00",
            "passed": true
        },
        {
            "bite": "Bite 176. Create a variable length chessboard",
            "code": "WHITE, BLACK = ' ', '#'\r\n\r\n\r\ndef create_chessboard(size=8):\r\n    \"\"\"Create a chessboard with of the size passed in.\r\n       Don't return anything, print the output to stdout\"\"\"\r\n    odd_row = (WHITE + BLACK)*(size // 2)\r\n    even_row = (BLACK + WHITE)*(size // 2)\r\n    if size%2:\r\n        odd_row+=WHITE\r\n        even_row+=BLACK\r\n    odd_row+=\"\\n\"\r\n    even_row+=\"\\n\"\r\n    board =  (odd_row + even_row)*(size // 2)\r\n    if size%2:\r\n        board+=odd_row\r\n    print(board)\r\n\r\ncreate_chessboard(8)",
            "date": "2022-10-23 17:09:15.964129+00:00",
            "passed": true
        },
        {
            "bite": "Bite 48. Make a bar chart of new Safari books",
            "code": "import os\r\nimport urllib.request\r\nimport time\r\nimport sys\r\n\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nDATA = 'safari.logs'\r\nSAFARI_LOGS = os.path.join(TMP, DATA)\r\nPY_BOOK, OTHER_BOOK = '\ud83d\udc0d', '.'\r\nBOOK_SENT_TO_SLACK=\"sending to slack channel\"\r\nPYTHON = \"python\"\r\n\r\nurllib.request.urlretrieve(\r\n    f'https://bites-data.s3.us-east-2.amazonaws.com/{DATA}',\r\n    SAFARI_LOGS\r\n)\r\n\r\ndef create_chart():\r\n    last_date = \"00-00\"\r\n    with open(SAFARI_LOGS) as f:\r\n        for line in f:\r\n            date, rest = line.split(\" \", 1)\r\n            _, book_title = rest.split(\"-\", 1)\r\n\r\n            if BOOK_SENT_TO_SLACK in next(f):\r\n                if date != last_date:\r\n                    sys.stdout.write(\"\\n\"+date+\" \")\r\n                    last_date = date\r\n                sys.stdout.write(PY_BOOK if PYTHON in book_title.lower() else OTHER_BOOK)\r\n\r\n                    \r\ncreate_chart()",
            "date": "2022-10-23 16:45:51.808438+00:00",
            "passed": true
        },
        {
            "bite": "Bite 48. Make a bar chart of new Safari books",
            "code": "import os\r\nimport urllib.request\r\nimport time\r\nimport sys\r\n\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nDATA = 'safari.logs'\r\nSAFARI_LOGS = os.path.join(TMP, DATA)\r\nPY_BOOK, OTHER_BOOK = '\ud83d\udc0d', '.'\r\nBOOK_SENT_TO_SLACK=\"sending to slack channel\"\r\nPYTHON = \"python\"\r\n\r\nurllib.request.urlretrieve(\r\n    f'https://bites-data.s3.us-east-2.amazonaws.com/{DATA}',\r\n    SAFARI_LOGS\r\n)\r\n\r\ndef _put_a_dot(c):\r\n    sys.stdout.write(c)\r\n    sys.stdout.flush()\r\n    # time.sleep(0.25)\r\n\r\ndef create_chart():\r\n    last_date = \"00-00\"\r\n    i=0\r\n    with open(SAFARI_LOGS) as f:\r\n        for line in f:\r\n            date, rest = tuple(line.split(\" \",1))\r\n            _, book_title = rest.split(\"-\",1)\r\n            *_, action = next(f).split(\"-\",1)\r\n\r\n            if BOOK_SENT_TO_SLACK in action:\r\n                if date != last_date:\r\n                    sys.stdout.write(\"\\n\"+date+\" \")\r\n                    last_date = date\r\n                _put_a_dot(PY_BOOK if PYTHON in book_title.lower() else OTHER_BOOK)\r\n\r\n                    \r\ncreate_chart()",
            "date": "2022-10-23 16:41:00.461113+00:00",
            "passed": true
        },
        {
            "bite": "Bite 48. Make a bar chart of new Safari books",
            "code": "import os\r\nimport urllib.request\r\nimport time\r\nimport sys\r\n\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nDATA = 'safari.logs'\r\nSAFARI_LOGS = os.path.join(TMP, DATA)\r\nPY_BOOK, OTHER_BOOK = '\ud83d\udc0d', '.'\r\nBOOK_SENT_TO_SLACK=\"sending to slack channel\"\r\nPYTHON = \"python\"\r\n\r\nurllib.request.urlretrieve(\r\n    f'https://bites-data.s3.us-east-2.amazonaws.com/{DATA}',\r\n    SAFARI_LOGS\r\n)\r\n\r\ndef _put_a_dot(c):\r\n    sys.stdout.write(c)\r\n    sys.stdout.flush()\r\n    # time.sleep(0.25)\r\n\r\ndef create_chart():\r\n    last_date = \"00-00\"\r\n    i=0\r\n    with open(SAFARI_LOGS) as f:\r\n        for line in f:\r\n            date, rest = tuple(line.split(\" \",1))\r\n            _, book_title = rest.split(\"-\",1)\r\n            *_, action = next(f).split(\"-\",1)\r\n            print(f\"{date=} {book_title=} {action=}\")\r\n            if BOOK_SENT_TO_SLACK in action:\r\n                if date != last_date:\r\n                    sys.stdout.write(\"\\n\"+date+\" \")\r\n                    last_date = date\r\n                _put_a_dot(PY_BOOK if PYTHON in book_title.lower() else OTHER_BOOK\r\n        \"\"\"\r\n            date, rest = tuple(line.split(\" \",1))\r\n            _, payload = rest.split(\"-\",1)\r\n            i+=1\r\n            if i%2 == 1:\r\n                book_title = payload\r\n            elif i%2 == 0:\r\n                action = payload\r\n                # print(f\"{date=} {book_title=} {action=}\")\r\n                if BOOK_SENT_TO_SLACK in action:\r\n                    if date != last_date:\r\n                        sys.stdout.write(\"\\n\"+date+\" \")\r\n                        last_date = date\r\n                    _put_a_dot(PY_BOOK if PYTHON in book_title.lower() else OTHER_BOOK\r\n        \"\"\"\r\n                    \r\ncreate_chart()",
            "date": "2022-10-23 16:39:21.429008+00:00",
            "passed": false
        },
        {
            "bite": "Bite 340. Update and delete food objects",
            "code": "from typing import Dict, List\r\n\r\nfrom fastapi import FastAPI, HTTPException\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n\r\n@app.post(\"/\", status_code=201)\r\nasync def create_food(food: Food):\r\n    \"\"\"Endpoint from Bite 03\"\"\"\r\n    foods[food.id] = food\r\n    return food\r\n\r\n\r\n@app.get(\"/\", response_model=List[Food])\r\nasync def read_foods():\r\n    \"\"\"Endpoints from Bite 04\"\"\"\r\n    return list(foods.values())\r\n\r\n\r\n@app.get(\"/{food_id}\", response_model=Food)\r\nasync def read_food(food_id: int):\r\n    \"\"\"Endpoints from Bite 04\"\"\"\r\n    return foods[food_id]\r\n\r\n\r\n# Create the update and delete endpoints here ...\r\n@app.put(\"/{food_id}\")\r\nasync def update_food(food_id: int, food: Food):\r\n    if food_id not in foods:\r\n        raise HTTPException(status_code=404, detail=\"Food not found\")\r\n    foods[food_id] = food\r\n    return foods[food_id]    \r\n\r\n\r\n@app.delete(\"/{food_id}\")\r\nasync def delete_food(food_id: int):\r\n    try:\r\n        foods.pop(food_id)\r\n    except:\r\n        raise HTTPException(404, detail=\"Food not found\")\r\n    return {\"ok\": True}",
            "date": "2022-10-22 12:09:53.522195+00:00",
            "passed": true
        },
        {
            "bite": "Bite 340. Update and delete food objects",
            "code": "from typing import Dict, List\r\n\r\nfrom fastapi import FastAPI, HTTPException\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n\r\n@app.post(\"/\", status_code=201)\r\nasync def create_food(food: Food):\r\n    \"\"\"Endpoint from Bite 03\"\"\"\r\n    foods[food.id] = food\r\n    return food\r\n\r\n\r\n@app.get(\"/\", response_model=List[Food])\r\nasync def read_foods():\r\n    \"\"\"Endpoints from Bite 04\"\"\"\r\n    return list(foods.values())\r\n\r\n\r\n@app.get(\"/{food_id}\", response_model=Food)\r\nasync def read_food(food_id: int):\r\n    \"\"\"Endpoints from Bite 04\"\"\"\r\n    return foods[food_id]\r\n\r\n\r\n# Create the update and delete endpoints here ...\r\n@app.put(\"/{food_id}\")\r\nasync def update_food(food_id: int, food: Food):\r\n    foods[food_id] = food\r\n    \"\"\"\r\n    try:\r\n        foods[food_id] = food\r\n    except:\r\n        raise HTTPException(404, detail=\"Food not found\")\r\n    \"\"\"\r\n    return foods[food_id]    \r\n\r\n\r\n@app.delete(\"/{food_id}\")\r\nasync def delete_food(food_id: int):\r\n    try:\r\n        foods.pop(food_id)\r\n    except:\r\n        raise HTTPException(404, detail=\"Food not found\")\r\n    return {\"ok\": True}",
            "date": "2022-10-22 12:04:41.722231+00:00",
            "passed": false
        },
        {
            "bite": "Bite 340. Update and delete food objects",
            "code": "from typing import Dict, List\r\n\r\nfrom fastapi import FastAPI, HTTPException\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n\r\n@app.post(\"/\", status_code=201)\r\nasync def create_food(food: Food):\r\n    \"\"\"Endpoint from Bite 03\"\"\"\r\n    foods[food.id] = food\r\n    return food\r\n\r\n\r\n@app.get(\"/\", response_model=List[Food])\r\nasync def read_foods():\r\n    \"\"\"Endpoints from Bite 04\"\"\"\r\n    return list(foods.values())\r\n\r\n\r\n@app.get(\"/{food_id}\", response_model=Food)\r\nasync def read_food(food_id: int):\r\n    \"\"\"Endpoints from Bite 04\"\"\"\r\n    return foods[food_id]\r\n\r\n\r\n# Create the update and delete endpoints here ...\r\n@app.put(\"/{food_id}\", response_model=Food)\r\nasync def update_food(food_id: int, food: Food):\r\n    try:\r\n        foods[food_id] = food\r\n    except:\r\n        raise HTTPException(404, detail=\"Food not found\")\r\n    return foods[food_id]    \r\n\r\n\r\n@app.delete(\"/{food_id}\")\r\nasync def delete_food(food_id: int):\r\n    try:\r\n        foods.pop(food_id)\r\n    except:\r\n        raise HTTPException(404, detail=\"Food not found\")\r\n    return {\"ok\": True}",
            "date": "2022-10-22 11:58:36.815976+00:00",
            "passed": false
        },
        {
            "bite": "Bite 340. Update and delete food objects",
            "code": "from typing import Dict, List\r\n\r\nfrom fastapi import FastAPI, HTTPException\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n\r\n@app.post(\"/\", status_code=201)\r\nasync def create_food(food: Food):\r\n    \"\"\"Endpoint from Bite 03\"\"\"\r\n    foods[food.id] = food\r\n    return food\r\n\r\n\r\n@app.get(\"/\", response_model=List[Food])\r\nasync def read_foods():\r\n    \"\"\"Endpoints from Bite 04\"\"\"\r\n    return list(foods.values())\r\n\r\n\r\n@app.get(\"/{food_id}\", response_model=Food)\r\nasync def read_food(food_id: int):\r\n    \"\"\"Endpoints from Bite 04\"\"\"\r\n    return foods[food_id]\r\n\r\n\r\n# Create the update and delete endpoints here ...\r\n@app.put(\"/{food_id}\", response_model=Food)\r\nasync def update_food(food_id: int, food: Food):\r\n    try:\r\n        foods[food_id] = food\r\n    except KeyError:\r\n        raise HTTPException(404, detail=\"Food not found\")\r\n    return foods[food_id]    \r\n\r\n\r\n@app.delete(\"/{food_id}\")\r\nasync def delete_food(food_id: int):\r\n    try:\r\n        foods.pop(food_id)\r\n    except KeyError:\r\n        raise HTTPException(404, detail=\"Food not found\")\r\n    return {\"ok\": True}",
            "date": "2022-10-22 11:57:45.665697+00:00",
            "passed": false
        },
        {
            "bite": "Bite 340. Update and delete food objects",
            "code": "from typing import Dict, List\r\n\r\nfrom fastapi import FastAPI, HTTPException\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n\r\n@app.post(\"/\", status_code=201)\r\nasync def create_food(food: Food):\r\n    \"\"\"Endpoint from Bite 03\"\"\"\r\n    foods[food.id] = food\r\n    return food\r\n\r\n\r\n@app.get(\"/\", response_model=List[Food])\r\nasync def read_foods():\r\n    \"\"\"Endpoints from Bite 04\"\"\"\r\n    return list(foods.values())\r\n\r\n\r\n@app.get(\"/{food_id}\", response_model=Food)\r\nasync def read_food(food_id: int):\r\n    \"\"\"Endpoints from Bite 04\"\"\"\r\n    return foods[food_id]\r\n\r\n\r\n# Create the update and delete endpoints here ...\r\n@app.put(\"/{food_id}\", response_model=Food)\r\nasync def read_food(food_id: int, food: Food):\r\n    try:\r\n        foods[food_id] = food\r\n    except KeyError:\r\n        raise HTTPException(404, detail=\"Food not found\")\r\n    return foods[food_id]    \r\n\r\n@app.delete(\"/{food_id}\", response_model=Food)\r\nasync def read_food(food_id: int):\r\n    try:\r\n        foods.pop(food_id)\r\n    except KeyError:\r\n        raise HTTPException(404, detail=\"Food not found\")\r\n    return {\"ok\": True}",
            "date": "2022-10-22 11:55:15.082842+00:00",
            "passed": false
        },
        {
            "bite": "Bite 339. Retrieve food objects",
            "code": "from typing import Dict\r\n\r\nfrom fastapi import FastAPI\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n\r\n@app.post(\"/\", status_code=201)\r\nasync def create_food(food: Food):\r\n    \"\"\"Endpoint from Bite 03\"\"\"\r\n    foods[food.id] = food\r\n    return food\r\n\r\n\r\n# write the two Read endpoints\r\n@app.get(\"/\", status_code=200)\r\nasync def read_foods():\r\n    \"\"\"Endpoint to read all foods\"\"\"\r\n    return [food for food in foods.values()]\r\n\r\n\r\n@app.get(\"/{item_id}\", status_code=200)\r\nasync def read_food(item_id:int):\r\n    \"\"\"Endpoint to read a given food item\"\"\"\r\n    \r\n    return foods[item_id]\r\n",
            "date": "2022-10-22 11:38:07.583709+00:00",
            "passed": true
        },
        {
            "bite": "Bite 339. Retrieve food objects",
            "code": "from typing import Dict\r\n\r\nfrom fastapi import FastAPI\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n\r\n@app.post(\"/\", status_code=201)\r\nasync def create_food(food: Food):\r\n    \"\"\"Endpoint from Bite 03\"\"\"\r\n    foods[food.id] = food\r\n    return food\r\n\r\n\r\n# write the two Read endpoints\r\n@app.get(\"/\", status_code=200)\r\nasync def read_foods():\r\n    \"\"\"Endpoint to read all foods\"\"\"\r\n    return [food for food in foods.values()]\r\n\r\n@app.get(\"/{item_id}\", status_code=200)\r\nasync def read_food(item_id:int):\r\n    \"\"\"Endpoint to read a given food item\"\"\"\r\n    \r\n    return foods[item_id]\r\n",
            "date": "2022-10-22 11:37:39.444839+00:00",
            "passed": true
        },
        {
            "bite": "Bite 339. Retrieve food objects",
            "code": "from typing import Dict\r\n\r\nfrom fastapi import FastAPI\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n\r\n@app.post(\"/\", status_code=201)\r\nasync def create_food(food: Food):\r\n    \"\"\"Endpoint from Bite 03\"\"\"\r\n    foods[food.id] = food\r\n    return food\r\n\r\n\r\n# write the two Read endpoints\r\n@app.get(\"/\", status_code=200)\r\nasync def read_foods():\r\n    \"\"\"Endpoint to read all foods\"\"\"\r\n    return [food for food in foods.values()]\r\n\r\n@app.get(\"/{item_id}\", status_code=200)\r\nasync def read_food(item_id:str):\r\n    \"\"\"Endpoint to read a given food item\"\"\"\r\n    \r\n    return foods[item_id]\r\n",
            "date": "2022-10-22 11:35:35.791799+00:00",
            "passed": false
        },
        {
            "bite": "Bite 339. Retrieve food objects",
            "code": "from typing import Dict\r\n\r\nfrom fastapi import FastAPI\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n\r\n@app.post(\"/\", status_code=201)\r\nasync def create_food(food: Food):\r\n    \"\"\"Endpoint from Bite 03\"\"\"\r\n    foods[food.id] = food\r\n    return food\r\n\r\n\r\n# write the two Read endpoints\r\n@app.get(\"/\", status_code=200)\r\nasync def read_foods():\r\n    \"\"\"Endpoint to read all foods\"\"\"\r\n    return [food for food in foods.values()]\r\n\r\n@app.get(\"/{item_id}\", status_code=200)\r\nasync def read_food(item_id):\r\n    \"\"\"Endpoint to read a given food item\"\"\"\r\n    \r\n    return foods[item_id]\r\n",
            "date": "2022-10-22 11:34:34.936079+00:00",
            "passed": false
        },
        {
            "bite": "Bite 339. Retrieve food objects",
            "code": "from typing import Dict\r\n\r\nfrom fastapi import FastAPI\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n\r\n@app.post(\"/\", status_code=201)\r\nasync def create_food(food: Food):\r\n    \"\"\"Endpoint from Bite 03\"\"\"\r\n    foods[food.id] = food\r\n    return food\r\n\r\n\r\n# write the two Read endpoints\r\n@app.get(\"/\", status_code=200)\r\nasync def read_foods():\r\n    \"\"\"Endpoint to read all foods\"\"\"\r\n    return foods\r\n\r\n@app.get(\"/\", status_code=200)\r\nasync def read_food(id):\r\n    \"\"\"Endpoint to read a given food item\"\"\"\r\n    return foods[id]\r\n",
            "date": "2022-10-22 11:29:28.199839+00:00",
            "passed": false
        },
        {
            "bite": "Bite 239. Test FizzBuzz",
            "code": "from fizzbuzz import fizzbuzz\r\n\r\n# write one or more pytest functions below, they need to start with test_\r\ndef test_for_fizz():\r\n    for num in [3, 6, 9, 12]:\r\n        assert fizzbuzz(num) == \"Fizz\"\r\n\r\ndef test_for_buzz():\r\n    for num in [5, 10, 20, 25]:\r\n        assert fizzbuzz(num) == \"Buzz\"\r\n    \r\ndef test_for_fizzbuzz():\r\n    for num in [15, 45, 75, 225]:\r\n        assert fizzbuzz(num) == \"Fizz Buzz\"\r\n\r\ndef test_for_other():\r\n    for num in [1, 2, 4, 7, 8, 11, 13, 14, 16]:\r\n        assert fizzbuzz(num) == num",
            "date": "2022-10-22 10:58:52.824247+00:00",
            "passed": true
        },
        {
            "bite": "Bite 172. Having fun with Python Partials",
            "code": "from functools import partial\r\n\r\n# create 2 partials:\r\n# - 'rounder_int' rounds to int (0 places)\r\n# - 'rounder_detailed' rounds to 4 places\r\nrounder_int =  partial(round, ndigits=0) \r\nrounder_detailed = partial(round, ndigits=4) \r\n\r\n",
            "date": "2022-10-22 10:41:17.760005+00:00",
            "passed": true
        },
        {
            "bite": "Bite 172. Having fun with Python Partials",
            "code": "from functools import partial\r\n\r\n# create 2 partials:\r\n# - 'rounder_int' rounds to int (0 places)\r\n# - 'rounder_detailed' rounds to 4 places\r\nrounder_int =  partial(round, ndigits=0) # you code\r\nrounder_detailed = partial(round, ndigits=4) # you code\r\n\r\nprint(rounder_int(10.456789))\r\nprint(rounder_detailed(10.456789))",
            "date": "2022-10-22 10:40:55.106782+00:00",
            "passed": true
        },
        {
            "bite": "Bite 169. Simple length converter",
            "code": "CM_PER_INCH=2.54\r\ndef convert(value: float, fmt: str) -> float:\r\n    \"\"\"Converts the value to the designated format.\r\n\r\n    :param value: The value to be converted must be numeric or raise a TypeError\r\n    :param fmt: String indicating format to convert to\r\n    :return: Float rounded to 4 decimal places after conversion\r\n    \"\"\"\r\n    if type(value) not in [int, float]:\r\n        raise TypeError\r\n    if not isinstance(fmt,str):\r\n        raise ValueError\r\n    if fmt.lower() == \"cm\":\r\n        k = CM_PER_INCH\r\n    elif fmt.lower() == \"in\":\r\n        k = 1 / CM_PER_INCH\r\n    else: \r\n        raise ValueError\r\n    \r\n    return round(k*value,4)",
            "date": "2022-10-21 19:29:37.128005+00:00",
            "passed": true
        },
        {
            "bite": "Bite 169. Simple length converter",
            "code": "CM_PER_INCH=2.54\r\ndef convert(value: float, fmt: str) -> float:\r\n    \"\"\"Converts the value to the designated format.\r\n\r\n    :param value: The value to be converted must be numeric or raise a TypeError\r\n    :param fmt: String indicating format to convert to\r\n    :return: Float rounded to 4 decimal places after conversion\r\n    \"\"\"\r\n    if type(value) not in [int, float]:\r\n        raise TypeError\r\n    if not isinstance(fmt,str) or fmt.lower() not in [\"cm\", \"in\"]:\r\n        raise ValueError\r\n    if fmt.lower() == \"cm\":\r\n        result = value * CM_PER_INCH\r\n    if fmt.lower() == \"in\":\r\n        result = value / CM_PER_INCH\r\n    \r\n    return round(result,4)",
            "date": "2022-10-21 19:27:23.588150+00:00",
            "passed": true
        },
        {
            "bite": "Bite 169. Simple length converter",
            "code": "CM_PER_INCH=2.54\r\ndef convert(value: float, fmt: str) -> float:\r\n    \"\"\"Converts the value to the designated format.\r\n\r\n    :param value: The value to be converted must be numeric or raise a TypeError\r\n    :param fmt: String indicating format to convert to\r\n    :return: Float rounded to 4 decimal places after conversion\r\n    \"\"\"\r\n    if type(value) not in [int, float]:\r\n        raise TypeError\r\n    if not isinstance(fmt,str) or fmt.lower() not in [\"cm\", \"in\"]:\r\n        raise ValueError\r\n    if fmt.lower() == \"cm\":\r\n        result = value * CM_PER_INCH\r\n    if fmt-lower() == \"in\":\r\n        result = value / CM_PER_INCH\r\n    \r\n    return round(result,4)",
            "date": "2022-10-21 19:27:04.946816+00:00",
            "passed": false
        },
        {
            "bite": "Bite 169. Simple length converter",
            "code": "CM_PER_INCH=2.54\r\ndef convert(value: float, fmt: str) -> float:\r\n    \"\"\"Converts the value to the designated format.\r\n\r\n    :param value: The value to be converted must be numeric or raise a TypeError\r\n    :param fmt: String indicating format to convert to\r\n    :return: Float rounded to 4 decimal places after conversion\r\n    \"\"\"\r\n    if type(value) not in [int, float]:\r\n        raise TypeError\r\n    if not isinstance(fmt,str) or fmt not in [\"cm\", \"in\"]:\r\n        raise ValueError\r\n    if fmt == \"cm\":\r\n        result = value * CM_PER_INCH\r\n    if fmt == \"in\":\r\n        result = value / CM_PER_INCH\r\n    \r\n    return round(result,4)",
            "date": "2022-10-21 19:26:06.519500+00:00",
            "passed": false
        },
        {
            "bite": "Bite 169. Simple length converter",
            "code": "CM_PER_INCH=2.54\r\ndef convert(value: float, fmt: str) -> float:\r\n    \"\"\"Converts the value to the designated format.\r\n\r\n    :param value: The value to be converted must be numeric or raise a TypeError\r\n    :param fmt: String indicating format to convert to\r\n    :return: Float rounded to 4 decimal places after conversion\r\n    \"\"\"\r\n    if type(value) not in [int, float]:\r\n        raise TypeError\r\n    if not isinstance(fmt,str) or fmt not in [\"cm\", \"in\"]:\r\n        raise ValueError\r\n    if fmt == \"cm\":\r\n        result = value / CM_PER_INCH\r\n    if fmt == \"in\":\r\n        result = value * CM_PER_INCH\r\n    \r\n    return round(result,4)",
            "date": "2022-10-21 19:23:42.983324+00:00",
            "passed": false
        },
        {
            "bite": "Bite 165. Parse an /etc/passwd file output",
            "code": "from typing import List\r\nimport re\r\n\r\nDEFAULT_SHELL = 'bash'\r\n# https://github.com/avar/git-anyonecanedit-etc/blob/master/passwd\r\nPASSWD_OUTPUT = \"\"\"root:x:0:0:root:/root:/bin/bash\r\ndaemon:x:1:1:daemon:/usr/sbin:/bin/sh\r\nbin:x:2:2:bin:/bin:/bin/sh\r\nsys:x:3:3:sys:/dev:/bin/sh\r\nsync:x:4:65534:sync:/bin:/bin/sync\r\ngames:x:5:60:games:/usr/games:/bin/sh\r\nman:x:6:12:man:/var/cache/man:/bin/sh\r\nlp:x:7:7:lp:/var/spool/lpd:/bin/sh\r\nmail:x:8:8:mail:/var/mail:/bin/sh\r\nnews:x:9:9:news:/var/spool/news:/bin/sh\r\nuucp:x:10:10:uucp:/var/spool/uucp:/bin/sh\r\nproxy:x:13:13:proxy:/bin:/bin/sh\r\nwww-data:x:33:33:www-data:/var/www:/bin/sh\r\nbackup:x:34:34:backup:/var/backups:/bin/sh\r\nlist:x:38:38:Mailing List Manager:/var/list:/bin/sh\r\nirc:x:39:39:ircd:/var/run/ircd:/bin/sh\r\ngnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/sh\r\nnobody:x:65534:65534:nobody:/nonexistent:/bin/sh\r\nlibuuid:x:100:101::/var/lib/libuuid:/bin/sh\r\nDebian-exim:x:101:103::/var/spool/exim4:/bin/false\r\nstatd:x:102:65534::/var/lib/nfs:/bin/false\r\nsshd:x:103:65534::/var/run/sshd:/usr/sbin/nologin\r\nftp:x:104:65534::/home/ftp:/bin/false\r\nmessagebus:x:105:106::/var/run/dbus:/bin/false\r\nmysql:x:106:107:MySQL Server,,,:/var/lib/mysql:/bin/false\r\navar:x:1000:1000::/home/avar:/bin/bash\r\nchad:x:1001:1001::/home/chad:/bin/bash\r\ngit-svn-mirror:x:1002:1002:Git mirror,,,:/home/git-svn-mirror:/bin/bash\r\ngerrit2:x:1003:1003:Gerrit User,,,:/home/gerrit2:/bin/bash\r\navahi:x:107:108:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/bin/false\r\npostfix:x:108:112::/var/spool/postfix:/bin/false\r\nssh-rsa:x:1004:1004::/home/ssh-rsa:/bin/bash\r\nartagnon:x:1005:1005:Ramkumar R,,,,Git GSOC:/home/artagnon:/bin/bash\"\"\"\r\n\r\n\r\ndef get_users_for_shell(passwd_output: str = PASSWD_OUTPUT,\r\n                        grep_shell: str = DEFAULT_SHELL) -> List[str]:\r\n    \"\"\"Match the passwd_output string for users with grep_shell.\r\n       Return a list of users.\r\n    \"\"\"\r\n    lst = []\r\n    for line in passwd_output.splitlines():\r\n        usr, rest = line.split(\":\",1)\r\n        if re.search(f\"/bin/{grep_shell}\",rest):\r\n            lst.append(usr)\r\n    return lst\r\n        \r\n# print(get_users_for_shell())\r\n",
            "date": "2022-10-19 21:17:13.906766+00:00",
            "passed": true
        },
        {
            "bite": "Bite 165. Parse an /etc/passwd file output",
            "code": "from typing import List\r\nimport re\r\n\r\nDEFAULT_SHELL = 'bash'\r\n# https://github.com/avar/git-anyonecanedit-etc/blob/master/passwd\r\nPASSWD_OUTPUT = \"\"\"root:x:0:0:root:/root:/bin/bash\r\ndaemon:x:1:1:daemon:/usr/sbin:/bin/sh\r\nbin:x:2:2:bin:/bin:/bin/sh\r\nsys:x:3:3:sys:/dev:/bin/sh\r\nsync:x:4:65534:sync:/bin:/bin/sync\r\ngames:x:5:60:games:/usr/games:/bin/sh\r\nman:x:6:12:man:/var/cache/man:/bin/sh\r\nlp:x:7:7:lp:/var/spool/lpd:/bin/sh\r\nmail:x:8:8:mail:/var/mail:/bin/sh\r\nnews:x:9:9:news:/var/spool/news:/bin/sh\r\nuucp:x:10:10:uucp:/var/spool/uucp:/bin/sh\r\nproxy:x:13:13:proxy:/bin:/bin/sh\r\nwww-data:x:33:33:www-data:/var/www:/bin/sh\r\nbackup:x:34:34:backup:/var/backups:/bin/sh\r\nlist:x:38:38:Mailing List Manager:/var/list:/bin/sh\r\nirc:x:39:39:ircd:/var/run/ircd:/bin/sh\r\ngnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/sh\r\nnobody:x:65534:65534:nobody:/nonexistent:/bin/sh\r\nlibuuid:x:100:101::/var/lib/libuuid:/bin/sh\r\nDebian-exim:x:101:103::/var/spool/exim4:/bin/false\r\nstatd:x:102:65534::/var/lib/nfs:/bin/false\r\nsshd:x:103:65534::/var/run/sshd:/usr/sbin/nologin\r\nftp:x:104:65534::/home/ftp:/bin/false\r\nmessagebus:x:105:106::/var/run/dbus:/bin/false\r\nmysql:x:106:107:MySQL Server,,,:/var/lib/mysql:/bin/false\r\navar:x:1000:1000::/home/avar:/bin/bash\r\nchad:x:1001:1001::/home/chad:/bin/bash\r\ngit-svn-mirror:x:1002:1002:Git mirror,,,:/home/git-svn-mirror:/bin/bash\r\ngerrit2:x:1003:1003:Gerrit User,,,:/home/gerrit2:/bin/bash\r\navahi:x:107:108:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/bin/false\r\npostfix:x:108:112::/var/spool/postfix:/bin/false\r\nssh-rsa:x:1004:1004::/home/ssh-rsa:/bin/bash\r\nartagnon:x:1005:1005:Ramkumar R,,,,Git GSOC:/home/artagnon:/bin/bash\"\"\"\r\n\r\n\r\ndef get_users_for_shell(passwd_output: str = PASSWD_OUTPUT,\r\n                        grep_shell: str = DEFAULT_SHELL) -> List[str]:\r\n    \"\"\"Match the passwd_output string for users with grep_shell.\r\n       Return a list of users.\r\n    \"\"\"\r\n    lst = []\r\n    for line in passwd_output.splitlines():\r\n        usr, rest = line.split(\":\",1)\r\n\r\n        if re.search(f\"/bin/{grep_shell}\",rest):\r\n            lst.append(usr)\r\n            print(f\"{usr=}, {rest=}\")\r\n    return lst\r\n        \r\n    # return [match.lstrip(\"home/\") for match in re.findall(f\"/(.+):/bin/{grep_shell}\", passwd_output)]\r\n    \r\n\r\nprint(get_users_for_shell())\r\n",
            "date": "2022-10-19 21:15:19.342880+00:00",
            "passed": true
        },
        {
            "bite": "Bite 165. Parse an /etc/passwd file output",
            "code": "from typing import List\r\nimport re\r\n\r\nDEFAULT_SHELL = 'bash'\r\n# https://github.com/avar/git-anyonecanedit-etc/blob/master/passwd\r\nPASSWD_OUTPUT = \"\"\"root:x:0:0:root:/root:/bin/bash\r\ndaemon:x:1:1:daemon:/usr/sbin:/bin/sh\r\nbin:x:2:2:bin:/bin:/bin/sh\r\nsys:x:3:3:sys:/dev:/bin/sh\r\nsync:x:4:65534:sync:/bin:/bin/sync\r\ngames:x:5:60:games:/usr/games:/bin/sh\r\nman:x:6:12:man:/var/cache/man:/bin/sh\r\nlp:x:7:7:lp:/var/spool/lpd:/bin/sh\r\nmail:x:8:8:mail:/var/mail:/bin/sh\r\nnews:x:9:9:news:/var/spool/news:/bin/sh\r\nuucp:x:10:10:uucp:/var/spool/uucp:/bin/sh\r\nproxy:x:13:13:proxy:/bin:/bin/sh\r\nwww-data:x:33:33:www-data:/var/www:/bin/sh\r\nbackup:x:34:34:backup:/var/backups:/bin/sh\r\nlist:x:38:38:Mailing List Manager:/var/list:/bin/sh\r\nirc:x:39:39:ircd:/var/run/ircd:/bin/sh\r\ngnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/sh\r\nnobody:x:65534:65534:nobody:/nonexistent:/bin/sh\r\nlibuuid:x:100:101::/var/lib/libuuid:/bin/sh\r\nDebian-exim:x:101:103::/var/spool/exim4:/bin/false\r\nstatd:x:102:65534::/var/lib/nfs:/bin/false\r\nsshd:x:103:65534::/var/run/sshd:/usr/sbin/nologin\r\nftp:x:104:65534::/home/ftp:/bin/false\r\nmessagebus:x:105:106::/var/run/dbus:/bin/false\r\nmysql:x:106:107:MySQL Server,,,:/var/lib/mysql:/bin/false\r\navar:x:1000:1000::/home/avar:/bin/bash\r\nchad:x:1001:1001::/home/chad:/bin/bash\r\ngit-svn-mirror:x:1002:1002:Git mirror,,,:/home/git-svn-mirror:/bin/bash\r\ngerrit2:x:1003:1003:Gerrit User,,,:/home/gerrit2:/bin/bash\r\navahi:x:107:108:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/bin/false\r\npostfix:x:108:112::/var/spool/postfix:/bin/false\r\nssh-rsa:x:1004:1004::/home/ssh-rsa:/bin/bash\r\nartagnon:x:1005:1005:Ramkumar R,,,,Git GSOC:/home/artagnon:/bin/bash\"\"\"\r\n\r\n\r\ndef get_users_for_shell(passwd_output: str = PASSWD_OUTPUT,\r\n                        grep_shell: str = DEFAULT_SHELL) -> List[str]:\r\n    \"\"\"Match the passwd_output string for users with grep_shell.\r\n       Return a list of users.\r\n    \"\"\"\r\n    return [match.lstrip(\"home/\") for match in re.findall(f\"/(.+):/bin/{grep_shell}\", passwd_output)]\r\n    \r\n\r\nprint(get_users_for_shell())\r\n",
            "date": "2022-10-19 19:07:05.427388+00:00",
            "passed": false
        },
        {
            "bite": "Bite 165. Parse an /etc/passwd file output",
            "code": "from typing import List\r\nimport re\r\n\r\nDEFAULT_SHELL = 'bash'\r\n# https://github.com/avar/git-anyonecanedit-etc/blob/master/passwd\r\nPASSWD_OUTPUT = \"\"\"root:x:0:0:root:/root:/bin/bash\r\ndaemon:x:1:1:daemon:/usr/sbin:/bin/sh\r\nbin:x:2:2:bin:/bin:/bin/sh\r\nsys:x:3:3:sys:/dev:/bin/sh\r\nsync:x:4:65534:sync:/bin:/bin/sync\r\ngames:x:5:60:games:/usr/games:/bin/sh\r\nman:x:6:12:man:/var/cache/man:/bin/sh\r\nlp:x:7:7:lp:/var/spool/lpd:/bin/sh\r\nmail:x:8:8:mail:/var/mail:/bin/sh\r\nnews:x:9:9:news:/var/spool/news:/bin/sh\r\nuucp:x:10:10:uucp:/var/spool/uucp:/bin/sh\r\nproxy:x:13:13:proxy:/bin:/bin/sh\r\nwww-data:x:33:33:www-data:/var/www:/bin/sh\r\nbackup:x:34:34:backup:/var/backups:/bin/sh\r\nlist:x:38:38:Mailing List Manager:/var/list:/bin/sh\r\nirc:x:39:39:ircd:/var/run/ircd:/bin/sh\r\ngnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/sh\r\nnobody:x:65534:65534:nobody:/nonexistent:/bin/sh\r\nlibuuid:x:100:101::/var/lib/libuuid:/bin/sh\r\nDebian-exim:x:101:103::/var/spool/exim4:/bin/false\r\nstatd:x:102:65534::/var/lib/nfs:/bin/false\r\nsshd:x:103:65534::/var/run/sshd:/usr/sbin/nologin\r\nftp:x:104:65534::/home/ftp:/bin/false\r\nmessagebus:x:105:106::/var/run/dbus:/bin/false\r\nmysql:x:106:107:MySQL Server,,,:/var/lib/mysql:/bin/false\r\navar:x:1000:1000::/home/avar:/bin/bash\r\nchad:x:1001:1001::/home/chad:/bin/bash\r\ngit-svn-mirror:x:1002:1002:Git mirror,,,:/home/git-svn-mirror:/bin/bash\r\ngerrit2:x:1003:1003:Gerrit User,,,:/home/gerrit2:/bin/bash\r\navahi:x:107:108:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/bin/false\r\npostfix:x:108:112::/var/spool/postfix:/bin/false\r\nssh-rsa:x:1004:1004::/home/ssh-rsa:/bin/bash\r\nartagnon:x:1005:1005:Ramkumar R,,,,Git GSOC:/home/artagnon:/bin/bash\"\"\"\r\n\r\n\r\ndef get_users_for_shell(passwd_output: str = PASSWD_OUTPUT,\r\n                        grep_shell: str = DEFAULT_SHELL) -> List[str]:\r\n    \"\"\"Match the passwd_output string for users with grep_shell.\r\n       Return a list of users.\r\n    \"\"\"\r\n    return [match.lstrip(\"/home\") for match in re.findall(f\"/(.+):/bin/{grep_shell}\", passwd_output)]\r\n    \r\n\r\nprint(get_users_for_shell())\r\n",
            "date": "2022-10-19 19:05:48.924798+00:00",
            "passed": false
        },
        {
            "bite": "Bite 165. Parse an /etc/passwd file output",
            "code": "from typing import List\r\nimport re\r\n\r\nDEFAULT_SHELL = 'bash'\r\n# https://github.com/avar/git-anyonecanedit-etc/blob/master/passwd\r\nPASSWD_OUTPUT = \"\"\"root:x:0:0:root:/root:/bin/bash\r\ndaemon:x:1:1:daemon:/usr/sbin:/bin/sh\r\nbin:x:2:2:bin:/bin:/bin/sh\r\nsys:x:3:3:sys:/dev:/bin/sh\r\nsync:x:4:65534:sync:/bin:/bin/sync\r\ngames:x:5:60:games:/usr/games:/bin/sh\r\nman:x:6:12:man:/var/cache/man:/bin/sh\r\nlp:x:7:7:lp:/var/spool/lpd:/bin/sh\r\nmail:x:8:8:mail:/var/mail:/bin/sh\r\nnews:x:9:9:news:/var/spool/news:/bin/sh\r\nuucp:x:10:10:uucp:/var/spool/uucp:/bin/sh\r\nproxy:x:13:13:proxy:/bin:/bin/sh\r\nwww-data:x:33:33:www-data:/var/www:/bin/sh\r\nbackup:x:34:34:backup:/var/backups:/bin/sh\r\nlist:x:38:38:Mailing List Manager:/var/list:/bin/sh\r\nirc:x:39:39:ircd:/var/run/ircd:/bin/sh\r\ngnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/sh\r\nnobody:x:65534:65534:nobody:/nonexistent:/bin/sh\r\nlibuuid:x:100:101::/var/lib/libuuid:/bin/sh\r\nDebian-exim:x:101:103::/var/spool/exim4:/bin/false\r\nstatd:x:102:65534::/var/lib/nfs:/bin/false\r\nsshd:x:103:65534::/var/run/sshd:/usr/sbin/nologin\r\nftp:x:104:65534::/home/ftp:/bin/false\r\nmessagebus:x:105:106::/var/run/dbus:/bin/false\r\nmysql:x:106:107:MySQL Server,,,:/var/lib/mysql:/bin/false\r\navar:x:1000:1000::/home/avar:/bin/bash\r\nchad:x:1001:1001::/home/chad:/bin/bash\r\ngit-svn-mirror:x:1002:1002:Git mirror,,,:/home/git-svn-mirror:/bin/bash\r\ngerrit2:x:1003:1003:Gerrit User,,,:/home/gerrit2:/bin/bash\r\navahi:x:107:108:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/bin/false\r\npostfix:x:108:112::/var/spool/postfix:/bin/false\r\nssh-rsa:x:1004:1004::/home/ssh-rsa:/bin/bash\r\nartagnon:x:1005:1005:Ramkumar R,,,,Git GSOC:/home/artagnon:/bin/bash\"\"\"\r\n\r\n\r\ndef get_users_for_shell(passwd_output: str = PASSWD_OUTPUT,\r\n                        grep_shell: str = DEFAULT_SHELL) -> List[str]:\r\n    \"\"\"Match the passwd_output string for users with grep_shell.\r\n       Return a list of users.\r\n    \"\"\"\r\n    return [match.lstrip(\"/home\") for match in re.findall(\"/(.+):/bin/\"+grep_shell, passwd_output)]\r\n    \r\n\r\n# print(get_users_for_shell())\r\n",
            "date": "2022-10-19 19:03:07.288716+00:00",
            "passed": false
        },
        {
            "bite": "Bite 208. Find the number pairs summing up N",
            "code": "def find_number_pairs(numbers, N=10):\r\n\r\n    return [(n1,n2) for i,n1 in enumerate(numbers) for n2 in numbers[i+1:] if n1+n2 == N]\r\n\r\n    \"\"\" this works \r\n    lst = []\r\n    for i,n1 in enumerate(numbers):\r\n        for n2 in numbers[i+1:]:\r\n            # print(f\"{n1},{n2}\")\r\n            if n1+n2 == N:\r\n                lst.append((n1,n2))\r\n                \r\n    return lst\r\n    \"\"\"\r\n    \r\ntest2 = [0.24, 0.36, 0.04, 0.06, 0.33, 0.08, 0.20, 0.27, 0.3, 0.31, 0.76, 0.05, 0.08, 0.08, 0.67, 0.09, 0.66, 0.79, 0.95]\r\nprint(find_number_pairs(test2, N=1))\r\n\r\n\r\n",
            "date": "2022-10-18 19:25:25.664714+00:00",
            "passed": true
        },
        {
            "bite": "Bite 208. Find the number pairs summing up N",
            "code": "def find_number_pairs(numbers, N=10):\r\n    lst = []\r\n    for i,n1 in enumerate(numbers):\r\n        for n2 in numbers[i+1:]:\r\n            # print(f\"{n1},{n2}\")\r\n            if n1+n2 == N:\r\n                lst.append((n1,n2))\r\n                \r\n    return lst\r\n\r\n# test2 = [0.24, 0.36, 0.04, 0.06, 0.33, 0.08, 0.20, 0.27, 0.3, 0.31, 0.76, 0.05, 0.08, 0.08, 0.67, 0.09, 0.66, 0.79, 0.95]\r\n# print(find_number_pairs(test2, N=1))",
            "date": "2022-10-18 19:22:23.519253+00:00",
            "passed": true
        },
        {
            "bite": "Bite 208. Find the number pairs summing up N",
            "code": "def find_number_pairs(numbers, N=10):\r\n    lst = []\r\n    for i in numbers:\r\n        for j in numbers[(i+1):]:\r\n            if i+j == N:\r\n                lst.append((i,j))\r\n                \r\n    return lst",
            "date": "2022-10-18 19:13:28.031038+00:00",
            "passed": false
        },
        {
            "bite": "Bite 114. Implement a Color class with staticmethod",
            "code": "import os\r\nimport sys\r\nimport urllib.request\r\nimport string\r\n\r\n# PREWORK (don't modify): import colors, save to temp file and import\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\ncolor_values_module = os.path.join(tmp, 'color_values.py')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/color_values.py',\r\n    color_values_module\r\n)\r\nsys.path.append(tmp)\r\n\r\n# should be importable now\r\nfrom color_values import COLOR_NAMES  # noqa E402\r\n\r\n\r\nclass Color:\r\n    \"\"\"Color class.\r\n\r\n    Takes the string of a color name and returns its RGB value.\r\n    \"\"\"\r\n\r\n    \r\n    def __init__(self, color):\r\n        self.color = color\r\n        self.rgb = COLOR_NAMES.get(color.upper(), None)\r\n\r\n    @staticmethod\r\n    def hex2rgb(h):\r\n        \"\"\"Class method that converts a hex value into an rgb one\"\"\"\r\n        if isinstance(h,str) and h[0]==\"#\" and len(h[1:])==6 and all(c in string.hexdigits for c in h[1:]):\r\n            return tuple(int(h[i:i+2], 16) for i in (1, 3, 5))\r\n        else:\r\n            raise ValueError\r\n        \r\n    @staticmethod\r\n    def rgb2hex(r):\r\n        \"\"\"Class method that converts an rgb value into a hex one\"\"\"\r\n        if isinstance(r, tuple) and len(r) == 3 and all(isinstance(n,int) and 0<=n<=255 for n in r): \r\n            return '#%02x%02x%02x' % r\r\n        else:\r\n            raise ValueError\r\n            \r\n\r\n    def __repr__(self):\r\n        \"\"\"Returns the repl of the object\"\"\"\r\n        return f\"Color('{self.color}')\"\r\n\r\n    def __str__(self):\r\n        \"\"\"Returns the string value of the color object\"\"\"\r\n        return str(self.rgb) if self.rgb else \"Unknown\"\r\n        \r\nprint(COLOR_NAMES['white'.upper()])",
            "date": "2022-10-18 19:02:51.355809+00:00",
            "passed": true
        },
        {
            "bite": "Bite 114. Implement a Color class with staticmethod",
            "code": "import os\r\nimport sys\r\nimport urllib.request\r\nimport string\r\n\r\n# PREWORK (don't modify): import colors, save to temp file and import\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\ncolor_values_module = os.path.join(tmp, 'color_values.py')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/color_values.py',\r\n    color_values_module\r\n)\r\nsys.path.append(tmp)\r\n\r\n# should be importable now\r\nfrom color_values import COLOR_NAMES  # noqa E402\r\n\r\n\r\nclass Color:\r\n    \"\"\"Color class.\r\n\r\n    Takes the string of a color name and returns its RGB value.\r\n    \"\"\"\r\n\r\n    \r\n    def __init__(self, color):\r\n        self.color = color\r\n        self.rgb = COLOR_NAMES.get(color.upper(), None)\r\n\r\n    @staticmethod\r\n    def hex2rgb(h):\r\n        \"\"\"Class method that converts a hex value into an rgb one\"\"\"\r\n        if not isinstance(h,str):\r\n            raise ValueError(\"not a string\")\r\n        if not h[0]==\"#\":\r\n            raise ValueError(\"missing #\")\r\n        if not len(h[1:])==6:\r\n            raise ValueError(\"wrong length\")\r\n        if not all(c in string.hexdigits for c in h[1:]):\r\n            raise ValueError(\"some characters are not hex\")\r\n\r\n        return tuple(int(h[i:i+2], 16) for i in (1, 3, 5))\r\n\r\n    @staticmethod\r\n    def rgb2hex(r):\r\n        \"\"\"Class method that converts an rgb value into a hex one\"\"\"\r\n        if isinstance(r, tuple) and len(r) == 3 and all(isinstance(n,int) and 0<=n<=255 for n in r): \r\n            return '#%02x%02x%02x' % r\r\n        else:\r\n            raise ValueError\r\n            \r\n\r\n    def __repr__(self):\r\n        \"\"\"Returns the repl of the object\"\"\"\r\n        return f\"Color('{self.color}')\"\r\n\r\n    def __str__(self):\r\n        \"\"\"Returns the string value of the color object\"\"\"\r\n        return str(self.rgb) if self.rgb else \"Unknown\"\r\n        \r\nprint(COLOR_NAMES['white'.upper()])",
            "date": "2022-10-18 19:00:35.672857+00:00",
            "passed": true
        },
        {
            "bite": "Bite 114. Implement a Color class with staticmethod",
            "code": "import os\r\nimport sys\r\nimport urllib.request\r\nimport string\r\n\r\n# PREWORK (don't modify): import colors, save to temp file and import\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\ncolor_values_module = os.path.join(tmp, 'color_values.py')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/color_values.py',\r\n    color_values_module\r\n)\r\nsys.path.append(tmp)\r\n\r\n# should be importable now\r\nfrom color_values import COLOR_NAMES  # noqa E402\r\n\r\n\r\nclass Color:\r\n    \"\"\"Color class.\r\n\r\n    Takes the string of a color name and returns its RGB value.\r\n    \"\"\"\r\n\r\n    \r\n    def __init__(self, color):\r\n        self.color = color\r\n        self.rgb = COLOR_NAMES.get(color.upper(), None)\r\n\r\n    @staticmethod\r\n    def hex2rgb(h):\r\n        \"\"\"Class method that converts a hex value into an rgb one\"\"\"\r\n        if not isinstance(h,str):\r\n            raise ValueError(\"not a string\")\r\n        if not h[0]==\"#\":\r\n            raise ValueError(\"missing #\")\r\n        if not len(h[1:])==6:\r\n            raise ValueError(\"wrong length\")\r\n        if not all(c in string.hexdigits for c in h[1:]):\r\n            raise ValueError(\"some characters are not hex\")\r\n\r\n        return tuple(int(h[i:i+2], 16) for i in (1, 3, 5))\r\n\r\n    @staticmethod\r\n    def rgb2hex(r):\r\n        \"\"\"Class method that converts an rgb value into a hex one\"\"\"\r\n        if isinstance(r, tuple) and len(r) == 3 and all(isinstance(n,int) and 0<=n<=255 for n in r): \r\n            return '#%02x%02x%02x' % r\r\n        else:\r\n            raise ValueError\r\n            \r\n\r\n    def __repr__(self):\r\n        \"\"\"Returns the repl of the object\"\"\"\r\n        return f\"Color('{self.color}')\"\r\n\r\n    def __str__(self):\r\n        \"\"\"Returns the string value of the color object\"\"\"\r\n        return self.rgb if self.rgb else \"Unknown\"\r\n        \r\nprint(COLOR_NAMES['white'.upper()])",
            "date": "2022-10-18 18:59:39.827698+00:00",
            "passed": false
        },
        {
            "bite": "Bite 114. Implement a Color class with staticmethod",
            "code": "import os\r\nimport sys\r\nimport urllib.request\r\nimport string\r\n\r\n# PREWORK (don't modify): import colors, save to temp file and import\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\ncolor_values_module = os.path.join(tmp, 'color_values.py')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/color_values.py',\r\n    color_values_module\r\n)\r\nsys.path.append(tmp)\r\n\r\n# should be importable now\r\nfrom color_values import COLOR_NAMES  # noqa E402\r\n\r\n\r\nclass Color:\r\n    \"\"\"Color class.\r\n\r\n    Takes the string of a color name and returns its RGB value.\r\n    \"\"\"\r\n\r\n    \r\n    def __init__(self, color):\r\n        self.color = color\r\n        self.rgb = COLOR_NAMES.get(color.upper(), None)\r\n\r\n    @staticmethod\r\n    def hex2rgb(h):\r\n        \"\"\"Class method that converts a hex value into an rgb one\"\"\"\r\n        if not isinstance(h,str):\r\n            raise ValueError(\"not a string\")\r\n        if not h[0]==\"#\":\r\n            raise ValueError(\"missing #\")\r\n        if not len(h[1:])==6:\r\n            raise ValueError(\"wrong length\")\r\n        if not all(c in string.hexdigits for c in h[1:]):\r\n            raise ValueError(\"some characters are not hex\")\r\n\r\n        return tuple(int(h[i:i+2], 16) for i in (0, 2, 4))\r\n\r\n    @staticmethod\r\n    def rgb2hex(r):\r\n        \"\"\"Class method that converts an rgb value into a hex one\"\"\"\r\n        if isinstance(r, tuple) and len(r) == 3 and all(isinstance(n,int) and 0<=n<=255 for n in r): \r\n            return '#%02x%02x%02x' % r\r\n        else:\r\n            raise ValueError\r\n            \r\n\r\n    def __repr__(self):\r\n        \"\"\"Returns the repl of the object\"\"\"\r\n        return f\"Color('{self.color}')\"\r\n\r\n    def __str__(self):\r\n        \"\"\"Returns the string value of the color object\"\"\"\r\n        return self.rgb if self.rgb else \"Unknown\"\r\n        \r\nprint(COLOR_NAMES['white'.upper()])",
            "date": "2022-10-18 18:58:05.397904+00:00",
            "passed": false
        },
        {
            "bite": "Bite 114. Implement a Color class with staticmethod",
            "code": "import os\r\nimport sys\r\nimport urllib.request\r\nimport string\r\n\r\n# PREWORK (don't modify): import colors, save to temp file and import\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\ncolor_values_module = os.path.join(tmp, 'color_values.py')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/color_values.py',\r\n    color_values_module\r\n)\r\nsys.path.append(tmp)\r\n\r\n# should be importable now\r\nfrom color_values import COLOR_NAMES  # noqa E402\r\n\r\n\r\nclass Color:\r\n    \"\"\"Color class.\r\n\r\n    Takes the string of a color name and returns its RGB value.\r\n    \"\"\"\r\n\r\n    \r\n    def __init__(self, color):\r\n        self.color = color\r\n        self.rgb = COLOR_NAMES.get(color.upper(), None)\r\n\r\n    @staticmethod\r\n    def hex2rgb(h):\r\n        \"\"\"Class method that converts a hex value into an rgb one\"\"\"\r\n        if not isinstance(h,str):\r\n            raise ValueError(\"not a string\")\r\n        if not h[0]==\"#\":\r\n            raise ValueError(\"missing #\")\r\n        if not len(h[1:])==6:\r\n            raise ValueError(\"wrong length\")\r\n        if not all(c in string.hexdigits for c in h):\r\n            raise ValueError(\"some characters are not hex\")\r\n\r\n        return tuple(int(h[i:i+2], 16) for i in (0, 2, 4))\r\n\r\n    @staticmethod\r\n    def rgb2hex(r):\r\n        \"\"\"Class method that converts an rgb value into a hex one\"\"\"\r\n        if isinstance(r, tuple) and len(r) == 3 and all(isinstance(n,int) and 0<=n<=255 for n in r): \r\n            return '#%02x%02x%02x' % r\r\n        else:\r\n            raise ValueError\r\n            \r\n\r\n    def __repr__(self):\r\n        \"\"\"Returns the repl of the object\"\"\"\r\n        return f\"Color('{self.color}')\"\r\n\r\n    def __str__(self):\r\n        \"\"\"Returns the string value of the color object\"\"\"\r\n        return self.rgb if self.rgb else \"Unknown\"\r\n        \r\nprint(COLOR_NAMES['white'.upper()])",
            "date": "2022-10-18 18:56:52.900161+00:00",
            "passed": false
        },
        {
            "bite": "Bite 161. Count the number of files and directories",
            "code": "import os\r\n\r\n\r\ndef count_dirs_and_files(directory='.'):\r\n    \"\"\"Count the amount of of directories and files in passed in \"directory\" arg.\r\n       Return a tuple of (number_of_directories, number_of_files)\r\n    \"\"\"\r\n    contents = list(os.walk(directory, topdown=True))\r\n    return len(contents)-1, sum(len(item[2]) for item in contents)\r\n",
            "date": "2022-10-18 13:09:19.481468+00:00",
            "passed": true
        },
        {
            "bite": "Bite 153. Round a sequence of numbers",
            "code": "import math\r\n\r\ndef round_up_or_down(transactions, up=True):\r\n    \"\"\"Round the list of transactions passed in.\r\n       If up=True (default) round up, else round down.\r\n       Return a new list of rounded values\r\n    \"\"\"\r\n    func=math.ceil if up else math.floor\r\n    return list(func(item) for item in transactions)\r\n    \r\n\r\n# t1 = [2.05, 3.55, 4.50, 10.76, 100.25]\r\n# print(round_up_or_down(t1, False))",
            "date": "2022-10-17 21:02:12.504697+00:00",
            "passed": true
        },
        {
            "bite": "Bite 149. Sorting words with constraint",
            "code": "import string\r\n\r\ndef sort_words_case_insensitively(words):\r\n    \"\"\"Sort the provided word list ignoring case, and numbers last\r\n       (1995, 19ab = numbers / Happy, happy4you = strings, hence for\r\n        numbers you only need to check the first char of the word)\r\n    \"\"\"\r\n    numbers=sorted([word for word in words if word[0] in string.digits], key=str.casefold)\r\n    return sorted([word for word in words if word not in numbers], key=str.casefold)+numbers\r\n    \r\nwords = \"It's almost Holidays and PyBites wishes You a Merry Christmas and a Happy 2019\".split()\r\n\r\nprint(sort_words_case_insensitively(words))",
            "date": "2022-10-16 08:51:20.332649+00:00",
            "passed": true
        },
        {
            "bite": "Bite 149. Sorting words with constraint",
            "code": "import string\r\n\r\ndef sort_words_case_insensitively(words):\r\n    \"\"\"Sort the provided word list ignoring case, and numbers last\r\n       (1995, 19ab = numbers / Happy, happy4you = strings, hence for\r\n        numbers you only need to check the first char of the word)\r\n    \"\"\"\r\n    words_list = words.split()\r\n    numbers=sorted([word for word in words_list if word[0] in string.digits], key=str.casefold)\r\n    return sorted([word for word in words_list if word not in numbers], key=str.casefold)+numbers\r\n    \r\nwords = \"It's almost Holidays and PyBites wishes You a Merry Christmas and a Happy 2019\"\r\n\r\nprint(sort_words_case_insensitively(words))",
            "date": "2022-10-16 08:49:55.522515+00:00",
            "passed": false
        },
        {
            "bite": "Bite 143. Look up a value in 3 dictionaries",
            "code": "NOT_FOUND = \"Not found\"\r\n\r\ngroup1 = {'tim': 30, 'bob': 17, 'ana': 24}\r\ngroup2 = {'ana': 26, 'thomas': 64, 'helen': 26}\r\ngroup3 = {'brenda': 17, 'otto': 44, 'thomas': 46}\r\n\r\n\r\ndef get_person_age(name):\r\n    \"\"\"Look up name (case insensitive search) and return age.\r\n       If name in > 1 dict, return the match of the group with\r\n       greatest N (so group3 > group2 > group1)\r\n    \"\"\"\r\n    if isinstance(name,str):\r\n        for group in [group3, group2, group1]:\r\n            if name.lower() in group:\r\n                return group[name.lower()]    \r\n    return NOT_FOUND\r\n",
            "date": "2022-10-15 20:03:11.877601+00:00",
            "passed": true
        },
        {
            "bite": "Bite 143. Look up a value in 3 dictionaries",
            "code": "NOT_FOUND = \"Not found\"\r\n\r\ngroup1 = {'tim': 30, 'bob': 17, 'ana': 24}\r\ngroup2 = {'ana': 26, 'thomas': 64, 'helen': 26}\r\ngroup3 = {'brenda': 17, 'otto': 44, 'thomas': 46}\r\n\r\n\r\ndef get_person_age(name):\r\n    \"\"\"Look up name (case insensitive search) and return age.\r\n       If name in > 1 dict, return the match of the group with\r\n       greatest N (so group3 > group2 > group1)\r\n    \"\"\"\r\n    if isinstance(name,str):\r\n        for group in [group3, group2, group1]:\r\n            if name.lower() in group:\r\n                return group[name.lower()]    \r\n    return NOT_FOUND\r\n        \r\n\r\nprint(get_person_age(\"thomas\"))\r\nprint(get_person_age(\"Ana\"))\r\nprint(get_person_age(\"jim\"))\r\nprint(get_person_age(None))\r\nprint(get_person_age(-1))",
            "date": "2022-10-15 20:02:48.394999+00:00",
            "passed": true
        },
        {
            "bite": "Bite 143. Look up a value in 3 dictionaries",
            "code": "NOT_FOUND = \"Not found\"\r\n\r\ngroup1 = {'tim': 30, 'bob': 17, 'ana': 24}\r\ngroup2 = {'ana': 26, 'thomas': 64, 'helen': 26}\r\ngroup3 = {'brenda': 17, 'otto': 44, 'thomas': 46}\r\n\r\n\r\ndef get_person_age(name):\r\n    \"\"\"Look up name (case insensitive search) and return age.\r\n       If name in > 1 dict, return the match of the group with\r\n       greatest N (so group3 > group2 > group1)\r\n    \"\"\"\r\n    if name:\r\n        for group in [group3, group2, group1]:\r\n            if name.lower() in group:\r\n                return group[name.lower()]    \r\n    return NOT_FOUND\r\n        \r\n\r\nprint(get_person_age(\"thomas\"))\r\nprint(get_person_age(\"Ana\"))\r\nprint(get_person_age(\"jim\"))\r\nprint(get_person_age(None))",
            "date": "2022-10-15 19:58:15.772307+00:00",
            "passed": false
        },
        {
            "bite": "Bite 143. Look up a value in 3 dictionaries",
            "code": "NOT_FOUND = \"Not found\"\r\n\r\ngroup1 = {'tim': 30, 'bob': 17, 'ana': 24}\r\ngroup2 = {'ana': 26, 'thomas': 64, 'helen': 26}\r\ngroup3 = {'brenda': 17, 'otto': 44, 'thomas': 46}\r\n\r\n\r\ndef get_person_age(name):\r\n    \"\"\"Look up name (case insensitive search) and return age.\r\n       If name in > 1 dict, return the match of the group with\r\n       greatest N (so group3 > group2 > group1)\r\n    \"\"\"\r\n    for group in [group3, group2, group1]:\r\n        if name.lower() in group:\r\n            return group[name.lower()]    \r\n    return NOT_FOUND\r\n        \r\n\r\nprint(get_person_age(\"thomas\"))\r\nprint(get_person_age(\"Ana\"))\r\nprint(get_person_age(\"jim\"))\r\n",
            "date": "2022-10-15 17:32:53.050339+00:00",
            "passed": false
        },
        {
            "bite": "Bite 136. Bloodtypes",
            "code": "\"\"\"\r\nWrite a function which checks the red blood cell compatibility between donor and recipient.\r\nhttps://en.wikipedia.org/wiki/Blood_type#Red_blood_cell_compatibility\r\nFor simplicity, the appearance of 8 basic types of blood is considered.\r\nThe input of blood type can be in the form of:\r\n    pre defined Bloodtype enum e.g.: Bloodtype.ZERO_NEG\r\n    value of the pre-defined Bloodtype 0..7\r\n    pre defined text  e.g. \"0-\", \"B+\", \"AB+\", ...\r\n    If input value is not a required type TypeError is raised.\r\n    If input value is not in defined interval ValueError is raised.\r\nKeywords: enum, exception handling, multi type input\r\n\"\"\"\r\n\r\nfrom enum import Enum\r\n\r\n\r\nclass Bloodtype(Enum):\r\n    ZERO_NEG = 0\r\n    ZERO_POS = 1\r\n    B_NEG = 2\r\n    B_POS = 3\r\n    A_NEG = 4\r\n    A_POS = 5\r\n    AB_NEG = 6\r\n    AB_POS = 7\r\n\r\n\r\nblood_type_text = {\r\n    \"0-\": Bloodtype.ZERO_NEG,\r\n    \"0+\": Bloodtype.ZERO_POS,\r\n    \"B-\": Bloodtype.B_NEG,\r\n    \"B+\": Bloodtype.B_POS,\r\n    \"A-\": Bloodtype.A_NEG,\r\n    \"A+\": Bloodtype.A_POS,\r\n    \"AB-\": Bloodtype.AB_NEG,\r\n    \"AB+\": Bloodtype.AB_POS,\r\n}\r\n\r\n# complete :\r\ndef check_bt(donor, recipient):\r\n    \"\"\" Checks red blood cell compatibility based on 8 blood types\r\n        Args:\r\n        donor (int | str | Bloodtype): red blood cell type of the donor\r\n        recipient (int | str | Bloodtype): red blood cell type of the recipient\r\n        Returns:\r\n        bool: True for compatability, False otherwise.\r\n    \"\"\"\r\n    return all(antigen>=0 for antigen in _particular_antigen_comp(_validated(donor), _validated(recipient)))\r\n\r\n\r\ndef _validated(blood_type):\r\n    if isinstance(blood_type, Bloodtype):\r\n        return blood_type.value\r\n    if isinstance(blood_type, int):\r\n        if 0<= blood_type <=7:\r\n            return blood_type\r\n        else:\r\n            raise ValueError\r\n    if isinstance(blood_type, str):\r\n        if blood_type in blood_type_text:\r\n            return blood_type_text[blood_type].value\r\n        else:\r\n            raise ValueError\r\n    raise TypeError\r\n\r\n# hint\r\ndef _particular_antigen_comp(donor: int, recipient: int) -> tuple:\r\n    \"\"\"Returns a particalar antigen compatibility, where each tuple member\r\n    marks a compatibility for a particular antigen  (A, B, Rh-D).\r\n    If tuple member is non-negative there is a compatibility.\r\n    For red blood cell compatibility is required that \r\n    all tuple members are non-negative (i.e. compatibility for all 3 antigens).\r\n    0- bloodtype is represented as 0 ; AB+ is represented as 7; see Bloodtype enum\r\n    Examples:\r\n    _particular_antigen_comp(0, 7) -> (1, 1, 1)    0- can donate to AB+\r\n    _particular_antigen_comp(1, 3) -> (0, 1, 0)    0+ can donate to B+\r\n    _particular_antigen_comp(2, 5) -> (1, -1, 1)   B+ cannot donate to A+\r\n    _particular_antigen_comp(7, 0) -> (-1, -1, -1) AB+ cannot donate to 0-\r\n    \"\"\"\r\n    return (\r\n        ((recipient // 4) % 2) - ((donor // 4) % 2),\r\n        ((recipient // 2) % 2) - ((donor // 2) % 2),\r\n        (recipient % 2) - (donor % 2),\r\n    )\r\n    \r\nprint(check_bt(2, 5))",
            "date": "2022-10-14 17:31:04.350299+00:00",
            "passed": true
        },
        {
            "bite": "Bite 136. Bloodtypes",
            "code": "\"\"\"\r\nWrite a function which checks the red blood cell compatibility between donor and recipient.\r\nhttps://en.wikipedia.org/wiki/Blood_type#Red_blood_cell_compatibility\r\nFor simplicity, the appearance of 8 basic types of blood is considered.\r\nThe input of blood type can be in the form of:\r\n    pre defined Bloodtype enum e.g.: Bloodtype.ZERO_NEG\r\n    value of the pre-defined Bloodtype 0..7\r\n    pre defined text  e.g. \"0-\", \"B+\", \"AB+\", ...\r\n    If input value is not a required type TypeError is raised.\r\n    If input value is not in defined interval ValueError is raised.\r\nKeywords: enum, exception handling, multi type input\r\n\"\"\"\r\n\r\nfrom enum import Enum\r\n\r\n\r\nclass Bloodtype(Enum):\r\n    ZERO_NEG = 0\r\n    ZERO_POS = 1\r\n    B_NEG = 2\r\n    B_POS = 3\r\n    A_NEG = 4\r\n    A_POS = 5\r\n    AB_NEG = 6\r\n    AB_POS = 7\r\n\r\n\r\nblood_type_text = {\r\n    \"0-\": Bloodtype.ZERO_NEG,\r\n    \"0+\": Bloodtype.ZERO_POS,\r\n    \"B-\": Bloodtype.B_NEG,\r\n    \"B+\": Bloodtype.B_POS,\r\n    \"A-\": Bloodtype.A_NEG,\r\n    \"A+\": Bloodtype.A_POS,\r\n    \"AB-\": Bloodtype.AB_NEG,\r\n    \"AB+\": Bloodtype.AB_POS,\r\n}\r\n\r\n# complete :\r\ndef check_bt(donor, recipient):\r\n    \"\"\" Checks red blood cell compatibility based on 8 blood types\r\n        Args:\r\n        donor (int | str | Bloodtype): red blood cell type of the donor\r\n        recipient (int | str | Bloodtype): red blood cell type of the recipient\r\n        Returns:\r\n        bool: True for compatability, False otherwise.\r\n    \"\"\"\r\n    result = _particular_antigen_comp(_validated(donor), _validated(recipient))\r\n    # print(result)\r\n    # print(all(antigen >=0 for antigen in result))\r\n    return all(antigen >=0 for antigen in result)\r\n\r\n\r\ndef _validated(blood_type):\r\n    if isinstance(blood_type, Bloodtype):\r\n        return blood_type.value\r\n    if isinstance(blood_type, int):\r\n        if 0<= blood_type <=7:\r\n            return blood_type\r\n        else:\r\n            raise ValueError\r\n    if isinstance(blood_type, str):\r\n        if blood_type in blood_type_text:\r\n            return blood_type_text[blood_type].value\r\n        else:\r\n            raise ValueError\r\n    raise TypeError\r\n\r\n# hint\r\ndef _particular_antigen_comp(donor: int, recipient: int) -> tuple:\r\n    \"\"\"Returns a particalar antigen compatibility, where each tuple member\r\n    marks a compatibility for a particular antigen  (A, B, Rh-D).\r\n    If tuple member is non-negative there is a compatibility.\r\n    For red blood cell compatibility is required that \r\n    all tuple members are non-negative (i.e. compatibility for all 3 antigens).\r\n    0- bloodtype is represented as 0 ; AB+ is represented as 7; see Bloodtype enum\r\n    Examples:\r\n    _particular_antigen_comp(0, 7) -> (1, 1, 1)    0- can donate to AB+\r\n    _particular_antigen_comp(1, 3) -> (0, 1, 0)    0+ can donate to B+\r\n    _particular_antigen_comp(2, 5) -> (1, -1, 1)   B+ cannot donate to A+\r\n    _particular_antigen_comp(7, 0) -> (-1, -1, -1) AB+ cannot donate to 0-\r\n    \"\"\"\r\n    return (\r\n        ((recipient // 4) % 2) - ((donor // 4) % 2),\r\n        ((recipient // 2) % 2) - ((donor // 2) % 2),\r\n        (recipient % 2) - (donor % 2),\r\n    )\r\n    \r\ncheck_bt(7, 0)",
            "date": "2022-10-14 17:27:08.896427+00:00",
            "passed": true
        },
        {
            "bite": "Bite 136. Bloodtypes",
            "code": "\"\"\"\r\nWrite a function which checks the red blood cell compatibility between donor and recipient.\r\nhttps://en.wikipedia.org/wiki/Blood_type#Red_blood_cell_compatibility\r\nFor simplicity, the appearance of 8 basic types of blood is considered.\r\nThe input of blood type can be in the form of:\r\n    pre defined Bloodtype enum e.g.: Bloodtype.ZERO_NEG\r\n    value of the pre-defined Bloodtype 0..7\r\n    pre defined text  e.g. \"0-\", \"B+\", \"AB+\", ...\r\n    If input value is not a required type TypeError is raised.\r\n    If input value is not in defined interval ValueError is raised.\r\nKeywords: enum, exception handling, multi type input\r\n\"\"\"\r\n\r\nfrom enum import Enum\r\n\r\n\r\nclass Bloodtype(Enum):\r\n    ZERO_NEG = 0\r\n    ZERO_POS = 1\r\n    B_NEG = 2\r\n    B_POS = 3\r\n    A_NEG = 4\r\n    A_POS = 5\r\n    AB_NEG = 6\r\n    AB_POS = 7\r\n\r\n\r\nblood_type_text = {\r\n    \"0-\": Bloodtype.ZERO_NEG,\r\n    \"0+\": Bloodtype.ZERO_POS,\r\n    \"B-\": Bloodtype.B_NEG,\r\n    \"B+\": Bloodtype.B_POS,\r\n    \"A-\": Bloodtype.A_NEG,\r\n    \"A+\": Bloodtype.A_POS,\r\n    \"AB-\": Bloodtype.AB_NEG,\r\n    \"AB+\": Bloodtype.AB_POS,\r\n}\r\n\r\n# complete :\r\ndef check_bt(donor, recipient):\r\n    \"\"\" Checks red blood cell compatibility based on 8 blood types\r\n        Args:\r\n        donor (int | str | Bloodtype): red blood cell type of the donor\r\n        recipient (int | str | Bloodtype): red blood cell type of the recipient\r\n        Returns:\r\n        bool: True for compatability, False otherwise.\r\n    \"\"\"\r\n    result = _particular_antigen_comp(_validated(donor), _validated(recipient))\r\n    return any(result)<0\r\n\r\n\r\ndef _validated(blood_type):\r\n    if isinstance(blood_type, Bloodtype):\r\n        return blood_type.value\r\n    if isinstance(blood_type, int):\r\n        if 0<= blood_type <=7:\r\n            return blood_type\r\n        else:\r\n            raise ValueError\r\n    if isinstance(blood_type, str):\r\n        if blood_type in blood_type_text:\r\n            return blood_type_text[blood_type].value\r\n        else:\r\n            raise ValueError\r\n    raise TypeError\r\n\r\n# hint\r\ndef _particular_antigen_comp(donor: int, recipient: int) -> tuple:\r\n    \"\"\"Returns a particalar antigen compatibility, where each tuple member\r\n    marks a compatibility for a particular antigen  (A, B, Rh-D).\r\n    If tuple member is non-negative there is a compatibility.\r\n    For red blood cell compatibility is required that \r\n    all tuple members are non-negative (i.e. compatibility for all 3 antigens).\r\n    0- bloodtype is represented as 0 ; AB+ is represented as 7; see Bloodtype enum\r\n    Examples:\r\n    _particular_antigen_comp(0, 7) -> (1, 1, 1)    0- can donate to AB+\r\n    _particular_antigen_comp(1, 3) -> (0, 1, 0)    0+ can donate to B+\r\n    _particular_antigen_comp(2, 5) -> (1, -1, 1)   B+ cannot donate to A+\r\n    _particular_antigen_comp(7, 0) -> (-1, -1, -1) AB+ cannot donate to 0-\r\n    \"\"\"\r\n    return (\r\n        ((recipient // 4) % 2) - ((donor // 4) % 2),\r\n        ((recipient // 2) % 2) - ((donor // 2) % 2),\r\n        (recipient % 2) - (donor % 2),\r\n    )\r\n    \r\n# check_bt(3, 7)",
            "date": "2022-10-14 17:21:07.949521+00:00",
            "passed": false
        },
        {
            "bite": "Bite 136. Bloodtypes",
            "code": "\"\"\"\r\nWrite a function which checks the red blood cell compatibility between donor and recipient.\r\nhttps://en.wikipedia.org/wiki/Blood_type#Red_blood_cell_compatibility\r\nFor simplicity, the appearance of 8 basic types of blood is considered.\r\nThe input of blood type can be in the form of:\r\n    pre defined Bloodtype enum e.g.: Bloodtype.ZERO_NEG\r\n    value of the pre-defined Bloodtype 0..7\r\n    pre defined text  e.g. \"0-\", \"B+\", \"AB+\", ...\r\n    If input value is not a required type TypeError is raised.\r\n    If input value is not in defined interval ValueError is raised.\r\nKeywords: enum, exception handling, multi type input\r\n\"\"\"\r\n\r\nfrom enum import Enum\r\n\r\n\r\nclass Bloodtype(Enum):\r\n    ZERO_NEG = 0\r\n    ZERO_POS = 1\r\n    B_NEG = 2\r\n    B_POS = 3\r\n    A_NEG = 4\r\n    A_POS = 5\r\n    AB_NEG = 6\r\n    AB_POS = 7\r\n\r\n\r\nblood_type_text = {\r\n    \"0-\": Bloodtype.ZERO_NEG,\r\n    \"0+\": Bloodtype.ZERO_POS,\r\n    \"B-\": Bloodtype.B_NEG,\r\n    \"B+\": Bloodtype.B_POS,\r\n    \"A-\": Bloodtype.A_NEG,\r\n    \"A+\": Bloodtype.A_POS,\r\n    \"AB-\": Bloodtype.AB_NEG,\r\n    \"AB+\": Bloodtype.AB_POS,\r\n}\r\n\r\n# complete :\r\ndef check_bt(donor, recipient):\r\n    \"\"\" Checks red blood cell compatibility based on 8 blood types\r\n        Args:\r\n        donor (int | str | Bloodtype): red blood cell type of the donor\r\n        recipient (int | str | Bloodtype): red blood cell type of the recipient\r\n        Returns:\r\n        bool: True for compatability, False otherwise.\r\n    \"\"\"\r\n    result = _particular_antigen_comp(_validated(donor), _validated(recipient))\r\n    return any(result)<0\r\n\r\n\r\ndef _validated(blood_type):\r\n    if isinstance(blood_type, Bloodtype):\r\n        return blood_type.value\r\n    if isinstance(blood_type, int):\r\n        if 0<= blood_type <=7:\r\n            return blood_type\r\n        else:\r\n            raise ValueError\r\n    if isinstance(blood_type, str):\r\n        if blood_type in blood_type_text:\r\n            return blood_type_text[blood_type].value\r\n        else:\r\n            raise ValueError\r\n    raise TypeError\r\n\r\n# hint\r\ndef _particular_antigen_comp(donor: int, recipient: int) -> tuple:\r\n    \"\"\"Returns a particalar antigen compatibility, where each tuple member\r\n    marks a compatibility for a particular antigen  (A, B, Rh-D).\r\n    If tuple member is non-negative there is a compatibility.\r\n    For red blood cell compatibility is required that \r\n    all tuple members are non-negative (i.e. compatibility for all 3 antigens).\r\n    0- bloodtype is represented as 0 ; AB+ is represented as 7; see Bloodtype enum\r\n    Examples:\r\n    _particular_antigen_comp(0, 7) -> (1, 1, 1)    0- can donate to AB+\r\n    _particular_antigen_comp(1, 3) -> (0, 1, 0)    0+ can donate to B+\r\n    _particular_antigen_comp(2, 5) -> (1, -1, 1)   B+ cannot donate to A+\r\n    _particular_antigen_comp(7, 0) -> (-1, -1, -1) AB+ cannot donate to 0-\r\n    \"\"\"\r\n    return (\r\n        ((recipient // 4) % 2) - ((donor // 4) % 2),\r\n        ((recipient // 2) % 2) - ((donor // 2) % 2),\r\n        (recipient % 2) - (donor % 2),\r\n    )\r\n    \r\ncheck_bt(3, 7)",
            "date": "2022-10-14 17:17:56.653339+00:00",
            "passed": false
        },
        {
            "bite": "Bite 136. Bloodtypes",
            "code": "\"\"\"\r\nWrite a function which checks the red blood cell compatibility between donor and recipient.\r\nhttps://en.wikipedia.org/wiki/Blood_type#Red_blood_cell_compatibility\r\nFor simplicity, the appearance of 8 basic types of blood is considered.\r\nThe input of blood type can be in the form of:\r\n    pre defined Bloodtype enum e.g.: Bloodtype.ZERO_NEG\r\n    value of the pre-defined Bloodtype 0..7\r\n    pre defined text  e.g. \"0-\", \"B+\", \"AB+\", ...\r\n    If input value is not a required type TypeError is raised.\r\n    If input value is not in defined interval ValueError is raised.\r\nKeywords: enum, exception handling, multi type input\r\n\"\"\"\r\n\r\nfrom enum import Enum\r\n\r\n\r\nclass Bloodtype(Enum):\r\n    ZERO_NEG = 0\r\n    ZERO_POS = 1\r\n    B_NEG = 2\r\n    B_POS = 3\r\n    A_NEG = 4\r\n    A_POS = 5\r\n    AB_NEG = 6\r\n    AB_POS = 7\r\n\r\n\r\nblood_type_text = {\r\n    \"0-\": Bloodtype.ZERO_NEG,\r\n    \"0+\": Bloodtype.ZERO_POS,\r\n    \"B-\": Bloodtype.B_NEG,\r\n    \"B+\": Bloodtype.B_POS,\r\n    \"A-\": Bloodtype.A_NEG,\r\n    \"A+\": Bloodtype.A_POS,\r\n    \"AB-\": Bloodtype.AB_NEG,\r\n    \"AB+\": Bloodtype.AB_POS,\r\n}\r\n\r\n# complete :\r\ndef check_bt(donor, recipient):\r\n    \"\"\" Checks red blood cell compatibility based on 8 blood types\r\n        Args:\r\n        donor (int | str | Bloodtype): red blood cell type of the donor\r\n        recipient (int | str | Bloodtype): red blood cell type of the recipient\r\n        Returns:\r\n        bool: True for compatability, False otherwise.\r\n    \"\"\"\r\n    result = _particular_antigen_comp(_validated(donor), _validated(recipient))\r\n    return any(result)<0\r\n\r\n\r\ndef _validated(blood_type):\r\n    if isinstance(blood_type, Bloodtype):\r\n        return blood_type.value\r\n    if isinstance(blood_type, int):\r\n        if 0<= blood_type <=7:\r\n            return blood_type\r\n        else:\r\n            raise ValueError\r\n    if isinstance(blood_type, str):\r\n        if blood_type in blood_type_text:\r\n            return blood_type_text[blood_type]\r\n        else:\r\n            raise ValueError\r\n    raise TypeError\r\n\r\n# hint\r\ndef _particular_antigen_comp(donor: int, recipient: int) -> tuple:\r\n    \"\"\"Returns a particalar antigen compatibility, where each tuple member\r\n    marks a compatibility for a particular antigen  (A, B, Rh-D).\r\n    If tuple member is non-negative there is a compatibility.\r\n    For red blood cell compatibility is required that \r\n    all tuple members are non-negative (i.e. compatibility for all 3 antigens).\r\n    0- bloodtype is represented as 0 ; AB+ is represented as 7; see Bloodtype enum\r\n    Examples:\r\n    _particular_antigen_comp(0, 7) -> (1, 1, 1)    0- can donate to AB+\r\n    _particular_antigen_comp(1, 3) -> (0, 1, 0)    0+ can donate to B+\r\n    _particular_antigen_comp(2, 5) -> (1, -1, 1)   B+ cannot donate to A+\r\n    _particular_antigen_comp(7, 0) -> (-1, -1, -1) AB+ cannot donate to 0-\r\n    \"\"\"\r\n    return (\r\n        ((recipient // 4) % 2) - ((donor // 4) % 2),\r\n        ((recipient // 2) % 2) - ((donor // 2) % 2),\r\n        (recipient % 2) - (donor % 2),\r\n    )\r\n    \r\ncheck_bt(3, 7)",
            "date": "2022-10-14 17:16:01.225331+00:00",
            "passed": false
        },
        {
            "bite": "Bite 39. Calculate the total duration of a course",
            "code": "from datetime import datetime, timedelta\r\nimport os\r\nimport re\r\nfrom typing import List\r\nimport urllib.request\r\n\r\n# getting the data\r\nCOURSE_TIMES = os.path.join(\r\n    os.getenv(\"TMP\", \"/tmp\"),\r\n    'course_timings'\r\n)\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/course_timings',\r\n    COURSE_TIMES\r\n)\r\n\r\n\r\ndef get_all_timestamps() -> List[str]:\r\n    \"\"\"Read in the COURSE_TIMES and extract all MM:SS timestamps.\r\n       Here is a snippet of the input file:\r\n\r\n       Start  What is Practical JavaScript? (3:47)\r\n       Start  The voice in your ear (4:41)\r\n       Start  Is this course right for you? (1:21)\r\n       ...\r\n\r\n        Return a list of MM:SS timestamps\r\n    \"\"\"\r\n    with open(COURSE_TIMES) as f:\r\n        raw_list = [re.findall(\"\\((.+)\\)$\", line.lstrip()) for line in f.readlines()]\r\n    return [timestamp[0] for timestamp in raw_list if timestamp]\r\n\r\n\r\ndef calc_total_course_duration(timestamps) -> str:\r\n    \"\"\"Takes timestamps list as returned by get_all_timestamps\r\n       and calculates the total duration as HH:MM:SS\"\"\"\r\n    lst = []\r\n    for item in timestamps:\r\n        mm_ss = item.split(\":\")\r\n        lst.append(timedelta(minutes=int(mm_ss[0]), seconds=int(mm_ss[1])))\r\n    return str(sum(lst, timedelta()))\r\n    \r\n\r\nprint(calc_total_course_duration(get_all_timestamps()))",
            "date": "2022-10-13 10:53:24.247323+00:00",
            "passed": true
        },
        {
            "bite": "Bite 39. Calculate the total duration of a course",
            "code": "from datetime import datetime, timedelta\r\nimport os\r\nimport re\r\nfrom typing import List\r\nimport urllib.request\r\n\r\n# getting the data\r\nCOURSE_TIMES = os.path.join(\r\n    os.getenv(\"TMP\", \"/tmp\"),\r\n    'course_timings'\r\n)\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/course_timings',\r\n    COURSE_TIMES\r\n)\r\n\r\n\r\ndef get_all_timestamps() -> List[str]:\r\n    \"\"\"Read in the COURSE_TIMES and extract all MM:SS timestamps.\r\n       Here is a snippet of the input file:\r\n\r\n       Start  What is Practical JavaScript? (3:47)\r\n       Start  The voice in your ear (4:41)\r\n       Start  Is this course right for you? (1:21)\r\n       ...\r\n\r\n        Return a list of MM:SS timestamps\r\n    \"\"\"\r\n    with open(COURSE_TIMES) as f:\r\n        raw_list = [re.findall(\"\\((.+)\\)$\", line.lstrip()) for line in f.readlines()]\r\n    return [timestamp[0] for timestamp in raw_list if timestamp]\r\n\r\n\r\ndef calc_total_course_duration(timestamps) -> str:\r\n    \"\"\"Takes timestamps list as returned by get_all_timestamps\r\n       and calculates the total duration as HH:MM:SS\"\"\"\r\n    lst = []\r\n    for item in timestamps:\r\n        mm_ss = item.split(\":\")\r\n        lst.append(timedelta(minutes=int(mm_ss[0]), seconds=int(mm_ss[1])))\r\n    return sum(lst, timedelta())\r\n    \r\n\r\nprint(calc_total_course_duration(get_all_timestamps()))",
            "date": "2022-10-13 10:50:58.813512+00:00",
            "passed": false
        },
        {
            "bite": "Bite 317. Pickling objects",
            "code": "from datetime import date\r\nimport os\r\n\r\nfrom pathlib import Path\r\nimport pickle\r\nfrom typing import Sequence, NamedTuple\r\nfrom urllib.request import urlretrieve\r\nfrom pprint import pprint\r\n\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nS3 = \"https://bites-data.s3.us-east-2.amazonaws.com\"\r\nPICKLE_INFILE = TMP / 'input.pkl'\r\nPICKLE_OUTFILE = TMP / 'output.pkl'\r\n\r\n\r\nclass MovieRented(NamedTuple):\r\n    title: str\r\n    price: int\r\n    date: date\r\n\r\n\r\ndef download_pickle_file():\r\n    \"\"\"download a pickle file we created with a\r\n       list of namedtuples\r\n    \"\"\"\r\n    urlretrieve(f'{S3}/bite317.pkl', PICKLE_INFILE)\r\n\r\n\r\ndef deserialize(pkl_file: Path = PICKLE_INFILE) -> Sequence[NamedTuple]:\r\n    \"\"\"Load the list of namedtuples from the pickle file passed in\"\"\"\r\n\r\n    if not os.path.exists(pkl_file):\r\n        download_pickle_file()\r\n        \r\n    with open(pkl_file, 'rb') as f:\r\n        return pickle.load(f)\r\n\r\n\r\ndef serialize(pkl_file: Path = PICKLE_OUTFILE,\r\n              data: Sequence[NamedTuple] = None) -> None:\r\n    \"\"\"Save the data passed in to the pickle file passed in\"\"\"\r\n    if data is None:\r\n        data = deserialize()\r\n    # you code ...\r\n    with open(pkl_file, 'wb') as f:\r\n        pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)\r\n",
            "date": "2022-10-12 15:59:22.932060+00:00",
            "passed": true
        },
        {
            "bite": "Bite 317. Pickling objects",
            "code": "from datetime import date\r\nimport os\r\n\r\nfrom pathlib import Path\r\nimport pickle\r\nfrom typing import Sequence, NamedTuple\r\nfrom urllib.request import urlretrieve\r\nfrom pprint import pprint\r\n\r\nTMP = Path(os.getenv(\"TMP\", \"/tmp\"))\r\nS3 = \"https://bites-data.s3.us-east-2.amazonaws.com\"\r\nPICKLE_INFILE = TMP / 'input.pkl'\r\nPICKLE_OUTFILE = TMP / 'output.pkl'\r\n\r\n\r\nclass MovieRented(NamedTuple):\r\n    title: str\r\n    price: int\r\n    date: date\r\n\r\n\r\ndef download_pickle_file():\r\n    \"\"\"download a pickle file we created with a\r\n       list of namedtuples\r\n    \"\"\"\r\n    urlretrieve(f'{S3}/bite317.pkl', PICKLE_INFILE)\r\n\r\n\r\ndef deserialize(pkl_file: Path = PICKLE_INFILE) -> Sequence[NamedTuple]:\r\n    \"\"\"Load the list of namedtuples from the pickle file passed in\"\"\"\r\n\r\n    if not os.path.exists(pkl_file):\r\n        download_pickle_file()\r\n        \r\n    with open(pkl_file, 'rb') as f:\r\n        return pickle.load(f)\r\n\r\n\r\ndef serialize(pkl_file: Path = PICKLE_OUTFILE,\r\n              data: Sequence[NamedTuple] = None) -> None:\r\n    \"\"\"Save the data passed in to the pickle file passed in\"\"\"\r\n    if data is None:\r\n        data = deserialize()\r\n    # you code ...\r\n    with open(pkl_file, 'wb') as f:\r\n        pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)\r\n\r\n# download_pickle_file()\r\n# pprint(deserialize())\r\n\r\nserialize()",
            "date": "2022-10-12 15:58:10.021084+00:00",
            "passed": true
        },
        {
            "bite": "Bite 125. Get the most recommended books",
            "code": "from collections import Counter\r\n\r\nfrom bs4 import BeautifulSoup\r\nimport requests\r\n\r\nAMAZON = \"amazon.com\"\r\n# static copy\r\nTIM_BLOG = ('https://bites-data.s3.us-east-2.amazonaws.com/'\r\n            'tribe-mentors-books.html')\r\nMIN_COUNT = 3\r\n\r\n\r\ndef load_page():\r\n    \"\"\"Download the blog html and return its decoded content\"\"\"\r\n    with requests.Session() as session:\r\n        return session.get(TIM_BLOG).content.decode('utf-8')\r\n\r\n\r\ndef get_top_books(content=None):\r\n    \"\"\"Make a BeautifulSoup object loading in content,\r\n       find all links that contain AMAZON, extract the book title\r\n       (stripping spacing characters), and count them.\r\n       Return a list of (title, count) tuples where\r\n       count is at least MIN_COUNT\r\n    \"\"\"\r\n    if content is None:\r\n        content = load_page()\r\n\r\n    soup = BeautifulSoup(content, 'html.parser')\r\n    entry = soup.find(\"div\", class_=\"entry-content\")\r\n    links = entry.find_all(\"a\")\r\n    result = []\r\n    for link in links:\r\n        # get text in the span/em inside a if href contains AMAZON\r\n        if AMAZON in link.get(\"href\"): \r\n            book_title = link.find({\"span\",\"em\"}).text.strip()\r\n            result.append(book_title)\r\n    count_books = Counter(result)\r\n    return sorted([ (title, count) for title, count in count_books.items() if count >= MIN_COUNT ] , \\\r\n            key=lambda tup: tup[1], reverse=True)\r\n\r\nprint(get_top_books())",
            "date": "2022-10-12 12:03:57.609778+00:00",
            "passed": true
        },
        {
            "bite": "Bite 125. Get the most recommended books",
            "code": "from collections import Counter\r\n\r\nfrom bs4 import BeautifulSoup\r\nimport requests\r\n\r\nAMAZON = \"amazon.com\"\r\n# static copy\r\nTIM_BLOG = ('https://bites-data.s3.us-east-2.amazonaws.com/'\r\n            'tribe-mentors-books.html')\r\nMIN_COUNT = 3\r\n\r\n\r\ndef load_page():\r\n    \"\"\"Download the blog html and return its decoded content\"\"\"\r\n    with requests.Session() as session:\r\n        return session.get(TIM_BLOG).content.decode('utf-8')\r\n\r\n\r\ndef get_top_books(content=None):\r\n    \"\"\"Make a BeautifulSoup object loading in content,\r\n       find all links that contain AMAZON, extract the book title\r\n       (stripping spacing characters), and count them.\r\n       Return a list of (title, count) tuples where\r\n       count is at least MIN_COUNT\r\n    \"\"\"\r\n    if content is None:\r\n        content = load_page()\r\n    # code here ...\r\n    soup = BeautifulSoup(content, 'html.parser')\r\n    entry = soup.find(\"div\", class_=\"entry-content\") # {\"class\": \"entry-content\"}\r\n    links = entry.find_all(\"a\")\r\n    result = []\r\n    for link in links:\r\n        # get text in span in a if href contiene AMAZON\r\n        # print(link)\r\n        if AMAZON in link.get(\"href\"): \r\n            book_title = link.find({\"span\",\"em\"}).text.strip()\r\n            result.append(book_title)\r\n            # print(book_title)\r\n    count_books = Counter(result)\r\n    return sorted([ (title, count) for title, count in count_books.items() if count >= MIN_COUNT ] , \\\r\n            key=lambda tup: tup[1], reverse=True)\r\n\r\nprint(get_top_books())",
            "date": "2022-10-12 11:59:45.416833+00:00",
            "passed": true
        },
        {
            "bite": "Bite 125. Get the most recommended books",
            "code": "from collections import Counter\r\n\r\nfrom bs4 import BeautifulSoup\r\nimport requests\r\n\r\nAMAZON = \"amazon.com\"\r\n# static copy\r\nTIM_BLOG = ('https://bites-data.s3.us-east-2.amazonaws.com/'\r\n            'tribe-mentors-books.html')\r\nMIN_COUNT = 3\r\n\r\n\r\ndef load_page():\r\n    \"\"\"Download the blog html and return its decoded content\"\"\"\r\n    with requests.Session() as session:\r\n        return session.get(TIM_BLOG).content.decode('utf-8')\r\n\r\n\r\ndef get_top_books(content=None):\r\n    \"\"\"Make a BeautifulSoup object loading in content,\r\n       find all links that contain AMAZON, extract the book title\r\n       (stripping spacing characters), and count them.\r\n       Return a list of (title, count) tuples where\r\n       count is at least MIN_COUNT\r\n    \"\"\"\r\n    if content is None:\r\n        content = load_page()\r\n    # code here ...\r\n    soup = BeautifulSoup(content, 'html.parser')\r\n    entry = soup.find(\"div\", class_=\"entry-content\") # {\"class\": \"entry-content\"}\r\n    links = entry.find_all(\"a\")\r\n    result = []\r\n    for link in links:\r\n        # get text in span in a if href contiene AMAZON\r\n        # print(link)\r\n        if AMAZON in link.get(\"href\"): \r\n            book_title = link.find({\"span\",\"em\"}).text.strip()\r\n            result.append(book_title)\r\n            # print(book_title)\r\n    count_books = Counter(result)\r\n    return { x: count for x, count in count_books.items() if count >= MIN_COUNT }\r\n\r\nprint(get_top_books())",
            "date": "2022-10-12 11:53:50.399372+00:00",
            "passed": false
        },
        {
            "bite": "Bite 133. Convert an Amazon URL into an affiliation link",
            "code": "def generate_affiliation_link(url):\r\n    code = url.split(\"/dp/\")[1].split(\"/\")[0]\r\n    return f\"http://www.amazon.com/dp/{code}/?tag=pyb0f-20\"\r\n    \r\n\r\nif __name__ == \"__main__\":\r\n    links=\"\"\"https://www.amazon.com/War-Art-Through-Creative-Battles/dp/1936891026/?keywords=war+of+art\r\nhttps://amazon.com/War-Art-Through-Creative-Battles/dp/1936891026/ref=sr_1_1\r\nhttps://www.amazon.es/War-Art-Through-Creative-Battles/dp/1936891026/?qid=1537226234\r\nhttps://www.amazon.co.uk/Pragmatic-Programmer-Andrew-Hunt/dp/020161622X\r\nhttps://www.amazon.com.au/Python-Cookbook-3e-David-Beazley/dp/1449340377/\r\n\"\"\"\r\n    for url in links.splitlines():\r\n        print(generate_affiliation_link(url))",
            "date": "2022-10-11 18:25:35.437481+00:00",
            "passed": true
        },
        {
            "bite": "Bite 265. Optimal fund raising",
            "code": "IMPOSSIBLE = 'Mission impossible. No one can contribute.'\r\n\r\n\r\ndef max_fund(village):\r\n    \"\"\"Find a contiguous subarray with the largest sum.\"\"\"\r\n    # Hint: while iterating, you could save the best_sum collected so far\r\n    # return total, starting, ending\r\n    start = 0\r\n    end = 0\r\n    max_donations= float('-inf')\r\n    for i in range(len(village)):\r\n        for j in range(i+1,len(village)+1):\r\n            donations = sum(village[i:j])\r\n            # print(f\"{i}:{j} ({village[i:j]})-> {donations}\")\r\n            if donations >= max_donations:\r\n                max_donations = donations\r\n                start = i\r\n                end = j\r\n                # print(f\"Found max!\")\r\n    if max_donations < 0:\r\n        print(IMPOSSIBLE)\r\n        return (0,0,0)\r\n    return (max_donations, start+1, end)\r\n    \r\n\r\nif __name__ == \"__main__\":\r\n    print(max_fund([0, -3, 2, 1, -7, 5, 3, -1, 6]))\r\n    print(max_fund([0, 1, -1, -5, 0, 4, -3, -2]))\r\n    print(max_fund([0, 0, 0, 0, 1, -5, -2, -1, -3]))\r\n    print(max_fund([-1, -2, -3, -4, -5]))\r\n\r\n",
            "date": "2022-10-11 18:06:43.982241+00:00",
            "passed": true
        },
        {
            "bite": "Bite 120. Write a numbers validation decorator",
            "code": "from functools import wraps\r\n\r\n\r\ndef int_args(func):\r\n    @wraps(func)\r\n    def wrapped(*args):\r\n        # do stuff before the original function gets called\r\n\r\n        for arg in args:\r\n            if not isinstance(arg,int):\r\n                raise TypeError\r\n            if arg < 0:\r\n                raise ValueError\r\n        return func(*args)\r\n\r\n    # return wrapper as a decorated function\r\n    return wrapped\r\n\r\n@int_args\r\ndef test_int(*args):\r\n    for arg in args: \r\n        print(arg)\r\n\r\nif __name__ == \"__main__\":\r\n    test_int(1,2,3,4,-5)",
            "date": "2022-10-10 22:06:11.892612+00:00",
            "passed": true
        },
        {
            "bite": "Bite 120. Write a numbers validation decorator",
            "code": "from functools import wraps\r\n\r\n\r\ndef int_args(func):\r\n    @wraps(func)\r\n    def wrapped(*args, **kwargs):\r\n        # do stuff before the original function gets called\r\n\r\n        for arg in args:\r\n            if not isinstance(arg,int):\r\n                raise TypeError\r\n            if arg < 0:\r\n                raise ValueError\r\n        return func(*args)\r\n\r\n    # return wrapper as a decorated function\r\n    return wrapped\r\n\r\n@int_args\r\ndef test_int(*args):\r\n    for arg in args: \r\n        print(arg)\r\n\r\nif __name__ == \"__main__\":\r\n    test_int(1,2,3,4,-5)",
            "date": "2022-10-10 22:04:47.621205+00:00",
            "passed": true
        },
        {
            "bite": "Bite 259. Reverse complement",
            "code": "# See tests for a more comprehensive complementary table\r\nSIMPLE_COMPLEMENTS_STR = \"\"\"#Reduced table with bases A, G, C, T\r\n Base\tComplementary Base\r\n A\tT\r\n T\tA\r\n G\tC\r\n C\tG\r\n\"\"\"\r\n\r\n\r\ndef _read_str_table(str_table):\r\n    \"\"\"\r\n    Takes a string defining a table of valid and comlementary bases \r\n    and returns a dict of base:complement\r\n    \"\"\"\r\n    lst = [line.split() for line in str_table.splitlines()[2:]]\r\n    return  {item[0].upper().strip(): item[-1].upper().strip() for item in lst}\r\n\r\n# Recommended helper function\r\ndef _clean_sequence(sequence, str_table):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns all sequences converted to upper case and remove invalid\r\n    characters\r\n    t!t%ttttAACCG --> TTTTTTAACCG\r\n    \"\"\"\r\n    base_table = _read_str_table(str_table)\r\n    return \"\".join([base for base in sequence.upper() if base in base_table])\r\n\r\n\r\ndef reverse(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a reversed string of sequence while removing all characters\r\n    not found in str_table characters\r\n    e.g. t!t%ttttAACCG --> GCCAATTTTTT\r\n    \"\"\"\r\n    return _clean_sequence(sequence, str_table)[::-1]\r\n\r\n\r\ndef complement(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a string containing complementary bases as defined in\r\n    str_table while removing non input_sequence characters\r\n    e.g. t!t%ttttAACCG --> AAAAAATTGGC\r\n    \"\"\"\r\n    base_table = _read_str_table(str_table)\r\n    return \"\".join([base_table[base] for base in _clean_sequence(sequence, str_table) ])\r\n    \r\n\r\ndef reverse_complement(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a string containing complementary bases as defined in str_table\r\n    while removing non input_sequence characters\r\n    e.g. t!t%ttttAACCG --> CGGTTAAAAAA\r\n    \"\"\"\r\n    return reverse(complement(sequence,str_table),str_table)\r\n\r\n\r\ntest_str = \"\"\"# Full table with ambigous bases\r\n Base\tName\tBases Represented\tComplementary Base\r\n A\tAdenine\tA\tT\r\n T\tThymidine\tT \tA\r\n U\tUridine(RNA only)\tU\tA\r\n G\tGuanidine\tG\tC\r\n C\tCytidine\tC\tG\r\n Y\tpYrimidine\tC T\tR\r\n R\tpuRine\tA G\tY\r\n S\tStrong(3Hbonds)\tG C\tS\r\n W\tWeak(2Hbonds)\tA T\tW\r\n K\tKeto\tT/U G\tM\r\n M\taMino\tA C\tK\r\n B\tnot A\tC G T\tV\r\n D\tnot C\tA G T\tH\r\n H\tnot G\tA C T\tD\r\n V\tnot T/U\tA C G\tB\r\n N\tUnknown\tA C G T\tN\r\n\"\"\"\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    print(_read_str_table(str_table=test_str))\r\n    print(_clean_sequence('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))\r\n    print(reverse('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))\r\n    print(complement('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))\r\n    print(reverse_complement('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))",
            "date": "2022-10-10 21:50:34.671606+00:00",
            "passed": true
        },
        {
            "bite": "Bite 259. Reverse complement",
            "code": "# See tests for a more comprehensive complementary table\r\nSIMPLE_COMPLEMENTS_STR = \"\"\"#Reduced table with bases A, G, C, T\r\n Base\tComplementary Base\r\n A\tT\r\n T\tA\r\n G\tC\r\n C\tG\r\n\"\"\"\r\n\r\n\r\ndef _read_str_table(str_table):\r\n    \"\"\"\r\n    Takes a string defining a table of valid and comlementary bases \r\n    and returns a dict of base:complement\r\n    \"\"\"\r\n    lst = [line.split() for line in str_table.splitlines()[2:]]\r\n    return  {item[0].upper().strip(): item[-1].upper().strip() for item in lst}\r\n\r\n# Recommended helper function\r\ndef _clean_sequence(sequence, str_table):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns all sequences converted to upper case and remove invalid\r\n    characters\r\n    t!t%ttttAACCG --> TTTTTTAACCG\r\n    \"\"\"\r\n    valid_bases = _read_str_table(str_table)\r\n    return \"\".join([letter for letter in sequence.upper() if letter in valid_bases])\r\n\r\n\r\ndef reverse(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a reversed string of sequence while removing all characters\r\n    not found in str_table characters\r\n    e.g. t!t%ttttAACCG --> GCCAATTTTTT\r\n    \"\"\"\r\n    return _clean_sequence(sequence, str_table)[::-1]\r\n\r\n\r\ndef complement(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a string containing complementary bases as defined in\r\n    str_table while removing non input_sequence characters\r\n    e.g. t!t%ttttAACCG --> AAAAAATTGGC\r\n    \"\"\"\r\n    complement = _read_str_table(str_table)\r\n    return \"\".join([complement[base] for base in _clean_sequence(sequence, str_table) ])\r\n    \r\n\r\ndef reverse_complement(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a string containing complementary bases as defined in str_table\r\n    while removing non input_sequence characters\r\n    e.g. t!t%ttttAACCG --> CGGTTAAAAAA\r\n    \"\"\"\r\n    return reverse(complement(sequence,str_table),str_table)\r\n\r\n\r\ntest_str = \"\"\"# Full table with ambigous bases\r\n Base\tName\tBases Represented\tComplementary Base\r\n A\tAdenine\tA\tT\r\n T\tThymidine\tT \tA\r\n U\tUridine(RNA only)\tU\tA\r\n G\tGuanidine\tG\tC\r\n C\tCytidine\tC\tG\r\n Y\tpYrimidine\tC T\tR\r\n R\tpuRine\tA G\tY\r\n S\tStrong(3Hbonds)\tG C\tS\r\n W\tWeak(2Hbonds)\tA T\tW\r\n K\tKeto\tT/U G\tM\r\n M\taMino\tA C\tK\r\n B\tnot A\tC G T\tV\r\n D\tnot C\tA G T\tH\r\n H\tnot G\tA C T\tD\r\n V\tnot T/U\tA C G\tB\r\n N\tUnknown\tA C G T\tN\r\n\"\"\"\r\n\r\n\r\n\r\n\r\nprint(_read_str_table(str_table=test_str))\r\nprint(_clean_sequence('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))\r\nprint(reverse('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))\r\nprint(complement('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))\r\nprint(reverse_complement('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))",
            "date": "2022-10-10 21:47:16.666567+00:00",
            "passed": true
        },
        {
            "bite": "Bite 259. Reverse complement",
            "code": "# See tests for a more comprehensive complementary table\r\nSIMPLE_COMPLEMENTS_STR = \"\"\"#Reduced table with bases A, G, C, T\r\n Base\tComplementary Base\r\n A\tT\r\n T\tA\r\n G\tC\r\n C\tG\r\n\"\"\"\r\n\r\n\r\ndef _read_str_table(str_table):\r\n    \"\"\"\r\n    Takes a string defining a table of valid and comlementary bases \r\n    and returns a dict of base:complement\r\n    \"\"\"\r\n    lst = [line.split() for line in str_table.splitlines()[2:]]\r\n    return  {item[0].upper().strip(): item[-1].upper().strip() for item in lst}\r\n\r\n# Recommended helper function\r\ndef _clean_sequence(sequence, str_table):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns all sequences converted to upper case and remove invalid\r\n    characters\r\n    t!t%ttttAACCG --> TTTTTTAACCG\r\n    \"\"\"\r\n    valid_bases = _read_str_table(str_table)\r\n    result = []\r\n    for seqs in sequence:\r\n        result.append(\"\".join([letter for letter in seqs.upper() if letter in valid_bases]))\r\n    return result\r\n\r\ndef reverse(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a reversed string of sequence while removing all characters\r\n    not found in str_table characters\r\n    e.g. t!t%ttttAACCG --> GCCAATTTTTT\r\n    \"\"\"\r\n    lst_clean = _clean_sequence(sequence, str_table)\r\n    return [seq[::-1] for seq in lst_clean]\r\n\r\n\r\ndef complement(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a string containing complementary bases as defined in\r\n    str_table while removing non input_sequence characters\r\n    e.g. t!t%ttttAACCG --> AAAAAATTGGC\r\n    \"\"\"\r\n    complement = _read_str_table(str_table)\r\n    result = []\r\n    for seq in _clean_sequence(sequence, str_table):\r\n        result.append(\"\".join([complement[base] for base in seq ]))\r\n    return result\r\n\r\ndef reverse_complement(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a string containing complementary bases as defined in str_table\r\n    while removing non input_sequence characters\r\n    e.g. t!t%ttttAACCG --> CGGTTAAAAAA\r\n    \"\"\"\r\n    return reverse(complement(sequence,str_table),str_table)\r\n\r\n\r\ntest_str = \"\"\"# Full table with ambigous bases\r\n Base\tName\tBases Represented\tComplementary Base\r\n A\tAdenine\tA\tT\r\n T\tThymidine\tT \tA\r\n U\tUridine(RNA only)\tU\tA\r\n G\tGuanidine\tG\tC\r\n C\tCytidine\tC\tG\r\n Y\tpYrimidine\tC T\tR\r\n R\tpuRine\tA G\tY\r\n S\tStrong(3Hbonds)\tG C\tS\r\n W\tWeak(2Hbonds)\tA T\tW\r\n K\tKeto\tT/U G\tM\r\n M\taMino\tA C\tK\r\n B\tnot A\tC G T\tV\r\n D\tnot C\tA G T\tH\r\n H\tnot G\tA C T\tD\r\n V\tnot T/U\tA C G\tB\r\n N\tUnknown\tA C G T\tN\r\n\"\"\"\r\n\r\n\r\n\r\n\r\nprint(_read_str_table(str_table=test_str))\r\nprint(_clean_sequence(['t!t%ttttAACCG'], str_table=SIMPLE_COMPLEMENTS_STR))\r\nprint(reverse(['t!t%ttttAACCG'], str_table=SIMPLE_COMPLEMENTS_STR))\r\nprint(complement(['t!t%ttttAACCG'], str_table=SIMPLE_COMPLEMENTS_STR))\r\nprint(reverse_complement(['t!t%ttttAACCG'], str_table=SIMPLE_COMPLEMENTS_STR))",
            "date": "2022-10-10 21:42:51.456072+00:00",
            "passed": false
        },
        {
            "bite": "Bite 259. Reverse complement",
            "code": "# See tests for a more comprehensive complementary table\r\nSIMPLE_COMPLEMENTS_STR = \"\"\"#Reduced table with bases A, G, C, T\r\n Base\tComplementary Base\r\n A\tT\r\n T\tA\r\n G\tC\r\n C\tG\r\n\"\"\"\r\n\r\n\r\ndef _read_str_table(str_table):\r\n    \"\"\"\r\n    Takes a string defining a table of valid and comlementary bases \r\n    and returns a dict of base:complement\r\n    \"\"\"\r\n    lst = [line.split() for line in str_table.splitlines()[2:]]\r\n    return  {item[0].upper().strip(): item[-1].upper().strip() for item in lst}\r\n\r\n# Recommended helper function\r\ndef _clean_sequence(sequence, str_table):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns all sequences converted to upper case and remove invalid\r\n    characters\r\n    t!t%ttttAACCG --> TTTTTTAACCG\r\n    \"\"\"\r\n    valid_bases = _read_str_table(str_table)\r\n    return \"\".join([letter for letter in sequence.upper() if letter in valid_bases])\r\n\r\n\r\ndef reverse(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a reversed string of sequence while removing all characters\r\n    not found in str_table characters\r\n    e.g. t!t%ttttAACCG --> GCCAATTTTTT\r\n    \"\"\"\r\n    return _clean_sequence('t!t%ttttAACCG', str_table)[::-1]\r\n\r\n\r\ndef complement(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a string containing complementary bases as defined in\r\n    str_table while removing non input_sequence characters\r\n    e.g. t!t%ttttAACCG --> AAAAAATTGGC\r\n    \"\"\"\r\n    valid_bases = _read_str_table(str_table)\r\n    return \"\".join([valid_bases[letter] for letter in _clean_sequence(sequence, str_table)])\r\n\r\n\r\ndef reverse_complement(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a string containing complementary bases as defined in str_table\r\n    while removing non input_sequence characters\r\n    e.g. t!t%ttttAACCG --> CGGTTAAAAAA\r\n    \"\"\"\r\n    return reverse(complement(sequence,str_table),str_table)\r\n\r\n\r\ntest_str = \"\"\"# Full table with ambigous bases\r\n Base\tName\tBases Represented\tComplementary Base\r\n A\tAdenine\tA\tT\r\n T\tThymidine\tT \tA\r\n U\tUridine(RNA only)\tU\tA\r\n G\tGuanidine\tG\tC\r\n C\tCytidine\tC\tG\r\n Y\tpYrimidine\tC T\tR\r\n R\tpuRine\tA G\tY\r\n S\tStrong(3Hbonds)\tG C\tS\r\n W\tWeak(2Hbonds)\tA T\tW\r\n K\tKeto\tT/U G\tM\r\n M\taMino\tA C\tK\r\n B\tnot A\tC G T\tV\r\n D\tnot C\tA G T\tH\r\n H\tnot G\tA C T\tD\r\n V\tnot T/U\tA C G\tB\r\n N\tUnknown\tA C G T\tN\r\n\"\"\"\r\n\r\n\r\n\r\n\r\nprint(_read_str_table(str_table=test_str))\r\nprint(_clean_sequence('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))\r\nprint(reverse('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))\r\nprint(complement('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))\r\nprint(reverse_complement('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))",
            "date": "2022-10-10 21:28:52.007890+00:00",
            "passed": false
        },
        {
            "bite": "Bite 259. Reverse complement",
            "code": "# See tests for a more comprehensive complementary table\r\nSIMPLE_COMPLEMENTS_STR = \"\"\"#Reduced table with bases A, G, C, T\r\n Base\tComplementary Base\r\n A\tT\r\n T\tA\r\n G\tC\r\n C\tG\r\n\"\"\"\r\n\r\n\r\ndef _read_str_table(str_table):\r\n    \"\"\"\r\n    Takes a string defining a table of valid and comlementary bases \r\n    and returns a dict of base:complement\r\n    \"\"\"\r\n    lst = [line.split() for line in str_table.splitlines()[2:]]\r\n    return  {item[0].upper().strip(): item[-1].upper().strip() for item in lst}\r\n\r\n# Recommended helper function\r\ndef _clean_sequence(sequence, str_table):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns all sequences converted to upper case and remove invalid\r\n    characters\r\n    t!t%ttttAACCG --> TTTTTTAACCG\r\n    \"\"\"\r\n    valid_bases = _read_str_table(str_table)\r\n    return \"\".join([letter for letter in sequence.upper() if letter in valid_bases])\r\n\r\n\r\ndef reverse(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a reversed string of sequence while removing all characters\r\n    not found in str_table characters\r\n    e.g. t!t%ttttAACCG --> GCCAATTTTTT\r\n    \"\"\"\r\n    return _clean_sequence('t!t%ttttAACCG', str_table)[::-1]\r\n\r\n\r\ndef complement(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a string containing complementary bases as defined in\r\n    str_table while removing non input_sequence characters\r\n    e.g. t!t%ttttAACCG --> AAAAAATTGGC\r\n    \"\"\"\r\n    valid_bases = _read_str_table(str_table)\r\n    return \"\".join([valid_bases[letter] for letter in _clean_sequence(sequence, str_table)])\r\n\r\n\r\ndef reverse_complement(sequence, str_table=SIMPLE_COMPLEMENTS_STR):\r\n    \"\"\"\r\n    Receives a DNA sequence and a str_table that defines valid (and\r\n    complementary) bases\r\n    Returns a string containing complementary bases as defined in str_table\r\n    while removing non input_sequence characters\r\n    e.g. t!t%ttttAACCG --> CGGTTAAAAAA\r\n    \"\"\"\r\n    return reverse(complement(sequence,str_table),str_table)\r\n\r\nprint(_read_str_table(str_table=SIMPLE_COMPLEMENTS_STR))\r\nprint(_clean_sequence('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))\r\nprint(reverse('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))\r\nprint(complement('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))\r\nprint(reverse_complement('t!t%ttttAACCG', str_table=SIMPLE_COMPLEMENTS_STR))",
            "date": "2022-10-10 21:24:40.864557+00:00",
            "passed": false
        },
        {
            "bite": "Bite 117. Round a number even (a.k.a. banker's rounding)",
            "code": "def round_even(number):\r\n    \"\"\"Takes a number and returns it rounded even\"\"\"\r\n    decimal_part = number % 1\r\n    int_part = number - decimal_part\r\n    if decimal_part < 0.5:\r\n        return int_part\r\n    if decimal_part > 0.5:\r\n        return int_part + 1\r\n    if decimal_part == 0.5:\r\n        if int_part%2 == 0:\r\n            return int_part\r\n        return int_part + 1\r\n\r\n    \r\n    \r\n",
            "date": "2022-10-10 20:41:00.553990+00:00",
            "passed": true
        },
        {
            "bite": "Bite 117. Round a number even (a.k.a. banker's rounding)",
            "code": "def round_even(number):\r\n    \"\"\"Takes a number and returns it rounded even\"\"\"\r\n    decimal_part = number % 1\r\n    int_part = number - decimal_part\r\n    if decimal_part < 0.5:\r\n        return int_part\r\n    if decimal_part > 0.5:\r\n        return int_part + 1\r\n    if decimal_part == 0.5:\r\n        if int_part%2 == 0:\r\n            return int_part + 1\r\n        return int_part \r\n\r\n    \r\n    \r\n",
            "date": "2022-10-10 20:40:46.533030+00:00",
            "passed": false
        },
        {
            "bite": "Bite 117. Round a number even (a.k.a. banker's rounding)",
            "code": "def round_even(number):\r\n    \"\"\"Takes a number and returns it rounded even\"\"\"\r\n    int_part = floor(number)\r\n    decimal_part = number - int_part\r\n    if decimal_part == 0.5:\r\n        if floor(number)%2 == 0:\r\n            return int_part + 1\r\n        return int_part \r\n    return round(number)\r\n    \r\n    \r\n",
            "date": "2022-10-10 20:34:46.867605+00:00",
            "passed": false
        },
        {
            "bite": "Bite 117. Round a number even (a.k.a. banker's rounding)",
            "code": "def round_even(number):\r\n    \"\"\"Takes a number and returns it rounded even\"\"\"\r\n    int_part = floor(number)\r\n    decimal_part = number - int_part\r\n    if decimal_part == 0.5:\r\n        if floor(number)%2 == 0:\r\n            return int_part\r\n        return int_part + 1\r\n    return round(number)\r\n    \r\n    \r\n",
            "date": "2022-10-10 20:34:26.739344+00:00",
            "passed": false
        },
        {
            "bite": "Bite 117. Round a number even (a.k.a. banker's rounding)",
            "code": "def round_even(number):\r\n    \"\"\"Takes a number and returns it rounded even\"\"\"\r\n    int_part = floor(number)\r\n    decimal_part = number - int_part\r\n    if decimal part == 0.5:\r\n        if floor(number)%2 == 0:\r\n            return int_part\r\n        return int_part + 1\r\n    return round(number)\r\n    \r\n    \r\n",
            "date": "2022-10-10 20:33:40.781895+00:00",
            "passed": false
        },
        {
            "bite": "Bite 95. Subclass the dict built-in",
            "code": "from datetime import date\r\nMSG = 'Hey {}, there are more people with your birthday!'\r\n\r\n\r\nclass BirthdayDict(dict):\r\n    \"\"\"Override dict to print a message every time a new person is added that has\r\n       the same birthday (day+month) as somebody already in the dict\"\"\"\r\n\r\n\r\n    def __setitem__(self, name, birthday):\r\n        for bday in self.values():\r\n            if birthday.day == bday.day and birthday.month == bday.month:\r\n                # match\r\n                print(MSG.format(name))\r\n        super().__setitem__(name, birthday)\r\n\r\n\r\nbd = BirthdayDict()\r\nbd['bob'] = date(1987, 6, 15)\r\nbd['tim'] = date(1984, 7, 15)\r\nprint(bd)\r\nbd['mary'] = date(1987, 6, 15)  # whole date match\r\n# Hey mary, there are more people with your birthday!\r\nbd['sara'] = date(1987, 6, 14)\r\nbd['mike'] = date(1981, 7, 15)  # day + month match\r\n# Hey mike, there are more people with your birthday!\r\n",
            "date": "2022-10-09 10:46:27.925786+00:00",
            "passed": true
        },
        {
            "bite": "Bite 95. Subclass the dict built-in",
            "code": "from datetime import date\r\nMSG = 'Hey {}, there are more people with your birthday!'\r\n\r\n\r\nclass BirthdayDict(dict):\r\n    \"\"\"Override dict to print a message every time a new person is added that has\r\n       the same birthday (day+month) as somebody already in the dict\"\"\"\r\n\r\n\r\n    def __init__(self):\r\n        self.dict ={}\r\n\r\n\r\n    def __setitem__(self, name, birthday):\r\n        for bday in self.dict.values():\r\n            if birthday.day == bday.day and birthday.month == bday.month:\r\n                # match\r\n                print(MSG.format(name))\r\n        self.dict[name] = birthday\r\n\r\n\r\n    def __getitem__(self, key):\r\n        return self.dict[key]\r\n\r\nbd = BirthdayDict()\r\nbd['bob'] = date(1987, 6, 15)\r\nbd['tim'] = date(1984, 7, 15)\r\nbd['mary'] = date(1987, 6, 15)  # whole date match\r\n# Hey mary, there are more people with your birthday!\r\nbd['sara'] = date(1987, 6, 14)\r\nbd['mike'] = date(1981, 7, 15)  # day + month match\r\n# Hey mike, there are more people with your birthday!\r\n",
            "date": "2022-10-09 10:42:09.280387+00:00",
            "passed": true
        },
        {
            "bite": "Bite 115. Count leading spaces",
            "code": "def count_indents(text: str) -> int:\r\n    \"\"\"\r\n    Count and return the number of leading white space characters (' ').\r\n    \"\"\"\r\n    for i,letter in enumerate(text):\r\n        if letter !=\" \":\r\n            return i\r\n    # only spaces found\r\n    return len(text)\r\n    \r\nprint(count_indents(\"   n\"))",
            "date": "2022-10-09 10:14:28.273865+00:00",
            "passed": true
        },
        {
            "bite": "Bite 263. Count the number of islands in a grid",
            "code": "from pprint import pprint\r\n\r\nVERBOSE = False\r\n\r\ndef count_islands(grid):\r\n    \"\"\"\r\n    Input: 2D matrix, each item is [x, y] -> row, col.\r\n    Output: number of islands, or 0 if found none.\r\n    Notes: island is denoted by 1, ocean by 0 islands is counted by continuously\r\n        connected vertically or horizontally  by '1's.\r\n    It's also preferred to check/mark the visited islands:\r\n    - eg. using the helper function - mark_islands().\r\n    \"\"\"\r\n    \r\n    islands = 0         # var. for the counts\r\n    nrows = len(grid)\r\n    ncols = len(grid[0])\r\n    for i in range(nrows):\r\n        for j in range(ncols):\r\n            if grid[i][j] == 1:\r\n                islands += 1\r\n                if VERBOSE:\r\n                    print(f\"Found island number {islands}\")\r\n                mark_islands(i, j, grid)\r\n    print (f\"{islands} islands\")\r\n    return islands\r\n\r\n\r\ndef _print_grid(grid):\r\n    nrows = len(grid)\r\n    print(\"Exploring island:\")\r\n    for i in range(nrows):\r\n        print(\" \".join([str(el) for el in grid[i]]))\r\n    print(\"\\n\")\r\n    \r\n    \r\ndef mark_islands(i, j, grid):\r\n    \"\"\"\r\n    Input: the row, column and grid\r\n    Output: None. Just mark the visited islands as in-place operation.\r\n    \"\"\"\r\n    nrows = len(grid)\r\n    ncols = len(grid[0])\r\n    grid[i][j] = '#'      # one way to mark visited ones - suggestion.\r\n    if VERBOSE:\r\n        _print_grid(grid)\r\n    if i>0: \r\n        if grid[i-1][j] == 1:\r\n            mark_islands(i-1, j, grid)\r\n    if i<nrows-1:\r\n        if grid[i+1][j] == 1:\r\n            mark_islands(i+1, j, grid)\r\n    if j>0:\r\n        if grid[i][j-1] == 1:\r\n            mark_islands(i, j-1, grid)\r\n    if j<ncols-1:\r\n        if grid[i][j+1] == 1:\r\n            mark_islands(i, j+1, grid)\r\n\r\nif __name__ == \"__main__\":\r\n    \r\n    test_grid = [[1, 0, 0, 1],\r\n             [0, 0, 0, 0],\r\n             [0, 0, 0, 0],\r\n             [1, 0, 0, 1]]\r\n    \r\n    count_islands(test_grid)\r\n        ",
            "date": "2022-10-08 21:54:22.850538+00:00",
            "passed": true
        },
        {
            "bite": "Bite 263. Count the number of islands in a grid",
            "code": "from pprint import pprint\r\n\r\ndef count_islands(grid):\r\n    \"\"\"\r\n    Input: 2D matrix, each item is [x, y] -> row, col.\r\n    Output: number of islands, or 0 if found none.\r\n    Notes: island is denoted by 1, ocean by 0 islands is counted by continuously\r\n        connected vertically or horizontally  by '1's.\r\n    It's also preferred to check/mark the visited islands:\r\n    - eg. using the helper function - mark_islands().\r\n    \"\"\"\r\n    islands = 0         # var. for the counts\r\n    nrows = len(grid)\r\n    ncols = len(grid[0])\r\n    for i in range(nrows):\r\n        for j in range(ncols):\r\n            if grid[i][j] == 1:\r\n               islands += 1\r\n               mark_islands(i, j, grid)\r\n    print (f\"{islands} islands\")\r\n    return islands\r\n\r\n\r\ndef mark_islands(i, j, grid):\r\n    \"\"\"\r\n    Input: the row, column and grid\r\n    Output: None. Just mark the visited islands as in-place operation.\r\n    \"\"\"\r\n    nrows = len(grid)\r\n    ncols = len(grid[0])\r\n    grid[i][j] = '#'      # one way to mark visited ones - suggestion.\r\n    print(grid)\r\n    if i>0: \r\n        if grid[i-1][j] == 1:\r\n            mark_islands(i-1, j, grid)\r\n    if i<nrows-1:\r\n        if grid[i+1][j] == 1:\r\n            mark_islands(i+1, j, grid)\r\n    if j>0:\r\n        if grid[i][j-1] == 1:\r\n            mark_islands(i, j-1, grid)\r\n    if j<ncols-1:\r\n        if grid[i][j+1] == 1:\r\n            mark_islands(i, j+1, grid)\r\n\r\nif __name__ == \"__main__\":\r\n    \r\n    test_grid = [[1, 0, 0, 1],\r\n             [0, 0, 0, 0],\r\n             [0, 0, 0, 0],\r\n             [1, 0, 0, 1]]\r\n    \r\n    count_islands(test_grid)\r\n        ",
            "date": "2022-10-08 21:46:39.275133+00:00",
            "passed": true
        },
        {
            "bite": "Bite 338. Create food objects",
            "code": "from typing import Dict\r\n\r\nfrom fastapi import FastAPI, Response, status\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n# write the Create endpoint\r\n@app.post(\"/\", status_code=200)\r\nasync def create_food(food: Food, response: Response):\r\n    foods[food.id] = food\r\n    response.status_code = status.HTTP_201_CREATED\r\n    return food",
            "date": "2022-10-08 21:15:14.701767+00:00",
            "passed": true
        },
        {
            "bite": "Bite 338. Create food objects",
            "code": "from typing import Dict\r\n\r\nfrom fastapi import FastAPI, Response, status\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n# write the Create endpoint\r\n@app.post(\"/\", status_code=200) # \r\nasync def create_food(food: Food, response: Response):\r\n    foods[food.id] = food\r\n    response.status_code = status.HTTP_201_CREATED\r\n    return foods",
            "date": "2022-10-08 21:13:14.557002+00:00",
            "passed": false
        },
        {
            "bite": "Bite 338. Create food objects",
            "code": "from typing import Dict\r\n\r\nfrom fastapi import FastAPI, Response, status\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n# write the Create endpoint\r\n@app.post(\"/\") # , status_code=201\r\nasync def create_food(food: Food, response: Response):\r\n    foods[food.id] = food\r\n    # response.status_code = status.HTTP_201_CREATED\r\n    return foods",
            "date": "2022-10-08 21:12:31.322829+00:00",
            "passed": false
        },
        {
            "bite": "Bite 338. Create food objects",
            "code": "from typing import Dict\r\n\r\nfrom fastapi import FastAPI, Response, status\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n# write the Create endpoint\r\n@app.post(\"/\") # , status_code=201\r\nasync def create_food(food: Food, response: Response):\r\n    foods[food.id] = food\r\n    response.status_code = status.HTTP_201_CREATED\r\n    return foods",
            "date": "2022-10-08 21:12:18.374177+00:00",
            "passed": false
        },
        {
            "bite": "Bite 338. Create food objects",
            "code": "from typing import Dict\r\n\r\nfrom fastapi import FastAPI, Response, status\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Food(BaseModel):\r\n    \"\"\"Model from Bite 02\"\"\"\r\n\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: float = 0\r\n\r\napp = FastAPI()\r\nfoods: Dict[int, Food] = {}\r\n\r\n# write the Create endpoint\r\n@app.post(\"/\", status_code=201)\r\nasync def create_food(food: Food, response: Response):\r\n    foods[food.id] = food\r\n    response.status_code = status.HTTP_201_CREATED\r\n    return foods",
            "date": "2022-10-08 21:11:59.247133+00:00",
            "passed": false
        },
        {
            "bite": "Bite 100. Display the last part of a file (Unix tail)",
            "code": "from pathlib import Path\r\nfrom typing import List\r\n\r\n\r\ndef tail(filepath: Path, n: int) -> List[str]:\r\n    \"\"\"\r\n    Simulate Unix' \"tail -n\" command:\r\n    - Read in the file (\"filepath\").\r\n    - Parse it into a list of lines, stripping trailing newlines.\r\n    - Return the last \"n\" lines.\r\n    \"\"\"\r\n    with open(filepath) as f:\r\n        lines = f.read().splitlines()\r\n    return lines[-n:]",
            "date": "2022-10-08 10:35:15.257070+00:00",
            "passed": true
        },
        {
            "bite": "Bite 100. Display the last part of a file (Unix tail)",
            "code": "from pathlib import Path\r\nfrom typing import List\r\n\r\n\r\ndef tail(filepath: Path, n: int) -> List[str]:\r\n    \"\"\"\r\n    Simulate Unix' \"tail -n\" command:\r\n    - Read in the file (\"filepath\").\r\n    - Parse it into a list of lines, stripping trailing newlines.\r\n    - Return the last \"n\" lines.\r\n    \"\"\"\r\n    with open(filepath) as f:\r\n        lines=f.read().splitlines()\r\n        lastlines = lines[-n:]\r\n    return lastlines\r\n    ",
            "date": "2022-10-08 10:33:54.480678+00:00",
            "passed": true
        },
        {
            "bite": "Bite 100. Display the last part of a file (Unix tail)",
            "code": "from pathlib import Path\r\nfrom typing import List\r\n\r\n\r\ndef tail(filepath: Path, n: int) -> List[str]:\r\n    \"\"\"\r\n    Simulate Unix' \"tail -n\" command:\r\n    - Read in the file (\"filepath\").\r\n    - Parse it into a list of lines, stripping trailing newlines.\r\n    - Return the last \"n\" lines.\r\n    \"\"\"\r\n    with open(filepath) as f:\r\n        lines=f.read().splitlines()\r\n        lastlines = lines(-n:)\r\n    return lastlines\r\n    ",
            "date": "2022-10-08 10:32:19.918929+00:00",
            "passed": false
        },
        {
            "bite": "Bite 97. BeautifulSoup II - scrape US holidays",
            "code": "from collections import defaultdict\r\nimport os\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup\r\nfrom pprint import pprint\r\nfrom datetime import datetime\r\n\r\n# prep data\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\npage = \"us_holidays.html\"\r\nholidays_page = os.path.join(tmp, page)\r\nurlretrieve(f\"https://bites-data.s3.us-east-2.amazonaws.com/{page}\", holidays_page)\r\n\r\nwith open(holidays_page) as f:\r\n    content = f.read()\r\n\r\nholidays = defaultdict(list)\r\n\r\n\r\ndef get_us_bank_holidays(content=content):\r\n    \"\"\"Receive scraped html output, make a BS object, parse the bank\r\n       holiday table (css class = list-table), and return a dict of\r\n       keys -> months and values -> list of bank holidays\"\"\"\r\n    result = {}\r\n    soup = BeautifulSoup(content, \"html.parser\")\r\n    table = soup.find(\"table\", {\"class\": \"list-table\"})\r\n    table_body = table.find(\"tbody\")\r\n    for row in table_body.find_all(\"tr\"):\r\n        holiday_date = row.find(\"time\").get(\"datetime\")\r\n        holiday_month = datetime.strptime(holiday_date, \"%Y-%m-%d\").strftime(\"%m\")\r\n        holiday_name = row.find(\"a\").text.strip()\r\n        holidays[holiday_month].append(holiday_name)\r\n    return holidays\r\n\r\n",
            "date": "2022-10-07 18:26:44.875985+00:00",
            "passed": true
        },
        {
            "bite": "Bite 97. BeautifulSoup II - scrape US holidays",
            "code": "from collections import defaultdict\r\nimport os\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup\r\nfrom pprint import pprint\r\nfrom datetime import datetime\r\n\r\n# prep data\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\npage = \"us_holidays.html\"\r\nholidays_page = os.path.join(tmp, page)\r\nurlretrieve(f\"https://bites-data.s3.us-east-2.amazonaws.com/{page}\", holidays_page)\r\n\r\nwith open(holidays_page) as f:\r\n    content = f.read()\r\n\r\nholidays = defaultdict(list)\r\n\r\n\r\ndef get_us_bank_holidays(content=content):\r\n    \"\"\"Receive scraped html output, make a BS object, parse the bank\r\n       holiday table (css class = list-table), and return a dict of\r\n       keys -> months and values -> list of bank holidays\"\"\"\r\n    result = {}\r\n    soup = BeautifulSoup(content, \"html.parser\")\r\n    table = soup.find(\"table\", {\"class\": \"list-table\"})\r\n    table_body = table.find(\"tbody\")\r\n    for row in table_body.find_all(\"tr\"):\r\n        holiday_date = row.find(\"time\").get(\"datetime\")\r\n        holiday_month = datetime.strptime(holiday_date, \"%Y-%m-%d\").strftime(\"%m\")\r\n        holiday_name = row.find(\"a\").text.strip()\r\n        holidays[holiday_month].append(holiday_name)\r\n        # result.setdefault(holiday_month, []).append(holiday_name)\r\n    return holidays\r\n    # return defaultdict(None, result)\r\n\r\n\r\n# print(get_us_bank_holidays())",
            "date": "2022-10-07 18:26:17.678043+00:00",
            "passed": true
        },
        {
            "bite": "Bite 97. BeautifulSoup II - scrape US holidays",
            "code": "from collections import defaultdict\r\nimport os\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup\r\nfrom pprint import pprint\r\nfrom datetime import datetime\r\n\r\n# prep data\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\npage = \"us_holidays.html\"\r\nholidays_page = os.path.join(tmp, page)\r\nurlretrieve(f\"https://bites-data.s3.us-east-2.amazonaws.com/{page}\", holidays_page)\r\n\r\nwith open(holidays_page) as f:\r\n    content = f.read()\r\n\r\nholidays = defaultdict(list)\r\n\r\n\r\ndef get_us_bank_holidays(content=content):\r\n    \"\"\"Receive scraped html output, make a BS object, parse the bank\r\n       holiday table (css class = list-table), and return a dict of\r\n       keys -> months and values -> list of bank holidays\"\"\"\r\n    result = {}\r\n    soup = BeautifulSoup(content, \"html.parser\")\r\n    table = soup.find(\"table\", {\"class\": \"list-table\"})\r\n    table_body = table.find(\"tbody\")\r\n    for row in table_body.find_all(\"tr\"):\r\n        holiday_date = row.find(\"time\").get(\"datetime\")\r\n        holiday_month = datetime.strptime(holiday_date, \"%Y-%m-%d\").strftime(\"%m\")\r\n        holiday_name = row.find(\"a\").text.strip()\r\n        holidays[holiday_month].append(holiday_name)\r\n        # result.setdefault(holiday_month, []).append(holiday_name)\r\n    return holidays\r\n    # return defaultdict(None, result)\r\n\r\n\r\nprint(get_us_bank_holidays())",
            "date": "2022-10-07 18:24:22.354032+00:00",
            "passed": false
        },
        {
            "bite": "Bite 97. BeautifulSoup II - scrape US holidays",
            "code": "from collections import defaultdict\r\nimport os\r\nfrom urllib.request import urlretrieve\r\n\r\nfrom bs4 import BeautifulSoup\r\nfrom pprint import pprint\r\nfrom datetime import datetime\r\n\r\n# prep data\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\npage = \"us_holidays.html\"\r\nholidays_page = os.path.join(tmp, page)\r\nurlretrieve(f\"https://bites-data.s3.us-east-2.amazonaws.com/{page}\", holidays_page)\r\n\r\nwith open(holidays_page) as f:\r\n    content = f.read()\r\n\r\nholidays = defaultdict(list)\r\n\r\n\r\ndef get_us_bank_holidays(content=content):\r\n    \"\"\"Receive scraped html output, make a BS object, parse the bank\r\n       holiday table (css class = list-table), and return a dict of\r\n       keys -> months and values -> list of bank holidays\"\"\"\r\n    result = {}\r\n    soup = BeautifulSoup(content, \"html.parser\")\r\n    table = soup.find(\"table\", {\"class\": \"list-table\"})\r\n    table_body = table.find(\"tbody\")\r\n    for row in table_body.find_all(\"tr\"):\r\n        holiday_date = row.find(\"time\").get(\"datetime\")\r\n        holiday_month = datetime.strptime(holiday_date, \"%Y-%m-%d\").strftime(\"%m\")\r\n        holiday_name = row.find(\"a\").text.strip()\r\n        result.setdefault(holiday_month, []).append(holiday_name)\r\n        # print(f\"{holiday_month}: {holiday_name}\")\r\n    return defaultdict(None, result)\r\n\r\n\r\nprint(get_us_bank_holidays())",
            "date": "2022-10-07 18:23:05.372749+00:00",
            "passed": true
        },
        {
            "bite": "Bite 246. Test print / standard output",
            "code": "import pytest\r\n\r\nfrom workouts import print_workout_days\r\n\r\n@pytest.mark.parametrize(\"test_input, expected\", [\r\n        (\"#1\", 'Mon, Tue\\n'), \r\n        (\"body\", 'Mon, Tue, Thu, Fri\\n'), \r\n        (\"cardio\", 'Wed\\n'),\r\n        (\"other\", 'No matching workout\\n')\r\n    ])\r\ndef test_print_workout_days(test_input, expected, capsys):\r\n    print_workout_days(test_input)\r\n    captured = capsys.readouterr()\r\n    assert captured.out == expected\r\n",
            "date": "2022-10-07 17:09:38.591209+00:00",
            "passed": true
        },
        {
            "bite": "Bite 246. Test print / standard output",
            "code": "import pytest\r\n\r\nfrom workouts import print_workout_days\r\n\r\n@pytest.mark.parametrize(\"test_input, expected\", [\r\n        (\"#1\", 'Mon, Tue\\n'), \r\n        (\"body\", 'Mon, Tue, Thu, Fri\\n\\n'), \r\n        (\"cardio\", 'Wed\\n'),\r\n        (\"other\", 'No matching workout\\n')\r\n    ])\r\ndef test_print_workout_days(test_input, expected, capsys):\r\n    print_workout_days(test_input)\r\n    captured = capsys.readouterr()\r\n    assert captured.out == expected\r\n",
            "date": "2022-10-07 17:09:03.227234+00:00",
            "passed": false
        },
        {
            "bite": "Bite 246. Test print / standard output",
            "code": "import pytest\r\n\r\nfrom workouts import print_workout_days\r\n\r\n@pytest.mark.parametrize(\"test_input, expected\", [\r\n        (\"#1\", 'Mon, Tue'), \r\n        (\"body\", 'Mon, Tue, Thu, Fri'), \r\n        (\"cardio\", 'Wed'),\r\n        (\"other\", 'No matching workout')\r\n    ])\r\ndef test_print_workout_days(test_input, expected, capsys):\r\n    print_workout_days(test_input)\r\n    captured = capsys.readouterr()\r\n    assert captured.out == expected\r\n",
            "date": "2022-10-07 17:07:58.399293+00:00",
            "passed": false
        },
        {
            "bite": "Bite 246. Test print / standard output",
            "code": "import pytest\r\n\r\nfrom workouts import print_workout_days\r\n\r\nWORKOUTS = {'mon': 'upper body #1',\r\n            'tue': 'lower body #1',\r\n            'wed': '30 min cardio',\r\n            'thu': 'upper body #2',\r\n            'fri': 'lower body #2'}\r\n\r\n@pytest.mark.parametrize(\"test_input, expected\", [\r\n    (\"#1\", 'Mon, Tue'), \r\n    (\"body\", 'Mon, Tue, Thu, Fri'), \r\n    (\"cardio\", 'Wed'),\r\n    (\"other\", 'No matching workout')\r\n    ])\r\ndef test_print_workout_days(test_input, expected, capsys):\r\n    print_workout_days(test_input)\r\n    captured = capsys.readouterr()\r\n    assert captured.out == expected\r\n",
            "date": "2022-10-07 17:06:59.548223+00:00",
            "passed": false
        },
        {
            "bite": "Bite 246. Test print / standard output",
            "code": "import pytest\r\n\r\nfrom workouts import print_workout_days\r\n\r\nWORKOUTS = {'mon': 'upper body #1',\r\n            'tue': 'lower body #1',\r\n            'wed': '30 min cardio',\r\n            'thu': 'upper body #2',\r\n            'fri': 'lower body #2'}\r\n\r\n@pytest.mark.parametrize(\"test_input, expected\", [\r\n    (\"#1\", 'Mon, Tue'), \r\n    (\"body\", 'Mon, Tue, Thu, Fri'), \r\n    (\"cardio\", 'Wed')\r\n    (\"other\", 'No matching workout')\r\n    ])\r\ndef test_print_workout_days(test_input, expected, capsys):\r\n    print_workout_days(test_input)\r\n    captured = capsys.readouterr()\r\n    assert captured.out == expected\r\n",
            "date": "2022-10-07 17:06:38.055322+00:00",
            "passed": false
        },
        {
            "bite": "Bite 71. Keep state in a class + make its instance callable",
            "code": "class RecordScore():\r\n    \"\"\"Class to track a game's maximum score\"\"\"\r\n\r\n\r\n    def __init__(self):\r\n        self.top_score = None\r\n\r\n    \r\n    def __call__(self, new_score):\r\n        if not self.top_score or new_score > self.top_score:\r\n            self.top_score = new_score\r\n        return self.top_score\r\n\r\n\r\nrecord = RecordScore()\r\nprint(record(-5))\r\nprint(record(-9))\r\nprint(record(-2))\r\n",
            "date": "2022-10-07 16:42:22.049493+00:00",
            "passed": true
        },
        {
            "bite": "Bite 71. Keep state in a class + make its instance callable",
            "code": "class RecordScore():\r\n    \"\"\"Class to track a game's maximum score\"\"\"\r\n    top_score = None\r\n    \r\n    def __call__(self, new_score):\r\n        if not self.top_score or new_score > self.top_score:\r\n            self.top_score = new_score\r\n\r\n\r\nrecord = RecordScore()\r\nprint(record(10))\r\nprint(record(9))\r\nprint(record(11))\r\n",
            "date": "2022-10-07 16:37:24.152294+00:00",
            "passed": false
        },
        {
            "bite": "Bite 283. Like there's no tomorrow?",
            "code": "from datetime import date, timedelta\r\ndef tomorrow(today=None):\r\n    # Your code goes here\r\n    if not today:\r\n        today = date.today()\r\n        \r\n    return today + timedelta(days=1)\r\n    \r\n\r\nprint(tomorrow(date(year = 1975, month=4, day=8)))",
            "date": "2022-10-07 16:28:06.773940+00:00",
            "passed": true
        },
        {
            "bite": "Bite 96. Build Unix' wc program in Python",
            "code": "def wc(file_):\r\n    \"\"\"Takes an absolute file path/name, calculates the number of\r\n       lines/words/chars, and returns a string of these numbers + file, e.g.:\r\n       3 12 60 /tmp/somefile\r\n       (both tabs and spaces are allowed as separator)\"\"\"\r\n\r\n    line_count = 0\r\n    word_count = 0\r\n    char_count = 0\r\n\r\n    with open(file_) as f:\r\n        for line in f.readlines():\r\n            line_count += 1\r\n            char_count += len(line)\r\n            word_count += len(line.split())\r\n\r\n    return f\"   {line_count}    {word_count}    {char_count}    {file_}\"\r\n\r\n\r\nif __name__ == '__main__':\r\n    # make it work from cli like original unix wc\r\n    import sys\r\n    print(wc(sys.argv[1]))",
            "date": "2022-10-07 16:15:30.470847+00:00",
            "passed": true
        },
        {
            "bite": "Bite 96. Build Unix' wc program in Python",
            "code": "def wc(file_):\r\n    \"\"\"Takes an absolute file path/name, calculates the number of\r\n       lines/words/chars, and returns a string of these numbers + file, e.g.:\r\n       3 12 60 /tmp/somefile\r\n       (both tabs and spaces are allowed as separator)\"\"\"\r\n\r\n    line_count = 0\r\n    word_count = 0\r\n    char_count = 0\r\n\r\n    with open(file_) as f:\r\n        for line in f.splitlines():\r\n            line_count +=1 \r\n            char_count += len(line)\r\n            word_count += len(line.split())            \r\n\r\n    return f\"   {line_count}    {word_count}    {char_count}    {_file}\"\r\n\r\nif __name__ == '__main__':\r\n    # make it work from cli like original unix wc\r\n    import sys\r\n    # print(wc(sys.argv[1]))\r\n    print(wc())",
            "date": "2022-10-07 16:09:35.395934+00:00",
            "passed": false
        },
        {
            "bite": "Bite 128. Work with datetime's strptime and strftime",
            "code": "from datetime import datetime\r\n\r\nTHIS_YEAR = 2018\r\n\r\n\r\ndef years_ago(date):\r\n    \"\"\"Receives a date string of 'DD MMM, YYYY', for example: 8 Aug, 2015\r\n       Convert this date str to a datetime object (use strptime).\r\n       Then extract the year from the obtained datetime object and subtract\r\n       it from the THIS_YEAR constant above, returning the int difference.\r\n       So in this example you would get: 2018 - 2015 = 3\"\"\"\r\n    date = datetime.strptime(date, \"%d %b, %Y\")\r\n    return THIS_YEAR - date.year \r\ndef convert_eu_to_us_date(date):\r\n    \"\"\"Receives a date string in European format of dd/mm/yyyy, e.g. 11/03/2002\r\n       Convert it to an American date: mm/dd/yyyy (in this case 03/11/2002).\r\n       To enforce the use of datetime's strptime / strftime (over slicing)\r\n       the tests check if a ValueError is raised for invalid day/month/year\r\n       ranges (no need to code this, datetime does this out of the box)\"\"\"\r\n    date_obj = datetime.strptime(date, \"%d/%m/%Y\")\r\n    return date_obj.strftime(\"%m/%d/%Y\")\r\nprint(years_ago(\"1 Aug, 2012\"))",
            "date": "2022-10-06 21:53:26.179711+00:00",
            "passed": true
        },
        {
            "bite": "Bite 128. Work with datetime's strptime and strftime",
            "code": "from datetime import datetime\r\n\r\nTHIS_YEAR = 2018\r\n\r\n\r\ndef years_ago(date):\r\n    \"\"\"Receives a date string of 'DD MMM, YYYY', for example: 8 Aug, 2015\r\n       Convert this date str to a datetime object (use strptime).\r\n       Then extract the year from the obtained datetime object and subtract\r\n       it from the THIS_YEAR constant above, returning the int difference.\r\n       So in this example you would get: 2018 - 2015 = 3\"\"\"\r\n    date = datetime.strptime(date, \"%d %b, %Y\")\r\n    return THIS_YEAR - date.year \r\ndef convert_eu_to_us_date(date):\r\n    \"\"\"Receives a date string in European format of dd/mm/yyyy, e.g. 11/03/2002\r\n       Convert it to an American date: mm/dd/yyyy (in this case 03/11/2002).\r\n       To enforce the use of datetime's strptime / strftime (over slicing)\r\n       the tests check if a ValueError is raised for invalid day/month/year\r\n       ranges (no need to code this, datetime does this out of the box)\"\"\"\r\n    pass\r\n\r\nprint(years_ago(\"1 Aug, 2012\"))",
            "date": "2022-10-06 21:50:10.906391+00:00",
            "passed": false
        },
        {
            "bite": "Bite 128. Work with datetime's strptime and strftime",
            "code": "from datetime import datetime\r\n\r\nTHIS_YEAR = 2018\r\n\r\n\r\ndef years_ago(date):\r\n    \"\"\"Receives a date string of 'DD MMM, YYYY', for example: 8 Aug, 2015\r\n       Convert this date str to a datetime object (use strptime).\r\n       Then extract the year from the obtained datetime object and subtract\r\n       it from the THIS_YEAR constant above, returning the int difference.\r\n       So in this example you would get: 2018 - 2015 = 3\"\"\"\r\n    date = datetime.strptime(date, \"%d %b, %Y\")\r\n    return date.year - THIS_YEAR\r\n\r\ndef convert_eu_to_us_date(date):\r\n    \"\"\"Receives a date string in European format of dd/mm/yyyy, e.g. 11/03/2002\r\n       Convert it to an American date: mm/dd/yyyy (in this case 03/11/2002).\r\n       To enforce the use of datetime's strptime / strftime (over slicing)\r\n       the tests check if a ValueError is raised for invalid day/month/year\r\n       ranges (no need to code this, datetime does this out of the box)\"\"\"\r\n    pass\r\n\r\nprint(years_ago(\"1 Aug, 2012\"))",
            "date": "2022-10-06 21:49:32.623959+00:00",
            "passed": false
        },
        {
            "bite": "Bite 128. Work with datetime's strptime and strftime",
            "code": "from datetime import datetime\r\n\r\nTHIS_YEAR = 2018\r\n\r\n\r\ndef years_ago(date):\r\n    \"\"\"Receives a date string of 'DD MMM, YYYY', for example: 8 Aug, 2015\r\n       Convert this date str to a datetime object (use strptime).\r\n       Then extract the year from the obtained datetime object and subtract\r\n       it from the THIS_YEAR constant above, returning the int difference.\r\n       So in this example you would get: 2018 - 2015 = 3\"\"\"\r\n    date = datetime.strptime(%d %b, %Y)\r\n    return date.year - THIS_YEAR\r\n\r\ndef convert_eu_to_us_date(date):\r\n    \"\"\"Receives a date string in European format of dd/mm/yyyy, e.g. 11/03/2002\r\n       Convert it to an American date: mm/dd/yyyy (in this case 03/11/2002).\r\n       To enforce the use of datetime's strptime / strftime (over slicing)\r\n       the tests check if a ValueError is raised for invalid day/month/year\r\n       ranges (no need to code this, datetime does this out of the box)\"\"\"\r\n    pass",
            "date": "2022-10-06 21:44:17.173838+00:00",
            "passed": false
        },
        {
            "bite": "Bite 69. Regex Fun - part II",
            "code": "import re\r\n\r\n\r\ndef has_timestamp(text):\r\n    \"\"\"Return True if text has a timestamp of this format:\r\n       2014-07-03T23:30:37\"\"\"\r\n    return bool(\r\n        re.match(r'.+[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.+', text)\r\n    )\r\n\r\n# 2014-07-03T23:27:51\r\n\r\n\r\ndef is_integer(number):\r\n    \"\"\"Return True if number is an integer\"\"\"\r\n    return bool(\r\n        re.match(r'^-*[0-9]+$', str(number))\r\n    )\r\n\r\n\r\ndef has_word_with_dashes(text):\r\n    \"\"\"Returns True if text has one or more words with dashes\"\"\"\r\n    return bool(\r\n        re.match(r'.*[a-z0-9]+?-[a-z0-9]+?.*', text.lower())\r\n    )\r\n\r\n\r\ndef remove_all_parenthesis_words(text):\r\n    \"\"\"Return text but without any words or phrases in parenthesis:\r\n       'Good morning (afternoon)' -> 'Good morning' (so don't forget\r\n       leading spaces)\"\"\"\r\n    return re.sub(r\"\\s\\(.+?\\)\", \"\", text)\r\n\r\n\r\ndef split_string_on_punctuation(text):\r\n    \"\"\"Split on ?!.,; - e.g. \"hi, how are you doing? blabla\" ->\r\n       ['hi', 'how are you doing', 'blabla']\r\n       (make sure you strip trailing spaces)\"\"\"\r\n    return re.findall(r\"\\s*([^?!.,;]+)\\s*\", text)\r\n\r\n\r\ndef remove_duplicate_spacing(text):\r\n    \"\"\"Replace multiple spaces by one space\"\"\"\r\n    return re.sub(r\"[ ]+\", \" \", text)\r\n\r\n\r\ndef has_three_consecutive_vowels(word):\r\n    \"\"\"Returns True if word has at least 3 consecutive vowels\"\"\"\r\n    return bool(\r\n        re.match('.+([aeiou]){3}.+', word.lower())\r\n    )\r\n\r\n\r\ndef convert_emea_date_to_amer_date(date):\r\n    \"\"\"Convert dd/mm/yyyy (EMEA date format) to mm/dd/yyyy\r\n       (AMER date format)\"\"\"\r\n    date_lst = re.findall(r\"^(\\d{2})/(\\d{2})/(\\d{4})$\", date)\r\n    if date_lst:\r\n        return f\"{date_lst[0][1]}/{date_lst[0][0]}/{date_lst[0][2]}\"\r\n    return date\r\n\r\n\r\nprint(has_timestamp('INFO 2014-07-03T23:27:51 Shutdown initiated.'))\r\nprint(is_integer(-29))\r\nprint(has_word_with_dashes(\"hola caracola speak-up hola\"))\r\n\r\nprint(remove_all_parenthesis_words('Good morning (afternoon)'))\r\nprint(split_string_on_punctuation(\"hi, how are you doing? blabla   \"))\r\nprint(remove_duplicate_spacing(\"  hello    how are   you   \"))\r\n\r\nprint(has_three_consecutive_vowels(\"sioux\"))\r\nprint(convert_emea_date_to_amer_date(\"31/12/2022\"))\r\n",
            "date": "2022-10-06 21:39:18.435534+00:00",
            "passed": true
        },
        {
            "bite": "Bite 36. Having fun with *args and **kwargs",
            "code": "def get_profile(name: str, age: int, *sports, **awards):\r\n    if not isinstance(age, int):\r\n        raise ValueError\r\n    if len(sports) > 5:\r\n        raise ValueError\r\n    result = {'name': name,\r\n              'age': age\r\n              }\r\n    if sports:\r\n        result['sports'] = sorted(list(sports))\r\n    if awards:\r\n        result['awards'] = awards\r\n    return result\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    print(get_profile('manolo', 47, 'ski', 'scuba diving', 'triathlon', participant='half ironman'))\r\n    ",
            "date": "2022-10-06 21:38:16.110707+00:00",
            "passed": true
        },
        {
            "bite": "Bite 69. Regex Fun - part II",
            "code": "import re\r\n\r\ndef has_timestamp(text):\r\n    \"\"\"Return True if text has a timestamp of this format:\r\n       2014-07-03T23:30:37\"\"\"\r\n    return bool(\r\n        re.match('.+[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.+', text)\r\n    )\r\n\r\n# 2014-07-03T23:27:51 \r\n\r\ndef is_integer(number):\r\n    \"\"\"Return True if number is an integer\"\"\"\r\n    return bool(\r\n        re.match('^-*[0-9]+$', str(number))\r\n    )\r\n\r\n\r\ndef has_word_with_dashes(text):\r\n    \"\"\"Returns True if text has one or more words with dashes\"\"\"\r\n    return bool(\r\n        re.match('([a-zA-Z]+?-[a-zA-Z]+?)', text)\r\n    )\r\n\r\n\r\ndef remove_all_parenthesis_words(text):\r\n    \"\"\"Return text but without any words or phrases in parenthesis:\r\n       'Good morning (afternoon)' -> 'Good morning' (so don't forget\r\n       leading spaces)\"\"\"\r\n    return re.sub(\"\\s\\(.\\)\", \"\", text)\r\n\r\n\r\ndef split_string_on_punctuation(text):\r\n    \"\"\"Split on ?!.,; - e.g. \"hi, how are you doing? blabla\" ->\r\n       ['hi', 'how are you doing', 'blabla']\r\n       (make sure you strip trailing spaces)\"\"\"\r\n    re.findall(\"^[?!.,;] \\s\",text)\r\n\r\n\r\ndef remove_duplicate_spacing(text):\r\n    \"\"\"Replace multiple spaces by one space\"\"\"\r\n    return re.sub(\"[ ]+?\", \" \", text)\r\n\r\ndef has_three_consecutive_vowels(word):\r\n    \"\"\"Returns True if word has at least 3 consecutive vowels\"\"\"\r\n    return bool(\r\n        re.match('([aeiou]){3}', word.lower())\r\n    )\r\n\r\n\r\ndef convert_emea_date_to_amer_date(date):\r\n    \"\"\"Convert dd/mm/yyyy (EMEA date format) to mm/dd/yyyy\r\n       (AMER date format)\"\"\"\r\n    date_lst = re.findall(\"^(\\d{2})/(\\d{2})/(\\d{4})$\", date)\r\n    return f\"{date_lst[0][1]}/{date_lst[0][0]}/{date_lst[0][2]}\"\r\n\r\n\r\nprint(has_timestamp('INFO 2014-07-03T23:27:51 Shutdown initiated.'))\r\nprint(is_integer(\"-29\"))\r\nprint(has_word_with_dashes(\"hola caracola speak-up\"))\r\n\r\nprint(remove_all_parenthesis_words('Good morning (afternoon)'))\r\nprint(split_string_on_punctuation(\"hi, how are you doing? blabla   \"))\r\nprint(remove_duplicate_spacing(\"  hello    how are   you   \"))\r\n\r\nprint(has_three_consecutive_vowels(\"sioux\"))\r\nprint(convert_emea_date_to_amer_date(\"31/12/2022\"))\r\n",
            "date": "2022-10-06 17:45:39.171973+00:00",
            "passed": false
        },
        {
            "bite": "Bite 69. Regex Fun - part II",
            "code": "import re\r\n\r\ndef has_timestamp(text):\r\n    \"\"\"Return True if text has a timestamp of this format:\r\n       2014-07-03T23:30:37\"\"\"\r\n    return bool(\r\n        re.match('.+[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.+', text)\r\n    )\r\n\r\n# 2014-07-03T23:27:51 \r\n\r\ndef is_integer(number):\r\n    \"\"\"Return True if number is an integer\"\"\"\r\n    return bool(\r\n        re.match('^-*[0-9]+$', number)\r\n    )\r\n\r\n\r\ndef has_word_with_dashes(text):\r\n    \"\"\"Returns True if text has one or more words with dashes\"\"\"\r\n    return bool(\r\n        re.match('([a-zA-Z]+?-[a-zA-Z]+?)', text)\r\n    )\r\n\r\n\r\ndef remove_all_parenthesis_words(text):\r\n    \"\"\"Return text but without any words or phrases in parenthesis:\r\n       'Good morning (afternoon)' -> 'Good morning' (so don't forget\r\n       leading spaces)\"\"\"\r\n    return re.sub(\"\\s\\(.\\)\", \"\", text)\r\n\r\n\r\ndef split_string_on_punctuation(text):\r\n    \"\"\"Split on ?!.,; - e.g. \"hi, how are you doing? blabla\" ->\r\n       ['hi', 'how are you doing', 'blabla']\r\n       (make sure you strip trailing spaces)\"\"\"\r\n    re.findall(\"^[?!.,;] \\s\",text)\r\n\r\n\r\ndef remove_duplicate_spacing(text):\r\n    \"\"\"Replace multiple spaces by one space\"\"\"\r\n    return re.sub(\"[ ]+?\", \" \", text)\r\n\r\ndef has_three_consecutive_vowels(word):\r\n    \"\"\"Returns True if word has at least 3 consecutive vowels\"\"\"\r\n    return bool(\r\n        re.match('([aeiou]){3}', word.lower())\r\n    )\r\n\r\n\r\ndef convert_emea_date_to_amer_date(date):\r\n    \"\"\"Convert dd/mm/yyyy (EMEA date format) to mm/dd/yyyy\r\n       (AMER date format)\"\"\"\r\n    date_lst = re.findall(\"^(\\d{2})/(\\d{2})/(\\d{4})$\", date)\r\n    return f\"{date_lst[0][1]}/{date_lst[0][0]}/{date_lst[0][2]}\"\r\n\r\n\r\nprint(has_timestamp('INFO 2014-07-03T23:27:51 Shutdown initiated.'))\r\nprint(is_integer(\"-29\"))\r\nprint(has_word_with_dashes(\"hola caracola speak-up\"))\r\n\r\nprint(remove_all_parenthesis_words('Good morning (afternoon)'))\r\nprint(split_string_on_punctuation(\"hi, how are you doing? blabla   \"))\r\nprint(remove_duplicate_spacing(\"  hello    how are   you   \"))\r\n\r\nprint(has_three_consecutive_vowels(\"sioux\"))\r\nprint(convert_emea_date_to_amer_date(\"31/12/2022\"))\r\n",
            "date": "2022-10-06 17:43:50.125009+00:00",
            "passed": false
        },
        {
            "bite": "Bite 69. Regex Fun - part II",
            "code": "import re\r\n\r\ndef has_timestamp(text):\r\n    \"\"\"Return True if text has a timestamp of this format:\r\n       2014-07-03T23:30:37\"\"\"\r\n    return bool(\r\n        re.match('^[0-9]{4}(-[0-9]{2}){2}T[0-9]{2}(:[0-9]{2}){2}$', text)\r\n    )\r\n\r\n\r\ndef is_integer(number):\r\n    \"\"\"Return True if number is an integer\"\"\"\r\n    return bool(\r\n        re.match('^[0-9]+$', number)\r\n    )\r\n\r\n\r\ndef has_word_with_dashes(text):\r\n    \"\"\"Returns True if text has one or more words with dashes\"\"\"\r\n    return bool(\r\n        re.match('([a-zA-Z]+?-[a-zA-Z]+?)', text)\r\n    )\r\n\r\n\r\ndef remove_all_parenthesis_words(text):\r\n    \"\"\"Return text but without any words or phrases in parenthesis:\r\n       'Good morning (afternoon)' -> 'Good morning' (so don't forget\r\n       leading spaces)\"\"\"\r\n    return re.sub(\"\\s\\(.\\)\", \"\", text)\r\n\r\n\r\ndef split_string_on_punctuation(text):\r\n    \"\"\"Split on ?!.,; - e.g. \"hi, how are you doing? blabla\" ->\r\n       ['hi', 'how are you doing', 'blabla']\r\n       (make sure you strip trailing spaces)\"\"\"\r\n    re.findall(\"^[?!.,;] \\s\",text)\r\n\r\n\r\ndef remove_duplicate_spacing(text):\r\n    \"\"\"Replace multiple spaces by one space\"\"\"\r\n    return re.sub(\"[ ]+?\", \" \", text)\r\n\r\ndef has_three_consecutive_vowels(word):\r\n    \"\"\"Returns True if word has at least 3 consecutive vowels\"\"\"\r\n    return bool(\r\n        re.match('([aeiou]){3}', word.lower())\r\n    )\r\n\r\n\r\ndef convert_emea_date_to_amer_date(date):\r\n    \"\"\"Convert dd/mm/yyyy (EMEA date format) to mm/dd/yyyy\r\n       (AMER date format)\"\"\"\r\n    date_lst = re.findall(\"^(\\d{2})/(\\d{2})/(\\d{4})$\", date)\r\n    return f\"{date_lst[0][1]}/{date_lst[0][0]}/{date_lst[0][2]}\"\r\n\r\n\r\nprint(has_timestamp(\"2014-07-03T23:30:37\"))\r\nprint(is_integer(\"29\"))\r\nprint(has_word_with_dashes(\"hola caracola speak-up\"))\r\n\r\nprint(remove_all_parenthesis_words('Good morning (afternoon)'))\r\nprint(split_string_on_punctuation(\"hi, how are you doing? blabla   \"))\r\nprint(remove_duplicate_spacing(\"  hello    how are   you   \"))\r\n\r\nprint(has_three_consecutive_vowels(\"sioux\"))\r\nprint(convert_emea_date_to_amer_date(\"31/12/2022\"))\r\n",
            "date": "2022-10-06 17:33:12.798231+00:00",
            "passed": false
        },
        {
            "bite": "Bite 215. Validate a license key",
            "code": "import re\r\n\r\n\r\ndef validate_license(key: str) -> bool:\r\n    \"\"\"Write a regex that matches a PyBites license key\r\n       (e.g. PB-U8N435EH-PG65PW87-IXPWQG5T-898XSZI4)\r\n    \"\"\"\r\n    is_valid = re.match('^PB(-([A-Z0-9]){8}){4}$',key)\r\n    return bool(is_valid)\r\n    \r\n# print(validate_license('pb-uhszep2x-ra1jiwmc-j0t3bszn-9qhw6g1n'))",
            "date": "2022-10-06 17:04:14.697234+00:00",
            "passed": true
        },
        {
            "bite": "Bite 215. Validate a license key",
            "code": "import re\r\n\r\n\r\ndef validate_license(key: str) -> bool:\r\n    \"\"\"Write a regex that matches a PyBites license key\r\n       (e.g. PB-U8N435EH-PG65PW87-IXPWQG5T-898XSZI4)\r\n    \"\"\"\r\n    is_valid = re.match('^PB(-([A-Z0-9]){8}){4}$',key.upper())\r\n    return bool(is_valid)\r\n    \r\n# print(validate_license('pb-uhszep2x-ra1jiwmc-j0t3bszn-9qhw6g1n'))",
            "date": "2022-10-06 17:03:00.554118+00:00",
            "passed": false
        },
        {
            "bite": "Bite 215. Validate a license key",
            "code": "import re\r\n\r\n\r\ndef validate_license(key: str) -> bool:\r\n    \"\"\"Write a regex that matches a PyBites license key\r\n       (e.g. PB-U8N435EH-PG65PW87-IXPWQG5T-898XSZI4)\r\n    \"\"\"\r\n    is_valid = re.match('^PB(-([A-Z0-9]){8}){4}$',key.upper())\r\n    return bool(is_valid)\r\n    \r\nprint(validate_license('Pb-U82N45EH-PG65P 87-IXPWQG5T-898XSZI4'))",
            "date": "2022-10-06 17:01:38.437367+00:00",
            "passed": false
        },
        {
            "bite": "Bite 182. Parse a bunch of quotes from HTML",
            "code": "import re\r\nfrom pprint import pprint\r\n\r\n# source: https://www.virgin.com/richard-branson/my-top-10-quotes-living-life-better\r\nHTML = \"\"\"<!DOCTYPE html>\r\n<head>\r\n  <meta charset=\"utf-8\" />\r\n  <title>My top 10 quotes on living life better | Virgin</title>\r\n</head>\r\n<body>\r\n  <div class=\"content\">\r\n    <p>I\u2019m striving this year to maintain my fitness and to always be learning new things. The new theme on Virgin.com is Live Life Better \u2013 a series shining a spotlight on how we can all lead happier, healthier and more fulfilled lives. Virgin has always wanted to make things better for our team and customers and to improve their experiences.</p>\r\n    <p>Here are my top 10 quotes on living life better for some New Year inspiration:</p>\r\n    <p>10. \"The beautiful thing about learning is nobody can take it away from you.\" - B.B King</p>\r\n    <p>9. \"Inexperience is an asset. Embrace it.\" - Wendy Kopp</p>\r\n    <p>8. \"Change will not come if we wait for some other person, or if we wait for some other time. We are the ones we\u2019ve been waiting for. We are the change that we seek.\" - Barack Obama</p>\r\n    <p>7. \"The sky is not my limit\u2026 I am.\" - T.F. Hodge</p>\r\n    <p>6. \"Life is either a daring adventure or nothing at all.\" - Helen Keller</p>\r\n    <p>5. \"It does not matter how slowly you go as long as you do not stop.\" - Confucius</p>\r\n    <p>4. \"Too many of us are not living our dreams because we are living our fears.\" - Les Brown</p>\r\n    <p>3. \"Continuous efforts \u2013 not strength or intelligence \u2013 is the key to unlocking our potential.\" - Winston Churchill</p>\r\n    <p>2. \"Believe you can and you\u2019re halfway there.\" - Theodore Roosevelt</p>\r\n    <p>1. \"Success means doing the best we can with what we have. Success is the doing, not the getting; in the trying, not the triumph. Success is a personal standard, reaching for the highest that is in us, becoming all that we can be.\" - Zig Ziglar</p>\r\n    <p>How do you try and live a healthier, happier life?</p>\r\n  </div>\r\n</body>\r\n</html>\"\"\"\r\n\r\n\r\ndef extract_quotes(html: str = HTML) -> dict:\r\n    \"\"\"See instructions in the Bite description\"\"\"\r\n    lst = [re.findall('<p>[0-9]+\\. \"(.+)\" - (.+)</p>', line) for line in html.splitlines()]\r\n    result = {item[0][1]:item[0][0] for item in lst if item}\r\n    return result\r\n\r\ntest_str = '\\n    <p>7. \"quote\" - A. U. Thor</p>\\n'\r\n\r\npprint(extract_quotes())\r\n\r\n",
            "date": "2022-10-06 16:46:56.980258+00:00",
            "passed": true
        },
        {
            "bite": "Bite 91. Matching multiple strings",
            "code": "import string\r\n\r\nVOWELS = 'aeiou'\r\nPYTHON = 'python'\r\n\r\ndef contains_only_vowels(input_str):\r\n    \"\"\"Receives input string and checks if all chars are\r\n       VOWELS. Match is case insensitive.\"\"\"\r\n    return all(letter.lower() in VOWELS for letter in input_str)\r\n\r\n\r\ndef contains_any_py_chars(input_str):\r\n    \"\"\"Receives input string and checks if any of the PYTHON\r\n       chars are in it. Match is case insensitive.\"\"\"\r\n    return any(letter.lower() in PYTHON for letter in input_str)\r\n\r\n\r\ndef contains_digits(input_str):\r\n    \"\"\"Receives input string and checks if it contains\r\n       one or more digits.\"\"\"\r\n    return any(letter in string.digits for letter in input_str)\r\n    \r\nif __name__== \"__main__\":\r\n    \r\n    print(contains_any_py_chars('pygjas'))\r\n    print(contains_any_py_chars('gella'))\r\n    \r\n    print(contains_only_vowels('aaeiouu'))\r\n    print(contains_only_vowels('aaerio'))\r\n    \r\n    print(contains_digits('12wer'))\r\n    print(contains_digits('fghwer'))",
            "date": "2022-10-05 21:50:38.520720+00:00",
            "passed": true
        },
        {
            "bite": "Bite 91. Matching multiple strings",
            "code": "import string\r\n\r\nVOWELS = 'aeiou'\r\nPYTHON = 'python'\r\n\r\ndef contains_only_vowels(input_str):\r\n    \"\"\"Receives input string and checks if all chars are\r\n       VOWELS. Match is case insensitive.\"\"\"\r\n    return all(letter.lower() in VOWELS for letter in input_str)\r\n\r\n\r\ndef contains_any_py_chars(input_str):\r\n    \"\"\"Receives input string and checks if any of the PYTHON\r\n       chars are in it. Match is case insensitive.\"\"\"\r\n    return any(letter.lower() in PYTHON for letter in input_str)\r\n\r\n\r\ndef contains_digits(input_str):\r\n    \"\"\"Receives input string and checks if it contains\r\n       one or more digits.\"\"\"\r\n    return any(letter in string.digits for letter in input_str)\r\n    \r\n    \r\nprint(contains_any_py_chars('pygjas'))\r\nprint(contains_any_py_chars('gella'))\r\n\r\nprint(contains_only_vowels('aaeiouu'))\r\nprint(contains_only_vowels('aaerio'))\r\n\r\nprint(contains_digits('12wer'))\r\nprint(contains_digits('fghwer'))",
            "date": "2022-10-05 21:49:53.379044+00:00",
            "passed": true
        },
        {
            "bite": "Bite 41. Write a login_required decorator",
            "code": "from functools import wraps\r\n\r\nknown_users = ['bob', 'julian', 'mike', 'carmen', 'sue']\r\nloggedin_users = ['mike', 'sue']\r\n\r\n\r\ndef login_required(func):\r\n    @wraps(func)\r\n    def wrapped(*args, **kwargs):\r\n        # do stuff before the original function gets called\r\n        user=args[0]\r\n        if user not in known_users:\r\n            return 'please create an account'\r\n        elif user not in loggedin_users:\r\n            return 'please login'\r\n        else:\r\n            # call function\r\n            return func(*args, **kwargs)\r\n        # do stuff after function call \r\n    # return wrapper as a decorated function\r\n    return wrapped\r\n\r\n\r\n@login_required\r\ndef welcome(user):\r\n    '''Return a welcome message if logged in'''\r\n    return f'welcome back {user}'\r\n    \r\nif __name__ == \"__main__\":\r\n    print(welcome('anonimous'))",
            "date": "2022-10-05 21:38:28.858249+00:00",
            "passed": true
        },
        {
            "bite": "Bite 41. Write a login_required decorator",
            "code": "from functools import wraps\r\n\r\nknown_users = ['bob', 'julian', 'mike', 'carmen', 'sue']\r\nloggedin_users = ['mike', 'sue']\r\n\r\n\r\ndef login_required(func):\r\n    @wraps(func)\r\n    def wrapped(*args, **kwargs):\r\n        # do stuff before the original function gets called\r\n        user=args[0]\r\n        if user not in known_users:\r\n            print('please create an account')\r\n        elif user not in loggedin_users:\r\n            print('please login')\r\n        else:\r\n            # call function\r\n            print(func(*args, **kwargs))\r\n        # do stuff after function call \r\n    # return wrapper as a decorated function\r\n    return wrapped\r\n\r\n\r\n@login_required\r\ndef welcome(user):\r\n    '''Return a welcome message if logged in'''\r\n    return f'welcome back {user}'\r\n    \r\nwelcome('mike')",
            "date": "2022-10-05 21:33:39.684341+00:00",
            "passed": false
        },
        {
            "bite": "Bite 30. Movie data analysis",
            "code": "import csv\r\nfrom collections import defaultdict, namedtuple\r\nimport os\r\nfrom urllib.request import urlretrieve\r\nfrom pprint import pprint\r\nfrom operator import itemgetter\r\n\r\n\r\nBASE_URL = 'https://bites-data.s3.us-east-2.amazonaws.com/'\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\n\r\nfname = 'movie_metadata.csv'\r\nremote = os.path.join(BASE_URL, fname)\r\nlocal = os.path.join(TMP, fname)\r\nurlretrieve(remote, local)\r\n\r\nMOVIE_DATA = local\r\nMIN_MOVIES = 4\r\nMIN_YEAR = 1960\r\n\r\nMovie = namedtuple('Movie', 'title year score')\r\n\r\n\r\ndef get_movies_by_director():\r\n    \"\"\"Extracts all movies from csv and stores them in a dict,\r\n    where keys are directors, and values are a list of movies,\r\n    use the defined Movie namedtuple\"\"\"\r\n    \r\n    with open(local, newline='') as f:\r\n        data = csv.DictReader(f)\r\n        result = {}\r\n        for row in data:\r\n            director = row['director_name']\r\n            year = row['title_year']\r\n            title = row['movie_title'].strip()\r\n            score = row['imdb_score']\r\n            result.setdefault(director,[])\r\n\r\n            if year and title and score:\r\n                year = int(year)\r\n                score = float(score)\r\n                if year >= MIN_YEAR:    \r\n                    result[director].append(\r\n                        Movie(title=title, year=year, score=score))\r\n                \r\n    return result\r\n        \r\n\r\ndef calc_mean_score(movies):\r\n    \"\"\"Helper method to calculate mean of list of Movie namedtuples,\r\n       round the mean to 1 decimal place\"\"\"\r\n    tmp = [movie.score for movie in movies]\r\n    return round(sum(tmp)/len(tmp),1)\r\n\r\ndef get_average_scores(directors):\r\n    \"\"\"Iterate through the directors dict (returned by get_movies_by_director),\r\n       return a list of tuples (director, average_score) ordered by highest\r\n       score in descending order. Only take directors into account\r\n       with >= MIN_MOVIES\"\"\"\r\n    result= [(name, calc_mean_score(movies)) for name, movies in directors.items() \\\r\n    if len(movies) >= MIN_MOVIES]\r\n    result.sort(key=lambda tup: tup[1], reverse=True)\r\n    return result\r\n\r\nif __name__ == \"__main__\":\r\n    \r\n    a= get_movies_by_director()\r\n    \r\n    pprint(a['Sergio Leone'])\r\n    print(calc_mean_score(a['Sergio Leone']))\r\n    \r\n    pprint(get_average_scores(a)[:8])",
            "date": "2022-10-05 21:11:16.475752+00:00",
            "passed": true
        },
        {
            "bite": "Bite 30. Movie data analysis",
            "code": "import csv\r\nfrom collections import defaultdict, namedtuple\r\nimport os\r\nfrom urllib.request import urlretrieve\r\nfrom pprint import pprint\r\nfrom operator import itemgetter\r\n\r\n\r\nBASE_URL = 'https://bites-data.s3.us-east-2.amazonaws.com/'\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\n\r\nfname = 'movie_metadata.csv'\r\nremote = os.path.join(BASE_URL, fname)\r\nlocal = os.path.join(TMP, fname)\r\nurlretrieve(remote, local)\r\n\r\nMOVIE_DATA = local\r\nMIN_MOVIES = 4\r\nMIN_YEAR = 1960\r\n\r\nMovie = namedtuple('Movie', 'title year score')\r\n\r\n\r\ndef get_movies_by_director():\r\n    \"\"\"Extracts all movies from csv and stores them in a dict,\r\n    where keys are directors, and values are a list of movies,\r\n    use the defined Movie namedtuple\"\"\"\r\n    \r\n    with open(local, newline='') as f:\r\n        data = csv.DictReader(f)\r\n        result = {}\r\n        for row in data:\r\n            year = row.get('title_year', None)\r\n            if year and int(year) >= MIN_YEAR:\r\n                director = row['director_name']\r\n                title = row['movie_title'].strip()\r\n                score = float(row['imdb_score'])\r\n                year = int(year)\r\n                result.setdefault(director,[]).append(\r\n                    Movie(title=title, year=year, score=score))\r\n    return result\r\n        \r\n\r\ndef calc_mean_score(movies):\r\n    \"\"\"Helper method to calculate mean of list of Movie namedtuples,\r\n       round the mean to 1 decimal place\"\"\"\r\n    tmp = [movie.score for movie in movies]\r\n    return round(sum(tmp)/len(tmp),1)\r\n\r\ndef get_average_scores(directors):\r\n    \"\"\"Iterate through the directors dict (returned by get_movies_by_director),\r\n       return a list of tuples (director, average_score) ordered by highest\r\n       score in descending order. Only take directors into account\r\n       with >= MIN_MOVIES\"\"\"\r\n    result= [(name, calc_mean_score(movies)) for name, movies in directors.items() \\\r\n    if len(movies) >= MIN_MOVIES]\r\n    result.sort(key=lambda tup: tup[1], reverse=True)\r\n    return result\r\n\r\nif __name__ == \"__main__\":\r\n    \r\n    a= get_movies_by_director()\r\n    \r\n    pprint(a['Sergio Leone'])\r\n    print(calc_mean_score(a['Sergio Leone']))\r\n    \r\n    pprint(get_average_scores(a)[:8])",
            "date": "2022-10-05 20:48:27.349076+00:00",
            "passed": false
        },
        {
            "bite": "Bite 30. Movie data analysis",
            "code": "import csv\r\nfrom collections import defaultdict, namedtuple\r\nimport os\r\nfrom urllib.request import urlretrieve\r\nfrom pprint import pprint\r\nfrom operator import itemgetter\r\n\r\n\r\nBASE_URL = 'https://bites-data.s3.us-east-2.amazonaws.com/'\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\n\r\nfname = 'movie_metadata.csv'\r\nremote = os.path.join(BASE_URL, fname)\r\nlocal = os.path.join(TMP, fname)\r\nurlretrieve(remote, local)\r\n\r\nMOVIE_DATA = local\r\nMIN_MOVIES = 4\r\nMIN_YEAR = 1960\r\n\r\nMovie = namedtuple('Movie', 'title year score')\r\n\r\n\r\ndef get_movies_by_director():\r\n    \"\"\"Extracts all movies from csv and stores them in a dict,\r\n    where keys are directors, and values are a list of movies,\r\n    use the defined Movie namedtuple\"\"\"\r\n    \r\n    with open(local, newline='') as f:\r\n        data = csv.DictReader(f)\r\n        result = {}\r\n        for row in data:\r\n            year = row.get('title_year', None)\r\n            if year and int(year) >= MIN_YEAR:\r\n                director = row['director_name']\r\n                title = row['movie_title'].strip()\r\n                score = float(row['imdb_score'])\r\n                year = int(year)\r\n                result.setdefault(director,[]).append(Movie(title=title, year=year, score=score))\r\n    return result\r\n        \r\n\r\ndef calc_mean_score(movies):\r\n    \"\"\"Helper method to calculate mean of list of Movie namedtuples,\r\n       round the mean to 1 decimal place\"\"\"\r\n    tmp = [movie.score for movie in movies]\r\n    return round(sum(tmp)/len(tmp),1)\r\n\r\ndef get_average_scores(directors):\r\n    \"\"\"Iterate through the directors dict (returned by get_movies_by_director),\r\n       return a list of tuples (director, average_score) ordered by highest\r\n       score in descending order. Only take directors into account\r\n       with >= MIN_MOVIES\"\"\"\r\n    result= [(name, calc_mean_score(movies)) for name, movies in directors.items() \\\r\n    if len(movies) > MIN_MOVIES]\r\n    result.sort(key=lambda tup: tup[1], reverse=True)\r\n    return result\r\n\r\nif __name__ == \"__main__\":\r\n    \r\n    a= get_movies_by_director()\r\n    \r\n    pprint(a['George Lucas'])\r\n    print(calc_mean_score(a['George Lucas']))\r\n    \r\n    pprint(get_average_scores(a))",
            "date": "2022-10-05 20:37:40.641023+00:00",
            "passed": false
        },
        {
            "bite": "Bite 30. Movie data analysis",
            "code": "import csv\r\nfrom collections import defaultdict, namedtuple\r\nimport os\r\nfrom urllib.request import urlretrieve\r\nfrom pprint import pprint\r\n\r\n\r\nBASE_URL = 'https://bites-data.s3.us-east-2.amazonaws.com/'\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\n\r\nfname = 'movie_metadata.csv'\r\nremote = os.path.join(BASE_URL, fname)\r\nlocal = os.path.join(TMP, fname)\r\nurlretrieve(remote, local)\r\n\r\nMOVIE_DATA = local\r\nMIN_MOVIES = 4\r\nMIN_YEAR = 1960\r\n\r\nMovie = namedtuple('Movie', 'title year score')\r\n\r\n\r\ndef get_movies_by_director():\r\n    \"\"\"Extracts all movies from csv and stores them in a dict,\r\n    where keys are directors, and values are a list of movies,\r\n    use the defined Movie namedtuple\"\"\"\r\n    \r\n    with open(local, newline='') as f:\r\n        data = csv.DictReader(f)\r\n        result = {}\r\n        for row in data:\r\n            year = row.get('title_year', None)\r\n            if year and int(year) >= MIN_YEAR:\r\n                director = row['director_name']\r\n                title = row['movie_title'].strip()\r\n                score = float(row['imdb_score'])\r\n                year = int(year)\r\n                result.setdefault(director,[]).append(Movie(title=title, year=year, score=score))\r\n    return result\r\n        \r\n\r\ndef calc_mean_score(movies):\r\n    \"\"\"Helper method to calculate mean of list of Movie namedtuples,\r\n       round the mean to 1 decimal place\"\"\"\r\n    tmp = [movie.score for movie in movies]\r\n    return round(sum(tmp)/len(tmp),1)\r\n\r\ndef get_average_scores(directors):\r\n    \"\"\"Iterate through the directors dict (returned by get_movies_by_director),\r\n       return a list of tuples (director, average_score) ordered by highest\r\n       score in descending order. Only take directors into account\r\n       with >= MIN_MOVIES\"\"\"\r\n    return [(director, calc_mean_score(movie_list)) for director, movie_list in directors.items() if len(movie_list) > MIN_MOVIES]\r\n\r\nif __name__ == \"__main__\":\r\n    \r\n    a= get_movies_by_director()\r\n    \r\n    pprint(a['George Lucas'])\r\n    print(calc_mean_score(a['George Lucas']))\r\n    \r\n    pprint(get_average_scores(a))",
            "date": "2022-10-05 20:30:13.862869+00:00",
            "passed": false
        },
        {
            "bite": "Bite 30. Movie data analysis",
            "code": "import csv\r\nfrom collections import defaultdict, namedtuple\r\nimport os\r\nfrom urllib.request import urlretrieve\r\nfrom pprint import pprint\r\n\r\nBASE_URL = 'https://bites-data.s3.us-east-2.amazonaws.com/'\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\n\r\nfname = 'movie_metadata.csv'\r\nremote = os.path.join(BASE_URL, fname)\r\nlocal = os.path.join(TMP, fname)\r\nurlretrieve(remote, local)\r\n\r\n\r\n\r\nMOVIE_DATA = local\r\nMIN_MOVIES = 4\r\nMIN_YEAR = 1960\r\n\r\nMovie = namedtuple('Movie', 'title year score')\r\n\r\n\r\ndef get_movies_by_director():\r\n    \"\"\"Extracts all movies from csv and stores them in a dict,\r\n    where keys are directors, and values are a list of movies,\r\n    use the defined Movie namedtuple\"\"\"\r\n    \r\n    FIELDS = {'director_name', 'movie_title', 'title_year', 'imdb_score'}\r\n    with open(local, newline='') as f:\r\n        data = csv.DictReader(f)\r\n        result = {}\r\n        for row in data:\r\n            year = row.get('title_year', None)\r\n            if year and int(year) >= MIN_YEAR:\r\n                director = row['director_name']\r\n                title = row['movie_title'].strip()\r\n                score = float(row['imdb_score'])\r\n                year = int(year)\r\n                if director in result.keys():\r\n                    result[director].append(Movie(title=title, year=year, score=score))\r\n                else:\r\n                    result[director]= [Movie(title=title, year=year, score=score)]\r\n    return result\r\n        \r\n\r\n\r\n\"\"\"\r\nextract director_name, movie_title, title_year, imdb_score\r\nignore movies without all of these fields.\r\nType conversions: title_year -> int / imdb_score -> float\r\nDiscard any movies older than 1960.\r\n\"\"\"\r\n\r\n\r\ndef calc_mean_score(movies):\r\n    \"\"\"Helper method to calculate mean of list of Movie namedtuples,\r\n       round the mean to 1 decimal place\"\"\"\r\n    pass\r\n\r\n\r\ndef get_average_scores(directors):\r\n    \"\"\"Iterate through the directors dict (returned by get_movies_by_director),\r\n       return a list of tuples (director, average_score) ordered by highest\r\n       score in descending order. Only take directors into account\r\n       with >= MIN_MOVIES\"\"\"\r\n    pass\r\n\r\n\r\n# pprint(get_movies_by_director())\r\n",
            "date": "2022-10-05 20:13:20.025897+00:00",
            "passed": false
        },
        {
            "bite": "Bite 83. At what time does PyBites live?",
            "code": "#!/usr/bin/env python\r\n\r\nfrom datetime import datetime\r\nfrom pytz import timezone, utc\r\n\r\nAUSTRALIA = timezone('Australia/Sydney')\r\nSPAIN = timezone('Europe/Madrid')\r\n\r\n\r\ndef what_time_lives_pybites(naive_utc_dt):\r\n    \"\"\"Receives a naive UTC datetime object and returns a two element\r\n       tuple of Australian and Spanish (timezone aware) datetimes\"\"\"\r\n    utc_dt = utc.localize(naive_utc_dt)\r\n    return (utc_dt.astimezone(AUSTRALIA), utc_dt.astimezone(SPAIN))\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    print(what_time_lives_pybites(datetime(2018, 11, 1, 14, 10, 0)))\r\n",
            "date": "2022-10-05 13:11:35.806105+00:00",
            "passed": true
        },
        {
            "bite": "Bite 349. Writing better Spanish",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom typing import List\r\nimport unicodedata\r\nfrom urllib.request import urlretrieve\r\nimport re\r\n\r\ndef _get_spanish_dictionary_words() -> List[str]:\r\n    filename = \"spanish.txt\"\r\n    # source of file\r\n    # https://raw.githubusercontent.com/bitcoin/bips\r\n    # /master/bip-0039/spanish.txt\r\n    url = f\"https://bites-data.s3.us-east-2.amazonaws.com/{filename}\"\r\n    tmp_folder = os.getenv(\"TMP\", \"/tmp\")\r\n    local_filepath = Path(tmp_folder) / filename\r\n    if not Path(local_filepath).exists():\r\n        urlretrieve(url, local_filepath)\r\n    return local_filepath.read_text().splitlines()\r\n\r\n\r\nSPANISH_WORDS = _get_spanish_dictionary_words()\r\n_accentuate = {unicodedata.normalize('NFKD', word).encode('ascii', 'ignore').decode('utf8'): word for word in SPANISH_WORDS}\r\n\r\ndef get_accentuated_sentence(\r\n    text: str, words: List[str] = SPANISH_WORDS\r\n) -> str:\r\n    replaced = []\r\n    for word_w_signs in text.split():\r\n        word = re.sub(r'[^a-zA-Z0-9]', '', word_w_signs)\r\n        replaced.append(word_w_signs.replace(word, _accentuate.get(word, word)))\r\n    return \" \".join(replaced)\r\n\r\nprint(get_accentuated_sentence(\"sesion de escribir, primera pagina de mi poesia hecha\"))",
            "date": "2022-10-04 19:12:01.566351+00:00",
            "passed": true
        },
        {
            "bite": "Bite 349. Writing better Spanish",
            "code": "import os\r\nfrom pathlib import Path\r\nfrom typing import List\r\nimport unicodedata\r\nfrom urllib.request import urlretrieve\r\n\r\n\r\ndef _get_spanish_dictionary_words() -> List[str]:\r\n    filename = \"spanish.txt\"\r\n    # source of file\r\n    # https://raw.githubusercontent.com/bitcoin/bips\r\n    # /master/bip-0039/spanish.txt\r\n    url = f\"https://bites-data.s3.us-east-2.amazonaws.com/{filename}\"\r\n    tmp_folder = os.getenv(\"TMP\", \"/tmp\")\r\n    local_filepath = Path(tmp_folder) / filename\r\n    if not Path(local_filepath).exists():\r\n        urlretrieve(url, local_filepath)\r\n    return local_filepath.read_text().splitlines()\r\n\r\n\r\nSPANISH_WORDS = _get_spanish_dictionary_words()\r\n\r\n\r\ndef get_accentuated_sentence(\r\n    text: str, words: List[str] = SPANISH_WORDS\r\n) -> str:\r\n    return unicodedata.normalize('NFKD', text).encode('ascii', 'ignore').decode('utf8')\r\n    \r\n\"\"\"\r\nstrings = [\r\n    (\r\n        \"Cuando era pequeno me gustaba jugar en la via\",\r\n        \"Cuando era pequen\u0303o me gustaba jugar en la vi\u0301a\",\r\n    ),\r\n    (\"un dos tres ... accion\", \"un dos tres ... accio\u0301n\"),\r\n    (\"anadir otra aficion\", \"an\u0303adir otra aficio\u0301n\"),\r\n    (\r\n        \"bajo el arbol descansando vi un avion\",\r\n        \"bajo el a\u0301rbol descansando vi un avio\u0301n\",\r\n    ),\r\n    (\r\n        \"no tomes mucho azucar o hay que evitar la bascula\",\r\n        \"no tomes mucho azu\u0301car o hay que evitar la ba\u0301scula\",\r\n    ),\r\n    (\r\n        \"vehiculo volando, utopia o realidad pronto ...?\",\r\n        \"vehi\u0301culo volando, utopi\u0301a o realidad pronto ...?\",\r\n    ),\r\n    (\r\n        \"telefono publico ... apenas ya no se ve en esta epoca\",\r\n        \"tele\u0301fono pu\u0301blico ... apenas ya no se ve en esta e\u0301poca\",\r\n    ),\r\n    (\"me falta jamon y jabon\", \"me falta jamo\u0301n y jabo\u0301n\"),\r\n    (\r\n        \"leyendo un libro en el jardin ... tarde de exito\",\r\n        \"leyendo un libro en el jardi\u0301n ... tarde de e\u0301xito\",\r\n    ),\r\n    (\r\n        \"sesion de escribir, primera pagina de mi poesia hecha\",\r\n        \"sesio\u0301n de escribir, primera pa\u0301gina de mi poesi\u0301a hecha\",\r\n    ),\r\n]\r\n\r\nfor tup in strings:\r\n    string = tup[1]\r\n    print(string)\r\n    print(get_accentuated_sentence(string))\r\n    \r\n\"\"\"",
            "date": "2022-10-04 18:19:03.155563+00:00",
            "passed": false
        },
        {
            "bite": "Bite 80. Check equality of two lists",
            "code": "from enum import Enum\r\nfrom collections import Counter\r\n\r\nclass Equality(Enum):\r\n    SAME_REFERENCE = 4\r\n    SAME_ORDERED = 3\r\n    SAME_UNORDERED = 2\r\n    SAME_UNORDERED_DEDUPED = 1\r\n    NO_EQUALITY = 0\r\n\r\n\r\ndef check_equality(list1, list2):\r\n    \"\"\"Check if list1 and list2 are equal returning the kind of equality.\r\n       Use the values in the Equality Enum:\r\n       - return SAME_REFERENCE if both lists reference the same object\r\n       - return SAME_ORDERED if they have the same content and order\r\n       - return SAME_UNORDERED if they have the same content unordered\r\n       - return SAME_UNORDERED_DEDUPED if they have the same unordered content\r\n         and reduced to unique items\r\n       - return NO_EQUALITY if none of the previous cases match\"\"\"\r\n    if list1 is list2:\r\n        return Equality.SAME_REFERENCE\r\n    if list1 == list2:\r\n        return Equality.SAME_ORDERED\r\n    if Counter(list1) == Counter(list2):\r\n        return Equality.SAME_UNORDERED\r\n    if set(list1) == set(list2):\r\n        return Equality.SAME_UNORDERED_DEDUPED\r\n    return Equality.NO_EQUALITY\r\n    \r\n\r\nlist0 = [1, 2, 3, 4, 4]\r\nlist1 = list0\r\nlist2 = [1, 2, 3, 4, 4]\r\nlist3 = [4, 1, 2, 3, 4]\r\nlist4 = [4, 2, 3, 1]\r\nlist5 = [4, 2, 3, 5]\r\n\r\nprint(check_equality(list0, list1))\r\nprint(check_equality(list0, list2))\r\nprint(check_equality(list0, list3))\r\nprint(check_equality(list0, list4))\r\nprint(check_equality(list0, list5))",
            "date": "2022-10-04 06:59:41.231539+00:00",
            "passed": true
        },
        {
            "bite": "Bite 80. Check equality of two lists",
            "code": "from enum import Enum\r\nfrom collections import Counter\r\n\r\nclass Equality(Enum):\r\n    SAME_REFERENCE = 4\r\n    SAME_ORDERED = 3\r\n    SAME_UNORDERED = 2\r\n    SAME_UNORDERED_DEDUPED = 1\r\n    NO_EQUALITY = 0\r\n\r\n\r\ndef check_equality(list1, list2):\r\n    \"\"\"Check if list1 and list2 are equal returning the kind of equality.\r\n       Use the values in the Equality Enum:\r\n       - return SAME_REFERENCE if both lists reference the same object\r\n       - return SAME_ORDERED if they have the same content and order\r\n       - return SAME_UNORDERED if they have the same content unordered\r\n       - return SAME_UNORDERED_DEDUPED if they have the same unordered content\r\n         and reduced to unique items\r\n       - return NO_EQUALITY if none of the previous cases match\"\"\"\r\n    if list1 is list2:\r\n        return Equality.SAME_REFERENCE\r\n    if list1 == list2:\r\n        return Equality.SAME_ORDERED\r\n    if Counter(list1) == Counter(list2):\r\n        return Equality.SAME_UNORDERED\r\n    if set(list1) == set(list2):\r\n        return Equality.SAME_UNORDERED_DEDUPED\r\n    return NO_EQUALITY\r\n    \r\n\r\nlist0 = [1, 2, 3, 4, 4]\r\nlist1 = list0\r\nlist2 = [1, 2, 3, 4, 4]\r\nlist3 = [4, 1, 2, 3, 4]\r\nlist4 = [4, 2, 3, 1]\r\n\r\nprint(check_equality(list0, list1))\r\nprint(check_equality(list0, list2))\r\nprint(check_equality(list0, list3))\r\nprint(check_equality(list0, list4))",
            "date": "2022-10-04 06:57:59.755846+00:00",
            "passed": false
        },
        {
            "bite": "Bite 33. Transpose a data structure",
            "code": "from collections import namedtuple\r\nfrom pprint import pprint\r\n\r\ndef transpose(data):\r\n    \"\"\"Transpose a data structure\r\n    1. dict\r\n    data = {'2017-8': 19, '2017-9': 13}\r\n    In:  transpose(data)\r\n    Out: [('2017-8', '2017-9'), (19, 13)]\r\n\r\n    2. list of (named)tuples\r\n    data = [Member(name='Bob', since_days=60, karma_points=60,\r\n                   bitecoin_earned=56),\r\n            Member(name='Julian', since_days=221, karma_points=34,\r\n                   bitecoin_earned=78)]\r\n    In: transpose(data)\r\n    Out: [('Bob', 'Julian'), (60, 221), (60, 34), (56, 78)]\r\n    \"\"\"\r\n    \r\n    if type(data) is dict:\r\n        data = data.items()\r\n\r\n    return list(zip(*data))\r\n    \r\n    \r\n# data = {'2017-8': 19, '2017-9': 13}\r\n\r\n# Declaring namedtuple()\r\nMember = namedtuple('Member', ['name','since_days', 'karma_points',\r\n                   'bitecoin_earned'])\r\ndata = [Member(name='Bob', since_days=60, karma_points=60,\r\n                   bitecoin_earned=56),\r\n            Member(name='Julian', since_days=221, karma_points=34,\r\n                   bitecoin_earned=78)]\r\n\r\n\r\n\r\npprint(transpose(data))",
            "date": "2022-10-03 17:25:55.520342+00:00",
            "passed": true
        },
        {
            "bite": "Bite 77. New places to travel to",
            "code": "def uncommon_cities(my_cities, other_cities):\r\n    \"\"\"Compare my_cities and other_cities and return the number of different\r\n       cities between the two\"\"\"\r\n    return len(set(my_cities) ^ set(other_cities))\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    a = ['1','2','3','4','5','6']\r\n    b= ['3','4','5','6','7','8']\r\n    \r\n    print(uncommon_cities(a,b))",
            "date": "2022-10-03 16:49:33.092621+00:00",
            "passed": true
        },
        {
            "bite": "Bite 279. Armstrong numbers",
            "code": "def is_armstrong(n: int) -> bool:\r\n    n_as_lst= [int(i) for i in str(n)]\r\n    # print(n_as_lst)\r\n    tmp = [i**len(n_as_lst) for i in n_as_lst]\r\n    # print(tmp)\r\n    return sum(tmp) == n\r\n\r\n    \r\n\r\nprint(is_armstrong(8))",
            "date": "2022-10-02 22:30:40.416996+00:00",
            "passed": true
        },
        {
            "bite": "Bite 279. Armstrong numbers",
            "code": "def is_armstrong(n: int) -> bool:\r\n    n_as_lst= [int(i) for i in str(n)]\r\n    if len(n_as_lst) == 1: \r\n        return True\r\n    return  sum([i**3 for i in n_as_lst]) == n\r\n\r\n    \r\n\r\n# print(is_armstrong(9474))",
            "date": "2022-10-02 22:27:47.654139+00:00",
            "passed": false
        },
        {
            "bite": "Bite 279. Armstrong numbers",
            "code": "def is_armstrong(n: int) -> bool:\r\n    n_as_lst= [int(i) for i in str(n)]\r\n    if len(n_as_lst) == 1: \r\n        return True\r\n    return  sum([i**3 for i in n_as_lst]) == n\r\n\r\n    \r\n\r\nprint(is_armstrong(8))",
            "date": "2022-10-02 22:26:54.160696+00:00",
            "passed": false
        },
        {
            "bite": "Bite 49. Scrape Packt's html with BeautifulSoup",
            "code": "from collections import namedtuple\r\n\r\nfrom bs4 import BeautifulSoup as Soup\r\nimport requests\r\n\r\nPACKT = 'https://bites-data.s3.us-east-2.amazonaws.com/packt.html'\r\nCONTENT = requests.get(PACKT).text\r\n\r\nBook = namedtuple('Book', 'title description image link')\r\n\r\n\r\ndef get_book():\r\n    \"\"\"make a Soup object, parse the relevant html sections, and return a Book namedtuple\"\"\"\r\n    soup = Soup(CONTENT, 'html.parser')\r\n    \r\n    dotd_title_div = soup.find_all('div', class_=\"dotd-title\")\r\n    title = [element.find(\"h2\").text.strip() for element in dotd_title_div][0]\r\n    \r\n    dotd_description_parent_div = soup.find('div', class_=\"dotd-main-book-summary\")\r\n    description = list(dotd_description_parent_div.children)[7]\r\n    description = description.text.strip()\r\n\r\n    dotd_link_div = soup.find_all('div', class_=\"dotd-main-book-image\")\r\n    for element in dotd_link_div:\r\n        link = element.find(\"a\")\r\n    link = link[\"href\"]\r\n\r\n    dotd_image_img = soup.find('img', class_=\"imagecache-dotd_main_image\")\r\n    image = dotd_image_img[\"src\"]\r\n    \r\n    book = Book(title, description, image, link)\r\n    return book\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    print(get_book())",
            "date": "2022-10-02 22:07:45.627156+00:00",
            "passed": true
        },
        {
            "bite": "Bite 49. Scrape Packt's html with BeautifulSoup",
            "code": "from collections import namedtuple\r\n\r\nfrom bs4 import BeautifulSoup as Soup\r\nimport requests\r\n\r\nPACKT = 'https://bites-data.s3.us-east-2.amazonaws.com/packt.html'\r\nCONTENT = requests.get(PACKT).text\r\n\r\nBook = namedtuple('Book', 'title description image link')\r\n\r\n\r\ndef get_book():\r\n    \"\"\"make a Soup object, parse the relevant html sections, and return a Book namedtuple\"\"\"\r\n    soup = Soup(CONTENT, 'html.parser')\r\n    dotd_title_div = soup.find_all('div', class_=\"dotd-title\")\r\n    \r\n    \"\"\" this works\r\n    for element in dotd_title_div:\r\n        title_element = element.find(\"h2\")\r\n    return title_element.text.strip()\r\n    \"\"\"\r\n    \r\n    return [element.find(\"h2\").text.strip() for element in dotd_title_div][0]\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    print(get_book())",
            "date": "2022-10-02 21:21:31.374416+00:00",
            "passed": false
        },
        {
            "bite": "Bite 74. What day of the week were you born on?",
            "code": "import calendar\r\nimport datetime\r\nWEEKDAYS = ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday']\r\n\r\ndef weekday_of_birth_date(date):\r\n    \"\"\"Takes a date object and returns the corresponding weekday string\"\"\"\r\n    weekday_index = calendar.weekday(date.year,date.month,date.day)\r\n    return WEEKDAYS[weekday_index]\r\n\r\nif __name__ ==\"__main__\":\r\n    date = datetime.datetime(year=2022,month=1,day=1)\r\n    print(weekday_of_birth_date(date))",
            "date": "2022-10-02 14:39:04.758959+00:00",
            "passed": true
        },
        {
            "bite": "Bite 74. What day of the week were you born on?",
            "code": "import calendar\r\nimport datetime\r\n\r\n\r\ndef weekday_of_birth_date(date):\r\n    \"\"\"Takes a date object and returns the corresponding weekday string\"\"\"\r\n    print(calendar.weekday(date.year,date.month,date.day))\r\n\r\ndate = datetime.datetime(year=1975,month=4,day=9)\r\nweekday_of_birth_date(date)",
            "date": "2022-10-02 14:36:03.813859+00:00",
            "passed": false
        },
        {
            "bite": "Bite 28. Converting date strings to datetimes",
            "code": "import collections\r\nfrom datetime import datetime\r\nimport os\r\nimport re\r\nfrom urllib.request import urlretrieve\r\n\r\nBASE_URL = 'https://bites-data.s3.us-east-2.amazonaws.com/'\r\nRSS_FEED = 'pybites_feed.rss.xml'\r\nPUB_DATE = re.compile(r'<pubDate>(.*?)</pubDate>')\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\n\r\n\r\ndef _get_dates():\r\n    \"\"\"Downloads PyBites feed and parses out all pub dates returning\r\n       a list of date strings, e.g.: ['Sun, 07 Jan 2018 12:00:00 +0100',\r\n       'Sun, 07 Jan 2018 11:00:00 +0100', ... ]\"\"\"\r\n    remote = os.path.join(BASE_URL, RSS_FEED)\r\n    local = os.path.join(TMP, RSS_FEED)\r\n    urlretrieve(remote, local)\r\n\r\n    with open(local) as f:\r\n        return PUB_DATE.findall(f.read())\r\n\r\n\r\ndef convert_to_datetime(date_str):\r\n    \"\"\"Receives a date str and convert it into a datetime object\"\"\"\r\n    date_str_clean = re.findall(',(.+)\\+',date_str)[0]\r\n    return datetime.strptime(date_str_clean.strip(), \"%d %b %Y %H:%M:%S\")\r\n\r\n\r\ndef get_month_most_posts(dates):\r\n    \"\"\"Receives a list of datetimes and returns the month (format YYYY-MM)\r\n       that occurs most\"\"\"\r\n    return collections.Counter([date.strftime(\"%Y-%m\") for date in dates]).most_common(1)[0][0]\r\n\r\n\r\nif __name__==\"__main__\":\r\n    test_str=\"Thu, 04 May 2017 20:46:00 +0200.\"\r\n    test_lst =[\r\n        datetime(year=2021, month=10, day=1),\r\n        datetime(year=2022, month=10, day=10),\r\n        datetime(year=2023, month=10, day=11),\r\n        datetime(year=2021, month=11, day=12),\r\n        datetime(year=2022, month=10, day=2),\r\n        datetime(year=2022, month=10, day=3),\r\n        datetime(year=2021, month=9, day=6)\r\n        ]\r\n    \r\n    date = convert_to_datetime(test_str)\r\n    print(date.strftime(\"%Y-%d\"))\r\n    print(get_month_most_posts(test_lst))\r\n",
            "date": "2022-10-01 22:14:39.110163+00:00",
            "passed": true
        },
        {
            "bite": "Bite 28. Converting date strings to datetimes",
            "code": "import collections\r\nfrom datetime import datetime\r\nimport os\r\nimport re\r\nfrom urllib.request import urlretrieve\r\n\r\nBASE_URL = 'https://bites-data.s3.us-east-2.amazonaws.com/'\r\nRSS_FEED = 'pybites_feed.rss.xml'\r\nPUB_DATE = re.compile(r'<pubDate>(.*?)</pubDate>')\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\n\r\n\r\ndef _get_dates():\r\n    \"\"\"Downloads PyBites feed and parses out all pub dates returning\r\n       a list of date strings, e.g.: ['Sun, 07 Jan 2018 12:00:00 +0100',\r\n       'Sun, 07 Jan 2018 11:00:00 +0100', ... ]\"\"\"\r\n    remote = os.path.join(BASE_URL, RSS_FEED)\r\n    local = os.path.join(TMP, RSS_FEED)\r\n    urlretrieve(remote, local)\r\n\r\n    with open(local) as f:\r\n        return PUB_DATE.findall(f.read())\r\n\r\n\r\ndef convert_to_datetime(date_str):\r\n    \"\"\"Receives a date str and convert it into a datetime object\"\"\"\r\n    date_str_clean = re.findall(',(.+)\\+',date_str)[0]\r\n    return datetime.strptime(date_str_clean.strip(), \"%d %B %Y %H:%M:%S\")\r\n\r\n\r\ndef get_month_most_posts(dates):\r\n    \"\"\"Receives a list of datetimes and returns the month (format YYYY-MM)\r\n       that occurs most\"\"\"\r\n    return collections.Counter([date.strftime(\"%Y-%m\") for date in dates]).most_common(1)[0][0]\r\n\r\n\r\nif __name__==\"__main__\":\r\n    test_str=\"Thu, 04 May 2017 20:46:00 +0200.\"\r\n    test_lst =[\r\n        datetime(year=2021, month=10, day=1),\r\n        datetime(year=2022, month=10, day=10),\r\n        datetime(year=2023, month=10, day=11),\r\n        datetime(year=2021, month=11, day=12),\r\n        datetime(year=2022, month=10, day=2),\r\n        datetime(year=2022, month=10, day=3),\r\n        datetime(year=2021, month=9, day=6)\r\n        ]\r\n    \r\n    date = convert_to_datetime(test_str)\r\n    print(date.strftime(\"%Y-%d\"))\r\n    print(get_month_most_posts(test_lst))\r\n",
            "date": "2022-10-01 22:13:22.880057+00:00",
            "passed": false
        },
        {
            "bite": "Bite 68. Remove punctuation characters from a string",
            "code": "PUNCTUATION = '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~'\r\n\r\ndef remove_punctuation(input_string):\r\n    \"\"\"Return a str with punctuation chars stripped out\"\"\"\r\n    return \"\".join([letter for letter in input_string if letter not in PUNCTUATION])\r\n\r\nprint(remove_punctuation(\"Some other (chars) |:-^, let's delete them\"))",
            "date": "2022-10-01 21:26:43.216732+00:00",
            "passed": true
        },
        {
            "bite": "Bite 27. Parse omdb movie json data",
            "code": "import os\r\nimport urllib.request\r\nimport json\r\nimport ast\r\nfrom pprint import pprint \r\n\r\n# this needed to do my testing with print, I am such a loser\r\n# download file\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\nomdb_json = os.path.join(tmp, 'omdb')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/omdb_data',\r\n    omdb_json)\r\n\r\n# load file in list of dicts\r\nwith open(omdb_json,) as f:\r\n    list_dicts = [ast.literal_eval(line) for line in f.readlines()]\r\n\r\n# create JSON files from list of dicts\r\nlist_of_files=[]\r\nfor i, movie_dict in enumerate(list_dicts):\r\n    filename = f\"{tmp}/file_{i}.json\" \r\n    with open(filename, \"w\") as outfile:\r\n        json.dump(movie_dict, outfile)\r\n    list_of_files.append(filename)\r\n\r\n# print(list_of_files)\r\n\r\n\r\ndef get_movie_data(files: list) -> list:\r\n    \"\"\"Parse movie json files into a list of dicts\"\"\"\r\n    lst=[]\r\n    for file in files:\r\n        with open(file) as f:\r\n            lst.append(json.load(f)) \r\n    return lst\r\n    \r\n\r\ndef get_single_comedy(movies: list) -> str:\r\n    \"\"\"return the movie with Comedy in Genres\"\"\"\r\n    for movie in movies:\r\n        if 'Comedy' in movie['Genre']:\r\n            return movie['Title']\r\n\r\n\r\ndef _parse_num_nominations(string):\r\n    return int(string.strip().split('&')[1].split()[0])\r\n    \r\n    \r\ndef get_movie_most_nominations(movies: list) -> str:\r\n    \"\"\"Return the movie that had the most nominations\"\"\"\r\n    \r\n    nominations=dict((movie['Title'], _parse_num_nominations(movie['Awards']) ) for movie in movies)\r\n    # print(runtimes)\r\n    return max(nominations, key=nominations.get)\r\n\r\ndef _parse_runtime(string):\r\n    return int(string.split()[0].strip())\r\n\r\n\r\ndef get_movie_longest_runtime(movies: list) -> str:\r\n    \"\"\"Return the movie that has the longest runtime\"\"\"\r\n    runtimes=dict((movie['Title'], _parse_runtime(movie['Runtime']) ) for movie in movies)\r\n    # print(runtimes)\r\n    return max(runtimes, key=runtimes.get)\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    lst=get_movie_data(list_of_files)\r\n    print(lst)\r\n    print(get_single_comedy(lst))\r\n    print(get_movie_most_nominations(lst))\r\n    print(get_movie_longest_runtime(lst))",
            "date": "2022-09-30 20:35:12.276001+00:00",
            "passed": true
        },
        {
            "bite": "Bite 27. Parse omdb movie json data",
            "code": "import json\r\n\r\n\"https://bites-data.s3.us-east-2.amazonaws.com/omdb_data\"\r\n\r\n\r\ndef get_movie_data(files: list) -> list:\r\n    \"\"\"Parse movie json files into a list of dicts\"\"\"\r\n    pass\r\n\r\ndef get_single_comedy(movies: list) -> str:\r\n    \"\"\"return the movie with Comedy in Genres\"\"\"\r\n    pass\r\n\r\n\r\ndef get_movie_most_nominations(movies: list) -> str:\r\n    \"\"\"Return the movie that had the most nominations\"\"\"\r\n    pass\r\n\r\n\r\ndef get_movie_longest_runtime(movies: list) -> str:\r\n    \"\"\"Return the movie that has the longest runtime\"\"\"\r\n    pass",
            "date": "2022-09-30 19:21:04.492532+00:00",
            "passed": false
        },
        {
            "bite": "Bite 67. Working with datetimes",
            "code": "from datetime import date, timedelta\r\n\r\nstart_100days = date(2017, 3, 30)\r\npybites_founded = date(2016, 12, 19)\r\npycon_date = date(2018, 5, 8)\r\n\r\n\r\ndef get_hundred_days_end_date():\r\n    \"\"\"Return a string of yyyy-mm-dd\"\"\"\r\n    end_challenge=start_100days + timedelta(days=100)\r\n    return(str(end_challenge))\r\n\r\n\r\ndef get_days_between_pb_start_first_joint_pycon():\r\n    \"\"\"Return the int number of days\"\"\"\r\n    days=pycon_date - pybites_founded\r\n    return days.days\r\n\r\nprint(get_hundred_days_end_date())\r\nprint(get_days_between_pb_start_first_joint_pycon())",
            "date": "2022-09-30 05:55:19.004771+00:00",
            "passed": true
        },
        {
            "bite": "Bite 255. Codon Usage",
            "code": "import os\r\nfrom urllib.request import urlretrieve\r\nfrom pprint import pprint\r\nfrom collections import Counter\r\n\r\n# Translation Table:\r\n# https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi#SG11\r\n# Each column represents one entry. Codon = {Base1}{Base2}{Base3}\r\n# All Base 'T's need to be converted to 'U's to convert DNA to RNA\r\nTRANSL_TABLE_11 = \"\"\"\r\n    AAs  = FFLLSSSSYY**CC*WLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\r\n  Starts = ---M------**--*----M------------MMMM---------------M------------\r\n  Base1  = TTTTTTTTTTTTTTTTCCCCCCCCCCCCCCCCAAAAAAAAAAAAAAAAGGGGGGGGGGGGGGGG\r\n  Base2  = TTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGG\r\n  Base3  = TCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAG\r\n\"\"\"\r\n\r\n# Converted from http://ftp.ncbi.nlm.nih.gov/genomes/archive/old_refseq/Bacteria/Staphylococcus_aureus_Newman_uid58839/NC_009641.ffn  # noqa E501\r\nURL = \"https://bites-data.s3.us-east-2.amazonaws.com/NC_009641.txt\"\r\n\r\n# Order of bases in the table\r\nBASE_ORDER = [\"U\", \"C\", \"A\", \"G\"]\r\n\r\n\r\ndef _preload_sequences(url=URL):\r\n    \"\"\"\r\n    Provided helper function\r\n    Returns coding sequences, one sequence each line\r\n    \"\"\"\r\n    filename = os.path.join(os.getenv(\"TMP\", \"/tmp\"), \"NC_009641.txt\")\r\n    if not os.path.isfile(filename):\r\n        urlretrieve(url, filename)\r\n    with open(filename, \"r\") as f:\r\n        return f.readlines()\r\n\r\ndef _preprocess_table(table_str):\r\n    \r\n    table_dict = dict((name.strip(), value.strip()) for name, value in \r\n        (tuple(line.split('=')) for line in table_str.strip().splitlines()))\r\n\r\n    table_dict['Base1']=table_dict['Base1'].replace('T','U')\r\n    table_dict['Base2']=table_dict['Base2'].replace('T','U')\r\n    table_dict['Base3']=table_dict['Base3'].replace('T','U')\r\n\r\n    return dict((''.join(line[1:4]), line[0]) for line in zip(\r\n        table_dict['AAs'],table_dict['Base1'],table_dict['Base2'],table_dict['Base3']))\r\n\r\n\r\ndef return_codon_usage_table(\r\n    sequences=_preload_sequences(), translation_table_str=TRANSL_TABLE_11\r\n):\r\n    \"\"\"\r\n    Receives a list of gene sequences and a translation table string\r\n    Returns a string with all bases and their frequencies in a table\r\n    with the following fields:\r\n    codon_triplet: amino_acid_letter frequency_per_1000 absolute_occurrences\r\n\r\n    Skip invalid coding sequences:\r\n       --> must consist entirely of codons (3-base triplet)\r\n    \"\"\"\r\n    chunks = []\r\n    n = 3\r\n    for sequence in sequences:\r\n        chunks += [sequence[i:i+n] for i in range(0, len(sequence), n)]\r\n    counter = Counter(chunks)\r\n    translation_table = _preprocess_table(translation_table_str)\r\n    unformatted_table = dict((codon, [aa, counter[codon]]) \\\r\n        for codon, aa in translation_table.items())\r\n\r\n    formatted_table = _format_table(unformatted_table, BASE_ORDER)\r\n    return formatted_table\r\n\r\ndef _format_table(table, base_order):\r\n    result = \"\"\"\r\n|  Codon AA  Freq  Count  |  Codon AA  Freq  Count  |  Codon AA  Freq  Count  |  Codon AA  Freq  Count  |\r\n---------------------------------------------------------------------------------------------------------\r\n|\"\"\"\r\n\r\n    ITEM_SEP=\"|\"\r\n    LINE_SEP=\"|\\n|\"\r\n    SEC_SEP=\"|\\n\"+105*\"-\"+\"\\n|\"\r\n    total = sum([item[1] for item in table.values()])\r\n    sections =[]\r\n    for i in base_order:\r\n        lines = []\r\n        for k in base_order:\r\n            items = []\r\n            for j in base_order:\r\n                codon=\"\".join([i,j,k])\r\n                aa=table[codon][0]\r\n                freq=1000*table[codon][1]/total \r\n                count=table[codon][1]\r\n                items.append(f\"  {codon}:  {aa} {freq:6.1f} {count:6}  \")\r\n            lines.append(ITEM_SEP.join(items))\r\n        sections.append(LINE_SEP.join(lines))\r\n    result+= SEC_SEP.join(sections) + \"|\\n\"+105*\"-\"+\"\\n\"\r\n    return result\r\nif __name__ == \"__main__\":\r\n    print(return_codon_usage_table())\r\n",
            "date": "2022-09-29 21:33:47.384418+00:00",
            "passed": true
        },
        {
            "bite": "Bite 255. Codon Usage",
            "code": "import os\r\nfrom urllib.request import urlretrieve\r\nfrom pprint import pprint\r\nfrom collections import Counter\r\n\r\n# Translation Table:\r\n# https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi#SG11\r\n# Each column represents one entry. Codon = {Base1}{Base2}{Base3}\r\n# All Base 'T's need to be converted to 'U's to convert DNA to RNA\r\nTRANSL_TABLE_11 = \"\"\"\r\n    AAs  = FFLLSSSSYY**CC*WLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\r\n  Starts = ---M------**--*----M------------MMMM---------------M------------\r\n  Base1  = TTTTTTTTTTTTTTTTCCCCCCCCCCCCCCCCAAAAAAAAAAAAAAAAGGGGGGGGGGGGGGGG\r\n  Base2  = TTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGG\r\n  Base3  = TCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAG\r\n\"\"\"\r\n\r\n# Converted from http://ftp.ncbi.nlm.nih.gov/genomes/archive/old_refseq/Bacteria/Staphylococcus_aureus_Newman_uid58839/NC_009641.ffn  # noqa E501\r\nURL = \"https://bites-data.s3.us-east-2.amazonaws.com/NC_009641.txt\"\r\n\r\n# Order of bases in the table\r\nBASE_ORDER = [\"U\", \"C\", \"A\", \"G\"]\r\n\r\n\r\ndef _preload_sequences(url=URL):\r\n    \"\"\"\r\n    Provided helper function\r\n    Returns coding sequences, one sequence each line\r\n    \"\"\"\r\n    filename = os.path.join(os.getenv(\"TMP\", \"/tmp\"), \"NC_009641.txt\")\r\n    if not os.path.isfile(filename):\r\n        urlretrieve(url, filename)\r\n    with open(filename, \"r\") as f:\r\n        return f.readlines()\r\n\r\ndef _preprocess_table(table_str):\r\n    \r\n    table_dict = dict((name.strip(), value.strip()) for name, value in \r\n        (tuple(line.split('=')) for line in table_str.strip().splitlines()))\r\n\r\n    table_dict['Base1']=table_dict['Base1'].replace('T','U')\r\n    table_dict['Base2']=table_dict['Base2'].replace('T','U')\r\n    table_dict['Base3']=table_dict['Base3'].replace('T','U')\r\n\r\n    return dict((''.join(line[1:4]), line[0]) for line in zip(\r\n        table_dict['AAs'],table_dict['Base1'],table_dict['Base2'],table_dict['Base3']))\r\n\r\n\r\ndef return_codon_usage_table(\r\n    sequences=_preload_sequences(), translation_table_str=TRANSL_TABLE_11\r\n):\r\n    \"\"\"\r\n    Receives a list of gene sequences and a translation table string\r\n    Returns a string with all bases and their frequencies in a table\r\n    with the following fields:\r\n    codon_triplet: amino_acid_letter frequency_per_1000 absolute_occurrences\r\n\r\n    Skip invalid coding sequences:\r\n       --> must consist entirely of codons (3-base triplet)\r\n    \"\"\"\r\n    chunks = []\r\n    n = 3\r\n    for sequence in sequences:\r\n        chunks += [sequence[i:i+n] for i in range(0, len(sequence), n)]\r\n    counter = Counter(chunks)\r\n    total= sum(counter.values())\r\n    translation_table = _preprocess_table(translation_table_str)\r\n    unformatted_table = dict((codon, [aa, counter[codon]/total, counter[codon]]) \\\r\n        for codon, aa in translation_table.items())\r\n    total2= sum([item[2] for item in unformatted_table.values()])\r\n    print(f\"{total=}, {total2=}\")\r\n    \r\n    formatted_table = _format_table(unformatted_table, BASE_ORDER)\r\n    return formatted_table\r\n\r\ndef _format_table(table, base_order):\r\n    result = \"\"\"\r\n|  Codon AA  Freq  Count  |  Codon AA  Freq  Count  |  Codon AA  Freq  Count  |  Codon AA  Freq  Count  |\r\n---------------------------------------------------------------------------------------------------------\r\n|\"\"\"\r\n\r\n    ITEM_SEP=\"|\"\r\n    LINE_SEP=\"|\\n|\"\r\n    SEC_SEP=\"|\\n\"+105*\"-\"+\"\\n|\"\r\n    total = sum([item[2] for item in table.values()])\r\n    sections =[]\r\n    for i in base_order:\r\n        lines = []\r\n        for k in base_order:\r\n            items = []\r\n            for j in base_order:\r\n                codon=\"\".join([i,j,k])\r\n                aa=table[codon][0]\r\n                freq=1000*table[codon][2]/total \r\n\r\n                count=table[codon][2]\r\n                items.append(f\"  {codon}:  {aa} {freq:6.1f} {count:6}  \")\r\n            lines.append(ITEM_SEP.join(items))\r\n        sections.append(LINE_SEP.join(lines))\r\n    result+= SEC_SEP.join(sections) + \"|\\n\"+105*\"-\"+\"\\n\"\r\n    return result\r\nif __name__ == \"__main__\":\r\n    print(return_codon_usage_table())\r\n",
            "date": "2022-09-29 21:31:02.141261+00:00",
            "passed": true
        },
        {
            "bite": "Bite 255. Codon Usage",
            "code": "import os\r\nfrom urllib.request import urlretrieve\r\nfrom pprint import pprint\r\nfrom collections import Counter\r\n\r\n# Translation Table:\r\n# https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi#SG11\r\n# Each column represents one entry. Codon = {Base1}{Base2}{Base3}\r\n# All Base 'T's need to be converted to 'U's to convert DNA to RNA\r\nTRANSL_TABLE_11 = \"\"\"\r\n    AAs  = FFLLSSSSYY**CC*WLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\r\n  Starts = ---M------**--*----M------------MMMM---------------M------------\r\n  Base1  = TTTTTTTTTTTTTTTTCCCCCCCCCCCCCCCCAAAAAAAAAAAAAAAAGGGGGGGGGGGGGGGG\r\n  Base2  = TTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGG\r\n  Base3  = TCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAG\r\n\"\"\"\r\n\r\n# Converted from http://ftp.ncbi.nlm.nih.gov/genomes/archive/old_refseq/Bacteria/Staphylococcus_aureus_Newman_uid58839/NC_009641.ffn  # noqa E501\r\nURL = \"https://bites-data.s3.us-east-2.amazonaws.com/NC_009641.txt\"\r\n\r\n# Order of bases in the table\r\nBASE_ORDER = [\"U\", \"C\", \"A\", \"G\"]\r\n\r\n\r\ndef _preload_sequences(url=URL):\r\n    \"\"\"\r\n    Provided helper function\r\n    Returns coding sequences, one sequence each line\r\n    \"\"\"\r\n    filename = os.path.join(os.getenv(\"TMP\", \"/tmp\"), \"NC_009641.txt\")\r\n    if not os.path.isfile(filename):\r\n        urlretrieve(url, filename)\r\n    with open(filename, \"r\") as f:\r\n        return f.readlines()\r\n\r\ndef _preprocess_table(table_str):\r\n    \r\n    table_dict = dict((name.strip(), value.strip()) for name, value in \r\n        (tuple(line.split('=')) for line in table_str.strip().splitlines()))\r\n\r\n    table_dict['Base1']=table_dict['Base1'].replace('T','U')\r\n    table_dict['Base2']=table_dict['Base2'].replace('T','U')\r\n    table_dict['Base3']=table_dict['Base3'].replace('T','U')\r\n\r\n    return dict((''.join(line[1:4]), line[0]) for line in zip(\r\n        table_dict['AAs'],table_dict['Base1'],table_dict['Base2'],table_dict['Base3']))\r\n\r\n\r\ndef return_codon_usage_table(\r\n    sequences=_preload_sequences(), translation_table_str=TRANSL_TABLE_11\r\n):\r\n    \"\"\"\r\n    Receives a list of gene sequences and a translation table string\r\n    Returns a string with all bases and their frequencies in a table\r\n    with the following fields:\r\n    codon_triplet: amino_acid_letter frequency_per_1000 absolute_occurrences\r\n\r\n    Skip invalid coding sequences:\r\n       --> must consist entirely of codons (3-base triplet)\r\n    \"\"\"\r\n    chunks = []\r\n    n = 3\r\n    for sequence in sequences:\r\n        chunks += [sequence[i:i+n] for i in range(0, len(sequence), n)]\r\n    counter = Counter(chunks)\r\n    total= sum(counter.values())\r\n    translation_table = _preprocess_table(translation_table_str)\r\n    unformatted_table = dict((codon, [aa, counter[codon]/total, counter[codon]]) \\\r\n        for codon, aa in translation_table.items())\r\n\r\n    formatted_table = _format_table(unformatted_table, BASE_ORDER)\r\n    return formatted_table\r\n\r\ndef _format_table(table, base_order):\r\n    result = \"\"\"\r\n|  Codon AA  Freq  Count  |  Codon AA  Freq  Count  |  Codon AA  Freq  Count  |  Codon AA  Freq  Count  |\r\n---------------------------------------------------------------------------------------------------------\r\n|\"\"\"\r\n\r\n    ITEM_SEP=\"|\"\r\n    LINE_SEP=\"|\\n|\"\r\n    SEC_SEP=\"|\\n\"+105*\"-\"+\"\\n|\"\r\n    sections =[]\r\n    for i in base_order:\r\n        lines = []\r\n        for k in base_order:\r\n            items = []\r\n            for j in base_order:\r\n                codon=\"\".join([i,j,k])\r\n                aa=table[codon][0]\r\n                freq=1000*table[codon][1]\r\n                count=table[codon][2]\r\n                items.append(f\"  {codon}:  {aa} {freq:6.1f} {count:6}  \")\r\n            lines.append(ITEM_SEP.join(items))\r\n        sections.append(LINE_SEP.join(lines))\r\n    result+= SEC_SEP.join(sections) + \"|\\n\"+105*\"-\"+\"\\n\"\r\n    return result\r\nif __name__ == \"__main__\":\r\n    print(return_codon_usage_table())\r\n",
            "date": "2022-09-29 17:36:44.706372+00:00",
            "passed": false
        },
        {
            "bite": "Bite 255. Codon Usage",
            "code": "import os\r\nfrom urllib.request import urlretrieve\r\nfrom pprint import pprint\r\nfrom collections import Counter\r\n\r\n# Translation Table:\r\n# https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi#SG11\r\n# Each column represents one entry. Codon = {Base1}{Base2}{Base3}\r\n# All Base 'T's need to be converted to 'U's to convert DNA to RNA\r\nTRANSL_TABLE_11 = \"\"\"\r\n    AAs  = FFLLSSSSYY**CC*WLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\r\n  Starts = ---M------**--*----M------------MMMM---------------M------------\r\n  Base1  = TTTTTTTTTTTTTTTTCCCCCCCCCCCCCCCCAAAAAAAAAAAAAAAAGGGGGGGGGGGGGGGG\r\n  Base2  = TTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGG\r\n  Base3  = TCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAG\r\n\"\"\"\r\n\r\n# Converted from http://ftp.ncbi.nlm.nih.gov/genomes/archive/old_refseq/Bacteria/Staphylococcus_aureus_Newman_uid58839/NC_009641.ffn  # noqa E501\r\nURL = \"https://bites-data.s3.us-east-2.amazonaws.com/NC_009641.txt\"\r\n\r\n# Order of bases in the table\r\nBASE_ORDER = [\"U\", \"C\", \"A\", \"G\"]\r\n\r\n\r\ndef _preload_sequences(url=URL):\r\n    \"\"\"\r\n    Provided helper function\r\n    Returns coding sequences, one sequence each line\r\n    \"\"\"\r\n    filename = os.path.join(os.getenv(\"TMP\", \"/tmp\"), \"NC_009641.txt\")\r\n    if not os.path.isfile(filename):\r\n        urlretrieve(url, filename)\r\n    with open(filename, \"r\") as f:\r\n        return f.readlines()\r\n\r\ndef _preprocess_table(table_str):\r\n    \r\n    table_dict = dict((name.strip(), value.strip()) for name, value in \r\n        (tuple(line.split('=')) for line in table_str.strip().splitlines()))\r\n\r\n    table_dict['Base1']=table_dict['Base1'].replace('T','U')\r\n    table_dict['Base2']=table_dict['Base2'].replace('T','U')\r\n    table_dict['Base3']=table_dict['Base3'].replace('T','U')\r\n\r\n    return dict((''.join(line[1:4]), line[0]) for line in zip(\r\n        table_dict['AAs'],table_dict['Base1'],table_dict['Base2'],table_dict['Base3']))\r\n\r\n\r\ndef return_codon_usage_table(\r\n    sequences=_preload_sequences(), translation_table_str=TRANSL_TABLE_11\r\n):\r\n    \"\"\"\r\n    Receives a list of gene sequences and a translation table string\r\n    Returns a string with all bases and their frequencies in a table\r\n    with the following fields:\r\n    codon_triplet: amino_acid_letter frequency_per_1000 absolute_occurrences\r\n\r\n    Skip invalid coding sequences:\r\n       --> must consist entirely of codons (3-base triplet)\r\n    \"\"\"\r\n    chunks = []\r\n    n = 3\r\n    for sequence in sequences:\r\n        chunks += [sequence[i:i+n] for i in range(0, len(sequence), n)]\r\n    counter = Counter(chunks)\r\n    total= sum(counter.values())\r\n    translation_table = _preprocess_table(translation_table_str)\r\n    unformatted_table = dict((codon, [aa, counter[codon]/total, counter[codon]]) \\\r\n        for codon, aa in translation_table.items())\r\n\r\n    formatted_table = _format_table(unformatted_table, BASE_ORDER)\r\n    return formatted_table\r\n\r\ndef _format_table(table, base_order):\r\n    result = \"\"\"\r\n|  Codon AA  Freq  Count  |  Codon AA  Freq  Count  |  Codon AA  Freq  Count  |  Codon AA  Freq  Count  |\r\n---------------------------------------------------------------------------------------------------------\r\n|\"\"\"\r\n\r\n    ITEM_SEP=\"|\"\r\n    LINE_SEP=\"|\\n|\"\r\n    SEC_SEP=\"|\\n\"+104*\"-\"+\"\\n|\"\r\n    sections =[]\r\n    for i in base_order:\r\n        lines = []\r\n        for k in base_order:\r\n            items = []\r\n            for j in base_order:\r\n                codon=\"\".join([i,j,k])\r\n                aa=table[codon][0]\r\n                freq=1000*table[codon][1]\r\n                count=table[codon][2]\r\n                items.append(f\"  {codon}:  {aa} {freq:6.1f} {count:6}  \")\r\n            lines.append(ITEM_SEP.join(items))\r\n        sections.append(LINE_SEP.join(lines))\r\n    result+= SEC_SEP.join(sections) + \"|\\n\"+104*\"-\"+\"\\n\"\r\n    return result\r\nif __name__ == \"__main__\":\r\n    print(return_codon_usage_table())\r\n",
            "date": "2022-09-29 17:28:15.390919+00:00",
            "passed": false
        },
        {
            "bite": "Bite 255. Codon Usage",
            "code": "import os\r\nfrom urllib.request import urlretrieve\r\nfrom pprint import pprint\r\nfrom collections import Counter\r\n\r\n# Translation Table:\r\n# https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi#SG11\r\n# Each column represents one entry. Codon = {Base1}{Base2}{Base3}\r\n# All Base 'T's need to be converted to 'U's to convert DNA to RNA\r\nTRANSL_TABLE_11 = \"\"\"\r\n    AAs  = FFLLSSSSYY**CC*WLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\r\n  Starts = ---M------**--*----M------------MMMM---------------M------------\r\n  Base1  = TTTTTTTTTTTTTTTTCCCCCCCCCCCCCCCCAAAAAAAAAAAAAAAAGGGGGGGGGGGGGGGG\r\n  Base2  = TTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGG\r\n  Base3  = TCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAG\r\n\"\"\"\r\n\r\n# Converted from http://ftp.ncbi.nlm.nih.gov/genomes/archive/old_refseq/Bacteria/Staphylococcus_aureus_Newman_uid58839/NC_009641.ffn  # noqa E501\r\nURL = \"https://bites-data.s3.us-east-2.amazonaws.com/NC_009641.txt\"\r\n\r\n# Order of bases in the table\r\nBASE_ORDER = [\"U\", \"C\", \"A\", \"G\"]\r\n\r\n\r\ndef _preload_sequences(url=URL):\r\n    \"\"\"\r\n    Provided helper function\r\n    Returns coding sequences, one sequence each line\r\n    \"\"\"\r\n    filename = os.path.join(os.getenv(\"TMP\", \"/tmp\"), \"NC_009641.txt\")\r\n    if not os.path.isfile(filename):\r\n        urlretrieve(url, filename)\r\n    with open(filename, \"r\") as f:\r\n        return f.readlines()\r\n\r\ndef _preprocess_table(table_str):\r\n    \r\n    table_dict = dict((name.strip(), value.strip()) for name, value in \r\n        (tuple(line.split('=')) for line in table_str.strip().splitlines()))\r\n\r\n    table_dict['Base1']=table_dict['Base1'].replace('T','U')\r\n    table_dict['Base2']=table_dict['Base2'].replace('T','U')\r\n    table_dict['Base3']=table_dict['Base3'].replace('T','U')\r\n\r\n    return dict((''.join(line[1:4]), line[0]) for line in zip(\r\n        table_dict['AAs'],table_dict['Base1'],table_dict['Base2'],table_dict['Base3']))\r\n\r\n\r\ndef return_codon_usage_table(\r\n    sequences=_preload_sequences(), translation_table_str=TRANSL_TABLE_11\r\n):\r\n    \"\"\"\r\n    Receives a list of gene sequences and a translation table string\r\n    Returns a string with all bases and their frequencies in a table\r\n    with the following fields:\r\n    codon_triplet: amino_acid_letter frequency_per_1000 absolute_occurrences\r\n\r\n    Skip invalid coding sequences:\r\n       --> must consist entirely of codons (3-base triplet)\r\n    \"\"\"\r\n    chunks = []\r\n    n = 3\r\n    for sequence in sequences:\r\n        chunks += [sequence[i:i+n] for i in range(0, len(sequence), n)]\r\n    counter = Counter(chunks)\r\n    total= sum(counter.values())\r\n    translation_table = _preprocess_table(translation_table_str)\r\n    unformatted_table = dict((codon, [aa, counter[codon]/total, counter[codon]]) \\\r\n        for codon, aa in translation_table.items())\r\n\r\n    formatted_table = _format_table(unformatted_table, BASE_ORDER)\r\n    return formatted_table\r\n\r\ndef _format_table(table, base_order):\r\n    result = \"\"\"\r\n|  Codon AA  Freq  Count  |  Codon AA  Freq  Count  |  Codon AA  Freq  Count  |  Codon AA  Freq  Count  |\r\n---------------------------------------------------------------------------------------------------------\r\n|\"\"\"\r\n\r\n    ITEM_SEP=\"|\"\r\n    LINE_SEP=\"|\\n|\"\r\n    SEC_SEP=\"|\\n\"+104*\"-\"+\"\\n|\"\r\n    sections =[]\r\n    for i in base_order:\r\n        lines = []\r\n        for k in base_order:\r\n            items = []\r\n            for j in base_order:\r\n                codon=\"\".join([i,j,k])\r\n                aa=table[codon][0]\r\n                freq=1000*table[codon][1]\r\n                count=table[codon][2]\r\n                items.append(f\"  {codon}:  {aa} {freq:6.1f} {count:6}  \")\r\n            lines.append(ITEM_SEP.join(items))\r\n        sections.append(LINE_SEP.join(lines))\r\n    result+= SEC_SEP.join(sections) + \"|\\n\"+104*\"-\"+\"\\n\"\r\n    return result\r\nif __name__ == \"__main__\":\r\n    print(return_codon_usage_table())\r\n    # _preprocess_table(TRANSL_TABLE_11)\r\n    \r\n\"\"\"\r\n|  UUU:  F   32.6  26200\r\n|  UUC:  F   12.1   9716\r\n|  UUA:  L   53.6  43053\r\n\r\n|  UUU:  F   32.7  26200  |  UCU:  S   12.9  10309  |  UAU:  Y   30.4  24332  |  UGU:  C    4.9   3919  |\r\n|  UUC:  F   12.1   9716  |  UCC:  S    1.6   1310  |  UAC:  Y    8.6   6887  |  UGC:  C    1.2    992  |\r\n\"\"\"\r\n",
            "date": "2022-09-29 17:27:13.887571+00:00",
            "passed": false
        },
        {
            "bite": "Bite 18. Find the most common word",
            "code": "import os\r\nimport urllib.request\r\nimport re\r\nfrom collections import Counter\r\n\r\n# data provided\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\nstopwords_file = os.path.join(tmp, 'stopwords')\r\nharry_text = os.path.join(tmp, 'harry')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/stopwords.txt',\r\n    stopwords_file\r\n)\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/harry.txt',\r\n    harry_text\r\n)\r\n\r\ndef get_words(file):\r\n    with open(file) as f:  \r\n        words = f.read().split()\r\n    return [re.sub(r'[^a-z0-9 ]+', '', word.lower()) for word in words]\r\n\r\ndef get_harry_most_common_word():\r\n    words = get_words(harry_text)\r\n    stop_words = get_words(stopwords_file)\r\n    lst = [word for word in words if len(word)>0 and word not in stop_words]\r\n    return Counter(lst).most_common(1)[0]\r\n    \r\n    \r\nprint(harry_text)\r\nprint(get_harry_most_common_word())",
            "date": "2022-09-29 13:49:35.148401+00:00",
            "passed": true
        },
        {
            "bite": "Bite 18. Find the most common word",
            "code": "import os\r\nimport urllib.request\r\nimport re\r\nfrom collections import Counter\r\n\r\n# data provided\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\nstopwords_file = os.path.join(tmp, 'stopwords')\r\nharry_text = os.path.join(tmp, 'harry')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/stopwords.txt',\r\n    stopwords_file\r\n)\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/harry.txt',\r\n    harry_text\r\n)\r\n\r\ndef get_words(file):\r\n    with open(file) as f:  \r\n        words = f.read().split()\r\n    return [re.sub(r'[^a-z0-9 ]+', '', word.lower()) for word in words]\r\n\r\ndef get_harry_most_common_word():\r\n    words = get_words(harry_text)\r\n    stop_words = get_words(stopwords_file)\r\n    lst = [word for word in words if len(word)>0 and word not in stop_words]\r\n    return Counter(lst).most_common(1)\r\n    \r\n    \r\nprint(harry_text)\r\nprint(get_harry_most_common_word())",
            "date": "2022-09-29 13:48:35.775066+00:00",
            "passed": false
        },
        {
            "bite": "Bite 11. Enrich a class with dunder methods",
            "code": "class Account:\r\n\r\n    def __init__(self, name, start_balance=0):\r\n        self.name = name\r\n        self.start_balance = start_balance\r\n        self._transactions = []\r\n\r\n    @property\r\n    def balance(self):\r\n        return self.start_balance + sum(self._transactions)\r\n\r\n    #\u00a0add dunder methods below\r\n    def __len__(self):\r\n        return len(self._transactions)\r\n    \r\n    \r\n    def __lt__(self,account):\r\n        return self.balance <account.balance\r\n\r\n    def __le__(self,account):\r\n        return self.balance <=account.balance\r\n\r\n    def __gt__(self,account):\r\n        return self.balance >account.balance\r\n\r\n    def __ge__(self,account):\r\n        return self.balance >=account.balance\r\n\r\n    def __eq__(self,account):\r\n        return self.balance >=account.balance\r\n\r\n    \r\n    def __getitem__(self, index):\r\n        return self._transactions[index]\r\n        \r\n    def __iter__(self):\r\n        return iter(self._transactions)\r\n    \r\n    \r\n    def __add__(self, amount:int ):\r\n        if isinstance(amount,int):\r\n            self._transactions.append(amount)\r\n        else:\r\n            raise TypeError\r\n\r\n    def __sub__(self, amount:int ):\r\n        if isinstance(amount,int):\r\n            self._transactions.append(-amount)\r\n        else:\r\n            raise TypeError\r\n\r\n    def __str__(self):\r\n        return f\"{self.name} account - balance: {self.balance}\"\r\n        \r\nacc1 = Account('aac1', 100)\r\nacc2 = Account('aac2', 200)\r\n\r\nacc1-50\r\nacc1+20\r\nacc1+100\r\nacc1-70\r\n\r\nprint(acc1 == acc2)\r\n\r\nprint(acc1)\r\n    \r\nprint(list(acc1))\r\n\r\nprint(acc1[0])\r\n\r\n",
            "date": "2022-09-28 21:54:30.657575+00:00",
            "passed": true
        },
        {
            "bite": "Bite 11. Enrich a class with dunder methods",
            "code": "class Account:\r\n\r\n    def __init__(self, name, start_balance=0):\r\n        self.name = name\r\n        self.start_balance = start_balance\r\n        self._transactions = []\r\n\r\n    @property\r\n    def balance(self):\r\n        return self.start_balance + sum(self._transactions)\r\n\r\n    #\u00a0add dunder methods below\r\n    def __len__(self,account):\r\n        return len(self._transactions)\r\n    \r\n    \r\n    def __lt__(self,account):\r\n        return self.balance <account.balance\r\n\r\n    def __le__(self,account):\r\n        return self.balance <=account.balance\r\n\r\n    def __gt__(self,account):\r\n        return self.balance >account.balance\r\n\r\n    def __ge__(self,account):\r\n        return self.balance >=account.balance\r\n\r\n    def __eq__(self,account):\r\n        return self.balance >=account.balance\r\n\r\n    \r\n    def __getitem__(self, index):\r\n        return self._transactions[index]\r\n        \r\n    def __iter__(self):\r\n        return iter(self._transactions)\r\n    \r\n    \r\n    def __add__(self, amount:int ):\r\n        if isinstance(amount,int):\r\n            self._transactions.append(amount)\r\n        else:\r\n            raise TypeError\r\n\r\n    def __sub__(self, amount:int ):\r\n        if isinstance(amount,int):\r\n            self._transactions.append(-amount)\r\n        else:\r\n            raise TypeError\r\n\r\n    def __str__(self):\r\n        return f\"{self.name} account - balance: {self.balance}\"\r\n        \r\nacc1 = Account('aac1', 100)\r\nacc2 = Account('aac2', 200)\r\n\r\nacc1-50\r\nacc1+20\r\nacc1+100\r\nacc1-70\r\n\r\nprint(acc1 == acc2)\r\n\r\nprint(acc1)\r\n    \r\nprint(list(acc1))\r\n\r\nprint(acc1[0])\r\n\r\n",
            "date": "2022-09-28 21:53:52.861136+00:00",
            "passed": false
        },
        {
            "bite": "Bite 11. Enrich a class with dunder methods",
            "code": "class Account:\r\n\r\n    def __init__(self, name, start_balance=0):\r\n        self.name = name\r\n        self.start_balance = start_balance\r\n        self._transactions = []\r\n\r\n    @property\r\n    def balance(self):\r\n        return self.start_balance + sum(self._transactions)\r\n\r\n    #\u00a0add dunder methods below\r\n    def __len__(self,account):\r\n        return len(self._transactions)\r\n    \r\n    \r\n    def __lt__(self,account):\r\n        return self.balance <account.balance\r\n\r\n    def __le__(self,account):\r\n        return self.balance <=account.balance\r\n\r\n    def __gt__(self,account):\r\n        return self.balance >account.balance\r\n\r\n    def __ge__(self,account):\r\n        return self.balance >=account.balance\r\n\r\n    def __eq__(self,account):\r\n        return self.balance >=account.balance\r\n  \r\n        \r\nacc1 = Account('aac1', 100)\r\nacc2 = Account('aac2', 200)\r\n\r\nprint(acc1 == acc1)\r\n    \r\n    \r\n\r\n",
            "date": "2022-09-28 14:55:17.459381+00:00",
            "passed": false
        },
        {
            "bite": "Bite 11. Enrich a class with dunder methods",
            "code": "class Account:\r\n\r\n    def __init__(self, name, start_balance=0):\r\n        self.name = name\r\n        self.start_balance = start_balance\r\n        self._transactions = []\r\n\r\n    @property\r\n    def balance(self):\r\n        return self.start_balance + sum(self._transactions)\r\n\r\n    #\u00a0add dunder methods below\r\n    def __lt__(self,account):\r\n        return self.balance <account.balance\r\n    def __le__(self,account):\r\n        return self.balance <=account.balance\r\n    def __gt__(self,account):\r\n        return self.balance >account.balance\r\n    def __ge__(self,account):\r\n        return self.balance >=account.balance\r\n    def __eq__(self,account):\r\n        return self.balance >=account.balance\r\n  \r\n        \r\nacc1 = Account('aac1', 100)\r\nacc2 = Account('aac2', 200)\r\n\r\nprint(acc1 == acc1)\r\n    \r\n    \r\n\r\n",
            "date": "2022-09-28 14:48:15.323280+00:00",
            "passed": false
        },
        {
            "bite": "Bite 25. No promo twice, keep state in a class",
            "code": "import random\r\n\r\nBITES = {6: 'PyBites Die Hard',\r\n         7: 'Parsing dates from logs',\r\n         9: 'Palindromes',\r\n         10: 'Practice exceptions',\r\n         11: 'Enrich a class with dunder methods',\r\n         12: 'Write a user validation function',\r\n         13: 'Convert dict in namedtuple/json',\r\n         14: 'Generate a table of n sequences',\r\n         15: 'Enumerate 2 sequences',\r\n         16: 'Special PyBites date generator',\r\n         17: 'Form teams from a group of friends',\r\n         18: 'Find the most common word',\r\n         19: 'Write a simple property',\r\n         20: 'Write a context manager',\r\n         21: 'Query a nested data structure'}\r\nBITES_DONE = {6, 10, 16, 18, 21}\r\n\r\n\r\nclass NoBitesAvailable(Exception):\r\n    \"\"\"There are no more Bites available to pick from\"\"\"\r\n\r\n\r\nclass Promo:\r\n\r\n    def __init__(self):\r\n        # updated Bite to make local copies (avoid globals!)\r\n        self.all_bites = BITES.copy()\r\n        self.bites_done = BITES_DONE.copy()\r\n\r\n    def _pick_random_bite(self):\r\n        \"\"\"Pick a random Bite that is not done yet, if all\r\n           Bites are done, raise a NoBitesAvailable exception\"\"\"\r\n        pending_bites = self.all_bites.keys()-self.bites_done\r\n        if len(pending_bites)==0:\r\n            raise NoBitesAvailable\r\n        return random.choice(list(pending_bites))\r\n\r\n    def new_bite(self):\r\n        \"\"\"Get  a random Bite using _pick_random_bite,\r\n           add it to self.bites_done, then return it\"\"\"\r\n        bite = self._pick_random_bite()\r\n        self.bites_done.add(bite)\r\n        return bite\r\n\r\nif __name__ == \"__main__\":\r\n    promo=Promo()\r\n    for _ in range(11):\r\n        next_bite=promo.new_bite()\r\n        print(f\"{next_bite=}\")\r\n        print(f\"{promo.bites_done=}\")\r\n",
            "date": "2022-09-27 22:59:43.760741+00:00",
            "passed": true
        },
        {
            "bite": "Bite 22. Write a decorator with argument",
            "code": "from functools import wraps\r\n\r\n\r\ndef make_html(element):\r\n    \r\n    def decorate(fn):\r\n        @wraps(fn)\r\n        def wrapper(*args, **kwargs):\r\n            return f\"<{element}>\" + fn(*args, **kwargs) + f\"</{element}>\"\r\n        return wrapper\r\n    return decorate\r\n\r\n\r\n@make_html('p')\r\n@make_html('strong')\r\ndef get_text(text='I code with PyBites'):\r\n    return text\r\n    \r\nprint(get_text(\"a test\"))",
            "date": "2022-09-27 22:21:52.025803+00:00",
            "passed": true
        },
        {
            "bite": "Bite 17. Form teams from a group of friends",
            "code": "from itertools import permutations, combinations\r\n\r\ndef friends_teams(friends_list, team_size:int = 2, order_does_matter:bool = False):\r\n    if order_does_matter:\r\n        return permutations(friends_list,team_size)\r\n    else:\r\n        return combinations(friends_list,team_size)\r\n        \r\n        \r\nfriends = 'Bob Dante Julian Martin'.split()\r\n\r\nprint(list(friends_teams(friends, team_size = 3, order_does_matter = False)))",
            "date": "2022-09-27 21:47:54.206224+00:00",
            "passed": true
        },
        {
            "bite": "Bite 17. Form teams from a group of friends",
            "code": "from itertools import permutations, combinations\r\n\r\ndef friends_teams(friends_list, team_size:int = 2, order_does_matter:bool = False):\r\n    return permutations(friends_list,team_size) \\\r\n        if order_does_matter else \\\r\n        combinations(friends_list,team_size)\r\n        \r\n        \r\nfriends = 'Bob Dante Julian Martin'.split()\r\n\r\nprint(list(friends_teams(friends,order_does_matter = True)))",
            "date": "2022-09-27 21:45:46.691006+00:00",
            "passed": true
        },
        {
            "bite": "Bite 56. Add a command line interface to our BMI calculator",
            "code": "import argparse\r\n\r\n\r\ndef calc_bmi(weight, length):\r\n    \"\"\"Provided/DONE:\r\n       Calc BMI give a weight in kg and length in cm, return the BMI\r\n       rounded on 2 decimals\"\"\"\r\n    bmi = int(weight) / ((int(length) / 100) ** 2)\r\n    return round(bmi, 2)\r\n\r\n\r\ndef create_parser():\r\n    \"\"\"TODO:\r\n       Create an ArgumentParser adding the right arguments to pass the tests,\r\n       returns a argparse.ArgumentParser object\"\"\"\r\n\r\n    parser = argparse.ArgumentParser(description=\"Calculate your BMI.\")\r\n    parser.add_argument(\"-w\", \"--weight\", type=float, help=\"Your weight in kg\")\r\n    parser.add_argument(\"-l\", \"--length\", type=float, help=\"Your length in cm\")\r\n    return parser\r\n\r\n\r\ndef handle_args(args=None):\r\n    \"\"\"Provided/DONE:\r\n       Call calc_bmi with provided args object.\r\n       If args are not provided get them from create_parser\"\"\"\r\n    if args is None:\r\n        parser = create_parser()\r\n        args = parser.parse_args()\r\n\r\n    if args.weight and args.length:\r\n        bmi = calc_bmi(args.weight, args.length)\r\n        print(f\"Your BMI is: {bmi}\")\r\n    else:\r\n        # could enforce SystemExit in create_parser/add_argument, but argparse\r\n        # docs are not clear how to do it, so raising the exception here manually\r\n        raise SystemExit\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    handle_args()",
            "date": "2022-09-27 09:37:10.630298+00:00",
            "passed": true
        },
        {
            "bite": "Bite 56. Add a command line interface to our BMI calculator",
            "code": "import argparse\r\n\r\n\r\ndef calc_bmi(weight, length):\r\n    \"\"\"Provided/DONE:\r\n       Calc BMI give a weight in kg and length in cm, return the BMI\r\n       rounded on 2 decimals\"\"\"\r\n    bmi = int(weight) / ((int(length) / 100) ** 2)\r\n    return round(bmi, 2)\r\n\r\n\r\ndef create_parser():\r\n    \"\"\"TODO:\r\n       Create an ArgumentParser adding the right arguments to pass the tests,\r\n       returns a argparse.ArgumentParser object\"\"\"\r\n    \r\n    parser = argparse.ArgumentParser(description='Calculate your BMI.')\r\n    parser.add_argument('-w','--weight', type=float, help='Your weight in kg')\r\n    parser.add_argument('-l','--length', type=float, help='Your length in cm')\r\n    return parser\r\n    \r\n\r\ndef handle_args(args=None):\r\n    \"\"\"Provided/DONE:\r\n       Call calc_bmi with provided args object.\r\n       If args are not provided get them from create_parser\"\"\"\r\n    if args is None:\r\n        parser = create_parser()\r\n        args = parser.parse_args()\r\n\r\n    if args.weight and args.length:\r\n        bmi = calc_bmi(args.weight, args.length)\r\n        print(f'Your BMI is: {bmi}')\r\n    else:\r\n        # could enforce SystemExit in create_parser/add_argument, but argparse\r\n        # docs are not clear how to do it, so raising the exception here manually\r\n        raise SystemExit\r\n\r\n\r\nif __name__ == '__main__':\r\n    handle_args()",
            "date": "2022-09-27 09:35:46.857109+00:00",
            "passed": true
        },
        {
            "bite": "Bite 66. Calculate the running average of a sequence",
            "code": "from itertools import accumulate\r\nimport operator\r\n\r\ndef running_mean(sequence):\r\n    \"\"\"Calculate the running mean of the sequence passed in,\r\n       returns a sequence of same length with the averages.\r\n       You can assume all items in sequence are numeric.\"\"\"\r\n    return (round(part_sum/(i+1),2) for i, part_sum in enumerate(accumulate(sequence, operator.add)))\r\n\r\n# print(list(running_mean([1,2,4,9,11,26])))",
            "date": "2022-09-26 17:59:12.991209+00:00",
            "passed": true
        },
        {
            "bite": "Bite 66. Calculate the running average of a sequence",
            "code": "from itertools import accumulate\r\nimport operator\r\n\r\ndef running_mean(sequence):\r\n    \"\"\"Calculate the running mean of the sequence passed in,\r\n       returns a sequence of same length with the averages.\r\n       You can assume all items in sequence are numeric.\"\"\"\r\n    return (round(sum/(i+1),2) for i,sum in enumerate(accumulate(sequence, operator.add)))\r\n\r\n# print(list(running_mean([1,2,4,9,11,26])))",
            "date": "2022-09-26 17:58:14.918425+00:00",
            "passed": true
        },
        {
            "bite": "Bite 66. Calculate the running average of a sequence",
            "code": "from itertools import accumulate\r\nimport operator\r\n\r\ndef running_mean(sequence):\r\n    \"\"\"Calculate the running mean of the sequence passed in,\r\n       returns a sequence of same length with the averages.\r\n       You can assume all items in sequence are numeric.\"\"\"\r\n    return (sum/(i+1) for i,sum in enumerate(accumulate(sequence, operator.add)))\r\n\r\n# print(list(running_mean([1,2,3,4,5,6,7,8,9])))",
            "date": "2022-09-26 17:55:36.699716+00:00",
            "passed": false
        },
        {
            "bite": "Bite 66. Calculate the running average of a sequence",
            "code": "from itertools import accumulate\r\nimport operator\r\n\r\ndef running_mean(sequence):\r\n    \"\"\"Calculate the running mean of the sequence passed in,\r\n       returns a sequence of same length with the averages.\r\n       You can assume all items in sequence are numeric.\"\"\"\r\n    sums= accumulate(sequence, operator.add)\r\n    avgs= (sum/(i+1) for i,sum in enumerate(sums))\r\n    return avgs\r\n\r\n# print(list(running_mean([1,2,3,4,5,6,7,8,9])))",
            "date": "2022-09-26 17:54:39.472037+00:00",
            "passed": false
        },
        {
            "bite": "Bite 14. Generate a table of n sequences",
            "code": "import random\r\nfrom pprint import pprint \r\n\r\nnames = ['Julian', 'Bob', 'PyBites', 'Dante', 'Martin', 'Rodolfo']\r\naliases = ['Pythonista', 'Nerd', 'Coder'] * 2\r\npoints = random.sample(range(81, 101), 6)\r\nawake = [True, False] * 3\r\nSEPARATOR = ' | '\r\n\r\n\r\ndef generate_table(*argv):\r\n    return (SEPARATOR.join([str(arg[i]) for arg in argv]) for i in range(0,len(argv[0])))\r\n        \r\n\r\npprint(list(generate_table(names, aliases,points,awake)))",
            "date": "2022-09-26 17:15:54.385633+00:00",
            "passed": true
        },
        {
            "bite": "Bite 2. Regex Fun",
            "code": "import re\r\n\r\nCOURSE = ('Introduction 1 Lecture 01:47'\r\n          'The Basics 4 Lectures 32:03'\r\n          'Getting Technical!  4 Lectures 41:51'\r\n          'Challenge 2 Lectures 27:48'\r\n          'Afterword 1 Lecture 05:02')\r\nTWEET = ('New PyBites article: Module of the Week - Requests-cache '\r\n         'for Repeated API Calls - http://pybit.es/requests-cache.html '\r\n         '#python #APIs')\r\nHTML = ('<p>pybites != greedy</p>'\r\n        '<p>not the same can be said REgarding ...</p>')\r\n\r\n\r\ndef extract_course_times(course=COURSE):\r\n    \"\"\"Return the course timings from the passed in\r\n       course string. Timings are in mm:ss (minutes:seconds)\r\n       format, so taking COURSE above you would extract:\r\n       ['01:47', '32:03', '41:51', '27:48', '05:02']\r\n       Return this list.\r\n    \"\"\"\r\n    return re.findall(r'(\\d\\d:\\d\\d)', course)\r\n\r\n\r\ndef get_all_hashtags_and_links(tweet=TWEET):\r\n    \"\"\"Get all hashtags and links from the tweet text\r\n       that is passed into this function. So for TWEET\r\n       above you need to extract the following list:\r\n       ['http://pybit.es/requests-cache.html',\r\n        '#python',\r\n        '#APIs']\r\n       Return this list.\r\n    \"\"\"\r\n    return re.findall(r'http://\\S*|#\\S*',tweet)\r\n\r\n\r\ndef match_first_paragraph(html=HTML):\r\n    \"\"\"Extract the first paragraph of the passed in\r\n       html, so for HTML above this would be:\r\n       'pybites != greedy' (= content of first paragraph).\r\n       Return this string.\r\n    \"\"\"\r\n    return re.findall(r'<p>(.*?)</p>',html)[0]\r\n    \r\n    \r\ntest_tweet = ('PyBites My Reading List | 12 Rules for Life - #books '\r\n             'that expand the mind! '\r\n             'http://pbreadinglist.herokuapp.com/books/'\r\n             'TvEqDAAAQBAJ#.XVOriU5z2tA.twitter'\r\n             ' #psychology #philosophy')\r\n\r\n\r\n# print(extract_course_times())\r\n# print(match_first_paragraph())\r\n# print(get_all_hashtags_and_links(test_tweet))",
            "date": "2022-09-25 23:11:03.726372+00:00",
            "passed": true
        },
        {
            "bite": "Bite 2. Regex Fun",
            "code": "import re\r\n\r\nCOURSE = ('Introduction 1 Lecture 01:47'\r\n          'The Basics 4 Lectures 32:03'\r\n          'Getting Technical!  4 Lectures 41:51'\r\n          'Challenge 2 Lectures 27:48'\r\n          'Afterword 1 Lecture 05:02')\r\nTWEET = ('New PyBites article: Module of the Week - Requests-cache '\r\n         'for Repeated API Calls - http://pybit.es/requests-cache.html '\r\n         '#python #APIs')\r\nHTML = ('<p>pybites != greedy</p>'\r\n        '<p>not the same can be said REgarding ...</p>')\r\n\r\n\r\ndef extract_course_times(course=COURSE):\r\n    \"\"\"Return the course timings from the passed in\r\n       course string. Timings are in mm:ss (minutes:seconds)\r\n       format, so taking COURSE above you would extract:\r\n       ['01:47', '32:03', '41:51', '27:48', '05:02']\r\n       Return this list.\r\n    \"\"\"\r\n    return re.findall(r'(\\d\\d:\\d\\d)', course)\r\n\r\n\r\ndef get_all_hashtags_and_links(tweet=TWEET):\r\n    \"\"\"Get all hashtags and links from the tweet text\r\n       that is passed into this function. So for TWEET\r\n       above you need to extract the following list:\r\n       ['http://pybit.es/requests-cache.html',\r\n        '#python',\r\n        '#APIs']\r\n       Return this list.\r\n    \"\"\"\r\n    return re.findall(r'\\s(http://\\S*)',tweet) + re.findall(r'\\s(#\\S*)',tweet)\r\n\r\n\r\ndef match_first_paragraph(html=HTML):\r\n    \"\"\"Extract the first paragraph of the passed in\r\n       html, so for HTML above this would be:\r\n       'pybites != greedy' (= content of first paragraph).\r\n       Return this string.\r\n    \"\"\"\r\n    return re.findall(r'<p>(.*?)</p>',html)[0]\r\n    \r\n    \r\ntest_tweet = ('PyBites My Reading List | 12 Rules for Life - #books '\r\n             'that expand the mind! '\r\n             'http://pbreadinglist.herokuapp.com/books/'\r\n             'TvEqDAAAQBAJ#.XVOriU5z2tA.twitter'\r\n             ' #psychology #philosophy')\r\n\r\n\r\nprint(extract_course_times())\r\nprint(match_first_paragraph())\r\nprint(get_all_hashtags_and_links(test_tweet))",
            "date": "2022-09-25 23:01:22.430972+00:00",
            "passed": false
        },
        {
            "bite": "Bite 2. Regex Fun",
            "code": "import re\r\n\r\nCOURSE = ('Introduction 1 Lecture 01:47'\r\n          'The Basics 4 Lectures 32:03'\r\n          'Getting Technical!  4 Lectures 41:51'\r\n          'Challenge 2 Lectures 27:48'\r\n          'Afterword 1 Lecture 05:02')\r\nTWEET = ('New PyBites article: Module of the Week - Requests-cache '\r\n         'for Repeated API Calls - http://pybit.es/requests-cache.html '\r\n         '#python #APIs')\r\nHTML = ('<p>pybites != greedy</p>'\r\n        '<p>not the same can be said REgarding ...</p>')\r\n\r\n\r\ndef extract_course_times(course=COURSE):\r\n    \"\"\"Return the course timings from the passed in\r\n       course string. Timings are in mm:ss (minutes:seconds)\r\n       format, so taking COURSE above you would extract:\r\n       ['01:47', '32:03', '41:51', '27:48', '05:02']\r\n       Return this list.\r\n    \"\"\"\r\n    return re.findall('(\\d\\d:\\d\\d)', course)\r\n\r\n\r\ndef get_all_hashtags_and_links(tweet=TWEET):\r\n    \"\"\"Get all hashtags and links from the tweet text\r\n       that is passed into this function. So for TWEET\r\n       above you need to extract the following list:\r\n       ['http://pybit.es/requests-cache.html',\r\n        '#python',\r\n        '#APIs']\r\n       Return this list.\r\n    \"\"\"\r\n    return re.findall('(http://\\S*)',tweet) + re.findall('(#\\S*)',tweet)\r\n\r\n\r\ndef match_first_paragraph(html=HTML):\r\n    \"\"\"Extract the first paragraph of the passed in\r\n       html, so for HTML above this would be:\r\n       'pybites != greedy' (= content of first paragraph).\r\n       Return this string.\r\n    \"\"\"\r\n    return re.findall('<p>(.*?)</p>',html)[0]\r\n    \r\nprint(extract_course_times())\r\nprint(match_first_paragraph())\r\nprint(get_all_hashtags_and_links())\r\n",
            "date": "2022-09-25 22:57:33.835448+00:00",
            "passed": false
        },
        {
            "bite": "Bite 12. Write a user validation function",
            "code": "from collections import namedtuple\r\n\r\nUser = namedtuple('User', 'name role expired')\r\nUSER, ADMIN = 'user', 'admin'\r\nSECRET = 'I am a very secret token'\r\n\r\njulian = User(name='Julian', role=USER, expired=False)\r\nbob = User(name='Bob', role=USER, expired=True)\r\npybites = User(name='PyBites', role=ADMIN, expired=False)\r\nUSERS = (julian, bob, pybites)\r\n\r\n# define exception classes here\r\nclass UserDoesNotExist(Exception):\r\n    \"\"\"Raised when the user does not exist\"\"\"\r\n    pass\r\n\r\nclass UserAccessExpired(Exception):\r\n    \"\"\"Raised when user access is expired\"\"\"\r\n    pass\r\n\r\nclass UserNoPermission(Exception):\r\n    \"\"\"Raised when the user is not Admin\"\"\"\r\n    pass\r\n\r\ndef get_secret_token(username):\r\n    try:\r\n        user=[user for user in USERS if user.name.lower() == username.lower()][0]\r\n    except:\r\n        raise UserDoesNotExist\r\n\r\n    if user.expired == True:\r\n        raise UserAccessExpired\r\n    if not user.role == ADMIN:\r\n        raise UserNoPermission\r\n    return SECRET\r\n    \r\n# get_secret_token('Bob')",
            "date": "2022-09-25 21:53:04.977762+00:00",
            "passed": true
        },
        {
            "bite": "Bite 12. Write a user validation function",
            "code": "from collections import namedtuple\r\n\r\nUser = namedtuple('User', 'name role expired')\r\nUSER, ADMIN = 'user', 'admin'\r\nSECRET = 'I am a very secret token'\r\n\r\njulian = User(name='Julian', role=USER, expired=False)\r\nbob = User(name='Bob', role=USER, expired=True)\r\npybites = User(name='PyBites', role=ADMIN, expired=False)\r\nUSERS = (julian, bob, pybites)\r\n\r\n# define exception classes here\r\nclass UserDoesNotExist(Exception):\r\n    \"\"\"Raised when the user does not exist\"\"\"\r\n    pass\r\n\r\nclass UserAccessExpired(Exception):\r\n    \"\"\"Raised when user access is expired\"\"\"\r\n    pass\r\n\r\nclass UserNoPermission(Exception):\r\n    \"\"\"Raised when the user is not Admin\"\"\"\r\n    pass\r\n\r\ndef get_secret_token(username):\r\n    try:\r\n        user=[user for user in USERS if user.name.lower() == username.lower()][0]\r\n        print(f\"{user=}\")\r\n    except:\r\n        raise UserDoesNotExist\r\n\r\n    if user.expired == True:\r\n        raise UserAccessExpired\r\n    if not user.role == ADMIN:\r\n        raise UserNoPermission\r\n    return SECRET\r\n    \r\n# get_secret_token('Bob')",
            "date": "2022-09-25 21:50:40.155286+00:00",
            "passed": true
        },
        {
            "bite": "Bite 12. Write a user validation function",
            "code": "from collections import namedtuple\r\n\r\nUser = namedtuple('User', 'name role expired')\r\nUSER, ADMIN = 'user', 'admin'\r\nSECRET = 'I am a very secret token'\r\n\r\njulian = User(name='Julian', role=USER, expired=False)\r\nbob = User(name='Bob', role=USER, expired=True)\r\npybites = User(name='PyBites', role=ADMIN, expired=False)\r\nUSERS = (julian, bob, pybites)\r\n\r\n# define exception classes here\r\nclass UserDoesNotExist(Exception):\r\n    \"\"\"Raised when the user does not exist\"\"\"\r\n    pass\r\n\r\nclass UserAccessExpired(Exception):\r\n    \"\"\"Raised when user access is expired\"\"\"\r\n    pass\r\n\r\nclass UserNoPermission(Exception):\r\n    \"\"\"Raised when the user is not Admin\"\"\"\r\n    pass\r\n\r\ndef get_secret_token(username):\r\n    try:\r\n        user=[user for user in USERS if user.name.lower() == username.lower()][0]\r\n        print(f\"{user=}\")\r\n    except:\r\n        raise UserDoesNotExist\r\n\r\n    if user.expired == True:\r\n        raise UserAccessExpired\r\n    if not user.role == ADMIN:\r\n        raise UserNoPermission\r\n    return SECRET\r\n    \r\nget_secret_token('Bob')",
            "date": "2022-09-25 21:50:32.333815+00:00",
            "passed": false
        },
        {
            "bite": "Bite 12. Write a user validation function",
            "code": "from collections import namedtuple\r\n\r\nUser = namedtuple('User', 'name role expired')\r\nUSER, ADMIN = 'user', 'admin'\r\nSECRET = 'I am a very secret token'\r\n\r\njulian = User(name='Julian', role=USER, expired=False)\r\nbob = User(name='Bob', role=USER, expired=True)\r\npybites = User(name='PyBites', role=ADMIN, expired=False)\r\nUSERS = (julian, bob, pybites)\r\n\r\n# define exception classes here\r\nclass UserDoesNotExist(Exception):\r\n    \"\"\"Raised when the user does not exist\"\"\"\r\n    pass\r\n\r\nclass UserAccessExpired(Exception):\r\n    \"\"\"Raised when user access is expired\"\"\"\r\n    pass\r\n\r\nclass UserNoPermission(Exception):\r\n    \"\"\"Raised when the user is not Admin\"\"\"\r\n    pass\r\n\r\ndef get_secret_token(username):\r\n    if username.lower() not in USERS:\r\n        raise UserDoesNotExist\r\n    if username.expired:\r\n        raise AccessExpired\r\n    if not username.role == ADMIN:\r\n        raise UserNoPermission\r\n    return SECRET\r\n    \r\n\r\n# get_secret_token('Tim')\r\n# get_secret_token('Bob')\r\n# get_secret_token('Julian')\r\n# print(get_secret_token('PyBites'))",
            "date": "2022-09-25 21:31:07.607873+00:00",
            "passed": false
        },
        {
            "bite": "Bite 12. Write a user validation function",
            "code": "from collections import namedtuple\r\n\r\nUser = namedtuple('User', 'name role expired')\r\nUSER, ADMIN = 'user', 'admin'\r\nSECRET = 'I am a very secret token'\r\n\r\njulian = User(name='Julian', role=USER, expired=False)\r\nbob = User(name='Bob', role=USER, expired=True)\r\npybites = User(name='PyBites', role=ADMIN, expired=False)\r\nUSERS = (julian, bob, pybites)\r\n\r\n# define exception classes here\r\nclass UserDoesNotExist(Exception):\r\n    \"\"\"Raised when the user does not exist\"\"\"\r\n    pass\r\n\r\nclass UserAccessExpired(Exception):\r\n    \"\"\"Raised when user access is expired\"\"\"\r\n    pass\r\n\r\nclass UserNoPermission(Exception):\r\n    \"\"\"Raised when the user is not Admin\"\"\"\r\n    pass\r\n\r\ndef get_secret_token(username):\r\n    if username not in USERS:\r\n        raise UserDoesNotExist\r\n    if username.expired:\r\n        raise AccessExpired\r\n    if not username.role == ADMIN:\r\n        raise UserNoPermission\r\n    return SECRET\r\n    \r\n\r\n# get_secret_token('Tim')\r\n# get_secret_token('Bob')\r\n# get_secret_token('Julian')\r\n# print(get_secret_token('PyBites'))",
            "date": "2022-09-25 21:30:02.465225+00:00",
            "passed": false
        },
        {
            "bite": "Bite 10. Practice exceptions",
            "code": "def positive_divide(numerator, denominator):\r\n    try: \r\n        result = numerator/denominator\r\n        if result < 0:\r\n            raise ValueError\r\n    except ZeroDivisionError:\r\n        return 0\r\n    except TypeError:\r\n        raise TypeError(\"I caught a TypeError\")\r\n    except ValueError:\r\n        raise ValueError(\"I caught a negative result\")\r\n    \r\n    return result\r\n\r\n# print(positive_divide(-1,2))\r\n# print(positive_divide(2,-1))\r\n# print(positive_divide(1, 's'))\r\n# print(positive_divide([], 2))\r\n# print(positive_divide(1,\"two\"))",
            "date": "2022-09-25 21:17:46.737278+00:00",
            "passed": true
        },
        {
            "bite": "Bite 10. Practice exceptions",
            "code": "def positive_divide(numerator, denominator):\r\n    try: \r\n        result = numerator/denominator\r\n        if result < 0:\r\n            raise ValueError(\"I caught a negative result\")\r\n    except ZeroDivisionError:\r\n        return 0\r\n    except TypeError:\r\n        raise TypeError(\"I caught a TypeError\")\r\n    \"\"\"\r\n    except ValueError:\r\n        raise ValueError(\"I caught a negative result\")\r\n    \"\"\"\r\n    \r\n    return result\r\n\r\n# print(positive_divide(-1,2))\r\n# print(positive_divide(2,-1))\r\n# print(positive_divide(1, 's'))\r\n# print(positive_divide([], 2))\r\n# print(positive_divide(1,\"two\"))",
            "date": "2022-09-25 21:17:04.782339+00:00",
            "passed": true
        },
        {
            "bite": "Bite 10. Practice exceptions",
            "code": "def positive_divide(numerator, denominator):\r\n    try: \r\n        result = numerator/denominator\r\n        if result < 0:\r\n            raise ValueError(\"I caught a negative result\")\r\n    except ZeroDivisionError:\r\n        return 0\r\n    except TypeError:\r\n        raise TypeError(\"I caught a TypeError\")\r\n    \"\"\"\r\n    except ValueError:\r\n        raise ValueError(\"I caught a negative result\")\r\n    \"\"\"\r\n    \r\n    return result\r\n\r\nprint(positive_divide(-1,2))\r\nprint(positive_divide(2,-1))\r\n# print(positive_divide(1, 's'))\r\n# print(positive_divide([], 2))\r\n# print(positive_divide(1,\"two\"))",
            "date": "2022-09-25 21:16:47.975452+00:00",
            "passed": false
        },
        {
            "bite": "Bite 10. Practice exceptions",
            "code": "def positive_divide(numerator, denominator):\r\n    try: \r\n        result = numerator/denominator\r\n        if result < 0:\r\n            raise ValueError\r\n    except ZeroDivisionError:\r\n        return 0\r\n    except TypeError:\r\n        raise TypeError(\"I caught a TypeError\")\r\n    except ValueError:\r\n        raise ValueError(\"I caught a negative result\")\r\n\r\n    return result\r\n\r\n# print(positive_divide(-1,2))\r\nprint(positive_divide(2,-1))\r\nprint(positive_divide(1,\"two\"))\r\n",
            "date": "2022-09-25 21:13:04.926897+00:00",
            "passed": false
        },
        {
            "bite": "Bite 10. Practice exceptions",
            "code": "def positive_divide(numerator, denominator):\r\n    try: \r\n        result = numerator/denominator\r\n        if result < 0:\r\n            raise ValueError\r\n    except ZeroDivisionError:\r\n        return 0\r\n    except TypeError:\r\n        raise TypeError(\"I caught a TypeError\")\r\n    except ValueError:\r\n        raise ValueError(\"I caught a negative result\")\r\n\r\n    return result\r\n\r\nprint(positive_divide(-1,2))\r\nprint(positive_divide(2,-1))\r\nprint(positive_divide(1,\"two\"))\r\n",
            "date": "2022-09-25 19:00:43.074261+00:00",
            "passed": false
        },
        {
            "bite": "Bite 9. Palindromes",
            "code": "\"\"\"A palindrome is a word, phrase, number, or other sequence of characters\r\nwhich reads the same backward as forward\"\"\"\r\nimport os\r\nimport urllib.request\r\nimport string\r\n\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nDICTIONARY = os.path.join(TMP, 'dictionary_m_words.txt')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/dictionary_m_words.txt',\r\n    DICTIONARY\r\n)\r\n\r\n\r\ndef load_dictionary():\r\n    \"\"\"Load dictionary (sample) and return as generator (done)\"\"\"\r\n    with open(DICTIONARY) as f:\r\n        return (word.lower().strip() for word in f.readlines())\r\n\r\n\r\ndef _as_stripped_list(word):\r\n    return [letter for letter in word.lower() if letter in string.ascii_lowercase]\r\n\r\ndef is_palindrome(word):\r\n    \"\"\"Return if word is palindrome, 'madam' would be one.\r\n       Case insensitive, so Madam is valid too.\r\n       It should work for phrases too so strip all but alphanumeric chars.\r\n       So \"No 'x' in 'Nixon'\" should pass (see tests for more)\"\"\"\r\n    stripped_lst = _as_stripped_list(word)\r\n    return stripped_lst == list(reversed(stripped_lst))\r\n\r\n\r\ndef get_longest_palindrome(words=None):\r\n    \"\"\"Given a list of words return the longest palindrome\r\n       If called without argument use the load_dictionary helper\r\n       to populate the words list\"\"\"\r\n    if words is None:\r\n        words = load_dictionary()\r\n    \r\n    longest_palindrome =\"\" \r\n    length= 0\r\n    for word in words:\r\n        if is_palindrome(word):\r\n            len_lst = len(_as_stripped_list(word))\r\n            if len_lst > length:\r\n                longest_palindrome = word\r\n                length = len_lst\r\n    return longest_palindrome\r\n\r\nprint(is_palindrome(\"No 'x' in 'Nixon'\"))\r\n\r\nword_list =\"\"\"\r\nAibohphobia\r\n'Avid diva\r\nAvid diva. \r\nA Toyota\u2019s a Toyota.\r\nA man, a plan, a canal: Panama\r\nNo 'x in 'Nixon'\r\nmalayalam\r\nPyBites\r\ntoyota\r\npalindrome\r\n\"\"\"\r\nprint(get_longest_palindrome(word_list.splitlines()))\r\n",
            "date": "2022-09-25 18:31:09.414892+00:00",
            "passed": true
        },
        {
            "bite": "Bite 9. Palindromes",
            "code": "\"\"\"A palindrome is a word, phrase, number, or other sequence of characters\r\nwhich reads the same backward as forward\"\"\"\r\nimport os\r\nimport urllib.request\r\nimport string\r\n\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nDICTIONARY = os.path.join(TMP, 'dictionary_m_words.txt')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/dictionary_m_words.txt',\r\n    DICTIONARY\r\n)\r\n\r\n\r\ndef load_dictionary():\r\n    \"\"\"Load dictionary (sample) and return as generator (done)\"\"\"\r\n    with open(DICTIONARY) as f:\r\n        return (word.lower().strip() for word in f.readlines())\r\n\r\n\r\ndef _as_stripped_list(word):\r\n    return [letter for letter in word.lower() if letter in string.ascii_lowercase]\r\n\r\ndef is_palindrome(word):\r\n    \"\"\"Return if word is palindrome, 'madam' would be one.\r\n       Case insensitive, so Madam is valid too.\r\n       It should work for phrases too so strip all but alphanumeric chars.\r\n       So \"No 'x' in 'Nixon'\" should pass (see tests for more)\"\"\"\r\n    stripped_lst = _as_stripped_list(word)\r\n    return stripped_lst == list(reversed(stripped_lst))\r\n\r\n\r\ndef get_longest_palindrome(words=None):\r\n    \"\"\"Given a list of words return the longest palindrome\r\n       If called without argument use the load_dictionary helper\r\n       to populate the words list\"\"\"\r\n    if words is None:\r\n        words = load_dictionary\r\n    \r\n    longest_palindrome =\"\" \r\n    length= 0\r\n    for word in words:\r\n        if is_palindrome(word):\r\n            len_lst = len(_as_stripped_list(word))\r\n            if len_lst > length:\r\n                longest_palindrome = word\r\n                length = len_lst\r\n    return longest_palindrome\r\n\r\nprint(is_palindrome(\"No 'x' in 'Nixon'\"))\r\n\r\nword_list =\"\"\"\r\nAibohphobia\r\n'Avid diva\r\nAvid diva. \r\nA Toyota\u2019s a Toyota.\r\nA man, a plan, a canal: Panama\r\nNo 'x in 'Nixon'\r\nmalayalam\r\nPyBites\r\ntoyota\r\npalindrome\r\n\"\"\"\r\nprint(get_longest_palindrome(word_list.splitlines()))\r\n",
            "date": "2022-09-25 18:30:34.746666+00:00",
            "passed": false
        },
        {
            "bite": "Bite 7. Parsing dates from logs",
            "code": "from datetime import datetime\r\nimport os\r\nimport urllib.request\r\n\r\nSHUTDOWN_EVENT = 'Shutdown initiated'\r\n\r\n# prep: read in the logfile\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\nlogfile = os.path.join(tmp, 'log')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/messages.log',\r\n    logfile\r\n)\r\n\r\nwith open(logfile) as f:\r\n    loglines = f.readlines()\r\n\r\n\r\n# for you to code:\r\n\r\ndef convert_to_datetime(line):\r\n    \"\"\"TODO 1:\r\n       Extract timestamp from logline and convert it to a datetime object.\r\n       For example calling the function with:\r\n       INFO 2014-07-03T23:27:51 supybot Shutdown complete.\r\n       returns:\r\n       datetime(2014, 7, 3, 23, 27, 51)\r\n    \"\"\"\r\n    label, timestamp, msg = tuple (line.strip().split(\" \", maxsplit=2))\r\n    l_date, l_time = tuple(timestamp.split(\"T\", maxsplit=1))\r\n    year, month, day = tuple(l_date.split(\"-\", maxsplit=2))\r\n    hour, minute, second = tuple(l_time.split(\":\", maxsplit=2))\r\n    return datetime(int(year),int(month),int(day), int(hour),int(minute),int(second))\r\n    \r\n\r\ndef time_between_shutdowns(loglines):\r\n    \"\"\"TODO 2:\r\n       Extract shutdown events (\"Shutdown initiated\") from loglines and\r\n       calculate the timedelta between the first and last one.\r\n       Return this datetime.timedelta object.\r\n    \"\"\"\r\n    shutdown_lines=[line for line in loglines if SHUTDOWN_EVENT in line]\r\n    first_shutdown=convert_to_datetime(shutdown_lines[0])\r\n    last_shutdown=convert_to_datetime(shutdown_lines[-1])\r\n    return last_shutdown-first_shutdown\r\n\r\n\r\nprint(convert_to_datetime(\"       INFO 2014-07-03T23:27:51 supybot Shutdown complete.\"))\r\n\r\n\r\ntest_loglines =\"\"\"\r\nERROR 2014-07-03T23:24:31 supybot Invalid user dictionary file\r\nINFO 2015-10-03T10:12:51 supybot Shutdown initiated.\r\nINFO 2015-10-03T10:13:51 supybot Shutdown continued.\r\nINFO 2015-10-03T10:22:51 supybot Shutdown continued.\r\nINFO 2015-10-03T11:12:51 supybot Shutdown initiated.\r\nINFO 2016-09-03T02:11:22 supybot Shutdown complete.\r\n\"\"\".splitlines()\r\n\r\nprint(time_between_shutdowns(loglines))",
            "date": "2022-09-25 11:47:44.554763+00:00",
            "passed": true
        },
        {
            "bite": "Bite 7. Parsing dates from logs",
            "code": "from datetime import datetime\r\nimport os\r\nimport urllib.request\r\n\r\nSHUTDOWN_EVENT = 'Shutdown initiated'\r\n\r\n# prep: read in the logfile\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\nlogfile = os.path.join(tmp, 'log')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/messages.log',\r\n    logfile\r\n)\r\n\r\nwith open(logfile) as f:\r\n    loglines = f.readlines()\r\n\r\n\r\n# for you to code:\r\n\r\ndef convert_to_datetime(line):\r\n    \"\"\"TODO 1:\r\n       Extract timestamp from logline and convert it to a datetime object.\r\n       For example calling the function with:\r\n       INFO 2014-07-03T23:27:51 supybot Shutdown complete.\r\n       returns:\r\n       datetime(2014, 7, 3, 23, 27, 51)\r\n    \"\"\"\r\n    label, timestamp, msg = tuple (line.strip().split(\" \", maxsplit=2))\r\n    l_date, l_time = tuple(timestamp.split(\"T\", maxsplit=1))\r\n    year, month, day = tuple(l_date.split(\"-\", maxsplit=2))\r\n    hour, minute, second = tuple(l_time.split(\":\", maxsplit=2))\r\n    return datetime(int(year),int(month),int(day), int(hour),int(minute),int(second))\r\n    \r\n\r\ndef time_between_shutdowns(loglines):\r\n    \"\"\"TODO 2:\r\n       Extract shutdown events (\"Shutdown initiated\") from loglines and\r\n       calculate the timedelta between the first and last one.\r\n       Return this datetime.timedelta object.\r\n    \"\"\"\r\n    shutdown_lines=[line for line in loglines.splitlines() if SHUTDOWN_EVENT in line]\r\n    first_shutdown=convert_to_datetime(shutdown_lines[0])\r\n    last_shutdown=convert_to_datetime(shutdown_lines[-1])\r\n    return last_shutdown-first_shutdown\r\n\r\n\r\nprint(convert_to_datetime(\"       INFO 2014-07-03T23:27:51 supybot Shutdown complete.\"))\r\n\r\n\r\nloglines =\"\"\"\r\nERROR 2014-07-03T23:24:31 supybot Invalid user dictionary file\r\nINFO 2015-10-03T10:12:51 supybot Shutdown initiated.\r\nINFO 2015-10-03T10:13:51 supybot Shutdown continued.\r\nINFO 2015-10-03T10:22:51 supybot Shutdown continued.\r\nINFO 2015-10-03T11:12:51 supybot Shutdown initiated.\r\nINFO 2016-09-03T02:11:22 supybot Shutdown complete.\r\n\"\"\"\r\n\r\nprint(time_between_shutdowns(loglines))",
            "date": "2022-09-25 11:43:41.624060+00:00",
            "passed": false
        },
        {
            "bite": "Bite 54. Nicer formatting of a poem or text",
            "code": "INDENTS = 4\r\nrosetti_unformatted = \"\"\"\r\n                      Remember me when I am gone away,\r\n                      Gone far away into the silent land;\r\n                      When you can no more hold me by the hand,\r\n\r\n                      Nor I half turn to go yet turning stay.\r\n\r\n                      Remember me when no more day by day\r\n                      You tell me of our future that you planned:\r\n                      Only remember me; you understand\r\n\"\"\"\r\n\r\nshakespeare_unformatted = \"\"\"\r\n                          To be, or not to be, that is the question:\r\n                          Whether 'tis nobler in the mind to suffer\r\n\r\n                          The slings and arrows of outrageous fortune,\r\n                          Or to take Arms against a Sea of troubles,\r\n                          \"\"\"\r\n\r\n\r\ndef print_hanging_indents(poem):\r\n\r\n    indent =\"\"\r\n    for line in poem.splitlines():\r\n        if len(line.lstrip())==0:\r\n            indent = \"\"\r\n        else:\r\n            print(indent+line.lstrip())\r\n            indent=INDENTS*\" \"\r\n            \r\nprint_hanging_indents(shakespeare_unformatted)",
            "date": "2022-09-25 10:51:39.502928+00:00",
            "passed": true
        },
        {
            "bite": "Bite 46. You are a programmer! Code Fizz Buzz",
            "code": "from typing import Union\r\n\r\n\r\ndef fizzbuzz(num: int) -> Union[str, int]:\r\n    if num%5 == 0 and num%3 == 0:\r\n        result = \"Fizz Buzz\"\r\n    elif num%3 == 0:\r\n        result = \"Fizz\"\r\n    elif num%5 == 0:\r\n        result = \"Buzz\"\r\n    else: \r\n        result = num\r\n    return result\r\n\r\nprint(\", \".join(str(fizzbuzz(i)) for i in range(1,30)))\r\n\r\n",
            "date": "2022-09-23 23:28:43.290226+00:00",
            "passed": true
        },
        {
            "bite": "Bite 46. You are a programmer! Code Fizz Buzz",
            "code": "from typing import Union\r\n\r\n\r\ndef fizzbuzz(num: int) -> Union[str, int]:\r\n    if num%5 == 0 and num%3 == 0:\r\n        result = \"Fizz Buzz\"\r\n    elif num%3 == 0:\r\n        result = \"Fizz\"\r\n    elif num%5 == 0:\r\n        result = \"Buzz\"\r\n    else: \r\n        result = num\r\n    return result\r\n\r\nprint(\", \".join(str(fizzbuzz(i)) for i in range(1,30)))\r\n\r\n# print([fizzbuzz(i) for i in range(1,30)])\r\n",
            "date": "2022-09-23 23:27:45.269498+00:00",
            "passed": true
        },
        {
            "bite": "Bite 45. Keep a queue of last n items",
            "code": "from collections import deque\r\nimport queue\r\n\r\ndef my_queue(n=5):\r\n    return deque([],n)\r\n\r\n\r\nif __name__ == '__main__':\r\n    mq = my_queue()\r\n    for i in range(10):\r\n        mq.append(i)\r\n        print((i, list(mq)))\r\n\r\n    \"\"\"Queue size does not go beyond n int, this outputs:\r\n    (0, [0])\r\n    (1, [0, 1])\r\n    (2, [0, 1, 2])\r\n    (3, [0, 1, 2, 3])\r\n    (4, [0, 1, 2, 3, 4])\r\n    (5, [1, 2, 3, 4, 5])\r\n    (6, [2, 3, 4, 5, 6])\r\n    (7, [3, 4, 5, 6, 7])\r\n    (8, [4, 5, 6, 7, 8])\r\n    (9, [5, 6, 7, 8, 9])\r\n    \"\"\"",
            "date": "2022-09-23 08:38:07.922575+00:00",
            "passed": true
        },
        {
            "bite": "Bite 45. Keep a queue of last n items",
            "code": "from collections import deque\r\nimport queue\r\n\r\ndef my_queue(n=5):\r\n    lst=[]\r\n    return deque(lst,n)\r\n\r\n\r\nif __name__ == '__main__':\r\n    mq = my_queue()\r\n    for i in range(10):\r\n        mq.append(i)\r\n        print((i, list(mq)))\r\n\r\n    \"\"\"Queue size does not go beyond n int, this outputs:\r\n    (0, [0])\r\n    (1, [0, 1])\r\n    (2, [0, 1, 2])\r\n    (3, [0, 1, 2, 3])\r\n    (4, [0, 1, 2, 3, 4])\r\n    (5, [1, 2, 3, 4, 5])\r\n    (6, [2, 3, 4, 5, 6])\r\n    (7, [3, 4, 5, 6, 7])\r\n    (8, [4, 5, 6, 7, 8])\r\n    (9, [5, 6, 7, 8, 9])\r\n    \"\"\"",
            "date": "2022-09-23 08:37:36.396284+00:00",
            "passed": true
        },
        {
            "bite": "Bite 44. License key generator",
            "code": "# use one or more Standard Library modules\r\nimport string\r\nimport secrets\r\n\r\ndef gen_key(parts: int = 4, chars_per_part: int = 8) -> str:\r\n    \"\"\"\r\n    Generate and return a random license key containing\r\n    upper case characters and digits.\r\n\r\n    Example with default \"parts\" and \"chars_per_part\"\r\n    being 4 and 8: KI80OMZ7-5OGYC1AC-735LDPT1-4L11XU1U\r\n\r\n    If parts = 3 and chars_per_part = 4 a random license\r\n    key would look like this: 54N8-I70K-2JZ7\r\n    \"\"\"\r\n    alphabet = string.ascii_uppercase + string.digits\r\n    return '-'.join(''.join(secrets.choice(alphabet) for j in range(chars_per_part)) for i in range(parts))\r\n\r\nprint(gen_key(4,8))\r\n",
            "date": "2022-09-22 20:29:13.693860+00:00",
            "passed": true
        },
        {
            "bite": "Bite 295. Join lists",
            "code": "from typing import List, Union\r\n\r\n\r\ndef join_lists(lst_of_lst: List[List[str]], sep: str) -> Union[List[str], None]:\r\n    if len(lst_of_lst)==0:\r\n        return None\r\n\r\n    joint_lst = [lst + [sep] for lst in lst_of_lst]\r\n    return [item for sublist in joint_lst for item in sublist][:-1]\r\n\r\nprint(join_lists([ ['a']], '&'))\r\nprint(join_lists([ ['a', 'b'], ['c'], ['d', 'e'] ], '+'))",
            "date": "2022-09-22 12:45:25.503900+00:00",
            "passed": true
        },
        {
            "bite": "Bite 295. Join lists",
            "code": "from typing import List, Union\r\n\r\n\r\ndef join_lists(lst_of_lst: List[List[str]], sep: str) -> Union[List[str], None]:\r\n    if len(lst_of_lst)==0:\r\n        return None\r\n    joint_lst = [lst + [sep] for lst in lst_of_lst]\r\n    return [item for sublist in joint_lst for item in sublist][:-1]\r\n\r\nprint(join_lists([ ['a']], '&'))\r\nprint(join_lists([ ['a', 'b'], ['c'], ['d', 'e'] ], '+'))",
            "date": "2022-09-22 12:38:13.429879+00:00",
            "passed": true
        },
        {
            "bite": "Bite 295. Join lists",
            "code": "from typing import List, Union\r\n\r\n\r\ndef join_lists(lst_of_lst: List[List[str]], sep: str) -> Union[List[str], None]:\r\n    if len(lst_of_lst)==0:\r\n        return None\r\n    if len(lst_of_lst) ==1:\r\n        return lst_of_lst[0]\r\n    joint_lst = [lst + [sep] for lst in lst_of_lst]\r\n    flat_list = [item for sublist in joint_lst for item in sublist][:-1]\r\n    return flat_list\r\n\r\nprint(join_lists([ ['a', 'b'], ['c'] ], '&'))\r\nprint(join_lists([ ['a', 'b'], ['c'], ['d', 'e'] ], '+'))",
            "date": "2022-09-22 12:35:53.049660+00:00",
            "passed": true
        },
        {
            "bite": "Bite 295. Join lists",
            "code": "from typing import List, Union\r\n\r\n\r\ndef join_lists(lst_of_lst: List[List[str]], sep: str) -> Union[List[str], None]:\r\n    if len(lst_of_lst)==0:\r\n        return None\r\n    if len(lst_of_lst) ==1:\r\n        return lst_of_lst[0]\r\n    joint_lst = [lst + [sep] for lst in lst_of_lst]\r\n    print(joint_lst)\r\n    flat_list = [item for sublist in joint_lst for item in sublist][:-1]\r\n    print(flat_list)\r\n    return joint_lst\r\n\r\nprint(join_lists([ ['a', 'b'], ['c'] ], '&'))\r\nprint(join_lists([ ['a', 'b'], ['c'], ['d', 'e'] ], '+'))",
            "date": "2022-09-22 12:34:18.209498+00:00",
            "passed": false
        },
        {
            "bite": "Bite 295. Join lists",
            "code": "from typing import List, Union\r\n\r\n\r\ndef join_lists(lst_of_lst: List[List[str]], sep: str) -> Union[List[str], None]:\r\n    if len(lst_of_lst)>1:\r\n        joint_lst = [lst + [sep] for lst in lst_of_lst]\r\n        print(joint_lst)\r\n        flat_list = [item for sublist in joint_lst for item in sublist][:-1]\r\n        print(flat_list)\r\n    else:\r\n        joint_lst = lst_of_lst \r\n    return joint_lst\r\n\r\nprint(join_lists([ ['a', 'b'], ['c'] ], '&'))\r\nprint(join_lists([ ['a', 'b'], ['c'], ['d', 'e'] ], '+'))",
            "date": "2022-09-22 12:29:32.444724+00:00",
            "passed": false
        },
        {
            "bite": "Bite 6. PyBites Die Hard",
            "code": "from collections import Counter, namedtuple\r\nimport os\r\nimport urllib.request\r\n\r\n# prep\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\ntempfile = os.path.join(tmp, 'dirnames')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/dirnames.txt',\r\n    tempfile\r\n)\r\n\r\nIGNORE = ['static', 'templates', 'data', 'pybites', 'bbelderbos', 'hobojoe1848']\r\n\r\nStats = namedtuple('Stats', 'user challenge')\r\n\r\n\r\n# code\r\n\r\ndef gen_files(tempfile=tempfile):\r\n    \"\"\"\r\n    Parse the tempfile passed in, filtering out directory names\r\n    (first column) using the last \"is_dir\" column.\r\n\r\n    Lowercase these directory names and return them as a generator.\r\n\r\n    \"tempfile\" has the following format:\r\n    challenge<int>/file_or_dir<str>,is_dir<bool>\r\n\r\n    For example:\r\n    03/rss.xml,False\r\n    03/tags.html,False\r\n    03/Mridubhatnagar,True\r\n    03/aleksandarknezevic,True\r\n\r\n    => Here you would return 03/mridubhatnagar (lowercased!)\r\n       followed by 03/aleksandarknezevic\r\n    \"\"\"\r\n    \r\n    with open(tempfile) as file:\r\n        for line in file:\r\n            split_line = line.strip().split(\",\")\r\n            if split_line[1] == \"True\":\r\n                yield split_line[0].lower()\r\n\r\n\r\ndef diehard_pybites(files=None):\r\n    \"\"\"\r\n    Return a Stats namedtuple (defined above) that contains:\r\n    1. the user that made the most pull requests (ignoring the users in IGNORE), and\r\n    2. a tuple of:\r\n        (\"most popular challenge id\", \"amount of pull requests for that challenge\")\r\n\r\n    Calling this function on the default dirnames.txt should return:\r\n\r\n    Stats(user='clamytoe', challenge=('01', 7))\r\n    \"\"\"\r\n\r\n    if files is None:\r\n        files = gen_files()\r\n    lst = [line.split(\"/\") for line in files]\r\n    users = Counter([item[1] for item in lst if item[1] not in IGNORE])\r\n    popular_challenges = Counter([item[0] for item in lst if item[1] not in IGNORE])\r\n\r\n    return Stats(user=users.most_common(1)[0][0],\r\n                 challenge=popular_challenges.most_common(1)[0])\r\n\r\n\r\nprint(diehard_pybites())\r\n",
            "date": "2022-09-21 18:47:19.010182+00:00",
            "passed": true
        },
        {
            "bite": "Bite 6. PyBites Die Hard",
            "code": "from collections import Counter, namedtuple\r\nimport os\r\nimport urllib.request\r\n\r\n# prep\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\ntempfile = os.path.join(tmp, 'dirnames')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/dirnames.txt',\r\n    tempfile\r\n)\r\n\r\nIGNORE = ['static', 'templates', 'data', 'pybites', 'bbelderbos', 'hobojoe1848']\r\n\r\nStats = namedtuple('Stats', 'user challenge')\r\n\r\n\r\n# code\r\n\r\ndef gen_files(tempfile=tempfile):\r\n    \"\"\"\r\n    Parse the tempfile passed in, filtering out directory names\r\n    (first column) using the last \"is_dir\" column.\r\n\r\n    Lowercase these directory names and return them as a generator.\r\n\r\n    \"tempfile\" has the following format:\r\n    challenge<int>/file_or_dir<str>,is_dir<bool>\r\n\r\n    For example:\r\n    03/rss.xml,False\r\n    03/tags.html,False\r\n    03/Mridubhatnagar,True\r\n    03/aleksandarknezevic,True\r\n\r\n    => Here you would return 03/mridubhatnagar (lowercased!)\r\n       followed by 03/aleksandarknezevic\r\n    \"\"\"\r\n    \r\n    with open(tempfile) as file:\r\n        for line in file:\r\n            split_line = line.strip().split(\",\")\r\n            if split_line[1] == \"True\":\r\n                yield split_line[0].lower()\r\n\r\n\r\ndef diehard_pybites(files=None):\r\n    \"\"\"\r\n    Return a Stats namedtuple (defined above) that contains:\r\n    1. the user that made the most pull requests (ignoring the users in IGNORE), and\r\n    2. a tuple of:\r\n        (\"most popular challenge id\", \"amount of pull requests for that challenge\")\r\n\r\n    Calling this function on the default dirnames.txt should return:\r\n\r\n    Stats(user='clamytoe', challenge=('01', 7))\r\n    \"\"\"\r\n\r\n    if files is None:\r\n        files = gen_files()\r\n    lst = [line.split(\"/\") for line in files]\r\n    users = Counter([item[1] for item in lst if item[1] not in IGNORE])\r\n    popular_challenges = Counter([item[0] for item in lst])\r\n\r\n    return Stats(user=users.most_common(1)[0][0],\r\n                 challenge=popular_challenges.most_common(1)[0])\r\n\r\n\r\nprint(diehard_pybites())\r\n",
            "date": "2022-09-21 18:44:50.569683+00:00",
            "passed": false
        },
        {
            "bite": "Bite 6. PyBites Die Hard",
            "code": "from collections import Counter, namedtuple\r\nimport os\r\nimport urllib.request\r\n\r\n# prep\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\ntempfile = os.path.join(tmp, 'dirnames')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/dirnames.txt',\r\n    tempfile\r\n)\r\n\r\nIGNORE = ['static', 'templates', 'data', 'pybites', 'bbelderbos', 'hobojoe1848']\r\n\r\nStats = namedtuple('Stats', 'user challenge')\r\n\r\n\r\n# code\r\n\r\ndef gen_files(tempfile=tempfile):\r\n    \"\"\"\r\n    Parse the tempfile passed in, filtering out directory names\r\n    (first column) using the last \"is_dir\" column.\r\n\r\n    Lowercase these directory names and return them as a generator.\r\n\r\n    \"tempfile\" has the following format:\r\n    challenge<int>/file_or_dir<str>,is_dir<bool>\r\n\r\n    For example:\r\n    03/rss.xml,False\r\n    03/tags.html,False\r\n    03/Mridubhatnagar,True\r\n    03/aleksandarknezevic,True\r\n\r\n    => Here you would return 03/mridubhatnagar (lowercased!)\r\n       followed by 03/aleksandarknezevic\r\n    \"\"\"\r\n    \r\n    with open(tempfile) as file:\r\n        for line in file:\r\n            split_line = line.strip().split(\",\")\r\n            if split_line[1] == \"True\":\r\n                yield split_line[0]\r\n\r\n\r\ndef diehard_pybites(files=None):\r\n    \"\"\"\r\n    Return a Stats namedtuple (defined above) that contains:\r\n    1. the user that made the most pull requests (ignoring the users in IGNORE), and\r\n    2. a tuple of:\r\n        (\"most popular challenge id\", \"amount of pull requests for that challenge\")\r\n\r\n    Calling this function on the default dirnames.txt should return:\r\n\r\n    Stats(user='clamytoe', challenge=('01', 7))\r\n    \"\"\"\r\n\r\n    if files is None:\r\n        files = gen_files()\r\n    lst = [line.split(\"/\") for line in files]\r\n    users = Counter([item[1] for item in lst if item[1] not in IGNORE])\r\n    popular_challenges = Counter([item[0] for item in lst])\r\n\r\n    return Stats(user=users.most_common(1)[0][0],\r\n                 challenge=popular_challenges.most_common(1)[0])\r\n\r\n\r\nprint(diehard_pybites())\r\n",
            "date": "2022-09-21 18:42:51.852939+00:00",
            "passed": false
        },
        {
            "bite": "Bite 3. Word Values",
            "code": "#!/usr/bin/env python\r\n\r\nimport os\r\nimport urllib.request\r\nfrom operator import itemgetter\r\n\r\n# PREWORK\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nS3 = 'https://bites-data.s3.us-east-2.amazonaws.com/'\r\nDICT = 'dictionary.txt'\r\nDICTIONARY = os.path.join(TMP, DICT)\r\nurllib.request.urlretrieve(f'{S3}{DICT}', DICTIONARY)\r\n\r\nscrabble_scores = [(1, \"E A O I N R T L S U\"), (2, \"D G\"), (3, \"B C M P\"),\r\n                   (4, \"F H V W Y\"), (5, \"K\"), (8, \"J X\"), (10, \"Q Z\")]\r\nLETTER_SCORES = {letter: score for score, letters in scrabble_scores\r\n                 for letter in letters.split()}\r\n\r\n# start coding\r\n\r\n\r\ndef load_words():\r\n    \"\"\"Load the words dictionary (DICTIONARY constant) into a list and return it\"\"\"\r\n    lst = []\r\n    with open(DICTIONARY) as dict:\r\n        for word in dict:\r\n            lst.append(word.strip())\r\n    return lst\r\n\r\n\r\ndef calc_word_value(word):\r\n    \"\"\"Given a word calculate its value using the LETTER_SCORES dict\"\"\"\r\n    score = 0\r\n    for letter in word.strip().upper():\r\n        for group in scrabble_scores:\r\n            if letter in group[1]:\r\n                score += group[0]\r\n    return score\r\n\r\n\r\ndef max_word_value(words):\r\n    \"\"\"Given a list of words calculate the word with the maximum value and return it\"\"\"\r\n    lst = [(word, calc_word_value(word)) for word in words]\r\n    return max(lst, key=itemgetter(1))[0]\r\n\r\n\r\nprint(list(load_words()))\r\n\r\nprint(f\"{calc_word_value('bob')} should be == 7\")\r\nprint(f\"{calc_word_value('JuliaN')} should be == 13\")\r\nprint(f\"{calc_word_value('PyBites')} should be == 14\")\r\nprint(f\"{calc_word_value('benzalphenylhydrazone')} should be == 56\")\r\n\r\nprint(max_word_value(['bob', 'benzalphenylhydrazone', 'julian', 'pybites']))\r\n",
            "date": "2022-09-20 19:28:10.328427+00:00",
            "passed": true
        },
        {
            "bite": "Bite 4. Top 10 PyBites tags",
            "code": "import os\r\nfrom collections import Counter\r\nimport urllib.request\r\nimport xml.etree.ElementTree as ET\r\n\r\n# prep\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\ntempfile = os.path.join(tmp, 'feed')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/feed',\r\n    tempfile\r\n)\r\n\r\nwith open(tempfile) as f:\r\n    content = f.read().lower()\r\n\r\ndef get_pybites_top_tags(n=10):\r\n    \"\"\"use Counter to get the top 10 PyBites tags from the feed\r\n       data already loaded into the content variable\"\"\"\r\n    lst=[]\r\n    for elem in ET.fromstring(content)[0]:\r\n        if elem.tag == 'item':\r\n            for attrb in elem:\r\n                if attrb.tag == 'category':\r\n                    lst.append(attrb.text)\r\n    return Counter(lst).most_common(n)\r\n\r\nprint(get_pybites_top_tags(10))",
            "date": "2022-09-20 10:42:19.116115+00:00",
            "passed": true
        },
        {
            "bite": "Bite 4. Top 10 PyBites tags",
            "code": "import os\r\nfrom collections import Counter\r\nimport urllib.request\r\nimport xml.etree.ElementTree as ET\r\n\r\n# prep\r\ntmp = os.getenv(\"TMP\", \"/tmp\")\r\ntempfile = os.path.join(tmp, 'feed')\r\nurllib.request.urlretrieve(\r\n    'https://bites-data.s3.us-east-2.amazonaws.com/feed',\r\n    tempfile\r\n)\r\n\r\nwith open(tempfile) as f:\r\n    content = f.read().lower()\r\n\r\ndef get_pybites_top_tags(n=10):\r\n    \"\"\"use Counter to get the top 10 PyBites tags from the feed\r\n       data already loaded into the content variable\"\"\"\r\n    lst=[]\r\n    for elem in ET.fromstring(content)[0]:\r\n        if elem.tag == 'item':\r\n            for attrb in elem:\r\n                if attrb.tag == 'category':\r\n                    lst.append(attrb.text)\r\n    count = Counter(lst).most_common(n)\r\n    print(count)\r\nget_pybites_top_tags(10)",
            "date": "2022-09-20 10:40:39.373876+00:00",
            "passed": false
        },
        {
            "bite": "Bite 38. Using ElementTree to parse XML",
            "code": "import xml.etree.ElementTree as ET\r\nfrom pprint import pprint\r\nfrom operator import itemgetter\r\n\r\n# from OMDB\r\nxmlstring = '''<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<root response=\"True\">\r\n  <movie title=\"The Prestige\" year=\"2006\" rated=\"PG-13\" released=\"20 Oct 2006\" runtime=\"130 min\" genre=\"Drama, Mystery, Sci-Fi\" director=\"Christopher Nolan\" />\r\n  <movie title=\"The Dark Knight\" year=\"2008\" rated=\"PG-13\" released=\"18 Jul 2008\" runtime=\"152 min\" genre=\"Action, Crime, Drama\" director=\"Christopher Nolan\" />\r\n  <movie title=\"The Dark Knight Rises\" year=\"2012\" rated=\"PG-13\" released=\"20 Jul 2012\" runtime=\"164 min\" genre=\"Action, Thriller\" director=\"Christopher Nolan\" />\r\n  <movie title=\"Dunkirk\" year=\"2017\" rated=\"PG-13\" released=\"21 Jul 2017\" runtime=\"106 min\" genre=\"Action, Drama, History\" director=\"Christopher Nolan\" />\r\n  <movie title=\"Interstellar\" year=\"2014\" rated=\"PG-13\" released=\"07 Nov 2014\" runtime=\"169 min\" genre=\"Adventure, Drama, Sci-Fi\" director=\"Christopher Nolan\"/>\r\n</root>'''  # noqa E501\r\n\r\n\r\ndef get_tree():\r\n    \"\"\"You probably want to use ET.fromstring\"\"\"\r\n    return ET.fromstring(xmlstring)\r\n\r\n\r\ndef get_movies():\r\n    \"\"\"Call get_tree and retrieve all movie titles, return a list or generator\"\"\"\r\n    for child in get_tree():\r\n        yield child.attrib['title']\r\n\r\ndef get_movie_longest_runtime():\r\n    \"\"\"Call get_tree again and return the movie title for the movie with the longest\r\n       runtime in minutes, for latter consider adding a _get_runtime helper\"\"\"\r\n    \r\n    lst = [ (_get_runtime(child.attrib['runtime']), child.attrib['title']) for child in get_tree() ] \r\n    longest_title= max(lst, key=itemgetter(0))[1] \r\n    return longest_title\r\n\r\n    \"\"\" this also works\r\n    longest_title=''\r\n    longest_t=0\r\n    for child in get_tree():\r\n        t = _get_runtime(child.attrib['runtime'])\r\n        if t > longest_t:\r\n            longest_t =t\r\n            longest_title = child.attrib['title']\r\n    return longest_title\r\n    \"\"\"\r\n\r\ndef _get_runtime(runtime_label):\r\n    return int(runtime_label.split()[0])\r\n    \r\n    \r\nprint(get_movie_longest_runtime())\r\n",
            "date": "2022-09-20 08:17:05.212761+00:00",
            "passed": true
        },
        {
            "bite": "Bite 38. Using ElementTree to parse XML",
            "code": "import xml.etree.ElementTree as ET\r\nfrom pprint import pprint\r\n\r\n# from OMDB\r\nxmlstring = '''<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<root response=\"True\">\r\n  <movie title=\"The Prestige\" year=\"2006\" rated=\"PG-13\" released=\"20 Oct 2006\" runtime=\"130 min\" genre=\"Drama, Mystery, Sci-Fi\" director=\"Christopher Nolan\" />\r\n  <movie title=\"The Dark Knight\" year=\"2008\" rated=\"PG-13\" released=\"18 Jul 2008\" runtime=\"152 min\" genre=\"Action, Crime, Drama\" director=\"Christopher Nolan\" />\r\n  <movie title=\"The Dark Knight Rises\" year=\"2012\" rated=\"PG-13\" released=\"20 Jul 2012\" runtime=\"164 min\" genre=\"Action, Thriller\" director=\"Christopher Nolan\" />\r\n  <movie title=\"Dunkirk\" year=\"2017\" rated=\"PG-13\" released=\"21 Jul 2017\" runtime=\"106 min\" genre=\"Action, Drama, History\" director=\"Christopher Nolan\" />\r\n  <movie title=\"Interstellar\" year=\"2014\" rated=\"PG-13\" released=\"07 Nov 2014\" runtime=\"169 min\" genre=\"Adventure, Drama, Sci-Fi\" director=\"Christopher Nolan\"/>\r\n</root>'''  # noqa E501\r\n\r\n\r\ndef get_tree():\r\n    \"\"\"You probably want to use ET.fromstring\"\"\"\r\n    return ET.fromstring(xmlstring)\r\n\r\n\r\ndef get_movies():\r\n    \"\"\"Call get_tree and retrieve all movie titles, return a list or generator\"\"\"\r\n    for child in get_tree():\r\n        yield child.attrib['title']\r\n\r\ndef get_movie_longest_runtime():\r\n    \"\"\"Call get_tree again and return the movie title for the movie with the longest\r\n       runtime in minutes, for latter consider adding a _get_runtime helper\"\"\"\r\n    longest_title=''\r\n    longest_t=0\r\n    for child in get_tree():\r\n        t = _get_runtime(child.attrib['runtime'])\r\n        if t > longest_t:\r\n            longest_t =t\r\n            longest_title = child.attrib['title']\r\n    return longest_title\r\n\r\n\r\ndef _get_runtime(runtime_label):\r\n    return int(runtime_label.split()[0])\r\n    \r\n    \r\nprint(get_movie_longest_runtime())\r\n",
            "date": "2022-09-20 08:08:08.420883+00:00",
            "passed": true
        },
        {
            "bite": "Bite 188. Get statistics from PyBites test code",
            "code": "import os\r\nimport statistics\r\nfrom urllib.request import urlretrieve\r\n\r\nTMP = os.getenv(\"TMP\", \"/tmp\")\r\nS3 = 'https://bites-data.s3.us-east-2.amazonaws.com/'\r\nDATA = 'testfiles_number_loc.txt'\r\nSTATS = os.path.join(TMP, DATA)\r\nif not os.path.isfile(STATS):\r\n    urlretrieve(os.path.join(S3, DATA), STATS)\r\n\r\nSTATS_OUTPUT = \"\"\"\r\nBasic statistics:\r\n- count     : {count:7d}\r\n- min       : {min_:7d}\r\n- max       : {max_:7d}\r\n- mean      : {mean:7.2f}\r\n\r\nPopulation variance:\r\n- pstdev    : {pstdev:7.2f}\r\n- pvariance : {pvariance:7.2f}\r\n\r\nEstimated variance for sample:\r\n- count     : {sample_count:7.2f}\r\n- stdev     : {sample_stdev:7.2f}\r\n- variance  : {sample_variance:7.2f}\r\n\"\"\"\r\n\r\n\r\ndef get_all_line_counts(data: str = STATS) -> list:\r\n    \"\"\"Get all 186 line counts from the STATS file,\r\n       returning a list of ints\"\"\"\r\n    # TODO 1: get the 186 ints from downloaded STATS file\r\n    with open(STATS) as file:\r\n        lines= file.readlines()\r\n    lst = []\r\n    for line in lines:\r\n        num = int(line.split()[0]) \r\n        lst.append(num)\r\n    return lst\r\n\r\n\r\n\r\ndef create_stats_report(data=None):\r\n    if data is None:\r\n        # converting to a list in case a generator was returned\r\n        data = list(get_all_line_counts())\r\n\r\n    # taking a sample for the last section\r\n    sample = list(data)[::2]\r\n\r\n    # TODO 2: complete this dict, use data list and\r\n    # for the last 3 sample_ variables, use sample list\r\n    stats = dict(count=len(data),\r\n                 min_=min(data),\r\n                 max_=max(data),\r\n                 mean=statistics.mean(data),\r\n                 pstdev=statistics.pstdev(data),\r\n                 pvariance=statistics.pvariance(data),\r\n                 sample_count=len(sample),\r\n                 sample_stdev=statistics.stdev(sample),\r\n                 sample_variance=statistics.variance(sample),\r\n                 )\r\n\r\n    return STATS_OUTPUT.format(**stats)\r\n    \r\n    \r\nprint(create_stats_report())\r\n\r\n",
            "date": "2022-09-19 16:32:35.426850+00:00",
            "passed": true
        },
        {
            "bite": "Bite 270. Most frequent digit in number",
            "code": "from collections import Counter\r\n\r\ndef freq_digit(num: int) -> int:\r\n    num_as_string = str(num)\r\n    most_common = Counter(num_as_string).most_common(1)\r\n    return int(most_common[0][0])\r\n\r\nprint(freq_digit(1121)+1-1)",
            "date": "2022-09-19 16:01:32.060420+00:00",
            "passed": true
        },
        {
            "bite": "Bite 270. Most frequent digit in number",
            "code": "from collections import Counter\r\n\r\ndef freq_digit(num: int) -> int:\r\n    num_as_list_of_chars = list(str(num))\r\n    most_common = Counter(num_as_list_of_chars).most_common(1)\r\n    return int(most_common[0][0])\r\n\r\n\r\nprint(freq_digit(1121)+1-1)",
            "date": "2022-09-19 15:58:28.858411+00:00",
            "passed": true
        },
        {
            "bite": "Bite 167. Complete a User class: properties and representation dunder methods",
            "code": "class User:\r\n    \"\"\"A User class\r\n       (Django's User model inspired us)\r\n    \"\"\"\r\n\r\n    def __init__(self, first_name, last_name):\r\n        \"\"\"Constructor, base values\"\"\"\r\n        self.first_name = first_name\r\n        self.last_name = last_name\r\n\r\n    @property\r\n    def get_full_name(self):\r\n        \"\"\"Return first and last name separated by a whitespace\r\n           and using title case for both.\r\n        \"\"\"\r\n        # TODO 1: you code\r\n        return \" \".join([self.first_name.title(), self.last_name.title()])\r\n\r\n    @property\r\n    def username(self):\r\n        \"\"\"A username consists of the first char of\r\n           the user's first_name and the first 7 chars\r\n           of the user's last_name, both lowercased.\r\n\r\n           If this is your first property, check out:\r\n           https://pybit.es/property-decorator.html\r\n        \"\"\"\r\n        # TODO 2: you code\r\n        return self.first_name[0].lower()+ self.last_name[0:7].lower()\r\n\r\n    # TODO 3: you code\r\n    #\r\n    # add a __str__ and a __repr__\r\n    # see: https://stackoverflow.com/a/1438297\r\n    # \"__repr__ is for devs, __str__ is for customers\"\r\n    #\r\n    # see also TESTS for required output\r\n\r\n    def __str__(self):\r\n        return f\"{self.get_full_name} ({self.username})\" \r\n\r\n    def __repr__(self):\r\n        \"\"\"Don't hardcode the class name, hint: use a\r\n           special attribute of self.__class__ ...\r\n        \"\"\"\r\n        return f\"{self.__class__.__name__}('{self.first_name}', '{self.last_name}')\"\r\n        \r\n        \r\nnoah = User(\"Noah\", \"Kagan\")\r\nprint(noah.get_full_name)\r\nprint(noah.username)\r\nprint(str(noah))\r\nprint(repr(noah))",
            "date": "2022-09-18 11:52:13.645184+00:00",
            "passed": true
        },
        {
            "bite": "Bite 167. Complete a User class: properties and representation dunder methods",
            "code": "class User:\r\n    \"\"\"A User class\r\n       (Django's User model inspired us)\r\n    \"\"\"\r\n\r\n    def __init__(self, first_name, last_name):\r\n        \"\"\"Constructor, base values\"\"\"\r\n        self.first_name = first_name\r\n        self.last_name = last_name\r\n\r\n    @property\r\n    def get_full_name(self):\r\n        \"\"\"Return first and last name separated by a whitespace\r\n           and using title case for both.\r\n        \"\"\"\r\n        # TODO 1: you code\r\n        return \" \".join([self.first_name.title(), self.last_name.title()])\r\n\r\n    @property\r\n    def username(self):\r\n        \"\"\"A username consists of the first char of\r\n           the user's first_name and the first 7 chars\r\n           of the user's last_name, both lowercased.\r\n\r\n           If this is your first property, check out:\r\n           https://pybit.es/property-decorator.html\r\n        \"\"\"\r\n        # TODO 2: you code\r\n        return self.first_name[0].lower()+ self.last_name[0:7].lower()\r\n\r\n    # TODO 3: you code\r\n    #\r\n    # add a __str__ and a __repr__\r\n    # see: https://stackoverflow.com/a/1438297\r\n    # \"__repr__ is for devs, __str__ is for customers\"\r\n    #\r\n    # see also TESTS for required output\r\n\r\n    def __str__(self):\r\n        return f\"{self.get_full_name} ({self.username})\" \r\n\r\n    def __repr__(self):\r\n        \"\"\"Don't hardcode the class name, hint: use a\r\n           special attribute of self.__class__ ...\r\n        \"\"\"\r\n        return f\"{self.__class__.__name__}('{self.first_name}', '{self.last_name}')\"\r\n        \r\n        \r\nbob = User(\"bob\", \"belderbos\")\r\nprint(bob.get_full_name)\r\nprint(bob.username)\r\nprint(str(bob))\r\nprint(repr(bob))",
            "date": "2022-09-18 11:50:21.138309+00:00",
            "passed": true
        },
        {
            "bite": "Bite 167. Complete a User class: properties and representation dunder methods",
            "code": "class User:\r\n    \"\"\"A User class\r\n       (Django's User model inspired us)\r\n    \"\"\"\r\n\r\n    def __init__(self, first_name, last_name):\r\n        \"\"\"Constructor, base values\"\"\"\r\n        self.first_name = first_name\r\n        self.last_name = last_name\r\n\r\n    @property\r\n    def get_full_name(self):\r\n        \"\"\"Return first and last name separated by a whitespace\r\n           and using title case for both.\r\n        \"\"\"\r\n        # TODO 1: you code\r\n        return \" \".join([self.first_name.title(), self.last_name.title()])\r\n\r\n    @property\r\n    def username(self):\r\n        \"\"\"A username consists of the first char of\r\n           the user's first_name and the first 7 chars\r\n           of the user's last_name, both lowercased.\r\n\r\n           If this is your first property, check out:\r\n           https://pybit.es/property-decorator.html\r\n        \"\"\"\r\n        # TODO 2: you code\r\n        return self.first_name[0].lower()+ self.last_name[0:7].lower()\r\n\r\n    # TODO 3: you code\r\n    #\r\n    # add a __str__ and a __repr__\r\n    # see: https://stackoverflow.com/a/1438297\r\n    # \"__repr__ is for devs, __str__ is for customers\"\r\n    #\r\n    # see also TESTS for required output\r\n\r\n    def __str__(self):\r\n        return f\"{self.get_full_name} ({self.username})\" \r\n\r\n    def __repr__(self):\r\n        \"\"\"Don't hardcode the class name, hint: use a\r\n           special attribute of self.__class__ ...\r\n        \"\"\"\r\n        return f\"{self.__class__.__name__}('{self.first_name}','{self.last_name}')\"\r\n        \r\n        \r\nbob = User(\"bob\", \"belderbos\")\r\nprint(bob.get_full_name)\r\nprint(bob.username)\r\nprint(str(bob))\r\nprint(repr(bob))",
            "date": "2022-09-18 11:49:06.002133+00:00",
            "passed": false
        },
        {
            "bite": "Bite 167. Complete a User class: properties and representation dunder methods",
            "code": "class User:\r\n    \"\"\"A User class\r\n       (Django's User model inspired us)\r\n    \"\"\"\r\n\r\n    def __init__(self, first_name, last_name):\r\n        \"\"\"Constructor, base values\"\"\"\r\n        self.first_name = first_name\r\n        self.last_name = last_name\r\n\r\n    @property\r\n    def get_full_name(self):\r\n        \"\"\"Return first and last name separated by a whitespace\r\n           and using title case for both.\r\n        \"\"\"\r\n        # TODO 1: you code\r\n        return \" \".join([self.first_name.title(), self.last_name.title()])\r\n\r\n    @property\r\n    def username(self):\r\n        \"\"\"A username consists of the first char of\r\n           the user's first_name and the first 7 chars\r\n           of the user's last_name, both lowercased.\r\n\r\n           If this is your first property, check out:\r\n           https://pybit.es/property-decorator.html\r\n        \"\"\"\r\n        # TODO 2: you code\r\n        return self.first_name[0].lower()+ self.last_name[0:7].lower()\r\n\r\n    # TODO 3: you code\r\n    #\r\n    # add a __str__ and a __repr__\r\n    # see: https://stackoverflow.com/a/1438297\r\n    # \"__repr__ is for devs, __str__ is for customers\"\r\n    #\r\n    # see also TESTS for required output\r\n\r\n    def __str__(self):\r\n        return f\"{self.get_full_name} ({self.username})\" \r\n\r\n    def __repr__(self):\r\n        \"\"\"Don't hardcode the class name, hint: use a\r\n           special attribute of self.__class__ ...\r\n        \"\"\"\r\n        return f\"{self.__class__}('{self.first_name}','{self.last_name}')\"",
            "date": "2022-09-18 11:42:39.597160+00:00",
            "passed": false
        },
        {
            "bite": "Bite 167. Complete a User class: properties and representation dunder methods",
            "code": "class User:\r\n    \"\"\"A User class\r\n       (Django's User model inspired us)\r\n    \"\"\"\r\n\r\n    def __init__(self, first_name, last_name):\r\n        \"\"\"Constructor, base values\"\"\"\r\n        self.first_name = first_name\r\n        self.last_name = last_name\r\n\r\n    @property\r\n    def get_full_name(self):\r\n        \"\"\"Return first and last name separated by a whitespace\r\n           and using title case for both.\r\n        \"\"\"\r\n        # TODO 1: you code\r\n        return \" \".join([self.first_name.title(), self.last_name.title()])\r\n\r\n    @property\r\n    def username(self):\r\n        \"\"\"A username consists of the first char of\r\n           the user's first_name and the first 7 chars\r\n           of the user's last_name, both lowercased.\r\n\r\n           If this is your first property, check out:\r\n           https://pybit.es/property-decorator.html\r\n        \"\"\"\r\n        # TODO 2: you code\r\n        return self.first_name[0].lower()+ self.last_name[0:7].lower()\r\n\r\n    # TODO 3: you code\r\n    #\r\n    # add a __str__ and a __repr__\r\n    # see: https://stackoverflow.com/a/1438297\r\n    # \"__repr__ is for devs, __str__ is for customers\"\r\n    #\r\n    # see also TESTS for required output\r\n\r\n    def __str__(self):\r\n        return f\"{get_full_name} ({username})\" \r\n\r\n    def __repr__(self):\r\n        \"\"\"Don't hardcode the class name, hint: use a\r\n           special attribute of self.__class__ ...\r\n        \"\"\"\r\n        return f\"{self.__class__}('{self.first_name}','{self.last_name}')\"",
            "date": "2022-09-18 11:41:44.636136+00:00",
            "passed": false
        },
        {
            "bite": "Bite 32. Don't let mutability fool you",
            "code": "from copy import deepcopy\r\n\r\nitems = [{'id': 1, 'name': 'laptop', 'value': 1000},\r\n         {'id': 2, 'name': 'chair', 'value': 300},\r\n         {'id': 3, 'name': 'book', 'value': 20}]\r\n\r\n\r\ndef duplicate_items(items):\r\n    return deepcopy(items)\r\n    \r\n",
            "date": "2022-09-18 11:11:29.878453+00:00",
            "passed": true
        },
        {
            "bite": "Bite 29. Martin's IQ test",
            "code": "from collections import Counter\r\n\r\nalphanumeric = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\r\n\r\ntest1= ['A', 'f', '.', 'Q', 2] \r\ntest2= ['.', '{', ' ^', '%', 'a'] \r\ntest3 = ['=', '=', '', '/', '/', 9, ':', ';', '?', '\u00a1']\r\n\r\ndef get_index_different_char(chars):\r\n    is_alphanumeric = [str(char) in alphanumeric and len(str(char))>0 for char in chars]\r\n    counter = Counter(is_alphanumeric).most_common(1)\r\n    least_common = not counter[0][0]\r\n    return [i for i,item in enumerate(is_alphanumeric) if item==least_common][0]\r\n\r\n    \r\n    \"\"\" alternative that also works\r\n    is_alphanumeric = [(i, str(char) in alphanumeric and len(str(char))>0) for i, char in enumerate(chars)]\r\n\r\n    if Counter([item[1] for item in is_alphanumeric])[True] == 1:\r\n        # alphanumeric is the different one\r\n        index = [item[0] for item in is_alphanumeric if item[1]==True]\r\n    else:\r\n        # non-alphanumeric is the different one\r\n        index = [item[0] for item in is_alphanumeric if item[1]==False]\r\n    return is_alphanumeric[index[0]][0]\r\n    \"\"\"\r\n\r\n\r\n\r\nprint(get_index_different_char(test1))\r\nprint(get_index_different_char(test2))\r\nprint(get_index_different_char(test3))",
            "date": "2022-09-17 09:03:01.958081+00:00",
            "passed": true
        },
        {
            "bite": "Bite 29. Martin's IQ test",
            "code": "from collections import Counter\r\n\r\nalphanumeric = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\r\n\r\ntest1= ['A', 'f', '.', 'Q', 2] \r\ntest2= ['.', '{', ' ^', '%', 'a'] \r\ntest3 = ['=', '=', '', '/', '/', 9, ':', ';', '?', '\u00a1']\r\n\r\ndef get_index_different_char(chars):\r\n    is_alphanumeric = [str(char) in alphanumeric and len(str(char))>0 for char in chars]\r\n    # print(\"is_alphanumeric=\",is_alphanumeric)\r\n    counter = Counter(is_alphanumeric).most_common(1)\r\n    # print(\"counter=\",counter)\r\n    least_common = not counter[0][0]\r\n    # print(\"least_common=\",least_common)\r\n    return [i for i,item in enumerate(is_alphanumeric) if item==least_common][0]\r\n\r\n    \r\n    \"\"\" alternative that also works\r\n    is_alphanumeric = [(i, str(char) in alphanumeric and len(str(char))>0) for i, char in enumerate(chars)]\r\n\r\n    if Counter([item[1] for item in is_alphanumeric])[True] == 1:\r\n        # alphanumeric is the different one\r\n        index = [item[0] for item in is_alphanumeric if item[1]==True]\r\n    else:\r\n        # non-alphanumeric is the different one\r\n        index = [item[0] for item in is_alphanumeric if item[1]==False]\r\n    return is_alphanumeric[index[0]][0]\r\n    \"\"\"\r\n\r\n\r\n\r\nprint(get_index_different_char(test1))\r\nprint(get_index_different_char(test2))\r\nprint(get_index_different_char(test3))",
            "date": "2022-09-17 09:02:42.986848+00:00",
            "passed": true
        },
        {
            "bite": "Bite 29. Martin's IQ test",
            "code": "from collections import Counter\r\n\r\nalphanumeric = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\r\n\r\ntest1= ['A', 'f', '.', 'Q', 2] \r\ntest2= ['.', '{', ' ^', '%', 'a'] \r\ntest3 = ['=', '=', '', '/', '/', 9, ':', ';', '?', '\u00a1']\r\n\r\ndef get_index_different_char(chars):\r\n    is_alphanumeric = [(i, str(char) in alphanumeric and len(str(char))>0) for i, char in enumerate(chars)]\r\n    print(is_alphanumeric)\r\n    if Counter([item[1] for item in is_alphanumeric])[True] == 1:\r\n        # alphanumeric is the different one\r\n        index = [item[0] for item in is_alphanumeric if item[1]==True]\r\n    else:\r\n        # non-alphanumeric is the different one\r\n        index = [item[0] for item in is_alphanumeric if item[1]==False]\r\n    return is_alphanumeric[index[0]][0]\r\n\r\n\r\nprint(get_index_different_char(test1))\r\nprint(get_index_different_char(test2))\r\nprint(get_index_different_char(test3))",
            "date": "2022-09-17 08:31:46.417211+00:00",
            "passed": true
        },
        {
            "bite": "Bite 29. Martin's IQ test",
            "code": "from collections import Counter\r\n\r\nalphanumeric = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\r\n\r\ntest1= ['A', 'f', '.', 'Q', 2] \r\ntest2= ['.', '{', ' ^', '%', 'a'] \r\ntest3 = ['=', '=', '', '/', '/', 9, ':', ';', '?', '\u00a1']\r\n\r\ndef get_index_different_char(chars):\r\n    is_alphanumeric = [(i, char in alphanumeric and len(char)>0) for i, char in enumerate(str(chars))]\r\n    print(is_alphanumeric)\r\n    if Counter([item[1] for item in is_alphanumeric])[True] == 1:\r\n        # alphanumeric is the different one\r\n        index = [item[0] for item in is_alphanumeric if item[1]==True]\r\n    else:\r\n        # non-alphanumeric is the different one\r\n        index = [item[0] for item in is_alphanumeric if item[1]==False]\r\n    return is_alphanumeric[index[0]][0]\r\n\r\n\r\nprint(get_index_different_char(test1))\r\nprint(get_index_different_char(test2))\r\nprint(get_index_different_char(test3))",
            "date": "2022-09-17 08:30:18.581670+00:00",
            "passed": false
        },
        {
            "bite": "Bite 29. Martin's IQ test",
            "code": "from collections import Counter\r\n\r\nalphanumeric = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\r\n\r\ntest1= ['A', 'f', '.', 'Q', 2] \r\ntest2= ['.', '{', ' ^', '%', 'a'] \r\n\r\ndef get_index_different_char(chars):\r\n    is_alphanumeric = [(i, str(char) in alphanumeric) for i, char in enumerate(chars)]\r\n\r\n    if Counter([item[1] for item in is_alphanumeric])[True] == 1:\r\n        # alphanumeric is the different one\r\n        index = [item[0] for item in is_alphanumeric if item[1]==True]\r\n    else:\r\n        # non-alphanumeric is the different one\r\n        index = [item[0] for item in is_alphanumeric if item[1]==False]\r\n    return is_alphanumeric[index[0]][0]\r\n\r\n\r\nprint(get_index_different_char(test1))\r\nprint(get_index_different_char(test2))",
            "date": "2022-09-17 08:22:13.087363+00:00",
            "passed": false
        },
        {
            "bite": "Bite 43. Force keyword arguments",
            "code": "def get_profile(*,name:str = \"julian\", profession:str = \"programmer\") -> str :\r\n    return f\"{name} is a {profession}\"\r\n    \r\n    \r\n    \r\nprint(get_profile(name=\"manolo\", profession=\"wannabe programmer\"))\r\n",
            "date": "2022-09-16 15:33:31.233027+00:00",
            "passed": true
        },
        {
            "bite": "Bite 43. Force keyword arguments",
            "code": "def get_profile(*,name:str = \"julian\", profession:str = \"programmer\") -> str :\r\n    return f\"{name} is a {profession}\"\r\n    \r\n    \r\n    \r\nprint(get_profile(name=\"pepe\", profession=\"tonto\"))\r\n",
            "date": "2022-09-16 15:32:16.691553+00:00",
            "passed": true
        },
        {
            "bite": "Bite 26. Dictionary comprehensions are awesome",
            "code": "from typing import Dict, Set\r\n\r\nDEFAULT_BITES = {\r\n    6: \"PyBites Die Hard\",\r\n    7: \"Parsing dates from logs\",\r\n    9: \"Palindromes\",\r\n    10: \"Practice exceptions\",\r\n    11: \"Enrich a class with dunder methods\",\r\n    12: \"Write a user validation function\",\r\n    13: \"Convert dict in namedtuple/json\",\r\n    14: \"Generate a table of n sequences\",\r\n    15: \"Enumerate 2 sequences\",\r\n    16: \"Special PyBites date generator\",\r\n    17: \"Form teams from a group of friends\",\r\n    18: \"Find the most common word\",\r\n    19: \"Write a simple property\",\r\n    20: \"Write a context manager\",\r\n    21: \"Query a nested data structure\",\r\n}\r\nEXCLUDE_BITES = {6, 10, 16, 18, 21}\r\n\r\n\r\ndef filter_bites(\r\n    bites: Dict[int, str] = DEFAULT_BITES,\r\n    bites_done: Set[int] = EXCLUDE_BITES\r\n) -> Dict[int, str]:\r\n    \"\"\"\r\n    Return the bites dict with bites_done filtered out.\r\n    \"\"\"\r\n    return {key:value for key,value in bites.items() if key not in bites_done}\r\n\r\n\r\nprint(filter_bites())",
            "date": "2022-09-16 14:38:13.657735+00:00",
            "passed": true
        },
        {
            "bite": "Bite 241. Write tests for list_to_decimal",
            "code": "import pytest\r\n\r\nfrom numbers_to_dec import list_to_decimal\r\n\r\ndef test_valid_cases():\r\n    samples = [\r\n        {'input':[0,4,2,8], 'result':428},\r\n        {'input':[1,2], 'result':12},\r\n        {'input':[3], 'result':3},\r\n        {'input':[0,6,5,9], 'result':659},\r\n    ]\r\n    for sample in samples:\r\n        assert list_to_decimal(sample['input']) == sample['result']\r\n\r\ndef test_for_type_error():\r\n    invalid_samples = [\r\n        {'input':[6,2,True]},\r\n        {'input':[3.6,4,1]},\r\n        {'input':['4',5,3,1]},\r\n        {'input':[[5,3],1]},\r\n        {'input':['foo',1]},\r\n    ]\r\n    with pytest.raises(TypeError):\r\n        for sample in invalid_samples:\r\n            list_to_decimal(sample['input'])\r\n        \r\ndef test_for_value_error():\r\n    invalid_samples = [\r\n        {'input':[-3,0]},\r\n        {'input':[1,12,1]},\r\n        {'input':[2,0,32]},\r\n        {'input':[-1,4,2]},\r\n        {'input':[2,10,7]},\r\n    ]\r\n    with pytest.raises(ValueError):\r\n        for sample in invalid_samples:\r\n            list_to_decimal(sample['input'])\r\n            \r\ndef test_for_10():\r\n    with pytest.raises(ValueError):\r\n        list_to_decimal([10])\r\n        ",
            "date": "2022-09-15 18:14:32.710730+00:00",
            "passed": true
        },
        {
            "bite": "Bite 241. Write tests for list_to_decimal",
            "code": "import pytest\r\n\r\nfrom numbers_to_dec import list_to_decimal\r\n\r\ndef test_valid_cases():\r\n    samples = [\r\n        {'input':[0,4,2,8], 'result':428},\r\n        {'input':[1,2], 'result':12},\r\n        {'input':[3], 'result':3},\r\n        {'input':[0,6,5,9], 'result':659},\r\n    ]\r\n    for sample in samples:\r\n        assert list_to_decimal(sample['input']) == sample['result']\r\n\r\ndef test_for_type_error():\r\n    invalid_samples = [\r\n        {'input':[6,2,True]},\r\n        {'input':[3.6,4,1]},\r\n        {'input':['4',5,3,1]},\r\n        {'input':[[5,3],1]},\r\n        {'input':['foo',1]},\r\n    ]\r\n    with pytest.raises(TypeError):\r\n        for sample in invalid_samples:\r\n            list_to_decimal(sample['input'])\r\n        \r\ndef test_for_value_error():\r\n    invalid_samples = [\r\n        {'input':[-3,0]},\r\n        {'input':[1,12,1]},\r\n        {'input':[2,0,32]},\r\n        {'input':[-1,4,2]},\r\n        {'input':[2,10,7]},\r\n    ]\r\n    with pytest.raises(ValueError):\r\n        for sample in invalid_samples:\r\n            list_to_decimal(sample['input'])\r\n            \r\ndef test_for_10r():\r\n    with pytest.raises(ValueError):\r\n        list_to_decimal([10])\r\n        ",
            "date": "2022-09-15 18:14:09.707527+00:00",
            "passed": true
        },
        {
            "bite": "Bite 241. Write tests for list_to_decimal",
            "code": "import pytest\r\n\r\nfrom numbers_to_dec import list_to_decimal\r\n\r\ndef test_valid_cases():\r\n    samples = [\r\n        {'input':[0,4,2,8], 'result':428},\r\n        {'input':[1,2], 'result':12},\r\n        {'input':[3], 'result':3},\r\n        {'input':[0,6,5,9], 'result':659},\r\n    ]\r\n    for sample in samples:\r\n        assert list_to_decimal(sample['input']) == sample['result']\r\n\r\ndef test_for_type_error():\r\n    invalid_samples = [\r\n        {'input':[6,2,True]},\r\n        {'input':[3.6,4,1]},\r\n        {'input':['4',5,3,1]},\r\n        {'input':[[5,3],1]},\r\n        {'input':['foo',1]},\r\n    ]\r\n    with pytest.raises(TypeError):\r\n        for sample in invalid_samples:\r\n            list_to_decimal(sample['input'])\r\n        \r\ndef test_for_value_error():\r\n    invalid_samples = [\r\n        {'input':[-3,0]},\r\n        {'input':[1,12,1]},\r\n        {'input':[2,0,32]},\r\n        {'input':[-1,4,2]},\r\n        {'input':[2,10,7]},\r\n    ]\r\n    with pytest.raises(ValueError):\r\n        for sample in invalid_samples:\r\n            list_to_decimal(sample['input'])\r\n        ",
            "date": "2022-09-15 17:58:26.893348+00:00",
            "passed": false
        },
        {
            "bite": "Bite 241. Write tests for list_to_decimal",
            "code": "import pytest\r\n\r\nfrom numbers_to_dec import list_to_decimal\r\n\r\ndef test_valid_cases():\r\n    samples = [\r\n        {'input':[0,4,2,8], 'result':428},\r\n        {'input':[1,2], 'result':12},\r\n        {'input':[3], 'result':3},\r\n        {'input':[0,6,5,9], 'result':659},\r\n    ]\r\n    for sample in samples:\r\n        assert list_to_decimal(sample['input']) == sample['result']\r\n\r\ndef test_bool_type_error():\r\n    samples = [\r\n        {'input':[6,2,True]},\r\n        {'input':[3.6,4,1]},\r\n        {'input':['4',5,3,1]},\r\n        {'input':[[5,3],1]},\r\n        {'input':['foo',1]},\r\n    ]\r\n    with pytest.raises(TypeError):\r\n        for sample in samples:\r\n            list_to_decimal(sample['input'])\r\n        \r\ndef test_bool_value_error():\r\n    samples = [\r\n        {'input':[-3,0]},\r\n        {'input':[1,12,1]},\r\n        {'input':[2,0,32]},\r\n        {'input':[-1,4,2]},\r\n        {'input':[2,10,7]},\r\n    ]\r\n    with pytest.raises(ValueError):\r\n        for sample in samples:\r\n            list_to_decimal(sample['input'])\r\n        ",
            "date": "2022-09-15 17:53:22.591671+00:00",
            "passed": false
        },
        {
            "bite": "Bite 241. Write tests for list_to_decimal",
            "code": "import pytest\r\n\r\nfrom numbers_to_dec import list_to_decimal\r\n\r\ndef test_valid_cases():\r\n    samples = [\r\n        {'input':[0,4,2,8], 'result':428},\r\n        {'input':[1,2], 'result':12},\r\n        {'input':[3], 'result':3},\r\n        {'input':[0,6,5,9], 'result':659},\r\n    ]\r\n    for sample in samples:\r\n        assert list_to_decimal(sample['input']) == sample['result']\r\n\r\ndef test_bool_type_error():\r\n    samples = [\r\n        {'input':[6,2,True]},\r\n        {'input':[3.6,4,1]},\r\n        {'input':['4',5,3,1]},\r\n        {'input':[[5,3],1]},\r\n        {'input':['foo',1]},\r\n    ]\r\n    with pytest.raises(TypeError):\r\n        for sample in samples:\r\n            list_to_decimal(sample['input'])\r\n        \r\ndef test_bool_value_error():\r\n    samples = [\r\n        {'input':[-3,0]},\r\n        {'input':[1,12,1]},\r\n        {'input':[-1,10,32]},\r\n\r\n    ]\r\n    with pytest.raises(ValueError):\r\n        for sample in samples:\r\n            list_to_decimal(sample['input'])\r\n        ",
            "date": "2022-09-15 17:46:19.261327+00:00",
            "passed": false
        },
        {
            "bite": "Bite 218. Create a sandwich decorator",
            "code": "from functools import wraps\r\n\r\nUPPER_SLICE = \"=== Upper bread slice ===\"\r\nLOWER_SLICE = \"=== Lower bread slice ===\"\r\n\r\n\r\ndef sandwich(func):\r\n    \"\"\"Write a decorator that prints UPPER_SLICE and\r\n       LOWER_SLICE before and after calling the function (func)\r\n       that is passed in  (@wraps is to preserve the original\r\n       func's docstring)\r\n    \"\"\"\r\n    @wraps(func)\r\n    def wrapped(*args, **kwargs):\r\n        # do stuff before the original function gets called\r\n        print(UPPER_SLICE)\r\n        # call function\r\n        func(*args, **kwargs)\r\n        # do stuff after function call \r\n        print(LOWER_SLICE)\r\n        # return the result\r\n        # return result\r\n    # return wrapper as a decorated function\r\n    return wrapped\r\n    \r\n    \r\nif __name__ == \"__main__\":\r\n    \r\n    @sandwich\r\n    def add_ingredients(ingredients):\r\n        print(' / '.join(ingredients))\r\n\r\n    ingredients = ['bacon', 'lettuce', 'tomato']\r\n    add_ingredients(ingredients)",
            "date": "2022-09-15 17:05:52.753352+00:00",
            "passed": true
        },
        {
            "bite": "Bite 218. Create a sandwich decorator",
            "code": "from functools import wraps\r\n\r\nUPPER_SLICE = \"=== Upper bread slice ===\"\r\nLOWER_SLICE = \"=== Lower bread slice ===\"\r\n\r\n\r\ndef sandwich(func):\r\n    \"\"\"Write a decorator that prints UPPER_SLICE and\r\n       LOWER_SLICE before and after calling the function (func)\r\n       that is passed in  (@wraps is to preserve the original\r\n       func's docstring)\r\n    \"\"\"\r\n    @wraps(func)\r\n    def wrapped(*args, **kwargs):\r\n        # do stuff before the original function gets called\r\n        print(UPPER_SLICE)\r\n        # call function\r\n        result = func(*args, **kwargs)\r\n        # do stuff after function call \r\n        print(LOWER_SLICE)\r\n        # return the result\r\n        # return result\r\n    # return wrapper as a decorated function\r\n    return wrapped\r\n    \r\n    \r\nif __name__ == \"__main__\":\r\n    \r\n    @sandwich\r\n    def add_ingredients(ingredients):\r\n        print(' / '.join(ingredients))\r\n\r\n    ingredients = ['bacon', 'lettuce', 'tomato']\r\n    add_ingredients(ingredients)",
            "date": "2022-09-15 17:05:07.652201+00:00",
            "passed": true
        },
        {
            "bite": "Bite 64. Fix a truncating zip function",
            "code": "import itertools\r\n\r\nnames = 'Tim Bob Julian Carmen Sofia Mike Kim Andre'.split()\r\nlocations = 'DE ES AUS NL BR US'.split()\r\nconfirmed = [False, True, True, False, True]\r\n\r\n\r\ndef get_attendees():\r\n    for participant in itertools.zip_longest(names, locations, confirmed, fillvalue=\"-\"):\r\n        print(participant)\r\n\r\n\r\nif __name__ == '__main__':\r\n   print(get_attendees())",
            "date": "2022-09-15 16:11:41.091033+00:00",
            "passed": true
        },
        {
            "bite": "Newbie Bite 11. Adding and Removing items from a list",
            "code": "ninjabelts = ['white', 'yellow', 'orange', 'green', 'blue', 'brown', 'black']\r\n\r\n# Add 'bronze' and remove 'blue' from the ninjabelts list. Code below this line:\r\n\r\n\r\nninjabelts.append('bronze')\r\nninjabelts.remove('blue')",
            "date": "2022-09-15 15:56:08.321917+00:00",
            "passed": true
        },
        {
            "bite": "Newbie Bite 10. Returning items by list index",
            "code": "ninjabelts = ['white', 'yellow', 'orange', 'green', 'blue', 'brown', 'black']\r\n\r\n# Code all three requirements below this line\r\n\r\nninjabelts[-1]\r\nninjabelts[4]\r\nninjabelts[0]",
            "date": "2022-09-15 15:54:55.238899+00:00",
            "passed": true
        },
        {
            "bite": "Newbie Bite 09. Lists",
            "code": "# Enter your code below this line\r\n\r\nninjabelts = [\"white\", \"yellow\", \"orange\", \"green\", \"blue\", \"brown\", \"black\"]",
            "date": "2022-09-15 15:52:53.593360+00:00",
            "passed": true
        },
        {
            "bite": "Newbie Bite 09. Lists",
            "code": "# Enter your code below this line\r\n\r\nninjabelts = [white, yellow, orange, green, blue, brown, black]",
            "date": "2022-09-15 15:51:49.558146+00:00",
            "passed": false
        },
        {
            "bite": "Bite 130. Analyze some basic Car Data",
            "code": "from collections import Counter\r\nfrom operator import itemgetter\r\n\r\nimport requests\r\n\r\nCAR_DATA = 'https://bites-data.s3.us-east-2.amazonaws.com/cars.json'\r\n\r\n# pre-work: load JSON data into program\r\n\r\nwith requests.Session() as s:\r\n    data = s.get(CAR_DATA).json()\r\n\r\n\r\n# your turn:\r\ndef most_prolific_automaker(year):\r\n    \"\"\"Given year 'year' return the automaker that released\r\n       the highest number of new car models\"\"\"\r\n    automakers_in_year = set([item['automaker'] for item in data if item['year'] == year])\r\n    models_per_automaker = [(automaker, len(get_models(automaker, year))) for automaker in automakers_in_year]\r\n    return max(models_per_automaker, key=itemgetter(1))[0]\r\n\r\n\r\ndef get_models(automaker, year):\r\n    \"\"\"Filter cars 'data' by 'automaker' and 'year',\r\n       return a set of models (a 'set' to avoid duplicate models)\"\"\"\r\n    filtered_list = [item['model'] for item in data if item['automaker'].lower() == automaker.lower() and item['year'] == year]\r\n    return set(filtered_list)\r\n\r\n\r\nprint(most_prolific_automaker(2013))",
            "date": "2022-09-14 21:37:25.933606+00:00",
            "passed": true
        },
        {
            "bite": "Bite 130. Analyze some basic Car Data",
            "code": "from collections import Counter\r\nfrom operator import itemgetter\r\n\r\nimport requests\r\n\r\nCAR_DATA = 'https://bites-data.s3.us-east-2.amazonaws.com/cars.json'\r\n\r\n# pre-work: load JSON data into program\r\n\r\nwith requests.Session() as s:\r\n    data = s.get(CAR_DATA).json()\r\n\r\n\r\n# your turn:\r\ndef most_prolific_automaker(year):\r\n    \"\"\"Given year 'year' return the automaker that released\r\n       the highest number of new car models\"\"\"\r\n    automakers_in_year = set([item['automaker'] for item in data if item['year'] == year])\r\n    models_per_automaker = [(automaker, len(get_models(automaker, year))) for automaker in automakers_in_year]\r\n    print(models_per_automaker)\r\n    return max(models_per_automaker ,key=itemgetter(1))[0]\r\n\r\n\r\n\r\ndef get_models(automaker, year):\r\n    \"\"\"Filter cars 'data' by 'automaker' and 'year',\r\n       return a set of models (a 'set' to avoid duplicate models)\"\"\"\r\n    filtered_list = [item['model'] for item in data if item['automaker'].lower() == automaker.lower() and item['year'] == year]\r\n    dedup_set = set(filtered_list)\r\n    return dedup_set\r\n    \r\n\r\nprint(most_prolific_automaker(2000))",
            "date": "2022-09-14 21:35:57.806906+00:00",
            "passed": true
        },
        {
            "bite": "Newbie Bite 08. String Manipulation",
            "code": "autobot = \"Optimus\"\r\ndecepticon = \"megatron\"\r\ntransformers = \"robots in disguise\"\r\n\r\n# Enter your code below this line\r\n\r\nlowercase_autobot = autobot.lower()\r\nuppercase_decepticon = decepticon.upper()\r\ntitlecase_transformers = transformers.title()",
            "date": "2022-09-14 20:24:58.618004+00:00",
            "passed": true
        },
        {
            "bite": "Newbie Bite 07. User Input",
            "code": "# Enter your code below this line\r\nmonth = input(\"What's the name of the 12th month of the calendar year? \")",
            "date": "2022-09-14 20:22:29.154123+00:00",
            "passed": true
        },
        {
            "bite": "Newbie Bite 07. User Input",
            "code": "# Enter your code below this line\r\n\r\nmonth = input(\"What's the name of the 12th month of the calendar year?\")\r\n",
            "date": "2022-09-14 20:22:11.024181+00:00",
            "passed": true
        },
        {
            "bite": "Newbie Bite 07. User Input",
            "code": "# Enter your code below this line\r\n\r\nmonth = input (\"What's the name of the 12th month of the calendar year?\")",
            "date": "2022-09-14 20:20:28.509084+00:00",
            "passed": false
        },
        {
            "bite": "Newbie Bite 07. User Input",
            "code": "# Enter your code below this line\r\n\r\nmonth = input (\"What's the name of the 12th month of the calendar year? \")",
            "date": "2022-09-14 20:20:21.700095+00:00",
            "passed": false
        },
        {
            "bite": "Newbie Bite 07. User Input",
            "code": "# Enter your code below this line\r\n\r\nmonth = input (\"What\\\\'s the name of the 12th month of the calendar year? \")",
            "date": "2022-09-14 20:20:14.159266+00:00",
            "passed": false
        },
        {
            "bite": "Newbie Bite 06. Additional Maths",
            "code": "# In the same way as the previous Bite, assign the relative calculations of a and b\r\n# to the objects as per the above instructions\r\na = 10\r\nb = 5\r\n\r\n# Enter your code below this line\r\n\r\nsubtraction = a - b\r\nmultiplication = a * b\r\ndivision = a/b",
            "date": "2022-09-14 20:15:21.315038+00:00",
            "passed": true
        },
        {
            "bite": "Bite 13. Convert dict to namedtuple/json",
            "code": "from collections import namedtuple\r\nfrom datetime import datetime\r\nimport json\r\nfrom pprint import pprint\r\n\r\n\r\nblog = dict(name='PyBites',\r\n            founders=('Julian', 'Bob'),\r\n            started=datetime(year=2016, month=12, day=19),\r\n            tags=['Python', 'Code Challenges', 'Learn by Doing'],\r\n            location='Spain/Australia',\r\n            site='https://pybit.es')\r\n\r\n# define namedtuple here\r\n\r\ndef dict2nt(dict_):\r\n    Blog = namedtuple('Blog', dict_.keys())\r\n    return Blog(**dict_)\r\n\r\n\r\ndef nt2json(nt):\r\n    return json.dumps(nt._asdict(), indent = 4, default=str) \r\n\r\n\r\nnt=dict2nt(blog)\r\npprint(nt2json(nt))\r\n\r\n",
            "date": "2022-09-14 20:11:53.706377+00:00",
            "passed": true
        },
        {
            "bite": "Bite 55. Get the latest game releases from Steam's RSS feed",
            "code": "from pprint import pprint\r\nfrom collections import namedtuple\r\n\r\nimport feedparser\r\n\r\n# cached version to have predictable results for testing\r\nFEED_URL = \"https://bites-data.s3.us-east-2.amazonaws.com/steam_gaming.xml\"\r\n\r\nGame = namedtuple('Game', 'title link')\r\n\r\n\r\ndef get_games():\r\n    \"\"\"Parses Steam's RSS feed and returns a list of Game namedtuples\"\"\"\r\n    feed = feedparser.parse(FEED_URL)\r\n    lst = []\r\n    for entry in feed.entries:\r\n        lst.append(Game(entry.title, entry.link))\r\n            \r\n    # pprint(lst)\r\n    return lst\r\n    \r\nif __name__==\"__main__\":\r\n    get_games()",
            "date": "2022-09-14 16:19:42.570839+00:00",
            "passed": true
        },
        {
            "bite": "Bite 55. Get the latest game releases from Steam's RSS feed",
            "code": "from pprint import pprint\r\nfrom collections import namedtuple\r\n\r\nimport feedparser\r\n\r\n# cached version to have predictable results for testing\r\nFEED_URL = \"https://bites-data.s3.us-east-2.amazonaws.com/steam_gaming.xml\"\r\n\r\nGame = namedtuple('Game', 'title link')\r\n\r\n\r\ndef get_games():\r\n    \"\"\"Parses Steam's RSS feed and returns a list of Game namedtuples\"\"\"\r\n    feed = feedparser.parse(FEED_URL)\r\n    lst = []\r\n    for entry in feed.entries:\r\n        lst.append(Game(entry.title.encode('utf-8'), entry.link.encode('utf-8')))\r\n            \r\n    pprint(lst)\r\n    return lst\r\n    \r\nif __name__==\"__main__\":\r\n    get_games()",
            "date": "2022-09-14 16:18:10.339811+00:00",
            "passed": false
        },
        {
            "bite": "Bite 55. Get the latest game releases from Steam's RSS feed",
            "code": "from pprint import pprint\r\nfrom collections import namedtuple\r\n\r\nimport feedparser\r\n\r\n# cached version to have predictable results for testing\r\nFEED_URL = \"https://bites-data.s3.us-east-2.amazonaws.com/steam_gaming.xml\"\r\n\r\nGame = namedtuple('Game', 'title link')\r\n\r\n\r\ndef get_games():\r\n    \"\"\"Parses Steam's RSS feed and returns a list of Game namedtuples\"\"\"\r\n    feed = feedparser.parse(FEED_URL)\r\n    lst = []\r\n    for entry in feed.entries:\r\n        lst.append(Game(entry.title.encode('utf-8'), entry.link.encode('utf-8')))  # u'http://example.org/item/1'\r\n            \r\n    pprint(lst)\r\n    \r\nif __name__==\"__main__\":\r\n    get_games()",
            "date": "2022-09-14 16:13:17.442989+00:00",
            "passed": false
        },
        {
            "bite": "Bite 238. Write tests for Fibonacci",
            "code": "from fibonacci import fib\r\n\r\nimport pytest\r\n\r\n# write one or more pytest functions below, they need to start with test_\r\n# 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144\r\n\r\n\r\ndef test_n_negative():\r\n    # fib(-1) ValueError\r\n    with pytest.raises(ValueError):\r\n        fib(-1)\r\n\r\n\r\ndef test_n_0():\r\n    fib_lst = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\r\n    for (i, expected) in enumerate(fib_lst):\r\n        assert fib(i) == expected\r\n\r\n\r\n\r\n",
            "date": "2022-09-14 00:38:33.388143+00:00",
            "passed": true
        },
        {
            "bite": "Bite 238. Write tests for Fibonacci",
            "code": "from fibonacci import fib\r\n\r\n# write one or more pytest functions below, they need to start with test_\r\n\r\n\r\n# 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144\r\n\r\n\r\ndef test_n_negative():\r\n    # fib(-1) ValueError\r\n    pass\r\n\r\ndef test_n_0():\r\n    fib_lst = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\r\n    for (i, expected) in enumerate(fib_lst):\r\n        assert fib(i) == expected\r\n\r\n\r\n\r\n",
            "date": "2022-09-14 00:34:13.230311+00:00",
            "passed": false
        },
        {
            "bite": "Bite 238. Write tests for Fibonacci",
            "code": "from fibonacci import fib\r\n\r\n# write one or more pytest functions below, they need to start with test_\r\n\r\n\r\n# 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144\r\n\r\n\r\ndef test_n_negative():\r\n    # fib(-1) ValueError\r\n    pass\r\n\r\ndef test_n_0():\r\n    fib_lst = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\r\n    for (i, expected) enumerate(fib_lst):\r\n        assert fib(i) == expected\r\n\r\n\r\n\r\n",
            "date": "2022-09-14 00:34:00.091106+00:00",
            "passed": false
        },
        {
            "bite": "Bite 238. Write tests for Fibonacci",
            "code": "from fibonacci import fib\r\n\r\n# write one or more pytest functions below, they need to start with test_\r\n\r\n\r\nfib(-1)",
            "date": "2022-09-14 00:23:58.451672+00:00",
            "passed": false
        },
        {
            "bite": "Bite 19. Write a property",
            "code": "from datetime import datetime, timedelta\r\nNOW = datetime.now()\r\n\r\n\r\nclass Promo:\r\n    def __init__(self, name:str, expires: datetime):\r\n        self.name = name\r\n        self.expires = expires\r\n        print(f\"{self.name} expires on {self.expires}\")\r\n        \r\n\r\n    @property\r\n    def expired(self):\r\n        return True if datetime.now() >= self.expires else False\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    test1 = Promo (\"Promo1\", datetime.now()-timedelta(days=2))\r\n    print(test1.expired)\r\n    test2 = Promo (\"Promo2\", datetime.now())\r\n    print(test2.expired)\r\n    test3 = Promo (\"Promo2\", datetime.now()+timedelta(days=2))\r\n    print(test3.expired)",
            "date": "2022-09-14 00:13:48.777551+00:00",
            "passed": true
        },
        {
            "bite": "Bite 19. Write a property",
            "code": "from datetime import datetime, timedelta\r\nNOW = datetime.now()\r\n\r\n\r\nclass Promo:\r\n    def __init__(self, name:str, expires: datetime):\r\n        self.name = name\r\n        self.expires = expires\r\n        print(f\"{self.name} expires on {self.expires}\")\r\n        \r\n\r\n    @property\r\n    def expired(self):\r\n        return True if datetime.now() >= self.expires else False\r\n\r\n\r\ntest1 = Promo (\"Promo1\", datetime.now()-timedelta(days=2))\r\nprint(test1.expired)\r\ntest2 = Promo (\"Promo2\", datetime.now())\r\nprint(test2.expired)\r\ntest3 = Promo (\"Promo2\", datetime.now()+timedelta(days=2))\r\nprint(test3.expired)",
            "date": "2022-09-14 00:12:40.343193+00:00",
            "passed": true
        },
        {
            "bite": "Bite 262. GC content",
            "code": "def calculate_gc_content(sequence):\r\n    \"\"\"\r\n    Receives a DNA sequence (A, G, C, or T)\r\n    Returns the percentage of GC content (rounded to the last two digits)\r\n    \"\"\"\r\n    clean_sequence = \"\".join([letter for letter in sequence.upper() if letter in \"AGCT\"])\r\n    total = len(clean_sequence)\r\n    gc_count = len([letter for letter in clean_sequence if letter in \"GC\"])\r\n\r\n    return round(100 * gc_count / total , 2)\r\n\r\n\r\npercent = calculate_gc_content(\"a,G.c T\\nAGcT\")\r\nprint(f\"{percent:0.2f}\")\r\n",
            "date": "2022-09-13 12:42:52.784225+00:00",
            "passed": true
        },
        {
            "bite": "Bite 337. A little detour: Pydantic",
            "code": "from pydantic import BaseModel\r\nfrom typing import Optional\r\n\r\n# write a Food pydantic model\r\n\r\n\r\n\r\n\r\nclass Food(BaseModel):\r\n    id: int\r\n    name: str\r\n    serving_size: str\r\n    kcal_per_serving: int\r\n    protein_grams: float\r\n    fibre_grams: Optional[float] = 0.0\r\n    \r\n\r\nif __name__ == \"__main__\":\r\n    food = Food(id = 3, name =\"spaghetti\", serving_size = \"100g\", kcal_per_serving=500, protein_grams =5.1)\r\n    print(food.name)\r\n    print(food.kcal_per_serving)\r\n    print(food.fibre_grams)",
            "date": "2022-09-13 12:03:03.143661+00:00",
            "passed": true
        },
        {
            "bite": "Newbie Bite 05. Basic Maths",
            "code": "# As per the instructions, assign the requested integer to the below objects, a and b,\r\n# then assign the calculation to the object \"answer\".\r\na = 7\r\nb = 3\r\nanswer = a + b",
            "date": "2022-09-12 19:59:15.168525+00:00",
            "passed": true
        },
        {
            "bite": "Bite 37. Rewrite a for loop using recursion",
            "code": "def countdown_for(start=10):\r\n    for i in reversed(range(1, start + 1)):\r\n        print(i)\r\n    print('time is up')\r\n\r\n\r\ndef countdown_recursive(start=10):\r\n    if start == 0:\r\n        print('time is up')\r\n        return             # Terminate recursion\r\n    else:\r\n        print(start)\r\n        countdown_recursive(start - 1)   # Recursive call\r\n\r\n\r\ncountdown_recursive(0)\r\n",
            "date": "2022-09-12 19:52:11.841945+00:00",
            "passed": true
        },
        {
            "bite": "Bite 37. Rewrite a for loop using recursion",
            "code": "def countdown_for(start=10):\r\n    for i in reversed(range(1, start + 1)):\r\n        print(i)\r\n    print('time is up')\r\n\r\n\r\ndef countdown_recursive(start=10):\r\n    print(start)\r\n    if start == 1:\r\n        print('time is up')\r\n        return             # Terminate recursion\r\n    else:\r\n        countdown_recursive(start - 1)   # Recursive call\r\n\r\n\r\ncountdown_recursive(10)\r\n",
            "date": "2022-09-12 19:47:20.248032+00:00",
            "passed": false
        },
        {
            "bite": "Bite 21. Query a nested data structure",
            "code": "from typing import Dict, List\r\n\r\ncars = {\r\n    'Ford': ['Falcon', 'Focus', 'Festiva', 'Fairlane'],\r\n    'Holden': ['Commodore', 'Captiva', 'Barina', 'Trailblazer'],\r\n    'Nissan': ['Maxima', 'Pulsar', '350Z', 'Navara'],\r\n    'Honda': ['Civic', 'Accord', 'Odyssey', 'Jazz'],\r\n    'Jeep': ['Grand Cherokee', 'Cherokee', 'Trailhawk', 'Trackhawk']\r\n}\r\nDEFAULT_SEARCH = \"trail\"\r\nCarsType = Dict[str, List[str]]\r\n\r\n\r\ndef get_all_jeeps(cars: CarsType = cars) -> str:\r\n    \"\"\"\r\n    Retrieve the 'Jeep' models from the cars dict and join them by a\r\n    comma and space (', '). Leave the original ordering intact.\r\n    \"\"\"\r\n    return \", \".join(cars[\"Jeep\"])\r\n\r\n\r\ndef get_first_model_each_manufacturer(cars: CarsType = cars) -> List[str]:\r\n    \"\"\"\r\n    Loop through the cars dict filtering out the first model for each\r\n    manufacturer. Return the matching models in a list leaving the original\r\n    ordering intact.\r\n    \"\"\"\r\n    return [cars[item][0] for item in cars]\r\n\r\n\r\ndef get_all_matching_models(\r\n    cars: CarsType = cars, grep: str = DEFAULT_SEARCH\r\n) -> List[str]:\r\n    \"\"\"\r\n    Return a list of all models containing the case insensitive\r\n    'grep' string which defaults to DEFAULT_SEARCH ('trail').\r\n    Sort the resulting sequence alphabetically\r\n    \"\"\"\r\n    model_lst = sum([cars[manuf] for manuf in cars],[])  # get flattened list of all models\r\n    # [f(x) for x in sequence if condition]\r\n    return sorted([item for item in model_lst if grep.lower() in item.lower() ])  # get the ones containing the grep\r\n\r\n\r\ndef sort_car_models(cars: CarsType = cars) -> CarsType:\r\n    \"\"\"\r\n    Loop through the cars dict returning a new dict with the\r\n    same keys and the values sorted alphabetically.\r\n    \"\"\"\r\n    \r\n    return dict([(item, sorted(cars[item])) for item in cars])\r\n\r\n\r\nprint(get_all_jeeps())\r\nprint(get_first_model_each_manufacturer())\r\nprint(get_all_matching_models())\r\nprint(sort_car_models())",
            "date": "2022-09-11 23:30:14.788427+00:00",
            "passed": true
        },
        {
            "bite": "Bite 21. Query a nested data structure",
            "code": "from typing import Dict, List\r\n\r\ncars = {\r\n    'Ford': ['Falcon', 'Focus', 'Festiva', 'Fairlane'],\r\n    'Holden': ['Commodore', 'Captiva', 'Barina', 'Trailblazer'],\r\n    'Nissan': ['Maxima', 'Pulsar', '350Z', 'Navara'],\r\n    'Honda': ['Civic', 'Accord', 'Odyssey', 'Jazz'],\r\n    'Jeep': ['Grand Cherokee', 'Cherokee', 'Trailhawk', 'Trackhawk']\r\n}\r\nDEFAULT_SEARCH = \"trail\"\r\nCarsType = Dict[str, List[str]]\r\n\r\n\r\ndef get_all_jeeps(cars: CarsType = cars) -> str:\r\n    \"\"\"\r\n    Retrieve the 'Jeep' models from the cars dict and join them by a\r\n    comma and space (', '). Leave the original ordering intact.\r\n    \"\"\"\r\n    return \", \".join(cars[\"Jeep\"])\r\n\r\n\r\ndef get_first_model_each_manufacturer(cars: CarsType = cars) -> List[str]:\r\n    \"\"\"\r\n    Loop through the cars dict filtering out the first model for each\r\n    manufacturer. Return the matching models in a list leaving the original\r\n    ordering intact.\r\n    \"\"\"\r\n    return [cars[item][0] for item in cars]\r\n\r\n\r\ndef get_all_matching_models(\r\n    cars: CarsType = cars, grep: str = DEFAULT_SEARCH\r\n) -> List[str]:\r\n    \"\"\"\r\n    Return a list of all models containing the case insensitive\r\n    'grep' string which defaults to DEFAULT_SEARCH ('trail').\r\n    Sort the resulting sequence alphabetically\r\n    \"\"\"\r\n    model_lst = sum([cars[manuf] for manuf in cars],[])  # get flattened list of all models\r\n    # [f(x) for x in sequence if condition]\r\n    return [item for item in model_lst if grep.lower() in item.lower() ]  # get the ones containing the grep\r\n\r\n\r\ndef sort_car_models(cars: CarsType = cars) -> CarsType:\r\n    \"\"\"\r\n    Loop through the cars dict returning a new dict with the\r\n    same keys and the values sorted alphabetically.\r\n    \"\"\"\r\n    \r\n    return dict([(item, sorted(cars[item])) for item in cars])\r\n\r\n\r\nprint(get_all_jeeps())\r\nprint(get_first_model_each_manufacturer())\r\nprint(get_all_matching_models())\r\nprint(sort_car_models())",
            "date": "2022-09-11 23:28:24.333761+00:00",
            "passed": false
        },
        {
            "bite": "Bite 21. Query a nested data structure",
            "code": "from typing import Dict, List\r\n\r\ncars = {\r\n    'Ford': ['Falcon', 'Focus', 'Festiva', 'Fairlane'],\r\n    'Holden': ['Commodore', 'Captiva', 'Barina', 'Trailblazer'],\r\n    'Nissan': ['Maxima', 'Pulsar', '350Z', 'Navara'],\r\n    'Honda': ['Civic', 'Accord', 'Odyssey', 'Jazz'],\r\n    'Jeep': ['Grand Cherokee', 'Cherokee', 'Trailhawk', 'Trackhawk']\r\n}\r\nDEFAULT_SEARCH = \"trail\"\r\nCarsType = Dict[str, List[str]]\r\n\r\n\r\ndef get_all_jeeps(cars: CarsType = cars) -> str:\r\n    \"\"\"\r\n    Retrieve the 'Jeep' models from the cars dict and join them by a\r\n    comma and space (', '). Leave the original ordering intact.\r\n    \"\"\"\r\n    return \", \".join(cars[\"Jeep\"])\r\n\r\n\r\ndef get_first_model_each_manufacturer(cars: CarsType = cars) -> List[str]:\r\n    \"\"\"\r\n    Loop through the cars dict filtering out the first model for each\r\n    manufacturer. Return the matching models in a list leaving the original\r\n    ordering intact.\r\n    \"\"\"\r\n    return [cars[item][0] for item in cars]\r\n\r\n\r\ndef get_all_matching_models(\r\n    cars: CarsType = cars, grep: str = DEFAULT_SEARCH\r\n) -> List[str]:\r\n    \"\"\"\r\n    Return a list of all models containing the case insensitive\r\n    'grep' string which defaults to DEFAULT_SEARCH ('trail').\r\n    Sort the resulting sequence alphabetically\r\n    \"\"\"\r\n    model_lst = sum([cars[manuf] for manuf in cars],[])  # get flattened list of all models\r\n    # [f(x) for x in sequence if condition]\r\n    return [item for item in model_lst if grep in item.lower() ]  # get the ones containing the grep\r\n\r\n\r\ndef sort_car_models(cars: CarsType = cars) -> CarsType:\r\n    \"\"\"\r\n    Loop through the cars dict returning a new dict with the\r\n    same keys and the values sorted alphabetically.\r\n    \"\"\"\r\n    \r\n    return dict([(item, sorted(cars[item])) for item in cars])\r\n\r\n\r\nprint(get_all_jeeps())\r\nprint(get_first_model_each_manufacturer())\r\nprint(get_all_matching_models())\r\nprint(sort_car_models())",
            "date": "2022-09-11 23:26:28.508394+00:00",
            "passed": false
        },
        {
            "bite": "Bite 21. Query a nested data structure",
            "code": "from typing import Dict, List\r\n\r\ncars = {\r\n    'Ford': ['Falcon', 'Focus', 'Festiva', 'Fairlane'],\r\n    'Holden': ['Commodore', 'Captiva', 'Barina', 'Trailblazer'],\r\n    'Nissan': ['Maxima', 'Pulsar', '350Z', 'Navara'],\r\n    'Honda': ['Civic', 'Accord', 'Odyssey', 'Jazz'],\r\n    'Jeep': ['Grand Cherokee', 'Cherokee', 'Trailhawk', 'Trackhawk']\r\n}\r\nDEFAULT_SEARCH = \"trail\"\r\nCarsType = Dict[str, List[str]]\r\n\r\n\r\ndef get_all_jeeps(cars: CarsType = cars) -> str:\r\n    \"\"\"\r\n    Retrieve the 'Jeep' models from the cars dict and join them by a\r\n    comma and space (', '). Leave the original ordering intact.\r\n    \"\"\"\r\n    return \", \".join(cars[\"Jeep\"])\r\n\r\n\r\ndef get_first_model_each_manufacturer(cars: CarsType = cars) -> List[str]:\r\n    \"\"\"\r\n    Loop through the cars dict filtering out the first model for each\r\n    manufacturer. Return the matching models in a list leaving the original\r\n    ordering intact.\r\n    \"\"\"\r\n    return [cars[item][0] for item in cars]\r\n\r\n\r\ndef get_all_matching_models(\r\n    cars: CarsType = cars, grep: str = DEFAULT_SEARCH\r\n) -> List[str]:\r\n    \"\"\"\r\n    Return a list of all models containing the case insensitive\r\n    'grep' string which defaults to DEFAULT_SEARCH ('trail').\r\n    Sort the resulting sequence alphabetically\r\n    \"\"\"\r\n    model_lst = sum([cars[manuf] for manuf in cars],[])  # flattened list of all models\r\n    # [f(x) for x in sequence if condition]\r\n    return [item for item in model_lst if grep in item.lower() ]  # get the ones containing the grep\r\n\r\n\r\n\r\n\r\ndef sort_car_models(cars: CarsType = cars) -> CarsType:\r\n    \"\"\"\r\n    Loop through the cars dict returning a new dict with the\r\n    same keys and the values sorted alphabetically.\r\n    \"\"\"\r\n    pass\r\n\r\nprint(get_all_jeeps())\r\nprint(get_first_model_each_manufacturer())\r\nprint(get_all_matching_models())\r\nprint(sort_car_models())",
            "date": "2022-09-11 23:18:12.546934+00:00",
            "passed": false
        },
        {
            "bite": "Bite 336. FastAPI Hello World",
            "code": "from fastapi import FastAPI # 1) import FastAPI\r\n\r\napp = FastAPI()  # 2) create a FastAPI instance in the variable my_app\r\n\r\n@app.get(\"/\")  # 3) define a path operation decorator for GET requests to the URL \"/\"\r\nasync def root():  # 4) write the path operation function\r\n    return {\"message\": \"Welcome to PyBites' FastAPI Learning Path \ud83d\udc0d \ud83c\udf89\"}  # 5) return the content",
            "date": "2022-09-11 22:41:18.504109+00:00",
            "passed": true
        },
        {
            "bite": "Bite 336. FastAPI Hello World",
            "code": "from fastapi import FastAPI # 1) import FastAPI\r\n\r\nmy_app = FastAPI()  # 2) create a FastAPI instance in the variable my_app\r\n\r\n@my_app.get(\"/\")  # 3) define a path operation decorator for GET requests to the URL \"/\"\r\nasync def root():  # 4) write the path operation function\r\n    return {\"message\": \"Welcome to PyBites' FastAPI Learning Path \ud83d\udc0d \ud83c\udf89\"}  # 5) return the content",
            "date": "2022-09-11 22:40:26.956759+00:00",
            "passed": false
        },
        {
            "bite": "Bite 16. PyBites date generator",
            "code": "from pprint import pprint\r\nfrom itertools import islice\r\nfrom datetime import datetime, timedelta\r\n\r\nPYBITES_BORN = datetime(year=2016, month=12, day=19)\r\n\r\n\r\ndef gen_special_pybites_dates():\r\n    special_date = PYBITES_BORN\r\n    while True:\r\n        special_date+=timedelta(days=100)\r\n        yield special_date\r\n        \r\n        \r\ngen = gen_special_pybites_dates()\r\npprint(list(islice(gen, 5)))",
            "date": "2022-09-11 15:25:12.857478+00:00",
            "passed": true
        },
        {
            "bite": "Bite 16. PyBites date generator",
            "code": "from pprint import pprint\r\nfrom itertools import islice\r\nfrom datetime import datetime, timedelta\r\n\r\nPYBITES_BORN = datetime(year=2016, month=12, day=19)\r\n\r\n\r\ndef gen_special_pybites_dates():\r\n    special_date = PYBITES_BORN\r\n    while True:\r\n        special_date+=timedelta(days=100)\r\n        yield special_date\r\ngen = gen_special_pybites_dates()\r\npprint(list(islice(gen, 5)))",
            "date": "2022-09-11 15:24:18.046127+00:00",
            "passed": true
        },
        {
            "bite": "Bite 16. PyBites date generator",
            "code": "from datetime import datetime, timedelta\r\n\r\nPYBITES_BORN = datetime(year=2016, month=12, day=19)\r\n\r\n\r\ndef gen_special_pybites_dates():\r\n    special_date = PYBITES_BORN\r\n    while True:\r\n        yield special_date+timedelta(days=10)\r\n        \r\ngen = gen_special_pybites_dates()\r\npprint(list(islice(gen, 5)))",
            "date": "2022-09-11 15:20:36.817729+00:00",
            "passed": false
        },
        {
            "bite": "Bite 15. Enumerate 2 sequences",
            "code": "names = 'Julian Bob PyBites Dante Martin Rodolfo'.split()\r\ncountries = 'Australia Spain Global Argentina USA Mexico'.split()\r\n\r\n\r\ndef enumerate_names_countries():\r\n    \"\"\"Outputs:\r\n       1. Julian     Australia\r\n       2. Bob        Spain\r\n       3. PyBites    Global\r\n       4. Dante      Argentina\r\n       5. Martin     USA\r\n       6. Rodolfo    Mexico\"\"\"\r\n    for count, (name, country) in enumerate(zip (names,countries)):\r\n        print(f\"{count+1}. {name:11}{country}\")\r\n        \r\n\r\nenumerate_names_countries()",
            "date": "2022-09-11 10:23:02.366679+00:00",
            "passed": true
        },
        {
            "bite": "Bite 15. Enumerate 2 sequences",
            "code": "names = 'Julian Bob PyBites Dante Martin Rodolfo'.split()\r\ncountries = 'Australia Spain Global Argentina USA Mexico'.split()\r\n\r\n\r\ndef enumerate_names_countries():\r\n    \"\"\"Outputs:\r\n       1. Julian     Australia\r\n       2. Bob        Spain\r\n       3. PyBites    Global\r\n       4. Dante      Argentina\r\n       5. Martin     USA\r\n       6. Rodolfo    Mexico\"\"\"\r\n    for count, (name, country) in enumerate(zip (names,countries)):\r\n        print(f\"{count}. {name:11}{country}\")\r\n        \r\n\r\nenumerate_names_countries()",
            "date": "2022-09-11 10:19:11.435672+00:00",
            "passed": false
        },
        {
            "bite": "Bite 15. Enumerate 2 sequences",
            "code": "names = 'Julian Bob PyBites Dante Martin Rodolfo'.split()\r\ncountries = 'Australia Spain Global Argentina USA Mexico'.split()\r\n\r\n\r\ndef enumerate_names_countries():\r\n    \"\"\"Outputs:\r\n       1. Julian     Australia\r\n       2. Bob        Spain\r\n       3. PyBites    Global\r\n       4. Dante      Argentina\r\n       5. Martin     USA\r\n       6. Rodolfo    Mexico\"\"\"\r\n    for count, (name, country) in enumerate(zip (names,countries)):\r\n        print(f\"{count}. {name:10}{country}\")\r\n        \r\n\r\nenumerate_names_countries()",
            "date": "2022-09-11 10:18:18.833580+00:00",
            "passed": false
        },
        {
            "bite": "Newbie Bite 04. Printing Objects",
            "code": "year = 2016\r\nmonth = \"December\"\r\nname = \"PyBites\"\r\n\r\n# Type your print statement below this line\r\nprint(f\"{name} was founded in {month} {year}.\")\r\n",
            "date": "2022-09-11 01:20:42.705175+00:00",
            "passed": true
        },
        {
            "bite": "Newbie Bite 04. Printing Objects",
            "code": "year = 2016\r\nmonth = \"December\"\r\nname = \"PyBites\"\r\n\r\n# Type your print statement below this line\r\nprint(f\"{name} was founded in {month} {year}\")\r\n",
            "date": "2022-09-11 01:20:15.346773+00:00",
            "passed": false
        },
        {
            "bite": "Newbie Bite 04. Printing Objects",
            "code": "year = 2016\r\nmonth = \"December\"\r\nname = \"PyBites\"\r\n\r\n# Type your print statement below this line\r\nprint(f\"{year}\")\r\nprint(f\"{month}\")\r\nprint(f\"{name}\")\r\n",
            "date": "2022-09-11 01:19:06.634787+00:00",
            "passed": false
        },
        {
            "bite": "Newbie Bite 04. Printing Objects",
            "code": "year = 2016\r\nmonth = \"December\"\r\nname = \"PyBites\"\r\n\r\n# Type your print statement below this line\r\nprint(f\"{name} {month} {year}\")",
            "date": "2022-09-11 01:17:31.957339+00:00",
            "passed": false
        },
        {
            "bite": "Bite 8. Rotate string characters",
            "code": "def rotate(string, n):\r\n    \"\"\"Rotate characters in a string.\r\n       Expects string and n (int) for number of characters to move.\r\n    \"\"\"\r\n    l=len(string)\r\n    n = n % l\r\n    return (string * 3)[l + n : 2 * l + n]\r\n                    \r\nprint(\"5: \",rotate(\"0123456789\",5)) \r\nprint(\"-2: \",rotate(\"0123456789\",-2)) \r\nprint(\"-12: \",rotate(\"0123456789\",-12)) \r\nprint(\"10: \",rotate(\"0123456789\",10)) ",
            "date": "2022-09-11 00:35:26.237377+00:00",
            "passed": true
        },
        {
            "bite": "Bite 8. Rotate string characters",
            "code": "def rotate(string, n):\r\n    \"\"\"Rotate characters in a string.\r\n       Expects string and n (int) for number of characters to move.\r\n    \"\"\"\r\n    \r\n    r_rot = l_rot = 0\r\n    \r\n    if n<0:\r\n        l_rot = -n\r\n    else:\r\n        r_rot = n\r\n            \r\n    return (string * 3)[len(string) + r_rot - l_rot : 2 * len(string) + r_rot - l_rot]\r\n                    \r\nprint(\"5: \",rotate(\"thisisatest\",5)) \r\nprint(\"-2: \",rotate(\"thisisatest\",-2)) ",
            "date": "2022-09-11 00:25:18.982622+00:00",
            "passed": false
        },
        {
            "bite": "Intro Bite 10. Type conversion and exception handling",
            "code": "def divide_numbers(numerator, denominator):\r\n    \"\"\"For this exercise you can assume numerator and denominator are of type\r\n       int/str/float.\r\n       Try to convert numerator and denominator to int types, if that raises a\r\n       ValueError reraise it. Following do the division and return the result.\r\n       However if denominator is 0 catch the corresponding exception Python\r\n       throws (cannot divide by 0), and return 0\"\"\"\r\n    try:\r\n        num=int(numerator)\r\n        den=int(denominator)\r\n    except ValueError:\r\n        print(\"numerator and denominator cannot be casted to int\")\r\n        raise\r\n    \r\n    try:\r\n        result = num/den\r\n    except ZeroDivisionError:\r\n        print(\"cannot divide by zero\")\r\n        result = 0\r\n    \r\n    return result",
            "date": "2022-09-10 22:24:01.776370+00:00",
            "passed": true
        },
        {
            "bite": "Intro Bite 09. Workout dictionary lookups",
            "code": "WORKOUT_SCHEDULE = {'Friday': 'Shoulders',\r\n                    'Monday': 'Chest+biceps',\r\n                    'Saturday': 'Rest',\r\n                    'Sunday': 'Rest',\r\n                    'Thursday': 'Legs',\r\n                    'Tuesday': 'Back+triceps',\r\n                    'Wednesday': 'Core'}\r\nREST, CHILL_OUT, TRAIN = 'Rest', 'Chill out!', 'Go train {}'\r\nINVALID_DAY = 'Not a valid day'\r\n\r\n\r\ndef get_workout_motd(day):\r\n    \"\"\"First title case the passed in day argument\r\n       (so monday or MONDAY both result in Monday).\r\n\r\n       If day is not in WORKOUT_SCHEDULE, return INVALID_DAY\r\n\r\n       If day is in WORKOUT_SCHEDULE retrieve the value (workout)\r\n       and return the following:\r\n       - weekday, return TRAIN with the workout value interpolated\r\n       - weekend day (value 'Rest'), return CHILL_OUT\r\n\r\n       Examples:\r\n       - if day is Monday -> function returns 'Go train Chest+biceps'\r\n       - if day is Thursday -> function returns 'Go train Legs'\r\n       - if day is Saturday -> function returns 'Chill out!'\r\n       - if day is nonsense -> function returns 'Not a valid day'\r\n\r\n       Trivia: /etc/motd is a file on Unix-like systems that contains\r\n       a 'message of the day'\r\n    \"\"\"\r\n    day = day.title()\r\n    if day not in WORKOUT_SCHEDULE:\r\n        return INVALID_DAY\r\n    if WORKOUT_SCHEDULE[day] == REST:\r\n        return CHILL_OUT\r\n    return TRAIN.format(WORKOUT_SCHEDULE[day])\r\n    \r\nprint(get_workout_motd(\"pepe\"))\r\nprint(get_workout_motd(\"monday\"))\r\nprint(get_workout_motd(\"sunday\"))",
            "date": "2022-09-10 20:52:51.796114+00:00",
            "passed": true
        },
        {
            "bite": "Intro Bite 08. Loop over a dict of namedtuples calculating a total score",
            "code": "from collections import namedtuple\r\n\r\nBeltStats = namedtuple('BeltStats', 'score ninjas')\r\n\r\nninja_belts = {'yellow': BeltStats(50, 11),\r\n               'orange': BeltStats(100, 7),\r\n               'green': BeltStats(175, 1),\r\n               'blue': BeltStats(250, 5)}\r\n\r\n\r\ndef get_total_points(belts=ninja_belts):\r\n    \"\"\"Calculate the amount of points rewarded on PyBites given the\r\n       ninja_belts dictionary, formula: belt score x belt owners (aka ninjas)\r\n       (of course there are more points but let's keep it simple)\r\n\r\n       Make your code generic so if we update ninja_belts to include\r\n       more belts (which we do in the tests) it will still work.\r\n\r\n       Ah and you can get score and ninjas from the namedtuple with nice\r\n       attribute access: belt.score / belt.ninjas (reason why we get\r\n       you familiar with namedtuple here, because we love them and use\r\n       them all over the place!)\r\n\r\n       Return the total number of points int from the function.\"\"\"\r\n    total = 0\r\n    print(belts)\r\n    print(belts['yellow'])\r\n    for item in belts:\r\n        total += int(belts[item].score) * int(belts[item].ninjas)\r\n    return total\r\n    \r\nprint(get_total_points())\r\n",
            "date": "2022-09-10 20:43:23.697874+00:00",
            "passed": true
        },
        {
            "bite": "Bite 5. Parse a list of names",
            "code": "from operator import itemgetter\r\n\r\nNAMES = ['arnold schwarzenegger', 'alec baldwin', 'bob belderbos',\r\n         'julian sequeira', 'sandra bullock', 'keanu reeves',\r\n         'julbob pybites', 'bob belderbos', 'julian sequeira',\r\n         'al pacino', 'brad pitt', 'matt damon', 'brad pitt']\r\n\r\n\r\ndef dedup_and_title_case_names(names):\r\n    \"\"\"Should return a list of title cased names,\r\n       each name appears only once\"\"\"\r\n    processed_names= []\r\n    for name in names:\r\n        name = name.title()\r\n        if name not in processed_names:\r\n            processed_names.append(name)\r\n    return processed_names\r\n\r\n\r\ndef sort_by_surname_desc(names):\r\n    \"\"\"Returns names list sorted desc by surname\"\"\"\r\n    names = dedup_and_title_case_names(names)\r\n    names_list= []\r\n    for name in names:\r\n        name=name.split()\r\n        names_list.append([name[0],name[1]])\r\n    names_list.sort(key=lambda x:x[1], reverse=True)\r\n    processed_names=[]\r\n    for name_surname in names_list:\r\n        processed_names.append(\" \".join(name_surname))\r\n    return processed_names\r\n\r\n\r\ndef shortest_first_name(names):\r\n    \"\"\"Returns the shortest first name (str).\r\n       You can assume there is only one shortest name.\r\n    \"\"\"\r\n    clean_names = dedup_and_title_case_names(names)\r\n    shortest_name= \"\"\r\n    shortest_length=len(names)+1\r\n    for name in clean_names:\r\n        name=name.split()\r\n        if len(name[0])<shortest_length:\r\n            shortest_name= name[0]\r\n            shortest_length= len(shortest_name) \r\n    return shortest_name\r\n\r\n    \r\nprint(dedup_and_title_case_names(NAMES))\r\nprint(sort_by_surname_desc(NAMES))\r\nprint(shortest_first_name(NAMES))\r\n",
            "date": "2022-09-10 13:17:07.725986+00:00",
            "passed": true
        },
        {
            "bite": "Bite 5. Parse a list of names",
            "code": "from operator import itemgetter\r\n\r\nNAMES = ['arnold schwarzenegger', 'alec baldwin', 'bob belderbos',\r\n         'julian sequeira', 'sandra bullock', 'keanu reeves',\r\n         'julbob pybites', 'bob belderbos', 'julian sequeira',\r\n         'al pacino', 'brad pitt', 'matt damon', 'brad pitt']\r\n\r\n\r\ndef dedup_and_title_case_names(names):\r\n    \"\"\"Should return a list of title cased names,\r\n       each name appears only once\"\"\"\r\n    processed_names= []\r\n    for name in names:\r\n        name = name.title()\r\n        if name not in processed_names:\r\n            processed_names.append(name)\r\n    return processed_names\r\n\r\n\r\ndef sort_by_surname_desc(names):\r\n    \"\"\"Returns names list sorted desc by surname\"\"\"\r\n    names = dedup_and_title_case_names(names)\r\n    names_list= []\r\n    for name in names:\r\n        name=name.split()\r\n        names_list.append([name[0],name[1]])\r\n    names_list.sort(key=lambda x:x[1])\r\n    processed_names=[]\r\n    for name_surname in names_list:\r\n        processed_names.append(\" \".join(name_surname))\r\n    return processed_names\r\n\r\n\r\ndef shortest_first_name(names):\r\n    \"\"\"Returns the shortest first name (str).\r\n       You can assume there is only one shortest name.\r\n    \"\"\"\r\n    clean_names = dedup_and_title_case_names(names)\r\n    shortest_name= \"\"\r\n    shortest_length=len(names)+1\r\n    for name in clean_names:\r\n        name=name.split()\r\n        if len(name[0])<shortest_length:\r\n            shortest_name= name[0]\r\n            shortest_length= len(shortest_name) \r\n    return shortest_name\r\n\r\n    \r\nprint(dedup_and_title_case_names(NAMES))\r\nprint(sort_by_surname_desc(NAMES))\r\nprint(shortest_first_name(NAMES))\r\n",
            "date": "2022-09-10 13:15:26.041373+00:00",
            "passed": false
        },
        {
            "bite": "Bite 5. Parse a list of names",
            "code": "from operator import itemgetter\r\n\r\nNAMES = ['arnold schwarzenegger', 'alec baldwin', 'bob belderbos',\r\n         'julian sequeira', 'sandra bullock', 'keanu reeves',\r\n         'julbob pybites', 'bob belderbos', 'julian sequeira',\r\n         'al pacino', 'brad pitt', 'matt damon', 'brad pitt']\r\n\r\n\r\ndef dedup_and_title_case_names(names):\r\n    \"\"\"Should return a list of title cased names,\r\n       each name appears only once\"\"\"\r\n    processed_names= []\r\n    for name in names:\r\n        name = name.title()\r\n        if name not in processed_names:\r\n            processed_names.append(name)\r\n    return processed_names\r\n\r\n\r\ndef sort_by_surname_desc(names):\r\n    \"\"\"Returns names list sorted desc by surname\"\"\"\r\n    names = dedup_and_title_case_names(names)\r\n    names_list= []\r\n    for name in names:\r\n        name=name.split()\r\n        names_list.append([name[0],name[1]])\r\n    names_list.sort(key=itemgetter(1))\r\n    print (names_list)\r\n    processed_names=[]\r\n    for name_surname in names_list:\r\n        processed_names.append(\" \".join(name_surname))\r\n    return processed_names\r\n\r\n\r\ndef shortest_first_name(names):\r\n    \"\"\"Returns the shortest first name (str).\r\n       You can assume there is only one shortest name.\r\n    \"\"\"\r\n    names = dedup_and_title_case_names(names)\r\n    # ...\r\n    \r\nprint(dedup_and_title_case_names(NAMES))\r\nprint(sort_by_surname_desc(NAMES))",
            "date": "2022-09-10 13:04:45.394308+00:00",
            "passed": false
        },
        {
            "bite": "Bite 1. Sum n numbers",
            "code": "def sum_numbers(numbers=None):\r\n    if numbers is None:\r\n        numbers = list(range(1,101))\r\n    return sum(numbers)\r\n    \r\nlst= list(range(1,10))\r\nprint(lst)\r\nprint(sum_numbers(lst))\r\nprint(sum_numbers(None))\r\nprint(sum_numbers([]))\r\n",
            "date": "2022-09-09 15:11:35.454277+00:00",
            "passed": true
        },
        {
            "bite": "Bite 1. Sum n numbers",
            "code": "def sum_numbers(numbers=None):\r\n    if numbers is None:\r\n        numbers = list(range[1:100])\r\n    return sum(numbers)",
            "date": "2022-09-09 15:06:52.259315+00:00",
            "passed": false
        },
        {
            "bite": "Intro Bite 07. Filter numbers with a list comprehension",
            "code": "def filter_positive_even_numbers(numbers):\r\n    \"\"\"Receives a list of numbers, and returns a filtered list of only the\r\n       numbers that are both positive and even (divisible by 2), try to use a\r\n       list comprehension.\"\"\"\r\n    return [x for x in numbers if x>0 and (x%2)==0 ]\r\n    \r\n    \r\n\r\nprint(filter_positive_even_numbers([-2, -1, 0, 1, 2, 3, 4]))",
            "date": "2022-09-09 14:47:40.417369+00:00",
            "passed": true
        },
        {
            "bite": "Intro Bite 06. Strip out vowels and count the number of replacements",
            "code": "from typing import Tuple\r\n\r\nTEXT = \"\"\"\r\nThe Zen of Python, by Tim Peters\r\nBeautiful is better than ugly.\r\nExplicit is better than implicit.\r\nSimple is better than complex.\r\nComplex is better than complicated.\r\nFlat is better than nested.\r\nSparse is better than dense.\r\nReadability counts.\r\nSpecial cases aren't special enough to break the rules.\r\nAlthough practicality beats purity.\r\nErrors should never pass silently.\r\nUnless explicitly silenced.\r\nIn the face of ambiguity, refuse the temptation to guess.\r\nThere should be one-- and preferably only one --obvious way to do it.\r\nAlthough that way may not be obvious at first unless you're Dutch.\r\nNow is better than never.\r\nAlthough never is often better than *right* now.\r\nIf the implementation is hard to explain, it's a bad idea.\r\nIf the implementation is easy to explain, it may be a good idea.\r\nNamespaces are one honking great idea -- let's do more of those!\r\n\"\"\"\r\nVOWELS = 'aeiou'\r\n\r\n\r\ndef strip_vowels(text: str = TEXT) -> Tuple[str, int]:\r\n    \"\"\"\r\n    Replace all vowels in the input text string by a star\r\n    character (*).\r\n    Return a tuple of (replaced_text, number_of_vowels_found)\r\n\r\n    So if this function is called like:\r\n    strip_vowels('hello world')\r\n\r\n    ... it would return:\r\n    ('h*ll* w*rld', 3)\r\n\r\n    str/int/Tuple in the function definition are type hints, see:\r\n    https://docs.python.org/3/library/typing.html\r\n    and:\r\n    https://pybit.es/articles/code-better-with-type-hints-part-1/\r\n    \"\"\"\r\n    \r\n    number_of_vowels_found =0\r\n    char_list = []\r\n    for character in text:\r\n        if character.lower() in VOWELS:\r\n            char_list.append(\"*\")\r\n            number_of_vowels_found+=1\r\n        else:\r\n            char_list.append(character)\r\n           \r\n    replaced_text = \"\".join(char_list)\r\n    return (replaced_text, number_of_vowels_found)\r\n    \r\nprint(strip_vowels(TEXT))\r\n        ",
            "date": "2022-09-09 14:42:58.634845+00:00",
            "passed": true
        },
        {
            "bite": "Intro Bite 05. Slice and dice",
            "code": "from typing import List\r\n\r\nfrom string import ascii_lowercase\r\n\r\nTEXT = \"\"\"\r\nOne really nice feature of Python is polymorphism: using the same operation\r\non different types of objects.\r\nLet's talk about an elegant feature: slicing.\r\nYou can use this on a string as well as a list for example\r\n'pybites'[0:2] gives 'py'.\r\n The first value is inclusive and the last one is exclusive so\r\nhere we grab indexes 0 and 1, the letter p and y.\r\n  When you have a 0 index you can leave it out so can write this as 'pybites'[:2]\r\nbut here is the kicker: you can use this on a list too!\r\n['pybites', 'teaches', 'you', 'Python'][-2:] would gives ['you', 'Python']\r\nand now you know about slicing from the end as well :)\r\nkeep enjoying our bites!\r\n\"\"\"\r\n\r\n\r\ndef slice_and_dice(text: str = TEXT) -> List[str]:\r\n    \"\"\"\r\n    Get a list of words from the passed in text.\r\n    See the Bite description for step by step instructions\r\n    \"\"\"\r\n    results = []\r\n    text = text.strip()\r\n    lines = text.split(\"\\n\")\r\n    for line in lines:\r\n        line = line.strip()\r\n        if line[0:1].islower():\r\n            words = line.split()\r\n            last_word = words[-1]\r\n            if  last_word[-1:]  in [\".\", \"!\"]:\r\n                last_word=last_word[0:-1]\r\n            results.append(last_word) \r\n\r\n    return results\r\n    \r\nprint(slice_and_dice())",
            "date": "2022-09-09 13:52:55.022462+00:00",
            "passed": true
        },
        {
            "bite": "Intro Bite 04. Split and join",
            "code": "MESSAGE = \"\"\"Hello world!\r\nWe hope that you are learning a lot of Python.\r\nHave fun with our Bites of Py.\r\nKeep calm and code in Python!\r\nBecome a PyBites ninja!\"\"\"\r\n\r\ndef split_in_columns(message=MESSAGE):\r\n    \"\"\"Split the message by newline (\\n) and join it together on '|'\r\n       (pipe), return the obtained output string\"\"\"\r\n    return \"|\".join(message.split(\"\\n\"))\r\n\r\n\r\na=split_in_columns()\r\nprint(a)",
            "date": "2022-09-09 13:18:01.372527+00:00",
            "passed": true
        },
        {
            "bite": "Intro Bite 03. Loop through a dictionary and pluralise a word",
            "code": "GAME_STATS = dict(sara=0, bob=1, tim=5, julian=3, jim=1)\r\n\r\n\r\ndef print_game_stats(games_won):\r\n    \"\"\"Loop through games_won's dict (key, value) pairs (dict.items)\r\n       printing (print, not return) how many games each person has won,\r\n       pluralize 'game' based on number.\r\n\r\n       Expected output (ignore the docstring's indentation):\r\n\r\n       sara has won 0 games\r\n       bob has won 1 game\r\n       tim has won 5 games\r\n       julian has won 3 games\r\n       jim has won 1 game\r\n\r\n       (Note that as of Python 3.7 - which we're using atm - dict insert order\r\n       is retained so no sorting is required for this Bite.)\r\n    \"\"\"\r\n    for name, number in games_won.items():\r\n        if number ==1:\r\n            game_x = \"game\"\r\n        else:\r\n            game_x = \"games\"\r\n        print(f\"{name} has won {number} {game_x}\")\r\n        \r\n\r\nprint_game_stats(GAME_STATS)",
            "date": "2022-09-09 13:08:35.863005+00:00",
            "passed": true
        },
        {
            "bite": "Intro Bite 02. Infinite loop, input, continue and break",
            "code": "VALID_COLORS = ['blue', 'yellow', 'red']\r\n\r\n\r\ndef print_colors():\r\n    \"\"\"In the while loop ask the user to enter a color,\r\n       lowercase it and store it in a variable. Next check: \r\n       - if 'quit' was entered for color, print 'bye' and break. \r\n       - if the color is not in VALID_COLORS, print 'Not a valid color' and continue.\r\n       - otherwise print the color in lower case.\"\"\"\r\n    while True:\r\n        try:\r\n            user_input = input(\"Enter a color (blue/yellow/red) or quit to exit\")\r\n        except EOFError:\r\n            break    \r\n        user_input = user_input.lower()\r\n        if user_input == \"quit\":\r\n            print(\"bye\")\r\n            break\r\n        if user_input not in VALID_COLORS:\r\n            print(\"Not a valid color\")\r\n            continue\r\n        print(user_input)\r\n\r\n\r\nprint_colors()\r\n",
            "date": "2022-09-09 12:58:35.720603+00:00",
            "passed": true
        },
        {
            "bite": "Intro Bite 01. F-strings and a simple if/else",
            "code": "MIN_DRIVING_AGE = 18\r\n\r\n\r\ndef allowed_driving(name, age):\r\n    \"\"\"Print '{name} is allowed to drive' or '{name} is not allowed to drive'\r\n       checking the passed in age against the MIN_DRIVING_AGE constant\"\"\"\r\n    if age >= MIN_DRIVING_AGE:\r\n        print (f\"{name} is allowed to drive\")\r\n    else:\r\n        print (f\"{name} is not allowed to drive\")       ",
            "date": "2022-09-09 12:43:46.932166+00:00",
            "passed": true
        },
        {
            "bite": "Newbie Bite 03. Basic Printing",
            "code": "# Enter your code below this line:\r\nprint(\"I find it unbearable that there are people out there who think DC is better than Marvel!\")",
            "date": "2022-09-09 12:36:33.855104+00:00",
            "passed": true
        },
        {
            "bite": "Newbie Bite 02. Basic Data Types",
            "code": "# Enter your code below this line\r\nmy_integer = 29\r\nmy_float = 400.68\r\nmy_lie = \"I love data types!\"",
            "date": "2022-09-09 12:31:21.139798+00:00",
            "passed": true
        },
        {
            "bite": "Newbie Bite 01. Assigning Objects",
            "code": "# Enter your code below this line:\r\nbobs_age = 86",
            "date": "2022-09-09 12:27:41.726206+00:00",
            "passed": true
        }
    ],
    "pccs": [
        {
            "challenge": "45 - TDD: Code FizzBuzz Writing Tests First!",
            "hours_spent": 1,
            "level": 2,
            "feedback": "",
            "learning": "learned some TDD",
            "completed": true,
            "github_pr_id": null,
            "date": "2022-09-24 22:32:42.205203+00:00"
        }
    ],
    "100days": [
        {
            "template": "bitesofpy",
            "learning_objectives": "Pre-filled in by bitesofpy template",
            "start_date": "2022-09-09 00:00:00+00:00",
            "perc_complete": 100,
            "day_logs": [
                {
                    "date": "2022-09-09 00:00:00+00:00",
                    "tweet": "Day 1: #100DaysOfCode progress: today I worked on Bite 1. Sum n numbers: https://codechalleng.es/bites/1 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-09-10 00:00:00+00:00",
                    "tweet": "Day 2: #100DaysOfCode progress: today I worked on Bite 5. Parse a list of names: https://codechalleng.es/bites/5 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "Learned about sort in place vs sorted, list comprehensions and parsing strings",
                    "done": true
                },
                {
                    "date": "2022-09-11 00:00:00+00:00",
                    "tweet": "Day 3: #100DaysOfCode progress: today I worked on Bite 8. Rotate string characters: https://codechalleng.es/bites/8 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-09-12 00:00:00+00:00",
                    "tweet": "Day 4: #100DaysOfCode progress: today I worked on Bite 15. Enumerate 2 sequences: https://codechalleng.es/bites/15 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-09-13 00:00:00+00:00",
                    "tweet": "Day 5: #100DaysOfCode progress: today I worked on Bite 16. PyBites date generator: https://codechalleng.es/bites/16 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "using yield to build a generator and timedelta() to add / subtract timestamps",
                    "done": true
                },
                {
                    "date": "2022-09-14 00:00:00+00:00",
                    "tweet": "Day 6: #100DaysOfCode progress: today I worked on Bite 19. Write a property: https://codechalleng.es/bites/19 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "class properties and constructor",
                    "done": true
                },
                {
                    "date": "2022-09-15 00:00:00+00:00",
                    "tweet": "Day 7: #100DaysOfCode progress: today I worked on Bite 21. Query a nested data structure: https://codechalleng.es/bites/21 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-09-16 00:00:00+00:00",
                    "tweet": "Day 8: #100DaysOfCode progress: today I worked on Bite 26. Dictionary comprehensions are awesome: https://codechalleng.es/bites/26 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "dict comprehensions",
                    "done": true
                },
                {
                    "date": "2022-09-17 00:00:00+00:00",
                    "tweet": "Day 9: #100DaysOfCode progress: today I worked on Bite 29. Martin's IQ test: https://codechalleng.es/bites/29 Not fully happy with how this one turned out, I got stuck and ended up submitting overly complicated code  - code more #Python @PyBites CodeChalleng.es",
                    "learning": "not fully happy with this one I think I got stuck in an overly complex loop ",
                    "done": true
                },
                {
                    "date": "2022-09-18 00:00:00+00:00",
                    "tweet": "Day 10: #100DaysOfCode progress: today I worked on Bite 32. Don't let mutability fool you: https://codechalleng.es/bites/32 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "deepcopy()",
                    "done": true
                },
                {
                    "date": "2022-09-19 00:00:00+00:00",
                    "tweet": "Day 11: #100DaysOfCode progress: today I worked on Bite 37. Rewrite a for loop using recursion: https://codechalleng.es/bites/37 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "recursion is difficult!",
                    "done": true
                },
                {
                    "date": "2022-09-20 00:00:00+00:00",
                    "tweet": "Day 12: #100DaysOfCode progress: today I worked on Bite 38. Using ElementTree to parse XML: https://codechalleng.es/bites/38 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-09-21 00:00:00+00:00",
                    "tweet": "Day 13: #100DaysOfCode progress: today I worked on Bite 43. Force keyword arguments: https://codechalleng.es/bites/43 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-09-22 00:00:00+00:00",
                    "tweet": "Day 14: #100DaysOfCode progress: today I worked on Bite 44. License key generator: https://codechalleng.es/bites/44 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "secrets",
                    "done": true
                },
                {
                    "date": "2022-09-23 00:00:00+00:00",
                    "tweet": "Day 15: #100DaysOfCode progress: today I worked on Bite 45. Keep a queue of last n items: https://codechalleng.es/bites/45 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-09-24 00:00:00+00:00",
                    "tweet": "Day 16: #100DaysOfCode progress: today I worked on Bite 46. You are a programmer! Code Fizz Buzz: https://codechalleng.es/bites/46 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-09-25 00:00:00+00:00",
                    "tweet": "Day 17: #100DaysOfCode progress: today I worked on Bite 54. Nicer formatting of a poem or text: https://codechalleng.es/bites/54 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-09-26 00:00:00+00:00",
                    "tweet": "Day 18: #100DaysOfCode progress: today I worked on Bite 55. Get the latest game releases from Steam's RSS feed: https://codechalleng.es/bites/55 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-09-27 00:00:00+00:00",
                    "tweet": "Day 19: #100DaysOfCode progress: today I worked on Bite 56. Add a command line interface to our BMI calculator: https://codechalleng.es/bites/56 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "argparse",
                    "done": true
                },
                {
                    "date": "2022-09-28 00:00:00+00:00",
                    "tweet": "Day 20: #100DaysOfCode progress: today I worked on Bite 64. Fix a truncating zip function: https://codechalleng.es/bites/64 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-09-29 00:00:00+00:00",
                    "tweet": "Day 21: #100DaysOfCode progress: today I worked on Bite 66. Calculate the running average of a sequence: https://codechalleng.es/bites/66 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-09-30 00:00:00+00:00",
                    "tweet": "Day 22: #100DaysOfCode progress: today I worked on Bite 67. Working with datetimes: https://codechalleng.es/bites/67 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "eaasy",
                    "done": true
                },
                {
                    "date": "2022-10-01 00:00:00+00:00",
                    "tweet": "Day 23: #100DaysOfCode progress: today I worked on Bite 68. Remove punctuation characters from a string: https://codechalleng.es/bites/68 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-02 00:00:00+00:00",
                    "tweet": "Day 24: #100DaysOfCode progress: today I worked on Bite 74. What day of the week were you born on?: https://codechalleng.es/bites/74 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-03 00:00:00+00:00",
                    "tweet": "Day 25: #100DaysOfCode progress: today I worked on Bite 77. New places to travel to: https://codechalleng.es/bites/77 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-04 00:00:00+00:00",
                    "tweet": "Day 26: #100DaysOfCode progress: today I worked on Bite 80. Check equality of two lists: https://codechalleng.es/bites/80 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-05 00:00:00+00:00",
                    "tweet": "Day 27: #100DaysOfCode progress: today I worked on Bite 83. At what time does PyBites live?: https://codechalleng.es/bites/83 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-06 00:00:00+00:00",
                    "tweet": "Day 28: #100DaysOfCode progress: today I worked on Bite 91. Matching multiple strings: https://codechalleng.es/bites/91 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-07 00:00:00+00:00",
                    "tweet": "Day 29: #100DaysOfCode progress: today I worked on Bite 96. Build Unix' wc program in Python: https://codechalleng.es/bites/96 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-08 00:00:00+00:00",
                    "tweet": "Day 30: #100DaysOfCode progress: today I worked on Bite 100. Display the last part of a file (Unix tail): https://codechalleng.es/bites/100 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-09 00:00:00+00:00",
                    "tweet": "Day 31: #100DaysOfCode progress: today I worked on Bite 115. Count leading spaces: https://codechalleng.es/bites/115 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-10 00:00:00+00:00",
                    "tweet": "Day 32: #100DaysOfCode progress: today I worked on Bite 117. Round a number even (a.k.a. banker's rounding): https://codechalleng.es/bites/117 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-11 00:00:00+00:00",
                    "tweet": "Day 33: #100DaysOfCode progress: today I worked on Bite 128. Work with datetime's strptime and strftime: https://codechalleng.es/bites/128 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-12 00:00:00+00:00",
                    "tweet": "Day 34: #100DaysOfCode progress: today I worked on Bite 130. Analyze some basic Car Data: https://codechalleng.es/bites/130 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-13 00:00:00+00:00",
                    "tweet": "Day 35: #100DaysOfCode progress: today I worked on Bite 133. Convert an Amazon URL into an affiliation link: https://codechalleng.es/bites/133 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-14 00:00:00+00:00",
                    "tweet": "Day 36: #100DaysOfCode progress: today I worked on Bite 136. Bloodtypes: https://codechalleng.es/bites/136 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-15 00:00:00+00:00",
                    "tweet": "Day 37: #100DaysOfCode progress: today I worked on Bite 143. Look up a value in 3 dictionaries: https://codechalleng.es/bites/143 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-16 00:00:00+00:00",
                    "tweet": "Day 38: #100DaysOfCode progress: today I worked on Bite 149. Sorting words with constraint: https://codechalleng.es/bites/149 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-17 00:00:00+00:00",
                    "tweet": "Day 39: #100DaysOfCode progress: today I worked on Bite 153. Round a sequence of numbers: https://codechalleng.es/bites/153 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-18 00:00:00+00:00",
                    "tweet": "Day 40: #100DaysOfCode progress: today I worked on Bite 161. Count the number of files and directories: https://codechalleng.es/bites/161 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-19 00:00:00+00:00",
                    "tweet": "Day 41: #100DaysOfCode progress: today I worked on Bite 165. Parse an /etc/passwd file output: https://codechalleng.es/bites/165 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-20 00:00:00+00:00",
                    "tweet": "Day 42: #100DaysOfCode progress: today I worked on Bite 167. Complete a User class: properties and representation dunder methods: https://codechalleng.es/bites/167 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-21 00:00:00+00:00",
                    "tweet": "Day 43: #100DaysOfCode progress: today I worked on Bite 169. Simple length converter: https://codechalleng.es/bites/169 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-22 00:00:00+00:00",
                    "tweet": "Day 44: #100DaysOfCode progress: today I worked on Bite 172. Having fun with Python Partials: https://codechalleng.es/bites/172 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-23 00:00:00+00:00",
                    "tweet": "Day 45: #100DaysOfCode progress: today I worked on Bite 176. Create a variable length chessboard: https://codechalleng.es/bites/176 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-24 00:00:00+00:00",
                    "tweet": "Day 46: #100DaysOfCode progress: today I worked on Bite 180. Group names by country: https://codechalleng.es/bites/180 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-25 00:00:00+00:00",
                    "tweet": "Day 47: #100DaysOfCode progress: today I worked on Bite 181. Keep a list sorted upon insert: https://codechalleng.es/bites/181 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-26 00:00:00+00:00",
                    "tweet": "Day 48: #100DaysOfCode progress: today I worked on Bite 188. Get statistics from PyBites test code: https://codechalleng.es/bites/188 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-27 00:00:00+00:00",
                    "tweet": "Day 49: #100DaysOfCode progress: today I worked on Bite 189. Filter a list of names: https://codechalleng.es/bites/189 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-28 00:00:00+00:00",
                    "tweet": "Day 50: #100DaysOfCode progress: today I worked on Bite 192. Some logging practice: https://codechalleng.es/bites/192 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-29 00:00:00+00:00",
                    "tweet": "Day 51: #100DaysOfCode progress: today I worked on Bite 208. Find the number pairs summing up N: https://codechalleng.es/bites/208 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-30 00:00:00+00:00",
                    "tweet": "Day 52: #100DaysOfCode progress: today I worked on Bite 209. Write a Sphinx docstring: https://codechalleng.es/bites/209 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-10-31 00:00:00+00:00",
                    "tweet": "Day 53: #100DaysOfCode progress: today I worked on Bite 210. Add Type Annotations: https://codechalleng.es/bites/210 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-01 00:00:00+00:00",
                    "tweet": "Day 54: #100DaysOfCode progress: today I worked on Bite 214. A countdown generator: https://codechalleng.es/bites/214 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-02 00:00:00+00:00",
                    "tweet": "Day 55: #100DaysOfCode progress: today I worked on Bite 215. Validate a license key: https://codechalleng.es/bites/215 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-03 00:00:00+00:00",
                    "tweet": "Day 56: #100DaysOfCode progress: today I worked on Bite 218. Create a sandwich decorator: https://codechalleng.es/bites/218 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-04 00:00:00+00:00",
                    "tweet": "Day 57: #100DaysOfCode progress: today I worked on Bite 225. Swap case PyBites characters: https://codechalleng.es/bites/225 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-05 00:00:00+00:00",
                    "tweet": "Day 58: #100DaysOfCode progress: today I worked on Bite 231. Where are the emojis?: https://codechalleng.es/bites/231 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-06 00:00:00+00:00",
                    "tweet": "Day 59: #100DaysOfCode progress: today I worked on Bite 238. Write tests for Fibonacci: https://codechalleng.es/bites/238 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-07 00:00:00+00:00",
                    "tweet": "Day 60: #100DaysOfCode progress: today I worked on Bite 241. Write tests for list_to_decimal: https://codechalleng.es/bites/241 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-08 00:00:00+00:00",
                    "tweet": "Day 61: #100DaysOfCode progress: today I worked on Bite 246. Test print / standard output: https://codechalleng.es/bites/246 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-09 00:00:00+00:00",
                    "tweet": "Day 62: #100DaysOfCode progress: today I worked on Bite 251. Introducing Pandas Series: https://codechalleng.es/bites/251 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-10 00:00:00+00:00",
                    "tweet": "Day 63: #100DaysOfCode progress: today I worked on Bite 252. Let's play with Pandas Series: https://codechalleng.es/bites/252 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-11 00:00:00+00:00",
                    "tweet": "Day 64: #100DaysOfCode progress: today I worked on Bite 254. Global vs local variables: https://codechalleng.es/bites/254 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-12 00:00:00+00:00",
                    "tweet": "Day 65: #100DaysOfCode progress: today I worked on Bite 257. Extract users dict from a multiline string: https://codechalleng.es/bites/257 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-13 00:00:00+00:00",
                    "tweet": "Day 66: #100DaysOfCode progress: today I worked on Bite 262. GC content: https://codechalleng.es/bites/262 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-14 00:00:00+00:00",
                    "tweet": "Day 67: #100DaysOfCode progress: today I worked on Bite 270. Most frequent digit in number: https://codechalleng.es/bites/270 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-15 00:00:00+00:00",
                    "tweet": "Day 68: #100DaysOfCode progress: today I worked on Bite 278. Major and minor numbers: https://codechalleng.es/bites/278 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-16 00:00:00+00:00",
                    "tweet": "Day 69: #100DaysOfCode progress: today I worked on Bite 279. Armstrong numbers: https://codechalleng.es/bites/279 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-17 00:00:00+00:00",
                    "tweet": "Day 70: #100DaysOfCode progress: today I worked on Bite 283. Like there's no tomorrow?: https://codechalleng.es/bites/283 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-18 00:00:00+00:00",
                    "tweet": "Day 71: #100DaysOfCode progress: today I worked on Bite 288. Smallest number: https://codechalleng.es/bites/288 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-19 00:00:00+00:00",
                    "tweet": "Day 72: #100DaysOfCode progress: today I worked on Bite 289. Round to next number: https://codechalleng.es/bites/289 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-20 00:00:00+00:00",
                    "tweet": "Day 73: #100DaysOfCode progress: today I worked on Bite 293. N digit numbers: https://codechalleng.es/bites/293 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-21 00:00:00+00:00",
                    "tweet": "Day 74: #100DaysOfCode progress: today I worked on Bite 295. Join lists: https://codechalleng.es/bites/295 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-22 00:00:00+00:00",
                    "tweet": "Day 75: #100DaysOfCode progress: today I worked on Bite 314. Print names to columns: https://codechalleng.es/bites/314 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-23 00:00:00+00:00",
                    "tweet": "Day 76: #100DaysOfCode progress: today I worked on Bite 317. Pickling objects: https://codechalleng.es/bites/317 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-24 00:00:00+00:00",
                    "tweet": "Day 77: #100DaysOfCode progress: today I worked on Bite 318. Decode base64 encoded data: https://codechalleng.es/bites/318 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-25 00:00:00+00:00",
                    "tweet": "Day 78: #100DaysOfCode progress: today I worked on Bite 319. Identity and equality: https://codechalleng.es/bites/319 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-26 00:00:00+00:00",
                    "tweet": "Day 79: #100DaysOfCode progress: today I worked on Bite 322. Reading progress: https://codechalleng.es/bites/322 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-27 00:00:00+00:00",
                    "tweet": "Day 80: #100DaysOfCode progress: today I worked on Bite 323. Iterables intersection: https://codechalleng.es/bites/323 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-28 00:00:00+00:00",
                    "tweet": "Day 81: #100DaysOfCode progress: today I worked on Bite 324. Pretty string: https://codechalleng.es/bites/324 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-29 00:00:00+00:00",
                    "tweet": "Day 82: #100DaysOfCode progress: today I worked on Bite 336. FastAPI Hello World: https://codechalleng.es/bites/336 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-11-30 00:00:00+00:00",
                    "tweet": "Day 83: #100DaysOfCode progress: today I worked on Bite 337. A little detour: Pydantic: https://codechalleng.es/bites/337 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-12-01 00:00:00+00:00",
                    "tweet": "Day 84: #100DaysOfCode progress: today I worked on Bite 347. Which words can you type with one hand?: https://codechalleng.es/bites/347 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-12-02 00:00:00+00:00",
                    "tweet": "Day 85: #100DaysOfCode progress: today I worked on Bite 3. Word Values: https://codechalleng.es/bites/3 - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-12-03 00:00:00+00:00",
                    "tweet": "Day 86: #100DaysOfCode progress: I have completed all the bites in the template ahead of time so today I worked on Bite 151. Contemporary Composers & Bite 124. Marvel data analysis - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-12-04 00:00:00+00:00",
                    "tweet": "Day 87: #100DaysOfCode progress: today I worked on Bite 195. Analyze NBA Data with sqlite3 & Bite 160. 15-way Rock Paper Scissors - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-12-05 00:00:00+00:00",
                    "tweet": "Day 88: #100DaysOfCode progress: today I worked on Bite 111. Use the ipinfo API to lookup IP country and Bite 256. Scrape PyCon events - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-12-06 00:00:00+00:00",
                    "tweet": "Day 89: #100DaysOfCode progress: today I worked on Bite 351. Get spelling suggestions (hello textblob!) & Bite 243. Test code that parses JSON and IP ranges  - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-12-07 00:00:00+00:00",
                    "tweet": "Day 90: #100DaysOfCode progress: yesterday I forgot to tweet, but I did work on Bite 348. Citation indexes - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-12-08 00:00:00+00:00",
                    "tweet": "Day 91: #100DaysOfCode progress: today I worked on Bite 229. Scrape best programming books & Bite 275. Get the most common email domains - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-12-09 00:00:00+00:00",
                    "tweet": "Day 92: #100DaysOfCode progress: Good day! Today I worked on  Bite 173. Set up future notifications, Bite 186. Calculate number of books to have read at date ... and Bite 187. Actor/actress age at movie release  - code more #Python @PyBites CodeChalleng.es",
                    "learning": "\r\n",
                    "done": true
                },
                {
                    "date": "2022-12-10 00:00:00+00:00",
                    "tweet": "Day 93: #100DaysOfCode progress: today I worked on Bite 197. What date is Mother's Day celebrated? &  Bite 291. Find the fastest speech - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-12-11 00:00:00+00:00",
                    "tweet": "Day 94: #100DaysOfCode progress: today I worked on Bite 226. Get top titles from news.python.sc and the mighty Bite 200. \ud83e\udd73 Minecraft Enchantable Items (worth 9 points!) - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-12-12 00:00:00+00:00",
                    "tweet": "Day 95: #100DaysOfCode progress: today I worked on Bite 50 - Make a little PyBites search engine (feedparser) &  Bite 94 - Parse PyCon talk data from YouTube  - code more #Python @PyBites",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-12-13 00:00:00+00:00",
                    "tweet": "Day 96: #100DaysOfCode progress: today I worked on Bite 325. Floating point arithmetic - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-12-14 00:00:00+00:00",
                    "tweet": "Day 97: #100DaysOfCode progress: today I worked on Bite 304. Most identical letters in a word (and I finished past midnight!) - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-12-15 00:00:00+00:00",
                    "tweet": "Day 98: #100DaysOfCode progress: today I worked on Bite 296. Jagged list ...and again I finished past midnight, but at this point I am not ready to break the streak - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-12-16 00:00:00+00:00",
                    "tweet": "Day 99: #100DaysOfCode progress: today I worked on Bite 206. Calculate and evenly split the bill (harder than I expected!) - code more #Python @PyBites CodeChalleng.es",
                    "learning": "",
                    "done": true
                },
                {
                    "date": "2022-12-17 00:00:00+00:00",
                    "tweet": "Day 100: today I worked on Bite 87 - Convert Decimal to Roman Numerals. I coded for 100 days straight!! - #100DaysOfCode #milestone #Python @PyBites http://CodeChalleng.es",
                    "learning": "",
                    "done": true
                }
            ]
        }
    ]
}